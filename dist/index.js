var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@actions/core/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCommandProperties = exports.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports.toCommandProperties = toCommandProperties;
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "node_modules/@actions/core/lib/command.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.issue = exports.issueCommand = void 0;
    var os3 = __importStar2(__require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os3.EOL);
    }
    exports.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "node_modules/@actions/core/lib/file-command.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
    var crypto3 = __importStar2(__require("crypto"));
    var fs2 = __importStar2(__require("fs"));
    var os3 = __importStar2(__require("os"));
    var utils_1 = require_utils();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs2.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs2.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os3.EOL}`, {
        encoding: "utf8"
      });
    }
    exports.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${crypto3.randomUUID()}`;
      const convertedValue = (0, utils_1.toCommandValue)(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os3.EOL}${convertedValue}${os3.EOL}${delimiter}`;
    }
    exports.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "node_modules/@actions/http-client/lib/proxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkBypass = exports.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        try {
          return new DecodedURL(proxyVar);
        } catch (_a) {
          if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
            return new DecodedURL(`http://${proxyVar}`);
        }
      } else {
        return void 0;
      }
    }
    exports.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
        if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
          return true;
        }
      }
      return false;
    }
    exports.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
    var DecodedURL = class extends URL {
      constructor(url, base) {
        super(url, base);
        this._decodedUsername = decodeURIComponent(super.username);
        this._decodedPassword = decodeURIComponent(super.password);
      }
      get username() {
        return this._decodedUsername;
      }
      get password() {
        return this._decodedPassword;
      }
    };
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/tunnel/lib/tunnel.js"(exports) {
    "use strict";
    var net2 = __require("net");
    var tls = __require("tls");
    var http3 = __require("http");
    var https2 = __require("https");
    var events = __require("events");
    var assert3 = __require("assert");
    var util = __require("util");
    exports.httpOverHttp = httpOverHttp;
    exports.httpsOverHttp = httpsOverHttp;
    exports.httpOverHttps = httpOverHttps;
    exports.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http3.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http3.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http3.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i2 = 0, len = self2.requests.length; i2 < len; ++i2) {
          var pending = self2.requests[i2];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i2, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug2("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug2(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error2 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error2.code = "ECONNRESET";
          options.request.emit("error", error2);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug2("got illegal response body from proxy");
          socket.destroy();
          var error2 = new Error("got illegal response body from proxy");
          error2.code = "ECONNRESET";
          options.request.emit("error", error2);
          self2.removeSocket(placeholder);
          return;
        }
        debug2("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug2(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error2 = new Error("tunneling socket could not be established, cause=" + cause.message);
        error2.code = "ECONNRESET";
        options.request.emit("error", error2);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i2 = 1, len = arguments.length; i2 < len; ++i2) {
        var overrides = arguments[i2];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug2;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports.debug = debug2;
  }
});

// node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/tunnel/index.js"(exports, module) {
    "use strict";
    module.exports = require_tunnel();
  }
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/undici/lib/core/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kClose: /* @__PURE__ */ Symbol("close"),
      kDestroy: /* @__PURE__ */ Symbol("destroy"),
      kDispatch: /* @__PURE__ */ Symbol("dispatch"),
      kUrl: /* @__PURE__ */ Symbol("url"),
      kWriting: /* @__PURE__ */ Symbol("writing"),
      kResuming: /* @__PURE__ */ Symbol("resuming"),
      kQueue: /* @__PURE__ */ Symbol("queue"),
      kConnect: /* @__PURE__ */ Symbol("connect"),
      kConnecting: /* @__PURE__ */ Symbol("connecting"),
      kHeadersList: /* @__PURE__ */ Symbol("headers list"),
      kKeepAliveDefaultTimeout: /* @__PURE__ */ Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: /* @__PURE__ */ Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: /* @__PURE__ */ Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: /* @__PURE__ */ Symbol("keep alive timeout"),
      kKeepAlive: /* @__PURE__ */ Symbol("keep alive"),
      kHeadersTimeout: /* @__PURE__ */ Symbol("headers timeout"),
      kBodyTimeout: /* @__PURE__ */ Symbol("body timeout"),
      kServerName: /* @__PURE__ */ Symbol("server name"),
      kLocalAddress: /* @__PURE__ */ Symbol("local address"),
      kHost: /* @__PURE__ */ Symbol("host"),
      kNoRef: /* @__PURE__ */ Symbol("no ref"),
      kBodyUsed: /* @__PURE__ */ Symbol("used"),
      kRunning: /* @__PURE__ */ Symbol("running"),
      kBlocking: /* @__PURE__ */ Symbol("blocking"),
      kPending: /* @__PURE__ */ Symbol("pending"),
      kSize: /* @__PURE__ */ Symbol("size"),
      kBusy: /* @__PURE__ */ Symbol("busy"),
      kQueued: /* @__PURE__ */ Symbol("queued"),
      kFree: /* @__PURE__ */ Symbol("free"),
      kConnected: /* @__PURE__ */ Symbol("connected"),
      kClosed: /* @__PURE__ */ Symbol("closed"),
      kNeedDrain: /* @__PURE__ */ Symbol("need drain"),
      kReset: /* @__PURE__ */ Symbol("reset"),
      kDestroyed: /* @__PURE__ */ Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: /* @__PURE__ */ Symbol("max headers size"),
      kRunningIdx: /* @__PURE__ */ Symbol("running index"),
      kPendingIdx: /* @__PURE__ */ Symbol("pending index"),
      kError: /* @__PURE__ */ Symbol("error"),
      kClients: /* @__PURE__ */ Symbol("clients"),
      kClient: /* @__PURE__ */ Symbol("client"),
      kParser: /* @__PURE__ */ Symbol("parser"),
      kOnDestroyed: /* @__PURE__ */ Symbol("destroy callbacks"),
      kPipelining: /* @__PURE__ */ Symbol("pipelining"),
      kSocket: /* @__PURE__ */ Symbol("socket"),
      kHostHeader: /* @__PURE__ */ Symbol("host header"),
      kConnector: /* @__PURE__ */ Symbol("connector"),
      kStrictContentLength: /* @__PURE__ */ Symbol("strict content length"),
      kMaxRedirections: /* @__PURE__ */ Symbol("maxRedirections"),
      kMaxRequests: /* @__PURE__ */ Symbol("maxRequestsPerClient"),
      kProxy: /* @__PURE__ */ Symbol("proxy agent options"),
      kCounter: /* @__PURE__ */ Symbol("socket request counter"),
      kInterceptors: /* @__PURE__ */ Symbol("dispatch interceptors"),
      kMaxResponseSize: /* @__PURE__ */ Symbol("max response size"),
      kHTTP2Session: /* @__PURE__ */ Symbol("http2Session"),
      kHTTP2SessionState: /* @__PURE__ */ Symbol("http2Session state"),
      kHTTP2BuildRequest: /* @__PURE__ */ Symbol("http2 build request"),
      kHTTP1BuildRequest: /* @__PURE__ */ Symbol("http1 build request"),
      kHTTP2CopyHeaders: /* @__PURE__ */ Symbol("http2 copy headers"),
      kHTTPConnVersion: /* @__PURE__ */ Symbol("http connection version"),
      kRetryHandlerDefaultRetry: /* @__PURE__ */ Symbol("retry agent default retry"),
      kConstruct: /* @__PURE__ */ Symbol("constructable")
    };
  }
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/undici/lib/core/errors.js"(exports, module) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, _ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, _SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, _HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class _RequestRetryError extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        Error.captureStackTrace(this, _RequestRetryError);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    module.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError
    };
  }
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS({
  "node_modules/undici/lib/core/constants.js"(exports, module) {
    "use strict";
    var headerNameLowerCasedRecord = {};
    var wellknownHeaderNames = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection"
    ];
    for (let i2 = 0; i2 < wellknownHeaderNames.length; ++i2) {
      const key = wellknownHeaderNames[i2];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    module.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    };
  }
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/undici/lib/core/util.js"(exports, module) {
    "use strict";
    var assert3 = __require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = __require("http");
    var stream2 = __require("stream");
    var net2 = __require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = __require("buffer");
    var nodeUtil = __require("util");
    var { stringify } = __require("querystring");
    var { headerNameLowerCasedRecord } = require_constants();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream2(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
        let path2 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path2 && !path2.startsWith("/")) {
          path2 = `/${path2}`;
        }
        url = new URL(origin + path2);
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert3(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert3.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net2.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable3(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable3(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream2(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer2(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream3) {
      return !stream3 || !!(stream3.destroyed || stream3[kDestroyed]);
    }
    function isReadableAborted(stream3) {
      const state = stream3 && stream3._readableState;
      return isDestroyed(stream3) && state && !state.endEmitted;
    }
    function destroy(stream3, err) {
      if (stream3 == null || !isStream2(stream3) || isDestroyed(stream3)) {
        return;
      }
      if (typeof stream3.destroy === "function") {
        if (Object.getPrototypeOf(stream3).constructor === IncomingMessage) {
          stream3.socket = null;
        }
        stream3.destroy(err);
      } else if (err) {
        process.nextTick((stream4, err2) => {
          stream4.emit("error", err2);
        }, stream3, err);
      }
      if (stream3.destroyed !== true) {
        stream3[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return headerNameLowerCasedRecord[value] || value.toLowerCase();
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers)) return headers;
      for (let i2 = 0; i2 < headers.length; i2 += 2) {
        const key = headers[i2].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i2 + 1])) {
            obj[key] = headers[i2 + 1].map((x) => x.toString("utf8"));
          } else {
            obj[key] = headers[i2 + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i2 + 1].toString("utf8"));
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n2 = 0; n2 < headers.length; n2 += 2) {
        const key = headers[n2 + 0].toString();
        const val = headers[n2 + 1].toString("utf8");
        if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer2(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream2.isDisturbed ? stream2.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream2.isErrored ? stream2.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream2.isReadable ? stream2.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk2 of iterable) {
        yield Buffer.isBuffer(chunk2) ? chunk2 : Buffer.from(chunk2);
      }
    }
    var ReadableStream3;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream3) {
        ReadableStream3 = __require("stream/web").ReadableStream;
      }
      if (ReadableStream3.from) {
        return ReadableStream3.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream3(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }
      return `${val}`;
    }
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream: isStream2,
      isIterable: isIterable3,
      isAsyncIterable: isAsyncIterable3,
      isDestroyed,
      headerNameToString,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer: isBuffer2,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
    };
  }
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "node_modules/undici/lib/timers.js"(exports, module) {
    "use strict";
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer2 = fastTimers[idx];
        if (timer2.state === 0) {
          timer2.state = fastNow + timer2.delay;
        } else if (timer2.state > 0 && fastNow >= timer2.state) {
          timer2.state = -1;
          timer2.callback(timer2.opaque);
        }
        if (timer2.state === -1) {
          timer2.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay3, opaque) {
        this.callback = callback;
        this.delay = delay3;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module.exports = {
      setTimeout(callback, delay3, opaque) {
        return delay3 < 1e3 ? setTimeout(callback, delay3, opaque) : new Timeout(callback, delay3, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports, module) {
    "use strict";
    var EventEmitter3 = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i2 = 0; i2 < needleLength - 1; ++i2) {
        this._occ[needle[i2]] = needleLength - 1 - i2;
      }
    }
    inherits(SBMH, EventEmitter3);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk2, pos) {
      if (!Buffer.isBuffer(chunk2)) {
        chunk2 = Buffer.from(chunk2, "binary");
      }
      const chlen = chunk2.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk2);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i2 = 0; i2 < len; ++i2) {
        if (this._sbmh_lookup_char(data, pos + i2) !== this._needle[i2]) {
          return false;
        }
      }
      return true;
    };
    module.exports = SBMH;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports, module) {
    "use strict";
    var inherits = __require("util").inherits;
    var ReadableStream3 = __require("stream").Readable;
    function PartStream(opts) {
      ReadableStream3.call(this, opts);
    }
    inherits(PartStream, ReadableStream3);
    PartStream.prototype._read = function(n2) {
    };
    module.exports = PartStream;
  }
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports, module) {
    "use strict";
    module.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }
      return limits[name];
    };
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports, module) {
    "use strict";
    var EventEmitter3 = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter3.call(this);
      cfg = cfg || {};
      const self2 = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self2.maxed) {
          if (self2.nread + end - start >= self2.maxHeaderSize) {
            end = self2.maxHeaderSize - self2.nread + start;
            self2.nread = self2.maxHeaderSize;
            self2.maxed = true;
          } else {
            self2.nread += end - start;
          }
          self2.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self2._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter3);
    HeaderParser.prototype.push = function(data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h2;
      for (var i2 = 0; i2 < len; ++i2) {
        if (lines[i2].length === 0) {
          continue;
        }
        if (lines[i2][0] === "	" || lines[i2][0] === " ") {
          if (h2) {
            this.header[h2][this.header[h2].length - 1] += lines[i2];
            continue;
          }
        }
        const posColon = lines[i2].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i2]);
        h2 = m[1].toLowerCase();
        this.header[h2] = this.header[h2] || [];
        this.header[h2].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module.exports = HeaderParser;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports, module) {
    "use strict";
    var WritableStream = __require("stream").Writable;
    var inherits = __require("util").inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self2 = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self2._inHeader = false;
        self2._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self2 = this;
          process.nextTick(function() {
            self2.emit("error", new Error("Unexpected end of multipart data"));
            if (self2._part && !self2._ignoreData) {
              const type2 = self2._isPreamble ? "Preamble" : "Part";
              self2._part.emit("error", new Error(type2 + " terminated early due to unexpected end of multipart data"));
              self2._part.push(null);
              process.nextTick(function() {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              });
              return;
            }
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self2 = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self2._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self2 = this;
      let i2 = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i2 < end) {
          if (data[start + i2] === DASH) {
            ++i2;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i2 < end && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", data.slice(start + i2, end));
          }
          this.reset();
          this._finished = true;
          if (self2._parts === 0) {
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n2) {
          self2._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self2._parts === 0) {
                if (self2._finished) {
                  self2._realFinish = true;
                  self2.emit("finish");
                  self2._realFinish = false;
                } else {
                  self2._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module.exports = Dicer;
  }
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports, module) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          // TODO: Make these a separate, strict decoder?
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports.toString())) {
          try {
            return textDecoders.get(exports).decode(data);
          } catch {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module.exports = decodeText;
  }
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports, module) {
    "use strict";
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = "";
      const len = str.length;
      for (var i2 = 0; i2 < len; ++i2) {
        const char = str[i2];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p] === void 0) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = "";
            ++p;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p] === void 0) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }
      return res;
    }
    module.exports = parseParams;
  }
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/basename.js"(exports, module) {
    "use strict";
    module.exports = function basename(path2) {
      if (typeof path2 !== "string") {
        return "";
      }
      for (var i2 = path2.length - 1; i2 >= 0; --i2) {
        switch (path2.charCodeAt(i2)) {
          case 47:
          // '/'
          case 92:
            path2 = path2.slice(i2 + 1);
            return path2 === ".." || path2 === "." ? "" : path2;
        }
      }
      return path2 === ".." || path2 === "." ? "" : path2;
    };
  }
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/@fastify/busboy/lib/types/multipart.js"(exports, module) {
    "use strict";
    var { Readable } = __require("stream");
    var { inherits } = __require("util");
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i2;
      let len;
      const self2 = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i2 = 0, len = parsedConType.length; i2 < len; ++i2) {
        if (Array.isArray(parsedConType[i2]) && RE_BOUNDARY.test(parsedConType[i2][0])) {
          boundary = parsedConType[i2][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished2 && !boy._done) {
          finished2 = false;
          self2.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished2 = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self2._needDrain = false;
        if (self2._cb && !self2._pause) {
          const cb = self2._cb;
          self2._cb = void 0;
          cb();
        }
      }).on("part", function onPart(part) {
        if (++self2._nparts > partsLimit) {
          self2.parser.removeListener("part", onPart);
          self2.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i2 = 0, len = parsed.length; i2 < len; ++i2) {
                if (RE_CHARSET.test(parsed[i2][0])) {
                  charset = parsed[i2][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i2 = 0, len = parsed.length; i2 < len; ++i2) {
              if (RE_NAME.test(parsed[i2][0])) {
                fieldname = parsed[i2][1];
              } else if (RE_FILENAME.test(parsed[i2][0])) {
                filename = parsed[i2][1];
                if (!preservePath) {
                  filename = basename(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (boy.listenerCount("file") === 0) {
              self2.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self2._pause = false;
              checkFinished();
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            });
            file._read = function(n2) {
              if (!self2._pause) {
                return;
              }
              self2._pause = false;
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self2._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished2 = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk2, cb) {
      const r = this.parser.write(chunk2);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self2 = this;
      if (self2.parser.writable) {
        self2.parser.end();
      } else if (!self2._boy._done) {
        process.nextTick(function() {
          self2._boy._done = true;
          self2._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function(n2) {
    };
    module.exports = Multipart;
  }
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports, module) {
    "use strict";
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i2 = 0;
      let p = 0;
      const len = str.length;
      for (; i2 < len; ++i2) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i2)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i2;
          } else {
            this.buffer += str[i2];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i2] === "%") {
          if (i2 > p) {
            res += str.substring(p, i2);
            p = i2;
          }
          this.buffer = "";
          ++p;
        }
      }
      if (p < len && this.buffer === void 0) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module.exports = Decoder;
  }
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports, module) {
    "use strict";
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i2 = 0, len = parsedConType.length; i2 < len; ++i2) {
        if (Array.isArray(parsedConType[i2]) && RE_CHARSET.test(parsedConType[i2][0])) {
          charset = parsedConType[i2][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i2;
      let p = 0;
      const len = data.length;
      while (p < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i2 = p; i2 < len; ++i2) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i2] === 61) {
              idxeq = i2;
              break;
            } else if (data[i2] === 38) {
              idxamp = i2;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p) {
              this._key += this.decoder.write(data.toString("binary", p, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i2 > p) {
              this._key += this.decoder.write(data.toString("binary", p, i2));
            }
            p = i2;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        } else {
          idxamp = void 0;
          for (i2 = p; i2 < len; ++i2) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i2] === 38) {
              idxamp = i2;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(data.toString("binary", p, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i2 > p) {
              this._val += this.decoder.write(data.toString("binary", p, i2));
            }
            p = i2;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module.exports = UrlEncoded;
  }
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/@fastify/busboy/lib/main.js"(exports, module) {
    "use strict";
    var WritableStream = __require("stream").Writable;
    var { inherits } = __require("util");
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk2, encoding, cb) {
      this._parser.write(chunk2, cb);
    };
    module.exports = Busboy;
    module.exports.default = Busboy;
    module.exports.Busboy = Busboy;
    module.exports.Dicer = Dicer;
  }
});

// node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS({
  "node_modules/undici/lib/fetch/constants.js"(exports, module) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var subresourceSet = new Set(subresource);
    var DOMException2 = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel;
    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function structuredClone2(value, options = void 0) {
      if (arguments.length === 0) {
        throw new TypeError("missing argument");
      }
      if (!channel) {
        channel = new MessageChannel();
      }
      channel.port1.unref();
      channel.port2.unref();
      channel.port1.postMessage(value, options?.transfer);
      return receiveMessageOnPort(channel.port2).message;
    };
    module.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "node_modules/undici/lib/fetch/global.js"(exports, module) {
    "use strict";
    var globalOrigin = /* @__PURE__ */ Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/undici/lib/fetch/util.js"(exports, module) {
    "use strict";
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = __require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert3 = __require("assert");
    var { isUint8Array: isUint8Array2 } = __require("util/types");
    var supportedHashes = [];
    var crypto3;
    try {
      crypto3 = __require("crypto");
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto3.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i2 = 0; i2 < statusText.length; ++i2) {
        const c3 = statusText.charCodeAt(i2);
        if (!(c3 === 9 || // HTAB
        c3 >= 32 && c3 <= 126 || // SP / VCHAR
        c3 >= 128 && c3 <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenCharCode(c3) {
      switch (c3) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c3 >= 33 && c3 <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i2 = 0; i2 < characters.length; ++i2) {
        if (!isTokenCharCode(characters.charCodeAt(i2))) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i2 = policyHeader.length; i2 !== 0; i2--) {
          const token = policyHeader[i2 - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert3(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        // eslint-disable-line
        /**
           * 1. If referrerURL is a potentially trustworthy URL and
           * requests current URL is not a potentially trustworthy URL,
           * then return no referrer.
           * 2. Return referrerOrigin
          */
        case "no-referrer-when-downgrade":
        // eslint-disable-line
        /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * requests current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      assert3(url instanceof URL);
      if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:") return true;
      if (url.protocol === "file:") return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null") return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto3 === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto3.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i2 = 1; i2 < metadataList.length; ++i2) {
        const metadata = metadataList[i2];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i2 = 0; i2 < metadataList.length; ++i2) {
        if (metadataList[i2].algo === algorithm) {
          metadataList[pos++] = metadataList[i2];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i2 = 0; i2 < actualValue.length; ++i2) {
        if (actualValue[i2] !== expectedValue[i2]) {
          if (actualValue[i2] === "+" && expectedValue[i2] === "-" || actualValue[i2] === "/" && expectedValue[i2] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    var normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    Object.setPrototypeOf(normalizeMethodRecord, null);
    function normalizeMethod(method) {
      return normalizeMethodRecord[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert3(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i2 = {
        next() {
          if (Object.getPrototypeOf(this) !== i2) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i2, esIteratorPrototype);
      return Object.setPrototypeOf({}, i2);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream3 = globalThis.ReadableStream;
    function isReadableStreamLike(stream2) {
      if (!ReadableStream3) {
        ReadableStream3 = __require("stream/web").ReadableStream;
      }
      return stream2 instanceof ReadableStream3 || stream2[Symbol.toStringTag] === "ReadableStream" && typeof stream2.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        assert3(input.charCodeAt(i2) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength2 = 0;
      while (true) {
        const { done, value: chunk2 } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength2);
        }
        if (!isUint8Array2(chunk2)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk2);
        byteLength2 += chunk2.length;
      }
    }
    function urlIsLocal(url) {
      assert3("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      if (typeof url === "string") {
        return url.startsWith("https:");
      }
      return url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert3("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord,
      parseMetadata
    };
  }
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/undici/lib/fetch/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kUrl: /* @__PURE__ */ Symbol("url"),
      kHeaders: /* @__PURE__ */ Symbol("headers"),
      kSignal: /* @__PURE__ */ Symbol("signal"),
      kState: /* @__PURE__ */ Symbol("state"),
      kGuard: /* @__PURE__ */ Symbol("guard"),
      kRealm: /* @__PURE__ */ Symbol("realm")
    };
  }
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/undici/lib/fetch/webidl.js"(exports, module) {
    "use strict";
    var { types: types2 } = __require("util");
    var { hasOwn, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts = void 0) {
      if (opts?.strict !== false && !(V instanceof I)) {
        throw new TypeError("Illegal invocation");
      } else {
        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n2) {
      const r = Math.floor(Math.abs(n2));
      if (n2 < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = V?.[Symbol.iterator]?.();
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`
          });
        }
        const result = {};
        if (!types2.isProxy(O)) {
          const keys2 = Object.keys(O);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i2) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i2)) {
          throw webidl.errors.exception({
            header: i2.name,
            message: `Expected ${V} to be an instance of ${i2.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type2 = webidl.util.Type(dictionary);
        const dict = {};
        if (type2 === "Null" || type2 === "Undefined") {
          return dict;
        } else if (type2 !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "signed");
      return x;
    };
    webidl.converters["unsigned long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned");
      return x;
    };
    webidl.converters["unsigned long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned");
      return x;
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types2.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types2.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types2.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      }
      if (opts.allowShared === false && types2.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types2.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types2.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types2.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types2.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types2.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module.exports = {
      webidl
    };
  }
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/undici/lib/fetch/dataURL.js"(exports, module) {
    "use strict";
    var assert3 = __require("assert");
    var { atob: atob2 } = __require("buffer");
    var { isomorphicDecode } = require_util2();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert3(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }
      const href = url.href;
      const hashLength = url.hash.length;
      return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i2 = 0; i2 < input.length; i2++) {
        const byte = input[i2];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i2 + 1], input[i2 + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i2 + 1], input[i2 + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i2 += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type2 = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type2.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type2)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type2.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert3(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert3(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert3(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    module.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/undici/lib/fetch/file.js"(exports, module) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = __require("buffer");
    var { types: types2 } = __require("util");
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util();
    var encoder = new TextEncoder();
    var File2 = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n2 = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n2,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, _File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, _File);
        return this[kState].type;
      }
    };
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        const n2 = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n2,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File2.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types2.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder.encode(s));
        } else if (types2.isAnyArrayBuffer(element) || types2.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File2 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module.exports = { File: File2, FileLike, isFileLike };
  }
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/undici/lib/fetch/formdata.js"(exports, module) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = __require("buffer");
    var File2 = NativeFile ?? UndiciFile;
    var FormData2 = class _FormData {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name = webidl.converters.USVString(name);
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
    Object.defineProperties(FormData2.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File2([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File2([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module.exports = { FormData: FormData2 };
  }
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/undici/lib/fetch/body.js"(exports, module) {
    "use strict";
    var Busboy = require_main();
    var util = require_util();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2();
    var { FormData: FormData2 } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants2();
    var { Blob: Blob2, File: NativeFile } = __require("buffer");
    var { kBodyUsed } = require_symbols();
    var assert3 = __require("assert");
    var { isErrored } = require_util();
    var { isUint8Array: isUint8Array2, isArrayBuffer: isArrayBuffer2 } = __require("util/types");
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var random;
    try {
      const crypto3 = __require("crypto");
      random = (max) => crypto3.randomInt(0, max);
    } catch {
      random = (max) => Math.floor(Math.random(max));
    }
    var ReadableStream3 = globalThis.ReadableStream;
    var File2 = NativeFile ?? UndiciFile;
    var textEncoder3 = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream3) {
        ReadableStream3 = __require("stream/web").ReadableStream;
      }
      let stream2 = null;
      if (object instanceof ReadableStream3) {
        stream2 = object;
      } else if (isBlobLike(object)) {
        stream2 = object.stream();
      } else {
        stream2 = new ReadableStream3({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder3.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert3(isReadableStreamLike(stream2));
      let action = null;
      let source = null;
      let length = null;
      let type2 = null;
      if (typeof object === "string") {
        source = object;
        type2 = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type2 = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer2(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk3 = textEncoder3.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk3);
            length += chunk3.byteLength;
          } else {
            const chunk3 = textEncoder3.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk3, value, rn);
            if (typeof value.size === "number") {
              length += chunk3.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk2 = textEncoder3.encode(`--${boundary}--`);
        blobParts.push(chunk2);
        length += chunk2.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type2 = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type2 = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream2 = object instanceof ReadableStream3 ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream2 = new ReadableStream3({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream2)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream: stream2, source, length };
      return [body, type2];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream3) {
        ReadableStream3 = __require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream3) {
        assert3(!util.isDisturbed(object), "The body has already been consumed.");
        assert3(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array2(body)) {
          yield body;
        } else {
          const stream2 = body.stream;
          if (util.isDisturbed(stream2)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream2.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream2[kBodyUsed] = true;
          yield* stream2;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
            const responseFormData = new FormData2();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk2) => {
                  base64chunk += chunk2.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk2) => {
                  chunks.push(chunk2);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve, reject) => {
              busboy.on("finish", resolve);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null) for await (const chunk2 of consumeBody(this[kState].body)) busboy.write(chunk2);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries2;
            try {
              let text = "";
              const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk2 of consumeBody(this[kState].body)) {
                if (!isUint8Array2(chunk2)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk2, { stream: true });
              }
              text += streamingDecoder.decode();
              entries2 = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData2();
            for (const [name, value] of entries2) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error2) => promise.reject(error2);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/undici/lib/core/request.js"(exports, module) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert3 = __require("assert");
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
    var util = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = /* @__PURE__ */ Symbol("handler");
    var channels2 = {};
    var extractBody;
    try {
      const diagnosticsChannel2 = __require("diagnostics_channel");
      channels2.create = diagnosticsChannel2.channel("undici:request:create");
      channels2.bodySent = diagnosticsChannel2.channel("undici:request:bodySent");
      channels2.headers = diagnosticsChannel2.channel("undici:request:headers");
      channels2.trailers = diagnosticsChannel2.channel("undici:request:trailers");
      channels2.error = diagnosticsChannel2.channel("undici:request:error");
    } catch {
      channels2.create = { hasSubscribers: false };
      channels2.bodySent = { hasSubscribers: false };
      channels2.headers = { hasSubscribers: false };
      channels2.trailers = { hasSubscribers: false };
      channels2.error = { hasSubscribers: false };
    }
    var Request2 = class _Request {
      constructor(origin, {
        path: path2,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path2 !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path2[0] !== "/" && !(path2.startsWith("http://") || path2.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path2) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path2, query) : path2;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i2 = 0; i2 < headers.length; i2 += 2) {
            processHeader(this, headers[i2], headers[i2 + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i2 = 0; i2 < keys.length; i2++) {
            const key = keys[i2];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels2.create.hasSubscribers) {
          channels2.create.publish({ request: this });
        }
      }
      onBodySent(chunk2) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk2);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels2.bodySent.hasSubscribers) {
          channels2.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert3(!this.aborted);
        assert3(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert3(!this.aborted);
        assert3(!this.completed);
        if (channels2.headers.hasSubscribers) {
          channels2.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk2) {
        assert3(!this.aborted);
        assert3(!this.completed);
        try {
          return this[kHandler].onData(chunk2);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert3(!this.aborted);
        assert3(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert3(!this.aborted);
        this.completed = true;
        if (channels2.trailers.hasSubscribers) {
          channels2.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error2) {
        this.onFinally();
        if (channels2.error.hasSubscribers) {
          channels2.error.publish({ request: this, error: error2 });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error2);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };
        const request = new _Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i2 = 0; i2 < headers.length; i2 += 2) {
            processHeader(request, headers[i2], headers[i2 + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i2 = 0; i2 < keys.length; i2++) {
            const key = keys[i2];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");
          if (value == null || value.length === 0) continue;
          if (headers[key]) headers[key] += `,${value}`;
          else headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
        else request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i2 = 0; i2 < val.length; i2++) {
            if (skipAppend) {
              if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i2], skipAppend)}`;
              else request.headers[key] = processHeaderValue(key, val[i2], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i2]);
            }
          }
        } else {
          if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
          else request.headers += processHeaderValue(key, val);
        }
      }
    }
    module.exports = Request2;
  }
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/undici/lib/dispatcher.js"(exports, module) {
    "use strict";
    var EventEmitter3 = __require("events");
    var Dispatcher = class extends EventEmitter3 {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module.exports = Dispatcher;
  }
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/undici/lib/dispatcher-base.js"(exports, module) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = /* @__PURE__ */ Symbol("destroyed");
    var kClosed = /* @__PURE__ */ Symbol("closed");
    var kOnDestroyed = /* @__PURE__ */ Symbol("onDestroyed");
    var kOnClosed = /* @__PURE__ */ Symbol("onClosed");
    var kInterceptedDispatch = /* @__PURE__ */ Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i2 = newInterceptors.length - 1; i2 >= 0; i2--) {
            const interceptor = this[kInterceptors][i2];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i2 = 0; i2 < callbacks.length; i2++) {
            callbacks[i2](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i2 = 0; i2 < callbacks.length; i2++) {
            callbacks[i2](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i2 = this[kInterceptors].length - 1; i2 >= 0; i2--) {
          dispatch = this[kInterceptors][i2](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module.exports = DispatcherBase;
  }
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/undici/lib/core/connect.js"(exports, module) {
    "use strict";
    var net2 = __require("net");
    var assert3 = __require("assert");
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname: hostname2, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = __require("tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname2;
          const session = sessionCache.get(sessionKey) || null;
          assert3(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname2
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert3(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net2.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname2
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module.exports = buildConnector;
  }
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "node_modules/undici/lib/llhttp/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports.enumToMap = enumToMap;
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants3 = __commonJS({
  "node_modules/undici/lib/llhttp/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
    var utils_1 = require_utils2();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports.ERROR || (exports.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports.TYPE || (exports.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports.METHODS || (exports.METHODS = {}));
    exports.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports.H_METHOD_MAP = {};
    Object.keys(exports.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports.FINISH || (exports.FINISH = {}));
    exports.ALPHA = [];
    for (let i2 = "A".charCodeAt(0); i2 <= "Z".charCodeAt(0); i2++) {
      exports.ALPHA.push(String.fromCharCode(i2));
      exports.ALPHA.push(String.fromCharCode(i2 + 32));
    }
    exports.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
    exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports.ALPHANUM);
    exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i2 = 128; i2 <= 255; i2++) {
      exports.URL_CHAR.push(i2);
    }
    exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports.ALPHANUM);
    exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
    exports.HEADER_CHARS = ["	"];
    for (let i2 = 32; i2 <= 255; i2++) {
      if (i2 !== 127) {
        exports.HEADER_CHARS.push(i2);
      }
    }
    exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c3) => c3 !== 44);
    exports.MAJOR = exports.NUM_MAP;
    exports.MINOR = exports.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
    exports.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "node_modules/undici/lib/handler/RedirectHandler.js"(exports, module) {
    "use strict";
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert3 = __require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = __require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = /* @__PURE__ */ Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert3(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert3(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error2) {
        this.handler.onError(error2);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path2 = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path2;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk2) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk2);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk2) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk2);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i2 = 0; i2 < headers.length; i2 += 2) {
        if (headers[i2].toString().toLowerCase() === "location") {
          return headers[i2 + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (removeContent && util.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name = util.headerNameToString(header);
        return name === "authorization" || name === "cookie" || name === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i2 = 0; i2 < headers.length; i2 += 2) {
          if (!shouldRemoveHeader(headers[i2], removeContent, unknownOrigin)) {
            ret.push(headers[i2], headers[i2 + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert3(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module.exports = RedirectHandler;
  }
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports, module) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module.exports = createRedirectInterceptor;
  }
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports, module) {
    "use strict";
    module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAUNgIUIAAgATYCDEEAIRAMogELIABBADYCHCAAIBQ2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKEBCyAAQQA2AhwgACABNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhEAygAQtBACEQIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgwMnwELIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgxBACEQDJ4BCyAAQQA2AhwgACAUNgIUIABB/pGAgAA2AhAgAEEHNgIMQQAhEAydAQsgAEEANgIcIAAgATYCFCAAQY6bgIAANgIQIABBBjYCDEEAIRAMnAELIBBBFUYNVyAAQQA2AhwgACABNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhEAybAQsgAEEANgIAIBBBAWohAUEkIRALIAAgEDoAKSAAKAIEIRAgAEEANgIEIAAgECABEKuAgIAAIhANVCABIQEMPgsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQfGbgIAANgIQIABBBjYCDAyXAQsgAUEVRg1QIABBADYCHCAAIAU2AhQgAEHwjICAADYCECAAQRs2AgxBACEQDJYBCyAAKAIEIQUgAEEANgIEIAAgBSAQEKmAgIAAIgUNASAQQQFqIQULQa0BIRAMewsgAEHBATYCHCAAIAU2AgwgACAQQQFqNgIUQQAhEAyTAQsgACgCBCEGIABBADYCBCAAIAYgEBCpgICAACIGDQEgEEEBaiEGC0GuASEQDHgLIABBwgE2AhwgACAGNgIMIAAgEEEBajYCFEEAIRAMkAELIABBADYCHCAAIAc2AhQgAEGXi4CAADYCECAAQQ02AgxBACEQDI8BCyAAQQA2AhwgACAINgIUIABB45CAgAA2AhAgAEEJNgIMQQAhEAyOAQsgAEEANgIcIAAgCDYCFCAAQZSNgIAANgIQIABBITYCDEEAIRAMjQELQQEhFkEAIRdBACEUQQEhEAsgACAQOgArIAlBAWohCAJAAkAgAC0ALUEQcQ0AAkACQAJAIAAtACoOAwEAAgQLIBZFDQMMAgsgFA0BDAILIBdFDQELIAAoAgQhECAAQQA2AgQgACAQIAgQrYCAgAAiEEUNPSAAQckBNgIcIAAgCDYCFCAAIBA2AgxBACEQDIwBCyAAKAIEIQQgAEEANgIEIAAgBCAIEK2AgIAAIgRFDXYgAEHKATYCHCAAIAg2AhQgACAENgIMQQAhEAyLAQsgACgCBCEEIABBADYCBCAAIAQgCRCtgICAACIERQ10IABBywE2AhwgACAJNgIUIAAgBDYCDEEAIRAMigELIAAoAgQhBCAAQQA2AgQgACAEIAoQrYCAgAAiBEUNciAAQc0BNgIcIAAgCjYCFCAAIAQ2AgxBACEQDIkBCwJAIAstAABBUGoiEEH/AXFBCk8NACAAIBA6ACogC0EBaiEKQbYBIRAMcAsgACgCBCEEIABBADYCBCAAIAQgCxCtgICAACIERQ1wIABBzwE2AhwgACALNgIUIAAgBDYCDEEAIRAMiAELIABBADYCHCAAIAQ2AhQgAEGQs4CAADYCECAAQQg2AgwgAEEANgIAQQAhEAyHAQsgAUEVRg0/IABBADYCHCAAIAw2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDIYBCyAAQYEEOwEoIAAoAgQhECAAQgA3AwAgACAQIAxBAWoiDBCrgICAACIQRQ04IABB0wE2AhwgACAMNgIUIAAgEDYCDEEAIRAMhQELIABBADYCAAtBACEQIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMgwELIAAoAgQhECAAQgA3AwAgACAQIAtBAWoiCxCrgICAACIQDQFBxgEhEAxpCyAAQQI6ACgMVQsgAEHVATYCHCAAIAs2AhQgACAQNgIMQQAhEAyAAQsgEEEVRg03IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEQDH8LIAAtADRBAUcNNCAAIAQgAhC8gICAACIQRQ00IBBBFUcNNSAAQdwBNgIcIAAgBDYCFCAAQdWWgIAANgIQIABBFTYCDEEAIRAMfgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQMfQtBACEQDGMLQQIhEAxiC0ENIRAMYQtBDyEQDGALQSUhEAxfC0ETIRAMXgtBFSEQDF0LQRYhEAxcC0EXIRAMWwtBGCEQDFoLQRkhEAxZC0EaIRAMWAtBGyEQDFcLQRwhEAxWC0EdIRAMVQtBHyEQDFQLQSEhEAxTC0EjIRAMUgtBxgAhEAxRC0EuIRAMUAtBLyEQDE8LQTshEAxOC0E9IRAMTQtByAAhEAxMC0HJACEQDEsLQcsAIRAMSgtBzAAhEAxJC0HOACEQDEgLQdEAIRAMRwtB1QAhEAxGC0HYACEQDEULQdkAIRAMRAtB2wAhEAxDC0HkACEQDEILQeUAIRAMQQtB8QAhEAxAC0H0ACEQDD8LQY0BIRAMPgtBlwEhEAw9C0GpASEQDDwLQawBIRAMOwtBwAEhEAw6C0G5ASEQDDkLQa8BIRAMOAtBsQEhEAw3C0GyASEQDDYLQbQBIRAMNQtBtQEhEAw0C0G6ASEQDDMLQb0BIRAMMgtBvwEhEAwxC0HBASEQDDALIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEQDEgLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhEAxHCyAAQfgANgIcIAAgDDYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMRgsgAEHRADYCHCAAIAU2AhQgAEGwl4CAADYCECAAQRU2AgxBACEQDEULIABB+QA2AhwgACABNgIUIAAgEDYCDEEAIRAMRAsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEQDEMLIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAxCCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAIRAMQQsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMQAsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEQDD8LIABBADYCBCAAIA8gDxCxgICAACIERQ0BIABBOjYCHCAAIAQ2AgwgACAPQQFqNgIUQQAhEAw+CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAIRAMPgsgAUEBaiEBDC0LIA9BAWohAQwtCyAAQQA2AhwgACAPNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhEAw7CyAAQTY2AhwgACAENgIUIAAgAjYCDEEAIRAMOgsgAEEuNgIcIAAgDjYCFCAAIAQ2AgxBACEQDDkLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhEAw4CyANQQFqIQEMLAsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMNgsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNQsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNAsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMMwsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMgsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMQsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAIRAMMAsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAMLwsgAEEANgIcIAAgEDYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMLgsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMLQsgAEEANgIAIAtBAWohCwtBuAEhEAwSCyAAQQA2AgAgEEEBaiEBQfUAIRAMEQsgASEBAkAgAC0AKUEFRw0AQeMAIRAMEQtB4gAhEAwQC0EAIRAgAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAwoCyAAQQA2AgAgF0EBaiEBQcAAIRAMDgtBASEBCyAAIAE6ACwgAEEANgIAIBdBAWohAQtBKCEQDAsLIAEhAQtBOCEQDAkLAkAgASIPIAJGDQADQAJAIA8tAABBgL6AgABqLQAAIgFBAUYNACABQQJHDQMgD0EBaiEBDAQLIA9BAWoiDyACRw0AC0E+IRAMIgtBPiEQDCELIABBADoALCAPIQEMAQtBCyEQDAYLQTohEAwFCyABQQFqIQFBLSEQDAQLIAAgAToALCAAQQA2AgAgFkEBaiEBQQwhEAwDCyAAQQA2AgAgF0EBaiEBQQohEAwCCyAAQQA2AgALIABBADoALCANIQFBCSEQDAALC0EAIRAgAEEANgIcIAAgCzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAIRAgAEEANgIcIAAgCjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAIRAgAEEANgIcIAAgCTYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAIRAgAEEANgIcIAAgCDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAIRAgAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAIRAgAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAIRAgAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAIRAgAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAIRAgAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAIRAgAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAIRAgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAIRAgAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAIRAgAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAIRAgAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAIRAgAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhEAwGC0EBIRAMBQtB1AAhECABIgQgAkYNBCADQQhqIAAgBCACQdjCgIAAQQoQxYCAgAAgAygCDCEEIAMoAggOAwEEAgALEMqAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgBEEBajYCFEEAIRAMAgsgAEEANgIcIAAgBDYCFCAAQcqagIAANgIQIABBCTYCDEEAIRAMAQsCQCABIgQgAkcNAEEiIRAMAQsgAEGJgICAADYCCCAAIAQ2AgRBISEQCyADQRBqJICAgIAAIBALrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAvyNgELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMuAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAkFIaiIFIANrIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAQYDUhIAAIAVqQTg2AgQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQACQAJAIANBAXEgBHJBAXMiBUEDdCIEQbDQgIAAaiIDIARBuNCAgABqKAIAIgQoAggiAkcNAEEAIAZBfiAFd3E2AojQgIAADAELIAMgAjYCCCACIAM2AgwLIARBCGohAyAEIAVBA3QiBUEDcjYCBCAEIAVqIgQgBCgCBEEBcjYCBAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgRBA3QiA0Gw0ICAAGoiBSADQbjQgIAAaigCACIDKAIIIgBHDQBBACAGQX4gBHdxIgY2AojQgIAADAELIAUgADYCCCAAIAU2AgwLIAMgAkEDcjYCBCADIARBA3QiBGogBCACayIFNgIAIAMgAmoiACAFQQFyNgIEAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAHQQN2dCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIICyADQQhqIQNBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQAgACgCCCIDQQAoApjQgIAASRogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNACAIKAIIIgNBACgCmNCAgABJGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAQgA2oiAyADKAIEQQFyNgIEQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMuAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMuAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDLgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQy4CAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQy4CAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQy4CAgAAhAEEAEMuAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBkFIaiIFIANrIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAIAAgBWpBODYCBAwCCyADLQAMQQhxDQAgBCAFSQ0AIAQgAE8NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAQgC2pBODYCBAwBCwJAIABBACgCmNCAgAAiCE8NAEEAIAA2ApjQgIAAIAAhCAsgACAGaiEFQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgBUYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiCyACQQNyNgIEIAVBeCAFa0EPcUEAIAVBCGpBD3EbaiIGIAsgAmoiAmshAwJAIAYgBEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgA2oiAzYClNCAgAAgAiADQQFyNgIEDAMLAkAgBkEAKAKc0ICAAEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgA2oiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAYoAgQiBEEDcUEBRw0AIARBeHEhBwJAAkAgBEH/AUsNACAGKAIIIgUgBEEDdiIIQQN0QbDQgIAAaiIARhoCQCAGKAIMIgQgBUcNAEEAQQAoAojQgIAAQX4gCHdxNgKI0ICAAAwCCyAEIABGGiAEIAU2AgggBSAENgIMDAELIAYoAhghCQJAAkAgBigCDCIAIAZGDQAgBigCCCIEIAhJGiAAIAQ2AgggBCAANgIMDAELAkAgBkEUaiIEKAIAIgUNACAGQRBqIgQoAgAiBQ0AQQAhAAwBCwNAIAQhCCAFIgBBFGoiBCgCACIFDQAgAEEQaiEEIAAoAhAiBQ0ACyAIQQA2AgALIAlFDQACQAJAIAYgBigCHCIFQQJ0QbjSgIAAaiIEKAIARw0AIAQgADYCACAADQFBAEEAKAKM0ICAAEF+IAV3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAGRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgBigCECIERQ0AIAAgBDYCECAEIAA2AhgLIAYoAhQiBEUNACAAQRRqIAQ2AgAgBCAANgIYCyAHIANqIQMgBiAHaiIGKAIEIQQLIAYgBEF+cTYCBCACIANqIAM2AgAgAiADQQFyNgIEAkAgA0H/AUsNACADQXhxQbDQgIAAaiEEAkACQEEAKAKI0ICAACIFQQEgA0EDdnQiA3ENAEEAIAUgA3I2AojQgIAAIAQhAwwBCyAEKAIIIQMLIAMgAjYCDCAEIAI2AgggAiAENgIMIAIgAzYCCAwDC0EfIQQCQCADQf///wdLDQAgA0EIdiIEIARBgP4/akEQdkEIcSIEdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiAEIAVyIAByayIEQQF0IAMgBEEVanZBAXFyQRxqIQQLIAIgBDYCHCACQgA3AhAgBEECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASAEdCIIcQ0AIAUgAjYCAEEAIAAgCHI2AozQgIAAIAIgBTYCGCACIAI2AgggAiACNgIMDAMLIANBAEEZIARBAXZrIARBH0YbdCEEIAUoAgAhAANAIAAiBSgCBEF4cSADRg0CIARBHXYhACAEQQF0IQQgBSAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBTYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBkFIaiIIIANrIgNBAXI2AgQgACAIakE4NgIEIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgAzYClNCAgABBACALNgKg0ICAACAIQRBqQQApAtDTgIAANwIAIAhBACkCyNOAgAA3AghBACAIQQhqNgLQ04CAAEEAIAY2AszTgIAAQQAgADYCyNOAgABBAEEANgLU04CAACAIQSRqIQMDQCADQQc2AgAgA0EEaiIDIAVJDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgA2AgAgBCAAQQFyNgIEAkAgAEH/AUsNACAAQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAAQf///wdLDQAgAEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIIIAhBgIAPakEQdkECcSIIdEEPdiADIAVyIAhyayIDQQF0IAAgA0EVanZBAXFyQRxqIQMLIAQgAzYCHCAEQgA3AhAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIghBASADdCIGcQ0AIAUgBDYCAEEAIAggBnI2AozQgIAAIAQgBTYCGCAEIAQ2AgggBCAENgIMDAQLIABBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhCANAIAgiBSgCBEF4cSAARg0DIANBHXYhCCADQQF0IQMgBSAIQQRxakEQaiIGKAIAIggNAAsgBiAENgIAIAQgBTYCGCAEIAQ2AgwgBCAENgIIDAMLIAUoAggiAyACNgIMIAUgAjYCCCACQQA2AhggAiAFNgIMIAIgAzYCCAsgC0EIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQQA2AhggBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgCCADaiIDIAMoAgRBAXI2AgQMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEF4cUGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIARBA3Z0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCAAIANqIgMgAygCBEEBcjYCBAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQMCQAJAQQEgB0EDdnQiCCAGcQ0AQQAgCCAGcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2ApzQgIAAQQAgBDYCkNCAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQyYCAgAAL4g0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApjQgIAAIgRJDQEgAiAAaiEAAkAgAUEAKAKc0ICAAEYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAEoAggiAiAESRogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABIAEoAhwiBEECdEG40oCAAGoiAigCAEcNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQ0ICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgASADTw0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkAgA0EAKAKg0ICAAEcNAEEAIAE2AqDQgIAAQQBBACgClNCAgAAgAGoiADYClNCAgAAgASAAQQFyNgIEIAFBACgCnNCAgABHDQNBAEEANgKQ0ICAAEEAQQA2ApzQgIAADwsCQCADQQAoApzQgIAARw0AQQAgATYCnNCAgABBAEEAKAKQ0ICAACAAaiIANgKQ0ICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNACADKAIIIgJBACgCmNCAgABJGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMgAygCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnNCAgABHDQFBACAANgKQ0ICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEF4cUGw0ICAAGohAgJAAkBBACgCiNCAgAAiBEEBIABBA3Z0IgBxDQBBACAEIAByNgKI0ICAACACIQAMAQsgAigCCCEACyAAIAE2AgwgAiABNgIIIAEgAjYCDCABIAA2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAEgAjYCHCABQgA3AhAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgASAENgIYIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABIAQ2AhggASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEANgIYIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLBAAAAAtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+NOAgABBfw8LIABBEHQPCxDKgICAAAAL8gICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports, module) {
    "use strict";
    module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/undici/lib/client.js"(exports, module) {
    "use strict";
    var assert3 = __require("assert");
    var net2 = __require("net");
    var http3 = __require("http");
    var { pipeline } = __require("stream");
    var util = require_util();
    var timers = require_timers();
    var Request2 = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols();
    var http22;
    try {
      http22 = __require("http2");
    } catch {
      http22 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http22;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = /* @__PURE__ */ Symbol("kClosedResolve");
    var channels2 = {};
    try {
      const diagnosticsChannel2 = __require("diagnostics_channel");
      channels2.sendHeaders = diagnosticsChannel2.channel("undici:client:sendHeaders");
      channels2.beforeConnect = diagnosticsChannel2.channel("undici:client:beforeConnect");
      channels2.connectError = diagnosticsChannel2.channel("undici:client:connectError");
      channels2.connected = diagnosticsChannel2.channel("undici:client:connected");
    } catch {
      channels2.sendHeaders = { hasSubscribers: false };
      channels2.beforeConnect = { hasSubscribers: false };
      channels2.connectError = { hasSubscribers: false };
      channels2.connected = { hasSubscribers: false };
    }
    var Client = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net2.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http3.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2 ? null : {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
          // Max peerConcurrentStreams for a Node h2 server
        };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = this[kHTTPConnVersion] === "h2" ? Request2[kHTTP2BuildRequest](origin, opts, handler) : Request2[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (!this[kSize]) {
            resolve(null);
          } else {
            this[kClosedResolve] = resolve;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i2 = 0; i2 < requests.length; i2++) {
            const request = requests[i2];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve();
          };
          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert3(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type2, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type2}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed"));
      util.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert3(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i2 = 0; i2 < requests.length; i2++) {
          const request = requests[i2];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert3(client[kRunning] === 0);
      client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      );
      resume(client);
    }
    var constants2 = require_constants3();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert3.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert3.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert3.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports2 }) {
        assert3(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports2;
        this.ptr = this.llhttp.llhttp_alloc(constants2.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type2) {
        this.timeoutType = type2;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert3(this.ptr != null);
        assert3(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert3(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk2 = this.socket.read();
          if (chunk2 === null) {
            break;
          }
          this.execute(chunk2);
        }
      }
      execute(data) {
        assert3(this.ptr != null);
        assert3(currentParser == null);
        assert3(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants2.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants2.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants2.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants2.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert3(this.ptr != null);
        assert3(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert3(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert3(request);
        assert3(!socket.destroyed);
        assert3(socket === client[kSocket]);
        assert3(!this.paused);
        assert3(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert3(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert3(!this.upgrade);
        assert3(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert3.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert3(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert3(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert3(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants2.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert3(request);
        assert3.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert3(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants2.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert3(request);
        assert3(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert3(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert3.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants2.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants2.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants2.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert3(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert3(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;
      assert3(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (client[kHTTPConnVersion] !== "h2") {
        if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert3(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i2 = 0; i2 < requests.length; i2++) {
          const request = requests[i2];
          errorRequest(client, request, err);
        }
        assert3(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2") {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;
      if (client[kHTTPConnVersion] === "h1" && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert3(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i2 = 0; i2 < requests.length; i2++) {
          const request = requests[i2];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert3(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert3(!client[kConnecting]);
      assert3(!client[kSocket]);
      let { host, hostname: hostname2, protocol, port } = client[kUrl];
      if (hostname2[0] === "[") {
        const idx = hostname2.indexOf("]");
        assert3(idx !== -1);
        const ip = hostname2.substring(1, idx);
        assert3(net2.isIP(ip));
        hostname2 = ip;
      }
      client[kConnecting] = true;
      if (channels2.beforeConnect.hasSubscribers) {
        channels2.beforeConnect.publish({
          connectParams: {
            host,
            hostname: hostname2,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname: hostname2,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        client[kConnecting] = false;
        assert3(socket);
        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", {
              code: "UNDICI-H2"
            });
          }
          const session = http22.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels2.connected.hasSubscribers) {
          channels2.connected.publish({
            connectParams: {
              host,
              hostname: hostname2,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels2.connectError.hasSubscribers) {
          channels2.connectError.publish({
            connectParams: {
              host,
              hostname: hostname2,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert3(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert3(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path: path2, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      let contentLength = bodyLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path2} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels2.sendHeaders.hasSubscribers) {
        channels2.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert3(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert3(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert3(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path: path2, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === "string") headers = Request2[kHTTP2CopyHeaders](reqHeaders.trim());
      else headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream2;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === "CONNECT") {
        session.ref();
        stream2 = session.request(headers, { endStream: false, signal });
        if (stream2.id && !stream2.pending) {
          request.onUpgrade(null, null, stream2);
          ++h2State.openStreams;
        } else {
          stream2.once("ready", () => {
            request.onUpgrade(null, null, stream2);
            ++h2State.openStreams;
          });
        }
        stream2.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0) session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path2;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert3(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream2 = session.request(headers, { endStream: shouldEndStream, signal });
        stream2.once("continue", writeBodyH2);
      } else {
        stream2 = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream2.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        if (request.onHeaders(Number(statusCode), realHeaders, stream2.resume.bind(stream2), "") === false) {
          stream2.pause();
        }
      });
      stream2.once("end", () => {
        request.onComplete([]);
      });
      stream2.on("data", (chunk2) => {
        if (request.onData(chunk2) === false) {
          stream2.pause();
        }
      });
      stream2.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) {
          session.unref();
        }
      });
      stream2.once("error", function(err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream2, err);
        }
      });
      stream2.once("frameError", (type2, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type2}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream2, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert3(contentLength === body.byteLength, "buffer body must have content length");
          stream2.cork();
          stream2.write(body);
          stream2.uncork();
          stream2.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream2,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: ""
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream2,
              header: "",
              socket: client[kSocket]
            });
          }
        } else if (util.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream2,
            header: ""
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream2,
            socket: client[kSocket]
          });
        } else {
          assert3(false);
        }
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert3(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      if (client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk2) {
          request.onBodySent(chunk2);
        };
        const pipe = pipeline(
          body,
          h2stream,
          (err) => {
            if (err) {
              util.destroy(body, err);
              util.destroy(h2stream, err);
            } else {
              request.onRequestSent();
            }
          }
        );
        pipe.on("data", onPipeData);
        pipe.once("end", () => {
          pipe.removeListener("data", onPipeData);
          util.destroy(pipe);
        });
        return;
      }
      let finished2 = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk2) {
        if (finished2) {
          return;
        }
        try {
          if (!writer.write(chunk2) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished2) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        if (finished2) {
          return;
        }
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      };
      const onFinished = function(err) {
        if (finished2) {
          return;
        }
        finished2 = true;
        assert3(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert3(contentLength === body.size, "blob body must have content length");
      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert3(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert3(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const chunk2 of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk2);
            request.onBodySent(chunk2);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk2 of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk2)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk2) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk2);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk2);
        socket.uncork();
        request.onBodySent(chunk2);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert3(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert3(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module.exports = Client;
  }
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/undici/lib/node/fixed-queue.js"(exports, module) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/undici/lib/pool-stats.js"(exports, module) {
    "use strict";
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = /* @__PURE__ */ Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module.exports = PoolStats;
  }
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/undici/lib/pool-base.js"(exports, module) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = /* @__PURE__ */ Symbol("clients");
    var kNeedDrain = /* @__PURE__ */ Symbol("needDrain");
    var kQueue = /* @__PURE__ */ Symbol("queue");
    var kClosedResolve = /* @__PURE__ */ Symbol("closed resolve");
    var kOnDrain = /* @__PURE__ */ Symbol("onDrain");
    var kOnConnect = /* @__PURE__ */ Symbol("onConnect");
    var kOnDisconnect = /* @__PURE__ */ Symbol("onDisconnect");
    var kOnConnectionError = /* @__PURE__ */ Symbol("onConnectionError");
    var kGetDispatcher = /* @__PURE__ */ Symbol("get dispatcher");
    var kAddClient = /* @__PURE__ */ Symbol("add client");
    var kRemoveClient = /* @__PURE__ */ Symbol("remove client");
    var kStats = /* @__PURE__ */ Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c3) => c3.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c3) => c3.close()));
        } else {
          return new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c3) => c3.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/undici/lib/pool.js"(exports, module) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = /* @__PURE__ */ Symbol("options");
    var kConnections = /* @__PURE__ */ Symbol("connections");
    var kFactory = /* @__PURE__ */ Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
        this.on("connectionError", (origin2, targets, error2) => {
          for (const target of targets) {
            const idx = this[kClients].indexOf(target);
            if (idx !== -1) {
              this[kClients].splice(idx, 1);
            }
          }
        });
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module.exports = Pool;
  }
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/undici/lib/balanced-pool.js"(exports, module) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = /* @__PURE__ */ Symbol("factory");
    var kOptions = /* @__PURE__ */ Symbol("options");
    var kGreatestCommonDivisor = /* @__PURE__ */ Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = /* @__PURE__ */ Symbol("kCurrentWeight");
    var kIndex = /* @__PURE__ */ Symbol("kIndex");
    var kWeight = /* @__PURE__ */ Symbol("kWeight");
    var kMaxWeightPerServer = /* @__PURE__ */ Symbol("kMaxWeightPerServer");
    var kErrorPenalty = /* @__PURE__ */ Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a2, b) {
      if (b === 0) return a2;
      return getGreatestCommonDivisor(b, a2 % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a2, b) => a2 && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module.exports = BalancedPool;
  }
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports, module) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module.exports = function() {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/undici/lib/agent.js"(exports, module) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = /* @__PURE__ */ Symbol("onConnect");
    var kOnDisconnect = /* @__PURE__ */ Symbol("onDisconnect");
    var kOnConnectionError = /* @__PURE__ */ Symbol("onConnectionError");
    var kMaxRedirections = /* @__PURE__ */ Symbol("maxRedirections");
    var kOnDrain = /* @__PURE__ */ Symbol("onDrain");
    var kFactory = /* @__PURE__ */ Symbol("factory");
    var kFinalizer = /* @__PURE__ */ Symbol("finalizer");
    var kOptions = /* @__PURE__ */ Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module.exports = Agent;
  }
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/undici/lib/api/readable.js"(exports, module) {
    "use strict";
    var assert3 = __require("assert");
    var { Readable } = __require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob2;
    var kConsume = /* @__PURE__ */ Symbol("kConsume");
    var kReading = /* @__PURE__ */ Symbol("kReading");
    var kBody = /* @__PURE__ */ Symbol("kBody");
    var kAbort = /* @__PURE__ */ Symbol("abort");
    var kContentType = /* @__PURE__ */ Symbol("kContentType");
    var noop4 = () => {
    };
    module.exports = class BodyReadable extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk2) {
        if (this[kConsume] && chunk2 !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk2);
          return this[kReading] ? super.push(chunk2) : true;
        }
        return super.push(chunk2);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert3(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        if (signal) {
          try {
            if (typeof signal !== "object" || !("aborted" in signal)) {
              throw new InvalidArgumentError("signal must be an AbortSignal");
            }
            util.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        }
        if (this.closed) {
          return Promise.resolve(null);
        }
        return new Promise((resolve, reject) => {
          const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
            this.destroy();
          }) : noop4;
          this.on("close", function() {
            signalListenerCleanup();
            if (signal && signal.aborted) {
              reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
            } else {
              resolve(null);
            }
          }).on("error", noop4).on("data", function(chunk2) {
            limit -= chunk2.length;
            if (limit <= 0) {
              this.destroy();
            }
          }).resume();
        });
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
    }
    function isUnusable(self2) {
      return util.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream2, type2) {
      if (isUnusable(stream2)) {
        throw new TypeError("unusable");
      }
      assert3(!stream2[kConsume]);
      return new Promise((resolve, reject) => {
        stream2[kConsume] = {
          type: type2,
          stream: stream2,
          resolve,
          reject,
          length: 0,
          body: []
        };
        stream2.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream2[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk2 of state.buffer) {
        consumePush(consume2, chunk2);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type: type2, body, resolve, stream: stream2, length } = consume2;
      try {
        if (type2 === "text") {
          resolve(toUSVString(Buffer.concat(body)));
        } else if (type2 === "json") {
          resolve(JSON.parse(Buffer.concat(body)));
        } else if (type2 === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve(dst.buffer);
        } else if (type2 === "blob") {
          if (!Blob2) {
            Blob2 = __require("buffer").Blob;
          }
          resolve(new Blob2(body, { type: stream2[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream2.destroy(err);
      }
    }
    function consumePush(consume2, chunk2) {
      consume2.length += chunk2.length;
      consume2.body.push(chunk2);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS({
  "node_modules/undici/lib/api/util.js"(exports, module) {
    "use strict";
    var assert3 = __require("assert");
    var {
      ResponseStatusCodeError
    } = require_errors();
    var { toUSVString } = require_util();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert3(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk2 of body) {
        chunks.push(chunk2);
        limit += chunk2.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module.exports = { getResolveErrorBodyCallback };
  }
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/undici/lib/api/abort-signal.js"(exports, module) {
    "use strict";
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors();
    var kListener = /* @__PURE__ */ Symbol("kListener");
    var kSignal = /* @__PURE__ */ Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort();
      } else {
        self2.onError(new RequestAbortedError());
      }
    }
    function addSignal(self2, signal) {
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      addAbortListener(self2[kSignal], self2[kListener]);
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/undici/lib/api/api-request.js"(exports, module) {
    "use strict";
    var Readable = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable({ resume, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context
            });
          }
        }
      }
      onData(chunk2) {
        const { res } = this;
        return res.push(chunk2);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = request;
    module.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/undici/lib/api/api-stream.js"(exports, module) {
    "use strict";
    var { finished: finished2, PassThrough } = __require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished2(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk2) {
        const { res } = this;
        return res ? res.write(chunk2) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream2(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream2.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = stream2;
  }
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/undici/lib/api/api-pipeline.js"(exports, module) {
    "use strict";
    var {
      Readable,
      Duplex: Duplex2,
      PassThrough
    } = __require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert3 = __require("assert");
    var kResume = /* @__PURE__ */ Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex2({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk2, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk2, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert3(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk2) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk2) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk2) {
        const { res } = this;
        return res.push(chunk2);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module.exports = pipeline;
  }
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/undici/lib/api/api-upgrade.js"(exports, module) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = __require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert3 = __require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert3.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = upgrade;
  }
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/undici/lib/api/api-connect.js"(exports, module) {
    "use strict";
    var { AsyncResource } = __require("async_hooks");
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = connect;
  }
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/undici/lib/api/index.js"(exports, module) {
    "use strict";
    module.exports.request = require_api_request();
    module.exports.stream = require_api_stream();
    module.exports.pipeline = require_api_pipeline();
    module.exports.upgrade = require_api_upgrade();
    module.exports.connect = require_api_connect();
  }
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/undici/lib/mock/mock-errors.js"(exports, module) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/undici/lib/mock/mock-symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kAgent: /* @__PURE__ */ Symbol("agent"),
      kOptions: /* @__PURE__ */ Symbol("options"),
      kFactory: /* @__PURE__ */ Symbol("factory"),
      kDispatches: /* @__PURE__ */ Symbol("dispatches"),
      kDispatchKey: /* @__PURE__ */ Symbol("dispatch key"),
      kDefaultHeaders: /* @__PURE__ */ Symbol("default headers"),
      kDefaultTrailers: /* @__PURE__ */ Symbol("default trailers"),
      kContentLength: /* @__PURE__ */ Symbol("content length"),
      kMockAgent: /* @__PURE__ */ Symbol("mock agent"),
      kMockAgentSet: /* @__PURE__ */ Symbol("mock agent set"),
      kMockAgentGet: /* @__PURE__ */ Symbol("mock agent get"),
      kMockDispatch: /* @__PURE__ */ Symbol("mock dispatch"),
      kClose: /* @__PURE__ */ Symbol("close"),
      kOriginalClose: /* @__PURE__ */ Symbol("original agent close"),
      kOrigin: /* @__PURE__ */ Symbol("origin"),
      kIsMockActive: /* @__PURE__ */ Symbol("is mock active"),
      kNetConnect: /* @__PURE__ */ Symbol("net connect"),
      kGetNetConnect: /* @__PURE__ */ Symbol("get net connect"),
      kConnected: /* @__PURE__ */ Symbol("connected")
    };
  }
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/undici/lib/mock/mock-utils.js"(exports, module) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util();
    var { STATUS_CODES } = __require("http");
    var {
      types: {
        isPromise: isPromise2
      }
    } = __require("util");
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i2 = 0; i2 < headers.length; i2 += 2) {
          if (headers[i2].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i2 + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries2 = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries2.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries2);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path2) {
      if (typeof path2 !== "string") {
        return path2;
      }
      const pathSegments = path2.split("?");
      if (pathSegments.length !== 2) {
        return path2;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path: path2, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path2);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path2 }) => matchValue(safeUrl(path2), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path: path2, method, body, headers, query } = opts;
      return {
        path: path2,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error: error2 }, delay: delay3, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error2 !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error2);
        return true;
      }
      if (typeof delay3 === "number" && delay3 > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay3);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise2(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error2) {
            if (error2 instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error2;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/undici/lib/mock/mock-interceptor.js"(exports, module) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error2) {
        if (typeof error2 === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module.exports.MockInterceptor = MockInterceptor;
    module.exports.MockScope = MockScope;
  }
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/undici/lib/mock/mock-client.js"(exports, module) {
    "use strict";
    var { promisify: promisify5 } = __require("util");
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify5(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module.exports = MockClient;
  }
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/undici/lib/mock/mock-pool.js"(exports, module) {
    "use strict";
    var { promisify: promisify5 } = __require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify5(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module.exports = MockPool;
  }
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "node_modules/undici/lib/mock/pluralizer.js"(exports, module) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports, module) {
    "use strict";
    var { Transform } = __require("stream");
    var { Console } = __require("console");
    module.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk2, _enc, cb) {
            cb(null, chunk2);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path: path2, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path2,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/undici/lib/mock/mock-agent.js"(exports, module) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module.exports = MockAgent;
  }
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/undici/lib/proxy-agent.js"(exports, module) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL3 } = __require("url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = /* @__PURE__ */ Symbol("proxy agent");
    var kClient = /* @__PURE__ */ Symbol("proxy client");
    var kProxyHeaders = /* @__PURE__ */ Symbol("proxy headers");
    var kRequestTls = /* @__PURE__ */ Symbol("request tls settings");
    var kProxyTls = /* @__PURE__ */ Symbol("proxy tls settings");
    var kConnectEndpoint = /* @__PURE__ */ Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        const resolvedUrl = new URL3(opts.uri);
        const { origin, port, host, username, password } = resolvedUrl;
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL3(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i2 = 0; i2 < headers.length; i2 += 2) {
          headersPair[headers[i2]] = headers[i2 + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module.exports = ProxyAgent;
  }
});

// node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
  "node_modules/undici/lib/handler/RetryHandler.js"(exports, module) {
    "use strict";
    var assert3 = __require("assert");
    var { kRetryHandlerDefaultRetry } = require_symbols();
    var { RequestRetryError } = require_errors();
    var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      const diff = new Date(retryAfter).getTime() - current;
      return diff;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = handlers.dispatch;
        this.handler = handlers.handler;
        this.opts = dispatchOpts;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          timeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE"
          ]
        };
        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }
      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }
      onBodySent(chunk2) {
        if (this.handler.onBodySent) return this.handler.onBodySent(chunk2);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        let { counter, currentTimeout } = state;
        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
        if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers != null && headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
        state.currentTimeout = retryTimeout;
        setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = parseHeaders(rawHeaders);
        this.retryCount += 1;
        if (statusCode >= 300) {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount
            })
          );
          return false;
        }
        if (this.resume != null) {
          this.resume = null;
          if (statusCode !== 206) {
            return true;
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          const { start, size, end = size } = contentRange;
          assert3(this.start === start, "content-range mismatch");
          assert3(this.end == null || this.end === end, "content-range mismatch");
          this.resume = resume;
          return true;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            }
            const { start, size, end = size } = range;
            assert3(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            );
            assert3(Number.isFinite(start));
            assert3(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            );
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }
          assert3(Number.isFinite(this.start));
          assert3(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = resume;
          this.etag = headers.etag != null ? headers.etag : null;
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        });
        this.abort(err);
        return false;
      }
      onData(chunk2) {
        this.start += chunk2.length;
        return this.handler.onData(chunk2);
      }
      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err2);
          }
          if (this.start !== 0) {
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                range: `bytes=${this.start}-${this.end ?? ""}`
              }
            };
          }
          try {
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module.exports = RetryHandler;
  }
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/undici/lib/global.js"(exports, module) {
    "use strict";
    var globalDispatcher = /* @__PURE__ */ Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "node_modules/undici/lib/handler/DecoratorHandler.js"(exports, module) {
    "use strict";
    module.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/undici/lib/fetch/headers.js"(exports, module) {
    "use strict";
    var { kHeadersList, kConstruct } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var util = __require("util");
    var { webidl } = require_webidl();
    var assert3 = __require("assert");
    var kHeadersMap = /* @__PURE__ */ Symbol("headers map");
    var kHeadersSortedMap = /* @__PURE__ */ Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i2 = 0;
      let j = potentialValue.length;
      while (j > i2 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
      while (j > i2 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i2))) ++i2;
      return i2 === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i2, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i2 = 0; i2 < object.length; ++i2) {
          const header = object[i2];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i2 = 0; i2 < keys.length; ++i2) {
          appendHeader(headers, keys[i2], object[keys[i2]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (headers[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (headers[kGuard] === "request-no-cors") {
      }
      return headers[kHeadersList].append(name, value);
    }
    var HeadersList = class _HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;
      constructor(init2) {
        if (init2 instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init2[kHeadersMap]);
          this[kHeadersSortedMap] = init2[kHeadersSortedMap];
          this.cookies = init2.cookies === null ? null : [...init2.cookies];
        } else {
          this[kHeadersMap] = new Map(init2);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          this.cookies ??= [];
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this[kHeadersMap].delete(name);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        const value = this[kHeadersMap].get(name.toLowerCase());
        return value === void 0 ? null : value.value;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
    };
    var Headers = class _Headers {
      constructor(init2 = void 0) {
        if (init2 === kConstruct) {
          return;
        }
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init2 !== void 0) {
          init2 = webidl.converters.HeadersInit(init2);
          fill(this, init2);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        this[kHeadersList].delete(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        this[kHeadersList].set(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a2, b) => a2[0] < b[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (let i2 = 0; i2 < names.length; ++i2) {
          const [name, value] = names[i2];
          if (name === "set-cookie") {
            for (let j = 0; j < cookies.length; ++j) {
              headers.push([name, cookies[j]]);
            }
          } else {
            assert3(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key+value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, _Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      },
      [util.inspect.custom]: {
        enumerable: false
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/undici/lib/fetch/response.js"(exports, module) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData: FormData2 } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert3 = __require("assert");
    var { types: types2 } = __require("util");
    var ReadableStream3 = globalThis.ReadableStream || __require("stream/web").ReadableStream;
    var textEncoder3 = new TextEncoder("utf-8");
    var Response2 = class _Response {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init2 = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init2 !== null) {
          init2 = webidl.converters.ResponseInit(init2);
        }
        const bytes = textEncoder3.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init2, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init2 = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init2 = webidl.converters.ResponseInit(init2);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type2] = extractBody(body);
          bodyWithType = { body: extractedBody, type: type2 };
        }
        initializeResponse(this, init2, bodyWithType);
      }
      // Returns responses type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns responses URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url = urlList[urlList.length - 1] ?? null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns responses status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether responses status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns responses status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns responses headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse2(this[kState]);
        const clonedResponseObject = new _Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response2);
    Object.defineProperties(Response2.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response2, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse2(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse2(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init2) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init2,
        headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList(),
        urlList: init2.urlList ? [...init2.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError2 = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError2 ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert3(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type2) {
      if (type2 === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type2 === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type2 === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type2 === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert3(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert3(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init2, body) {
      if (init2.status !== null && (init2.status < 200 || init2.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init2 && init2.statusText != null) {
        if (!isValidReasonPhrase(String(init2.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init2 && init2.status != null) {
        response[kState].status = init2.status;
      }
      if ("statusText" in init2 && init2.statusText != null) {
        response[kState].statusText = init2.statusText;
      }
      if ("headers" in init2 && init2.headers != null) {
        fill(response[kHeaders], init2.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream3
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData2
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types2.isArrayBuffer(V) || types2.isTypedArray(V) || types2.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream3) {
        return webidl.converters.ReadableStream(V);
      }
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response: Response2,
      cloneResponse: cloneResponse2
    };
  }
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/undici/lib/fetch/request.js"(exports, module) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants2();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert3 = __require("assert");
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events");
    var TransformStream3 = globalThis.TransformStream;
    var kAbortController = /* @__PURE__ */ Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request2 = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init2 = {}) {
        if (input === kConstruct) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init2 = webidl.converters.RequestInit(init2);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert3(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window2 = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window2 = request.window;
        }
        if (init2.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if ("window" in init2) {
          window2 = "no-window";
        }
        request = makeRequest({
          // URL requests URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method requests method.
          method: request.method,
          // header list A copy of requests header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client Thiss relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window: window2,
          // priority requests priority.
          priority: request.priority,
          // origin requests origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer requests referrer.
          referrer: request.referrer,
          // referrer policy requests referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode requests mode.
          mode: request.mode,
          // credentials mode requests credentials mode.
          credentials: request.credentials,
          // cache mode requests cache mode.
          cache: request.cache,
          // redirect mode requests redirect mode.
          redirect: request.redirect,
          // integrity metadata requests integrity metadata.
          integrity: request.integrity,
          // keepalive requests keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag requests reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag requests history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of requests URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init2).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init2.referrer !== void 0) {
          const referrer = init2.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init2.referrerPolicy !== void 0) {
          request.referrerPolicy = init2.referrerPolicy;
        }
        let mode;
        if (init2.mode !== void 0) {
          mode = init2.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init2.credentials !== void 0) {
          request.credentials = init2.credentials;
        }
        if (init2.cache !== void 0) {
          request.cache = init2.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init2.redirect !== void 0) {
          request.redirect = init2.redirect;
        }
        if (init2.integrity != null) {
          request.integrity = String(init2.integrity);
        }
        if (init2.keepalive !== void 0) {
          request.keepalive = Boolean(init2.keepalive);
        }
        if (init2.method !== void 0) {
          let method = init2.method;
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizeMethodRecord[method] ?? normalizeMethod(method);
          request.method = method;
        }
        if (init2.signal !== void 0) {
          signal = init2.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function() {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (initHasKey) {
          const headersList = this[kHeaders][kHeadersList];
          const headers = init2.headers !== void 0 ? init2.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const [key, val] of headers) {
              headersList.append(key, val);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init2.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init2.body != null) {
          const [extractedBody, contentType] = extractBody(
            init2.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init2.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream3) {
            TransformStream3 = __require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream3();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns requests HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the globals default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the requests
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browsers cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns requests subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new _Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers(kConstruct);
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(
            this.signal,
            () => {
              ac.abort(this.signal.reason);
            }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request2);
    function makeRequest(init2) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init2,
        headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request2.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request2
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request2) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module.exports = { Request: Request2, makeRequest };
  }
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/undici/lib/fetch/index.js"(exports, module) {
    "use strict";
    var {
      Response: Response2,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request: Request2, makeRequest } = require_request2();
    var zlib2 = __require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert3 = __require("assert");
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants2();
    var { kHeadersList } = require_symbols();
    var EE = __require("events");
    var { Readable, pipeline } = __require("stream");
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream: TransformStream3 } = __require("stream/web");
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = __require("http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var resolveObjectURL;
    var ReadableStream3 = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error2) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error2) {
          error2 = new DOMException2("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error2;
        this.connection?.destroy(error2);
        this.emit("terminated", error2);
      }
    };
    function fetch(input, init2 = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request2(input, init2);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert3(controller != null);
          controller.abort(requestObject.signal.reason);
          abortFetch(p, request, responseObject, requestObject.signal.reason);
        }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return Promise.resolve();
        }
        responseObject = new Response2();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init2.dispatcher ?? getGlobalDispatcher()
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error2) {
      if (!error2) {
        error2 = new DOMException2("The operation was aborted.", "AbortError");
      }
      p.reject(error2);
      if (request.body != null && isReadable(request.body?.stream)) {
        request.body.stream.cancel(error2).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error2).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert3(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client?.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - requests current URLs origin is same origin with requests origin,
            //   and requests response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // requests current URLs scheme is "data"
            currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert3(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = __require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type2 = bodyWithType[1] ?? "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type2 }]
            ]
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk2, controller) => {
          controller.enqueue(chunk2);
        };
        const transformStream = new TransformStream3({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert3(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }
      if (request.body != null) {
        assert3(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      httpRequest.headersList.delete("host");
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // responses status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert3(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = (async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        })();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream3) {
        ReadableStream3 = __require("stream/web").ReadableStream;
      }
      const stream2 = new ReadableStream3(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream: stream2 };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream2)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream2)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream2)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException2("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              if (Array.isArray(headersList)) {
                for (let n2 = 0; n2 < headersList.length; n2 += 2) {
                  const key = headersList[n2 + 0].toString("latin1");
                  const val = headersList[n2 + 1].toString("latin1");
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim());
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              } else {
                const keys = Object.keys(headersList);
                for (const key of keys) {
                  const val = headersList[key];
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              }
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib2.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib2.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib2.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(zlib2.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib2.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk2) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk2;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error2) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error2);
              fetchParams.controller.terminate(error2);
              reject(error2);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers();
              for (let n2 = 0; n2 < headersList.length; n2 += 2) {
                const key = headersList[n2 + 0].toString("latin1");
                const val = headersList[n2 + 1].toString("latin1");
                headers[kHeadersList].append(key, val);
              }
              resolve({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/undici/lib/fileapi/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kState: /* @__PURE__ */ Symbol("FileReader state"),
      kResult: /* @__PURE__ */ Symbol("FileReader result"),
      kError: /* @__PURE__ */ Symbol("FileReader error"),
      kLastProgressEventFired: /* @__PURE__ */ Symbol("FileReader last progress event fired timestamp"),
      kEvents: /* @__PURE__ */ Symbol("FileReader events"),
      kAborted: /* @__PURE__ */ Symbol("FileReader aborted")
    };
  }
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "node_modules/undici/lib/fileapi/progressevent.js"(exports, module) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = /* @__PURE__ */ Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type2, eventInitDict = {}) {
        type2 = webidl.converters.DOMString(type2);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type2, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module.exports = {
      ProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "node_modules/undici/lib/fileapi/encoding.js"(exports, module) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module.exports = {
      getEncoding
    };
  }
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS({
  "node_modules/undici/lib/fileapi/util.js"(exports, module) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants2();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types: types2 } = __require("util");
    var { StringDecoder } = __require("string_decoder");
    var { btoa: btoa2 } = __require("buffer");
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type2, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException2("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream2 = blob.stream();
      const reader = stream2.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types2.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type2, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error2) {
                  fr[kError] = error2;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error2) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error2;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type2, mimeType, encodingName) {
      switch (type2) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk2 of bytes) {
            dataURL += btoa2(decoder.write(chunk2));
          }
          dataURL += btoa2(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type3 = parseMIMEType(mimeType);
            if (type3 !== "failure") {
              encoding = getEncoding(type3.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk2 of bytes) {
            binaryString += decoder.write(chunk2);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a2, b, c3] = ioQueue;
      if (a2 === 239 && b === 187 && c3 === 191) {
        return "UTF-8";
      } else if (a2 === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a2 === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a2, b) => {
        return a2 + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a2, b) => {
        a2.set(b, offset);
        offset += b.byteLength;
        return a2;
      }, new Uint8Array(size));
    }
    module.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "node_modules/undici/lib/fileapi/filereader.js"(exports, module) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util4();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module.exports = {
      FileReader
    };
  }
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/undici/lib/cache/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kConstruct: require_symbols().kConstruct
    };
  }
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS({
  "node_modules/undici/lib/cache/util.js"(exports, module) {
    "use strict";
    var assert3 = __require("assert");
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert3(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "node_modules/undici/lib/cache/cache.js"(exports, module) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { urlEquals, fieldValues: getFieldValues } = require_util5();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { kHeadersList } = require_symbols();
    var { webidl } = require_webidl();
    var { Response: Response2, cloneResponse: cloneResponse2 } = require_response();
    var { Request: Request2 } = require_request2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert3 = __require("assert");
    var { getGlobalDispatcher } = require_global2();
    var Cache = class _Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        this.#relevantRequestResponseList = arguments[1];
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p = await this.matchAll(request, options);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request2) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request2(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response2(response.body?.source ?? null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        requests = webidl.converters["sequence<RequestInfo>"](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request2(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request2) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request2(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse2(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream2 = innerResponse.body.stream;
          const reader = stream2.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request2) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert3(typeof request === "string");
          r = new Request2(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request2) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request2(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request2("https://a");
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        const cache = this.#relevantRequestResponseList;
        const backupCache = [...cache];
        const addedItems = [];
        const resultList = [];
        try {
          for (const operation of operations) {
            if (operation.type !== "delete" && operation.type !== "put") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"'
              });
            }
            if (operation.type === "delete" && operation.response != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "delete operation should not have an associated response"
              });
            }
            if (this.#queryCache(operation.request, operation.options, addedItems).length) {
              throw new DOMException("???", "InvalidStateError");
            }
            let requestResponses;
            if (operation.type === "delete") {
              requestResponses = this.#queryCache(operation.request, operation.options);
              if (requestResponses.length === 0) {
                return [];
              }
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert3(idx !== -1);
                cache.splice(idx, 1);
              }
            } else if (operation.type === "put") {
              if (operation.response == null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response"
                });
              }
              const r = operation.request;
              if (!urlIsHttpHttpsScheme(r.url)) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme"
                });
              }
              if (r.method !== "GET") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method"
                });
              }
              if (operation.options != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined"
                });
              }
              requestResponses = this.#queryCache(operation.request);
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert3(idx !== -1);
                cache.splice(idx, 1);
              }
              cache.push([operation.request, operation.response]);
              addedItems.push([operation.request, operation.response]);
            }
            resultList.push([operation.request, operation.response]);
          }
          return resultList;
        } catch (e) {
          this.#relevantRequestResponseList.length = 0;
          this.#relevantRequestResponseList = backupCache;
          throw e;
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        const resultList = [];
        const storage = targetStorage ?? this.#relevantRequestResponseList;
        for (const requestResponse of storage) {
          const [cachedRequest, cachedResponse] = requestResponse;
          if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
            resultList.push(requestResponse);
          }
        }
        return resultList;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(requestQuery, request, response = null, options) {
        const queryURL = new URL(requestQuery.url);
        const cachedURL = new URL(request.url);
        if (options?.ignoreSearch) {
          cachedURL.search = "";
          queryURL.search = "";
        }
        if (!urlEquals(queryURL, cachedURL, true)) {
          return false;
        }
        if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
          return true;
        }
        const fieldValues = getFieldValues(response.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            return false;
          }
          const requestValue = request.headersList.get(fieldValue);
          const queryValue = requestQuery.headersList.get(fieldValue);
          if (requestValue !== queryValue) {
            return false;
          }
        }
        return true;
      }
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response2);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module.exports = {
      Cache
    };
  }
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/undici/lib/cache/cachestorage.js"(exports, module) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var CacheStorage = class _CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = /* @__PURE__ */ new Map();
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (this.#caches.has(options.cacheName)) {
            const cacheList = this.#caches.get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of this.#caches.values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        cacheName = webidl.converters.DOMString(cacheName);
        if (this.#caches.has(cacheName)) {
          const cache2 = this.#caches.get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        this.#caches.set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = this.#caches.keys();
        return [...keys];
      }
    };
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module.exports = {
      CacheStorage
    };
  }
});

// node_modules/undici/lib/cookies/constants.js
var require_constants4 = __commonJS({
  "node_modules/undici/lib/cookies/constants.js"(exports, module) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS({
  "node_modules/undici/lib/cookies/util.js"(exports, module) {
    "use strict";
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path2) {
      for (const char of path2) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    module.exports = {
      isCTLExcludingHtab,
      validateCookieName,
      validateCookiePath,
      validateCookieValue,
      toIMFDate,
      stringify
    };
  }
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/undici/lib/cookies/parse.js"(exports, module) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
    var { isCTLExcludingHtab } = require_util6();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert3 = __require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert3(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/undici/lib/cookies/index.js"(exports, module) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify } = require_util6();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = headers.getSetCookie();
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// node_modules/undici/lib/websocket/constants.js
var require_constants5 = __commonJS({
  "node_modules/undici/lib/websocket/constants.js"(exports, module) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  "node_modules/undici/lib/websocket/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kWebSocketURL: /* @__PURE__ */ Symbol("url"),
      kReadyState: /* @__PURE__ */ Symbol("ready state"),
      kController: /* @__PURE__ */ Symbol("controller"),
      kResponse: /* @__PURE__ */ Symbol("response"),
      kBinaryType: /* @__PURE__ */ Symbol("binary type"),
      kSentClose: /* @__PURE__ */ Symbol("sent close"),
      kReceivedClose: /* @__PURE__ */ Symbol("received close"),
      kByteParser: /* @__PURE__ */ Symbol("byte parser")
    };
  }
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "node_modules/undici/lib/websocket/events.js"(exports, module) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { MessagePort } = __require("worker_threads");
    var MessageEvent = class _MessageEvent extends Event {
      #eventInit;
      constructor(type2, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type2 = webidl.converters.DOMString(type2);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type2, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }
        return this.#eventInit.ports;
      }
      initMessageEvent(type2, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new _MessageEvent(type2, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    };
    var CloseEvent = class _CloseEvent extends Event {
      #eventInit;
      constructor(type2, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type2 = webidl.converters.DOMString(type2);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type2, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.reason;
      }
    };
    var ErrorEvent = class _ErrorEvent extends Event {
      #eventInit;
      constructor(type2, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type2, eventInitDict);
        type2 = webidl.converters.DOMString(type2);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        this.#eventInit = eventInitDict;
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS({
  "node_modules/undici/lib/websocket/util.js"(exports, module) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants5();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type2, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type2 === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type2 === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if (response?.socket && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/undici/lib/websocket/connection.js"(exports, module) {
    "use strict";
    var diagnosticsChannel2 = __require("diagnostics_channel");
    var { uid, states } = require_constants5();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols5();
    var { fireEvent, failWebsocketConnection } = require_util7();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers } = require_headers();
    var { getGlobalDispatcher } = require_global2();
    var { kHeadersList } = require_symbols();
    var channels2 = {};
    channels2.open = diagnosticsChannel2.channel("undici:websocket:open");
    channels2.close = diagnosticsChannel2.channel("undici:websocket:close");
    channels2.socketError = diagnosticsChannel2.channel("undici:websocket:socket_error");
    var crypto3;
    try {
      crypto3 = __require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto3.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto3.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels2.open.hasSubscribers) {
            channels2.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk2) {
      if (!this.ws[kByteParser].write(chunk2)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels2.close.hasSubscribers) {
        channels2.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error2) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels2.socketError.hasSubscribers) {
        channels2.socketError.publish(error2);
      }
      this.destroy();
    }
    module.exports = {
      establishWebSocketConnection
    };
  }
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/undici/lib/websocket/frame.js"(exports, module) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants5();
    var crypto3;
    try {
      crypto3 = __require("crypto");
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto3.randomBytes(4);
      }
      createFrame(opcode) {
        const bodyLength = this.frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i2 = 0; i2 < bodyLength; i2++) {
          buffer[offset + i2] = this.frameData[i2] ^ this.maskKey[i2 % 4];
        }
        return buffer;
      }
    };
    module.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/undici/lib/websocket/receiver.js"(exports, module) {
    "use strict";
    var { Writable } = __require("stream");
    var diagnosticsChannel2 = __require("diagnostics_channel");
    var { parserStates, opcodes, states, emptyBuffer } = require_constants5();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
    var { WebsocketFrameSend } = require_frame();
    var channels2 = {};
    channels2.ping = diagnosticsChannel2.channel("undici:websocket:ping");
    channels2.pong = diagnosticsChannel2.channel("undici:websocket:pong");
    var ByteParser = class extends Writable {
      #buffers = [];
      #byteOffset = 0;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      constructor(ws) {
        super();
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk2, _, callback) {
        this.#buffers.push(chunk2);
        this.#byteOffset += chunk2.length;
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (true) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.fin = (buffer[0] & 128) !== 0;
            this.#info.opcode = buffer[0] & 15;
            this.#info.originalOpcode ??= this.#info.opcode;
            this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
            if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }
            if (this.#info.fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (this.#info.opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              this.#info.closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(this.#info.closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (this.#info.opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels2.ping.hasSubscribers) {
                  channels2.ping.publish({
                    payload: body
                  });
                }
              }
              this.#state = parserStates.INFO;
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (this.#info.opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels2.pong.hasSubscribers) {
                channels2.pong.publish({
                  payload: body
                });
              }
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.payloadLength = buffer.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              return callback();
            } else if (this.#byteOffset >= this.#info.payloadLength) {
              const body = this.consume(this.#info.payloadLength);
              this.#fragments.push(body);
              if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
                this.#info = {};
                this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            }
          }
          if (this.#byteOffset > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n2) {
        if (n2 > this.#byteOffset) {
          return null;
        } else if (n2 === 0) {
          return emptyBuffer;
        }
        if (this.#buffers[0].length === n2) {
          this.#byteOffset -= this.#buffers[0].length;
          return this.#buffers.shift();
        }
        const buffer = Buffer.allocUnsafe(n2);
        let offset = 0;
        while (offset !== n2) {
          const next = this.#buffers[0];
          const { length } = next;
          if (length + offset === n2) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n2) {
            buffer.set(next.subarray(0, n2 - offset), offset);
            this.#buffers[0] = next.subarray(n2 - offset);
            break;
          } else {
            buffer.set(this.#buffers.shift(), offset);
            offset += next.length;
          }
        }
        this.#byteOffset -= n2;
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module.exports = {
      ByteParser
    };
  }
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/undici/lib/websocket/websocket.js"(exports, module) {
    "use strict";
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants2();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types: types2 } = __require("util");
    var experimentalWarned = false;
    var WebSocket = class _WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException2(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException2("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => this.#onConnectionEstablished(response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (types2.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += ab.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= ab.byteLength;
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            this.#bufferedAmount += value.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return this.#bufferedAmount;
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return this.#extensions;
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return this.#protocol;
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }
        if (typeof fn === "function") {
          this.#events.close = fn;
          this.addEventListener("close", fn);
        } else {
          this.#events.close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type2) {
        webidl.brandCheck(this, _WebSocket);
        if (type2 !== "blob" && type2 !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type2;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response) {
        this[kResponse] = response;
        const parser = new ByteParser(this);
        parser.on("drain", function onParserDrain() {
          this.ws[kResponse].socket.resume();
        });
        response.socket.ws = this;
        this[kByteParser] = parser;
        this[kReadyState] = states.OPEN;
        const extensions = response.headersList.get("sec-websocket-extensions");
        if (extensions !== null) {
          this.#extensions = extensions;
        }
        const protocol = response.headersList.get("sec-websocket-protocol");
        if (protocol !== null) {
          this.#protocol = protocol;
        }
        fireEvent("open", this);
      }
    };
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types2.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module.exports = {
      WebSocket
    };
  }
});

// node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/undici/index.js"(exports, module) {
    "use strict";
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var RetryHandler = require_RetryHandler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      __require("crypto");
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module.exports.Dispatcher = Dispatcher;
    module.exports.Client = Client;
    module.exports.Pool = Pool;
    module.exports.BalancedPool = BalancedPool;
    module.exports.Agent = Agent;
    module.exports.ProxyAgent = ProxyAgent;
    module.exports.RetryHandler = RetryHandler;
    module.exports.DecoratorHandler = DecoratorHandler;
    module.exports.RedirectHandler = RedirectHandler;
    module.exports.createRedirectInterceptor = createRedirectInterceptor;
    module.exports.buildConnector = buildConnector;
    module.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path2 = opts.path;
          if (!opts.path.startsWith("/")) {
            path2 = `/${path2}`;
          }
          url = new URL(util.parseOrigin(url).origin + path2);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module.exports.setGlobalDispatcher = setGlobalDispatcher;
    module.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
      let fetchImpl = null;
      module.exports.fetch = async function fetch(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module.exports.Headers = require_headers().Headers;
      module.exports.Response = require_response().Response;
      module.exports.Request = require_request2().Request;
      module.exports.FormData = require_formdata().FormData;
      module.exports.File = require_file().File;
      module.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module.exports.setGlobalOrigin = setGlobalOrigin;
      module.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols4();
      module.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module.exports.deleteCookie = deleteCookie;
      module.exports.getCookies = getCookies;
      module.exports.getSetCookies = getSetCookies;
      module.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module.exports.parseMIMEType = parseMIMEType;
      module.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module.exports.WebSocket = WebSocket;
    }
    module.exports.request = makeDispatcher(api.request);
    module.exports.stream = makeDispatcher(api.stream);
    module.exports.pipeline = makeDispatcher(api.pipeline);
    module.exports.connect = makeDispatcher(api.connect);
    module.exports.upgrade = makeDispatcher(api.upgrade);
    module.exports.MockClient = MockClient;
    module.exports.MockPool = MockPool;
    module.exports.MockAgent = MockAgent;
    module.exports.mockErrors = mockErrors;
  }
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/@actions/http-client/lib/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
    var http3 = __importStar2(__require("http"));
    var https2 = __importStar2(__require("https"));
    var pm = __importStar2(require_proxy());
    var tunnel = __importStar2(require_tunnel2());
    var undici_1 = require_undici();
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2["Accept"] = "accept";
      Headers2["ContentType"] = "content-type";
    })(Headers || (exports.Headers = Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter7(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter7(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk2) => {
              output = Buffer.concat([output, chunk2]);
            });
            this.message.on("end", () => {
              resolve(output.toString());
            });
          }));
        });
      }
      readBodyBuffer() {
        return __awaiter7(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter7(this, void 0, void 0, function* () {
            const chunks = [];
            this.message.on("data", (chunk2) => {
              chunks.push(chunk2);
            });
            this.message.on("end", () => {
              resolve(Buffer.concat(chunks));
            });
          }));
        });
      }
    };
    exports.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter7(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter7(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter7(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter7(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter7(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter7(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter7(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream2, additionalHeaders) {
        return __awaiter7(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream2, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter7(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter7(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter7(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter7(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter7(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info2 = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info2, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info2, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info2 = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info2, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info2, data) {
        return __awaiter7(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve(res);
              }
            }
            this.requestRawWithCallback(info2, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info2, data, onResult) {
        if (typeof data === "string") {
          if (!info2.options.headers) {
            info2.options.headers = {};
          }
          info2.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info2.httpModule.request(info2.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info2.options.path}`));
        });
        req.on("error", function(err) {
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info2 = {};
        info2.parsedUrl = requestUrl;
        const usingSsl = info2.parsedUrl.protocol === "https:";
        info2.httpModule = usingSsl ? https2 : http3;
        const defaultPort = usingSsl ? 443 : 80;
        info2.options = {};
        info2.options.host = info2.parsedUrl.hostname;
        info2.options.port = info2.parsedUrl.port ? parseInt(info2.parsedUrl.port) : defaultPort;
        info2.options.path = (info2.parsedUrl.pathname || "") + (info2.parsedUrl.search || "");
        info2.options.method = method;
        info2.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info2.options.headers["user-agent"] = this.userAgent;
        }
        info2.options.agent = this._getAgent(info2.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info2.options);
          }
        }
        return info2;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys2(this.requestOptions.headers), lowercaseKeys2(headers || {}));
        }
        return lowercaseKeys2(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys2(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (!useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http3.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (!agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https2.Agent(options) : new http3.Agent(options);
          this._agent = agent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
          token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
        }));
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
            rejectUnauthorized: false
          });
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter7(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve) => setTimeout(() => resolve(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter7(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => __awaiter7(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a2 = new Date(value);
                if (!isNaN(a2.valueOf())) {
                  return a2;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve(response);
            }
          }));
        });
      }
    };
    exports.HttpClient = HttpClient;
    var lowercaseKeys2 = (obj) => Object.keys(obj).reduce((c3, k) => (c3[k.toLowerCase()] = obj[k], c3), {});
  }
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "node_modules/@actions/http-client/lib/auth.js"(exports) {
    "use strict";
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter7(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter7(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter7(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "node_modules/@actions/core/lib/oidc-utils.js"(exports) {
    "use strict";
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core();
    var OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter7(this, void 0, void 0, function* () {
          const httpclient = _OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error2) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error2.statusCode}
 
        Error Message: ${error2.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter7(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            (0, core_1.debug)(`ID token url is ${id_token_url}`);
            const id_token = yield _OidcClient.getCall(id_token_url);
            (0, core_1.setSecret)(id_token);
            return id_token;
          } catch (error2) {
            throw new Error(`Error message: ${error2.message}`);
          }
        });
      }
    };
    exports.OidcClient = OidcClient;
  }
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "node_modules/@actions/core/lib/summary.js"(exports) {
    "use strict";
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
    var os_1 = __require("os");
    var fs_1 = __require("fs");
    var { access, appendFile, writeFile } = fs_1.promises;
    exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter7(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter7(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter7(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports.markdownSummary = _summary;
    exports.summary = _summary;
  }
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "node_modules/@actions/core/lib/path-utils.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
    var path2 = __importStar2(__require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path2.sep);
    }
    exports.toPlatformPath = toPlatformPath;
  }
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({
  "node_modules/@actions/io/lib/io-util.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
    var fs2 = __importStar2(__require("fs"));
    var path2 = __importStar2(__require("path"));
    _a = fs2.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
    exports.IS_WINDOWS = process.platform === "win32";
    exports.UV_FS_O_EXLOCK = 268435456;
    exports.READONLY = fs2.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter7(this, void 0, void 0, function* () {
        try {
          yield exports.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports.exists = exists;
    function isDirectory(fsPath, useStat = false) {
      return __awaiter7(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
        return stats.isDirectory();
      });
    }
    exports.isDirectory = isDirectory;
    function isRooted(p) {
      p = normalizeSeparators(p);
      if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports.IS_WINDOWS) {
        return p.startsWith("\\") || /^[A-Z]:/i.test(p);
      }
      return p.startsWith("/");
    }
    exports.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter7(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield exports.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            const upperExt = path2.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield exports.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
              try {
                const directory = path2.dirname(filePath);
                const upperName = path2.basename(filePath).toUpperCase();
                for (const actualName of yield exports.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path2.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p) {
      p = p || "";
      if (exports.IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        return p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
    exports.getCmdPath = getCmdPath;
  }
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS({
  "node_modules/@actions/io/lib/io.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
    var assert_1 = __require("assert");
    var path2 = __importStar2(__require("path"));
    var ioUtil = __importStar2(require_io_util());
    function cp(source, dest, options = {}) {
      return __awaiter7(this, void 0, void 0, function* () {
        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force) {
          return;
        }
        const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path2.join(dest, path2.basename(source)) : dest;
        if (!(yield ioUtil.exists(source))) {
          throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
          if (!recursive) {
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
          } else {
            yield cpDirRecursive(source, newDest, 0, force);
          }
        } else {
          if (path2.relative(source, newDest) === "") {
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          }
          yield copyFile2(source, newDest, force);
        }
      });
    }
    exports.cp = cp;
    function mv(source, dest, options = {}) {
      return __awaiter7(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = true;
          if (yield ioUtil.isDirectory(dest)) {
            dest = path2.join(dest, path2.basename(source));
            destExists = yield ioUtil.exists(dest);
          }
          if (destExists) {
            if (options.force == null || options.force) {
              yield rmRF(dest);
            } else {
              throw new Error("Destination already exists");
            }
          }
        }
        yield mkdirP(path2.dirname(dest));
        yield ioUtil.rename(source, dest);
      });
    }
    exports.mv = mv;
    function rmRF(inputPath) {
      return __awaiter7(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
          if (/[*"<>|]/.test(inputPath)) {
            throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
          }
        }
        try {
          yield ioUtil.rm(inputPath, {
            force: true,
            maxRetries: 3,
            recursive: true,
            retryDelay: 300
          });
        } catch (err) {
          throw new Error(`File was unable to be removed ${err}`);
        }
      });
    }
    exports.rmRF = rmRF;
    function mkdirP(fsPath) {
      return __awaiter7(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided");
        yield ioUtil.mkdir(fsPath, { recursive: true });
      });
    }
    exports.mkdirP = mkdirP;
    function which(tool, check) {
      return __awaiter7(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        if (check) {
          const result = yield which(tool, false);
          if (!result) {
            if (ioUtil.IS_WINDOWS) {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
            } else {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
            }
          }
          return result;
        }
        const matches = yield findInPath(tool);
        if (matches && matches.length > 0) {
          return matches[0];
        }
        return "";
      });
    }
    exports.which = which;
    function findInPath(tool) {
      return __awaiter7(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
          for (const extension of process.env["PATHEXT"].split(path2.delimiter)) {
            if (extension) {
              extensions.push(extension);
            }
          }
        }
        if (ioUtil.isRooted(tool)) {
          const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          if (filePath) {
            return [filePath];
          }
          return [];
        }
        if (tool.includes(path2.sep)) {
          return [];
        }
        const directories = [];
        if (process.env.PATH) {
          for (const p of process.env.PATH.split(path2.delimiter)) {
            if (p) {
              directories.push(p);
            }
          }
        }
        const matches = [];
        for (const directory of directories) {
          const filePath = yield ioUtil.tryGetExecutablePath(path2.join(directory, tool), extensions);
          if (filePath) {
            matches.push(filePath);
          }
        }
        return matches;
      });
    }
    exports.findInPath = findInPath;
    function readCopyOptions(options) {
      const force = options.force == null ? true : options.force;
      const recursive = Boolean(options.recursive);
      const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
      return { force, recursive, copySourceDirectory };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter7(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++;
        yield mkdirP(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
          const srcFile = `${sourceDir}/${fileName}`;
          const destFile = `${destDir}/${fileName}`;
          const srcFileStat = yield ioUtil.lstat(srcFile);
          if (srcFileStat.isDirectory()) {
            yield cpDirRecursive(srcFile, destFile, currentDepth, force);
          } else {
            yield copyFile2(srcFile, destFile, force);
          }
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile2(srcFile, destFile, force) {
      return __awaiter7(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile);
            yield ioUtil.unlink(destFile);
          } catch (e) {
            if (e.code === "EPERM") {
              yield ioUtil.chmod(destFile, "0666");
              yield ioUtil.unlink(destFile);
            }
          }
          const symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else if (!(yield ioUtil.exists(destFile)) || force) {
          yield ioUtil.copyFile(srcFile, destFile);
        }
      });
    }
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({
  "node_modules/@actions/exec/lib/toolrunner.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argStringToArray = exports.ToolRunner = void 0;
    var os3 = __importStar2(__require("os"));
    var events = __importStar2(__require("events"));
    var child = __importStar2(__require("child_process"));
    var path2 = __importStar2(__require("path"));
    var io = __importStar2(require_io());
    var ioUtil = __importStar2(require_io_util());
    var timers_1 = __require("timers");
    var IS_WINDOWS = process.platform === "win32";
    var ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
      }
      _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
          this.options.listeners.debug(message);
        }
      }
      _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (const a2 of args) {
              cmd += ` ${a2}`;
            }
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (const a2 of args) {
              cmd += ` ${a2}`;
            }
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (const a2 of args) {
              cmd += ` ${this._windowsQuoteCmdArg(a2)}`;
            }
          }
        } else {
          cmd += toolPath;
          for (const a2 of args) {
            cmd += ` ${a2}`;
          }
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s = strBuffer + data.toString();
          let n2 = s.indexOf(os3.EOL);
          while (n2 > -1) {
            const line = s.substring(0, n2);
            onLine(line);
            s = s.substring(n2 + os3.EOL.length);
            n2 = s.indexOf(os3.EOL);
          }
          return s;
        } catch (err) {
          this._debug(`error processing line. Failed with error ${err}`);
          return "";
        }
      }
      _getSpawnFileName() {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            return process.env["COMSPEC"] || "cmd.exe";
          }
        }
        return this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
            for (const a2 of this.args) {
              argline += " ";
              argline += options.windowsVerbatimArguments ? a2 : this._windowsQuoteCmdArg(a2);
            }
            argline += '"';
            return [argline];
          }
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile()) {
          return this._uvQuoteCmdArg(arg);
        }
        if (!arg) {
          return '""';
        }
        const cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
          if (cmdSpecialChars.some((x) => x === char)) {
            needsQuotes = true;
            break;
          }
        }
        if (!needsQuotes) {
          return arg;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i2 = arg.length; i2 > 0; i2--) {
          reverse += arg[i2 - 1];
          if (quoteHit && arg[i2 - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i2 - 1] === '"') {
            quoteHit = true;
            reverse += '"';
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg) {
          return '""';
        }
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
          return arg;
        }
        if (!arg.includes('"') && !arg.includes("\\")) {
          return `"${arg}"`;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i2 = arg.length; i2 > 0; i2--) {
          reverse += arg[i2 - 1];
          if (quoteHit && arg[i2 - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i2 - 1] === '"') {
            quoteHit = true;
            reverse += "\\";
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        const result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || false,
          windowsVerbatimArguments: options.windowsVerbatimArguments || false,
          failOnStdErr: options.failOnStdErr || false,
          ignoreReturnCode: options.ignoreReturnCode || false,
          delay: options.delay || 1e4
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
          result.argv0 = `"${toolPath}"`;
        }
        return result;
      }
      /**
       * Exec a tool.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     tool     path to tool to exec
       * @param     options  optional exec options.  See ExecOptions
       * @returns   number
       */
      exec() {
        return __awaiter7(this, void 0, void 0, function* () {
          if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
            this.toolPath = path2.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
          }
          this.toolPath = yield io.which(this.toolPath, true);
          return new Promise((resolve, reject) => __awaiter7(this, void 0, void 0, function* () {
            this._debug(`exec tool: ${this.toolPath}`);
            this._debug("arguments:");
            for (const arg of this.args) {
              this._debug(`   ${arg}`);
            }
            const optionsNonNull = this._cloneExecOptions(this.options);
            if (!optionsNonNull.silent && optionsNonNull.outStream) {
              optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os3.EOL);
            }
            const state = new ExecState(optionsNonNull, this.toolPath);
            state.on("debug", (message) => {
              this._debug(message);
            });
            if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
              return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
            }
            const fileName = this._getSpawnFileName();
            const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
            let stdbuffer = "";
            if (cp.stdout) {
              cp.stdout.on("data", (data) => {
                if (this.options.listeners && this.options.listeners.stdout) {
                  this.options.listeners.stdout(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(data);
                }
                stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.stdline) {
                    this.options.listeners.stdline(line);
                  }
                });
              });
            }
            let errbuffer = "";
            if (cp.stderr) {
              cp.stderr.on("data", (data) => {
                state.processStderr = true;
                if (this.options.listeners && this.options.listeners.stderr) {
                  this.options.listeners.stderr(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                  const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                  s.write(data);
                }
                errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.errline) {
                    this.options.listeners.errline(line);
                  }
                });
              });
            }
            cp.on("error", (err) => {
              state.processError = err.message;
              state.processExited = true;
              state.processClosed = true;
              state.CheckComplete();
            });
            cp.on("exit", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            cp.on("close", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              state.processClosed = true;
              this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            state.on("done", (error2, exitCode) => {
              if (stdbuffer.length > 0) {
                this.emit("stdline", stdbuffer);
              }
              if (errbuffer.length > 0) {
                this.emit("errline", errbuffer);
              }
              cp.removeAllListeners();
              if (error2) {
                reject(error2);
              } else {
                resolve(exitCode);
              }
            });
            if (this.options.input) {
              if (!cp.stdin) {
                throw new Error("child process missing stdin");
              }
              cp.stdin.end(this.options.input);
            }
          }));
        });
      }
    };
    exports.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      const args = [];
      let inQuotes = false;
      let escaped = false;
      let arg = "";
      function append(c3) {
        if (escaped && c3 !== '"') {
          arg += "\\";
        }
        arg += c3;
        escaped = false;
      }
      for (let i2 = 0; i2 < argString.length; i2++) {
        const c3 = argString.charAt(i2);
        if (c3 === '"') {
          if (!escaped) {
            inQuotes = !inQuotes;
          } else {
            append(c3);
          }
          continue;
        }
        if (c3 === "\\" && escaped) {
          append(c3);
          continue;
        }
        if (c3 === "\\" && inQuotes) {
          escaped = true;
          continue;
        }
        if (c3 === " " && !inQuotes) {
          if (arg.length > 0) {
            args.push(arg);
            arg = "";
          }
          continue;
        }
        append(c3);
      }
      if (arg.length > 0) {
        args.push(arg.trim());
      }
      return args;
    }
    exports.argStringToArray = argStringToArray;
    var ExecState = class _ExecState extends events.EventEmitter {
      constructor(options, toolPath) {
        super();
        this.processClosed = false;
        this.processError = "";
        this.processExitCode = 0;
        this.processExited = false;
        this.processStderr = false;
        this.delay = 1e4;
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
          throw new Error("toolPath must not be empty");
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
          this.delay = options.delay;
        }
      }
      CheckComplete() {
        if (this.done) {
          return;
        }
        if (this.processClosed) {
          this._setResult();
        } else if (this.processExited) {
          this.timeout = timers_1.setTimeout(_ExecState.HandleTimeout, this.delay, this);
        }
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error2;
        if (this.processExited) {
          if (this.processError) {
            error2 = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
          } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
            error2 = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
          } else if (this.processStderr && this.options.failOnStdErr) {
            error2 = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
          }
        }
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.done = true;
        this.emit("done", error2, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (state.done) {
          return;
        }
        if (!state.processClosed && state.processExited) {
          const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    };
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({
  "node_modules/@actions/exec/lib/exec.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getExecOutput = exports.exec = void 0;
    var string_decoder_1 = __require("string_decoder");
    var tr = __importStar2(require_toolrunner());
    function exec4(commandLine, args, options) {
      return __awaiter7(this, void 0, void 0, function* () {
        const commandArgs = tr.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
          throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr.ToolRunner(toolPath, args, options);
        return runner.exec();
      });
    }
    exports.exec = exec4;
    function getExecOutput2(commandLine, args, options) {
      var _a, _b;
      return __awaiter7(this, void 0, void 0, function* () {
        let stdout = "";
        let stderr = "";
        const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
        const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
        const stdErrListener = (data) => {
          stderr += stderrDecoder.write(data);
          if (originalStdErrListener) {
            originalStdErrListener(data);
          }
        };
        const stdOutListener = (data) => {
          stdout += stdoutDecoder.write(data);
          if (originalStdoutListener) {
            originalStdoutListener(data);
          }
        };
        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
        const exitCode = yield exec4(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        stdout += stdoutDecoder.end();
        stderr += stderrDecoder.end();
        return {
          exitCode,
          stdout,
          stderr
        };
      });
    }
    exports.getExecOutput = getExecOutput2;
  }
});

// node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS({
  "node_modules/@actions/core/lib/platform.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
    var os_1 = __importDefault2(__require("os"));
    var exec4 = __importStar2(require_exec());
    var getWindowsInfo2 = () => __awaiter7(void 0, void 0, void 0, function* () {
      const { stdout: version } = yield exec4.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
        silent: true
      });
      const { stdout: name } = yield exec4.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
        silent: true
      });
      return {
        name: name.trim(),
        version: version.trim()
      };
    });
    var getMacOsInfo2 = () => __awaiter7(void 0, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      const { stdout } = yield exec4.getExecOutput("sw_vers", void 0, {
        silent: true
      });
      const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
      const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "";
      return {
        name,
        version
      };
    });
    var getLinuxInfo2 = () => __awaiter7(void 0, void 0, void 0, function* () {
      const { stdout } = yield exec4.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
        silent: true
      });
      const [name, version] = stdout.trim().split("\n");
      return {
        name,
        version
      };
    });
    exports.platform = os_1.default.platform();
    exports.arch = os_1.default.arch();
    exports.isWindows = exports.platform === "win32";
    exports.isMacOS = exports.platform === "darwin";
    exports.isLinux = exports.platform === "linux";
    function getDetails2() {
      return __awaiter7(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo2() : exports.isMacOS ? getMacOsInfo2() : getLinuxInfo2()), {
          platform: exports.platform,
          arch: exports.arch,
          isWindows: exports.isWindows,
          isMacOS: exports.isMacOS,
          isLinux: exports.isLinux
        });
      });
    }
    exports.getDetails = getDetails2;
  }
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "node_modules/@actions/core/lib/core.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os3 = __importStar2(__require("os"));
    var path2 = __importStar2(__require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode || (exports.ExitCode = ExitCode = {}));
    function exportVariable2(name, val) {
      const convertedVal = (0, utils_1.toCommandValue)(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
      }
      (0, command_1.issueCommand)("set-env", { name }, convertedVal);
    }
    exports.exportVariable = exportVariable2;
    function setSecret(secret) {
      (0, command_1.issueCommand)("add-mask", {}, secret);
    }
    exports.setSecret = setSecret;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        (0, file_command_1.issueFileCommand)("PATH", inputPath);
      } else {
        (0, command_1.issueCommand)("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path2.delimiter}${process.env["PATH"]}`;
    }
    exports.addPath = addPath;
    function getInput2(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports.getInput = getInput2;
    function getMultilineInput2(name, options) {
      const inputs = getInput2(name, options).split("\n").filter((x) => x !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports.getMultilineInput = getMultilineInput2;
    function getBooleanInput2(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput2(name, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports.getBooleanInput = getBooleanInput2;
    function setOutput(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      process.stdout.write(os3.EOL);
      (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports.setOutput = setOutput;
    function setCommandEcho(enabled) {
      (0, command_1.issue)("echo", enabled ? "on" : "off");
    }
    exports.setCommandEcho = setCommandEcho;
    function setFailed3(message) {
      process.exitCode = ExitCode.Failure;
      error2(message);
    }
    exports.setFailed = setFailed3;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports.isDebug = isDebug;
    function debug2(message) {
      (0, command_1.issueCommand)("debug", {}, message);
    }
    exports.debug = debug2;
    function error2(message, properties = {}) {
      (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.error = error2;
    function warning2(message, properties = {}) {
      (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.warning = warning2;
    function notice(message, properties = {}) {
      (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.notice = notice;
    function info2(message) {
      process.stdout.write(message + os3.EOL);
    }
    exports.info = info2;
    function startGroup2(name) {
      (0, command_1.issue)("group", name);
    }
    exports.startGroup = startGroup2;
    function endGroup2() {
      (0, command_1.issue)("endgroup");
    }
    exports.endGroup = endGroup2;
    function group(name, fn) {
      return __awaiter7(this, void 0, void 0, function* () {
        startGroup2(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup2();
        }
        return result;
      });
    }
    exports.group = group;
    function saveState2(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports.saveState = saveState2;
    function getState2(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports.getState = getState2;
    function getIDToken(aud) {
      return __awaiter7(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
    exports.platform = __importStar2(require_platform());
  }
});

// node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS({
  "node_modules/http-cache-semantics/index.js"(exports, module) {
    "use strict";
    var statusCodeCacheableByDefault = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      206,
      300,
      301,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var understoodStatuses = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var errorStatusCodes = /* @__PURE__ */ new Set([
      500,
      502,
      503,
      504
    ]);
    var hopByHopHeaders = {
      date: true,
      // included, because we add Age update Date
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    };
    var excludedFromRevalidationUpdate = {
      // Since the old body is reused, it doesn't make sense to change properties of the body
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function toNumberOrZero(s) {
      const n2 = parseInt(s, 10);
      return isFinite(n2) ? n2 : 0;
    }
    function isErrorResponse(response) {
      if (!response) {
        return true;
      }
      return errorStatusCodes.has(response.status);
    }
    function parseCacheControl(header) {
      const cc = {};
      if (!header) return cc;
      const parts = header.trim().split(/,/);
      for (const part of parts) {
        const [k, v] = part.split(/=/, 2);
        cc[k.trim()] = v === void 0 ? true : v.trim().replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module.exports = class CachePolicy {
      /**
       * Creates a new CachePolicy instance.
       * @param {HttpRequest} req - Incoming client request.
       * @param {HttpResponse} res - Received server response.
       * @param {Object} [options={}] - Configuration options.
       * @param {boolean} [options.shared=true] - Is the cache shared (a public proxy)? `false` for personal browser caches.
       * @param {number} [options.cacheHeuristic=0.1] - Fallback heuristic (age fraction) for cache duration.
       * @param {number} [options.immutableMinTimeToLive=86400000] - Minimum TTL for immutable responses in milliseconds.
       * @param {boolean} [options.ignoreCargoCult=false] - Detect nonsense cache headers, and override them.
       * @param {any} [options._fromObject] - Internal parameter for deserialization. Do not use.
       */
      constructor(req, res, {
        shared,
        cacheHeuristic,
        immutableMinTimeToLive,
        ignoreCargoCult,
        _fromObject
      } = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._ignoreCargoCult = !!ignoreCargoCult;
        this._cacheHeuristic = void 0 !== cacheHeuristic ? cacheHeuristic : 0.1;
        this._immutableMinTtl = void 0 !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (this._ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": formatCacheControl(this._rescc)
          });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      /**
       * You can monkey-patch it for testing.
       * @returns {number} Current time in milliseconds.
       */
      now() {
        return Date.now();
      }
      /**
       * Determines if the response is storable in a cache.
       * @returns {boolean} `false` if can never be cached.
       */
      storable() {
        return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
        // The request method is understood by the cache and defined as being cacheable, and
        ("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
        understoodStatuses.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
        !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
        (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
        // contains an Expires header field, or
        (this._resHeaders.expires || // contains a max-age response directive, or
        // contains a s-maxage response directive and the cache is shared, or
        // contains a public response directive.
        this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || // has a status code that is defined as cacheable by default
        statusCodeCacheableByDefault.has(this._status)));
      }
      /**
       * @returns {boolean} true if expiration is explicitly defined.
       */
      _hasExplicitExpiration() {
        return !!(this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires);
      }
      /**
       * @param {HttpRequest} req - a request
       * @throws {Error} if the headers are missing.
       */
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      }
      /**
       * Checks if the request matches the cache and can be satisfied from the cache immediately,
       * without having to make a request to the server.
       *
       * This doesn't support `stale-while-revalidate`. See `evaluateRequest()` for a more complete solution.
       *
       * @param {HttpRequest} req - The new incoming HTTP request.
       * @returns {boolean} `true`` if the cached response used to construct this cache policy satisfies the request without revalidation.
       */
      satisfiesWithoutRevalidation(req) {
        const result = this.evaluateRequest(req);
        return !result.revalidation;
      }
      /**
       * @param {{headers: Record<string, string>, synchronous: boolean}|undefined} revalidation - Revalidation information, if any.
       * @returns {{response: {headers: Record<string, string>}, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object with a cached response headers and revalidation info.
       */
      _evaluateRequestHitResult(revalidation) {
        return {
          response: {
            headers: this.responseHeaders()
          },
          revalidation
        };
      }
      /**
       * @param {HttpRequest} request - new incoming
       * @param {boolean} synchronous - whether revalidation must be synchronous (not s-w-r).
       * @returns {{headers: Record<string, string>, synchronous: boolean}} An object with revalidation headers and a synchronous flag.
       */
      _evaluateRequestRevalidation(request, synchronous) {
        return {
          synchronous,
          headers: this.revalidationHeaders(request)
        };
      }
      /**
       * @param {HttpRequest} request - new incoming
       * @returns {{response: undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}}} An object indicating no cached response and revalidation details.
       */
      _evaluateRequestMissResult(request) {
        return {
          response: void 0,
          revalidation: this._evaluateRequestRevalidation(request, true)
        };
      }
      /**
       * Checks if the given request matches this cache entry, and how the cache can be used to satisfy it. Returns an object with:
       *
       * ```
       * {
       *     // If defined, you must send a request to the server.
       *     revalidation: {
       *         headers: {}, // HTTP headers to use when sending the revalidation response
       *         // If true, you MUST wait for a response from the server before using the cache
       *         // If false, this is stale-while-revalidate. The cache is stale, but you can use it while you update it asynchronously.
       *         synchronous: bool,
       *     },
       *     // If defined, you can use this cached response.
       *     response: {
       *         headers: {}, // Updated cached HTTP headers you must use when responding to the client
       *     },
       * }
       * ```
       * @param {HttpRequest} req - new incoming HTTP request
       * @returns {{response: {headers: Record<string, string>}|undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object containing keys:
       *   - revalidation: { headers: Record<string, string>, synchronous: boolean } Set if you should send this to the origin server
       *   - response: { headers: Record<string, string> } Set if you can respond to the client with these cached headers
       */
      evaluateRequest(req) {
        this._assertRequestHasHeaders(req);
        if (this._rescc["must-revalidate"]) {
          return this._evaluateRequestMissResult(req);
        }
        if (!this._requestMatches(req, false)) {
          return this._evaluateRequestMissResult(req);
        }
        const requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return this._evaluateRequestMissResult(req);
        }
        if (requestCC["max-age"] && this.age() > toNumberOrZero(requestCC["max-age"])) {
          return this._evaluateRequestMissResult(req);
        }
        if (requestCC["min-fresh"] && this.maxAge() - this.age() < toNumberOrZero(requestCC["min-fresh"])) {
          return this._evaluateRequestMissResult(req);
        }
        if (this.stale()) {
          const allowsStaleWithoutRevalidation = "max-stale" in requestCC && (true === requestCC["max-stale"] || requestCC["max-stale"] > this.age() - this.maxAge());
          if (allowsStaleWithoutRevalidation) {
            return this._evaluateRequestHitResult(void 0);
          }
          if (this.useStaleWhileRevalidate()) {
            return this._evaluateRequestHitResult(this._evaluateRequestRevalidation(req, false));
          }
          return this._evaluateRequestMissResult(req);
        }
        return this._evaluateRequestHitResult(void 0);
      }
      /**
       * @param {HttpRequest} req - check if this is for the same cache entry
       * @param {boolean} allowHeadMethod - allow a HEAD method to match.
       * @returns {boolean} `true` if the request matches.
       */
      _requestMatches(req, allowHeadMethod) {
        return !!((!this._url || this._url === req.url) && this._host === req.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
        (!req.method || this._method === req.method || allowHeadMethod && "HEAD" === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and
        this._varyMatches(req));
      }
      /**
       * Determines whether storing authenticated responses is allowed.
       * @returns {boolean} `true` if allowed.
       */
      _allowsStoringAuthenticated() {
        return !!(this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"]);
      }
      /**
       * Checks whether the Vary header in the response matches the new request.
       * @param {HttpRequest} req - incoming HTTP request
       * @returns {boolean} `true` if the vary headers match.
       */
      _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields) {
          if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
        return true;
      }
      /**
       * Creates a copy of the given headers without any hop-by-hop headers.
       * @param {Record<string, string>} inHeaders - old headers from the cached response
       * @returns {Record<string, string>} A new headers object without hop-by-hop headers.
       */
      _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
          if (hopByHopHeaders[name]) continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (const name of tokens) {
            delete headers[name];
          }
        }
        if (headers.warning) {
          const warnings = headers.warning.split(/,/).filter((warning2) => {
            return !/^\s*1[0-9][0-9]/.test(warning2);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      }
      /**
       * Returns the response headers adjusted for serving the cached response.
       * Removes hop-by-hop headers and updates the Age and Date headers.
       * @returns {Record<string, string>} The adjusted response headers.
       */
      responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
      }
      /**
       * Returns the Date header value from the response or the current time if invalid.
       * @returns {number} Timestamp (in milliseconds) representing the Date header or response time.
       */
      date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
          return serverDate;
        }
        return this._responseTime;
      }
      /**
       * Value of the Age header, in seconds, updated for the current time.
       * May be fractional.
       * @returns {number} The age in seconds.
       */
      age() {
        let age = this._ageValue();
        const residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      /**
       * @returns {number} The Age header value as a number.
       */
      _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
      }
      /**
       * Possibly outdated value of applicable max-age (or heuristic equivalent) in seconds.
       * This counts since response's `Date`.
       *
       * For an up-to-date value, see `timeToLive()`.
       *
       * Returns the maximum age (freshness lifetime) of the response in seconds.
       * @returns {number} The max-age value in seconds.
       */
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return toNumberOrZero(this._rescc["s-maxage"]);
          }
        }
        if (this._rescc["max-age"]) {
          return toNumberOrZero(this._rescc["max-age"]);
        }
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const serverDate = this.date();
        if (this._resHeaders.expires) {
          const expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < serverDate) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          const lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && serverDate > lastModified) {
            return Math.max(
              defaultMinTtl,
              (serverDate - lastModified) / 1e3 * this._cacheHeuristic
            );
          }
        }
        return defaultMinTtl;
      }
      /**
       * Remaining time this cache entry may be useful for, in *milliseconds*.
       * You can use this as an expiration time for your cache storage.
       *
       * Prefer this method over `maxAge()`, because it includes other factors like `age` and `stale-while-revalidate`.
       * @returns {number} Time-to-live in milliseconds.
       */
      timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.round(Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3);
      }
      /**
       * If true, this cache entry is past its expiration date.
       * Note that stale cache may be useful sometimes, see `evaluateRequest()`.
       * @returns {boolean} `false` doesn't mean it's fresh nor usable
       */
      stale() {
        return this.maxAge() <= this.age();
      }
      /**
       * @returns {boolean} `true` if `stale-if-error` condition allows use of a stale response.
       */
      _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
      }
      /** See `evaluateRequest()` for a more complete solution
       * @returns {boolean} `true` if `stale-while-revalidate` is currently allowed.
       */
      useStaleWhileRevalidate() {
        const swr = toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return swr > 0 && this.maxAge() + swr > this.age();
      }
      /**
       * Creates a `CachePolicy` instance from a serialized object.
       * @param {Object} obj - The serialized object.
       * @returns {CachePolicy} A new CachePolicy instance.
       */
      static fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      }
      /**
       * @param {any} obj - The serialized object.
       * @throws {Error} If already initialized or if the object is invalid.
       */
      _fromObject(obj) {
        if (this._responseTime) throw Error("Reinitialized");
        if (!obj || obj.v !== 1) throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._ignoreCargoCult = !!obj.icc;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      }
      /**
       * Serializes the `CachePolicy` instance into a JSON-serializable object.
       * @returns {Object} The serialized object.
       */
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          icc: this._ignoreCargoCult,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      /**
       * Headers for sending to the origin server to revalidate stale response.
       * Allows server to return 304 to allow reuse of the previous response.
       *
       * Hop by hop headers are always stripped.
       * Revalidation headers may be added or removed, depending on request.
       * @param {HttpRequest} incomingReq - The incoming HTTP request.
       * @returns {Record<string, string>} The headers for the revalidation request.
       */
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            const etags = headers["if-none-match"].split(/,/).filter((etag) => {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      }
      /**
       * Creates new CachePolicy with information combined from the previews response,
       * and the new revalidation response.
       *
       * Returns {policy, modified} where modified is a boolean indicating
       * whether the response body has been modified, and old cached body can't be used.
       *
       * @param {HttpRequest} request - The latest HTTP request asking for the cached entry.
       * @param {HttpResponse} response - The latest revalidation HTTP response from the origin server.
       * @returns {{policy: CachePolicy, modified: boolean, matches: boolean}} The updated policy and modification status.
       * @throws {Error} If the response headers are missing.
       */
      revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if (this._useStaleIfError() && isErrorResponse(response)) {
          return {
            policy: this,
            modified: false,
            matches: true
          };
        }
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        let matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        const optionsCopy = {
          shared: this._isShared,
          cacheHeuristic: this._cacheHeuristic,
          immutableMinTimeToLive: this._immutableMinTtl,
          ignoreCargoCult: this._ignoreCargoCult
        };
        if (!matches) {
          return {
            policy: new this.constructor(request, response, optionsCopy),
            // Client receiving 304 without body, even if it's invalid/mismatched has no option
            // but to reuse a cached body. We don't have a good way to tell clients to do
            // error recovery in such case.
            modified: response.status != 304,
            matches: false
          };
        }
        const headers = {};
        for (const k in this._resHeaders) {
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }
        const newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request, newResponse, optionsCopy),
          modified: false,
          matches: true
        };
      }
    };
  }
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/quick-lru/index.js"(exports, module) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value2] of this.oldCache.entries()) {
              this.onEviction(key2, value2);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module.exports = QuickLRU;
  }
});

// node_modules/http2-wrapper/source/utils/delay-async-destroy.js
var require_delay_async_destroy = __commonJS({
  "node_modules/http2-wrapper/source/utils/delay-async-destroy.js"(exports, module) {
    "use strict";
    module.exports = (stream2) => {
      if (stream2.listenerCount("error") !== 0) {
        return stream2;
      }
      stream2.__destroy = stream2._destroy;
      stream2._destroy = (...args) => {
        const callback = args.pop();
        stream2.__destroy(...args, async (error2) => {
          await Promise.resolve();
          callback(error2);
        });
      };
      const onError = (error2) => {
        Promise.resolve().then(() => {
          stream2.emit("error", error2);
        });
      };
      stream2.once("error", onError);
      Promise.resolve().then(() => {
        stream2.off("error", onError);
      });
      return stream2;
    };
  }
});

// node_modules/http2-wrapper/source/agent.js
var require_agent2 = __commonJS({
  "node_modules/http2-wrapper/source/agent.js"(exports, module) {
    "use strict";
    var { URL: URL3 } = __require("url");
    var EventEmitter3 = __require("events");
    var tls = __require("tls");
    var http22 = __require("http2");
    var QuickLRU = require_quick_lru();
    var delayAsyncDestroy = require_delay_async_destroy();
    var kCurrentStreamCount = /* @__PURE__ */ Symbol("currentStreamCount");
    var kRequest = /* @__PURE__ */ Symbol("request");
    var kOriginSet = /* @__PURE__ */ Symbol("cachedOriginSet");
    var kGracefullyClosing = /* @__PURE__ */ Symbol("gracefullyClosing");
    var kLength = /* @__PURE__ */ Symbol("length");
    var nameKeys = [
      // Not an Agent option actually
      "createConnection",
      // `http2.connect()` options
      "maxDeflateDynamicTableSize",
      "maxSettings",
      "maxSessionMemory",
      "maxHeaderListPairs",
      "maxOutstandingPings",
      "maxReservedRemoteStreams",
      "maxSendHeaderBlockLength",
      "paddingStrategy",
      "peerMaxConcurrentStreams",
      "settings",
      // `tls.connect()` source options
      "family",
      "localAddress",
      "rejectUnauthorized",
      // `tls.connect()` secure context options
      "pskCallback",
      "minDHSize",
      // `tls.connect()` destination options
      // - `servername` is automatically validated, skip it
      // - `host` and `port` just describe the destination server,
      "path",
      "socket",
      // `tls.createSecureContext()` options
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "ticketKeys"
    ];
    var getSortedIndex = (array, value, compare) => {
      let low = 0;
      let high = array.length;
      while (low < high) {
        const mid = low + high >>> 1;
        if (compare(array[mid], value)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    };
    var compareSessions = (a2, b) => a2.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
    var closeCoveredSessions = (where, session) => {
      for (let index = 0; index < where.length; index++) {
        const coveredSession = where[index];
        if (
          // Unfortunately `.every()` returns true for an empty array
          coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams
        ) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var closeSessionIfCovered = (where, coveredSession) => {
      for (let index = 0; index < where.length; index++) {
        const session = where[index];
        if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
          return true;
        }
      }
      return false;
    };
    var gracefullyClose = (session) => {
      session[kGracefullyClosing] = true;
      if (session[kCurrentStreamCount] === 0) {
        session.close();
      }
    };
    var Agent = class _Agent extends EventEmitter3 {
      constructor({ timeout = 0, maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions = 10, maxCachedTlsSessions = 100 } = {}) {
        super();
        this.sessions = {};
        this.queue = {};
        this.timeout = timeout;
        this.maxSessions = maxSessions;
        this.maxEmptySessions = maxEmptySessions;
        this._emptySessionCount = 0;
        this._sessionCount = 0;
        this.settings = {
          enablePush: false,
          initialWindowSize: 1024 * 1024 * 32
          // 32MB, see https://github.com/nodejs/node/issues/38426
        };
        this.tlsSessionCache = new QuickLRU({ maxSize: maxCachedTlsSessions });
      }
      get protocol() {
        return "https:";
      }
      normalizeOptions(options) {
        let normalized = "";
        for (let index = 0; index < nameKeys.length; index++) {
          const key = nameKeys[index];
          normalized += ":";
          if (options && options[key] !== void 0) {
            normalized += options[key];
          }
        }
        return normalized;
      }
      _processQueue() {
        if (this._sessionCount >= this.maxSessions) {
          this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
          return;
        }
        for (const normalizedOptions in this.queue) {
          for (const normalizedOrigin in this.queue[normalizedOptions]) {
            const item = this.queue[normalizedOptions][normalizedOrigin];
            if (!item.completed) {
              item.completed = true;
              item();
            }
          }
        }
      }
      _isBetterSession(thisStreamCount, thatStreamCount) {
        return thisStreamCount > thatStreamCount;
      }
      _accept(session, listeners, normalizedOrigin, options) {
        let index = 0;
        while (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {
          listeners[index].resolve(session);
          index++;
        }
        listeners.splice(0, index);
        if (listeners.length > 0) {
          this.getSession(normalizedOrigin, options, listeners);
          listeners.length = 0;
        }
      }
      getSession(origin, options, listeners) {
        return new Promise((resolve, reject) => {
          if (Array.isArray(listeners) && listeners.length > 0) {
            listeners = [...listeners];
            resolve();
          } else {
            listeners = [{ resolve, reject }];
          }
          try {
            if (typeof origin === "string") {
              origin = new URL3(origin);
            } else if (!(origin instanceof URL3)) {
              throw new TypeError("The `origin` argument needs to be a string or an URL object");
            }
            if (options) {
              const { servername } = options;
              const { hostname: hostname2 } = origin;
              if (servername && hostname2 !== servername) {
                throw new Error(`Origin ${hostname2} differs from servername ${servername}`);
              }
            }
          } catch (error2) {
            for (let index = 0; index < listeners.length; index++) {
              listeners[index].reject(error2);
            }
            return;
          }
          const normalizedOptions = this.normalizeOptions(options);
          const normalizedOrigin = origin.origin;
          if (normalizedOptions in this.sessions) {
            const sessions = this.sessions[normalizedOptions];
            let maxConcurrentStreams = -1;
            let currentStreamsCount = -1;
            let optimalSession;
            for (let index = 0; index < sessions.length; index++) {
              const session = sessions[index];
              const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
                break;
              }
              if (!session[kOriginSet].includes(normalizedOrigin)) {
                continue;
              }
              const sessionCurrentStreamsCount = session[kCurrentStreamCount];
              if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed) {
                continue;
              }
              if (!optimalSession) {
                maxConcurrentStreams = sessionMaxConcurrentStreams;
              }
              if (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {
                optimalSession = session;
                currentStreamsCount = sessionCurrentStreamsCount;
              }
            }
            if (optimalSession) {
              this._accept(optimalSession, listeners, normalizedOrigin, options);
              return;
            }
          }
          if (normalizedOptions in this.queue) {
            if (normalizedOrigin in this.queue[normalizedOptions]) {
              this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
              return;
            }
          } else {
            this.queue[normalizedOptions] = {
              [kLength]: 0
            };
          }
          const removeFromQueue = () => {
            if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
              delete this.queue[normalizedOptions][normalizedOrigin];
              if (--this.queue[normalizedOptions][kLength] === 0) {
                delete this.queue[normalizedOptions];
              }
            }
          };
          const entry = async () => {
            this._sessionCount++;
            const name = `${normalizedOrigin}:${normalizedOptions}`;
            let receivedSettings = false;
            let socket;
            try {
              const computedOptions = { ...options };
              if (computedOptions.settings === void 0) {
                computedOptions.settings = this.settings;
              }
              if (computedOptions.session === void 0) {
                computedOptions.session = this.tlsSessionCache.get(name);
              }
              const createConnection = computedOptions.createConnection || this.createConnection;
              socket = await createConnection.call(this, origin, computedOptions);
              computedOptions.createConnection = () => socket;
              const session = http22.connect(origin, computedOptions);
              session[kCurrentStreamCount] = 0;
              session[kGracefullyClosing] = false;
              const getOriginSet = () => {
                const { socket: socket2 } = session;
                let originSet;
                if (socket2.servername === false) {
                  socket2.servername = socket2.remoteAddress;
                  originSet = session.originSet;
                  socket2.servername = false;
                } else {
                  originSet = session.originSet;
                }
                return originSet;
              };
              const isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;
              session.socket.once("session", (tlsSession) => {
                this.tlsSessionCache.set(name, tlsSession);
              });
              session.once("error", (error2) => {
                for (let index = 0; index < listeners.length; index++) {
                  listeners[index].reject(error2);
                }
                this.tlsSessionCache.delete(name);
              });
              session.setTimeout(this.timeout, () => {
                session.destroy();
              });
              session.once("close", () => {
                this._sessionCount--;
                if (receivedSettings) {
                  this._emptySessionCount--;
                  const where = this.sessions[normalizedOptions];
                  if (where.length === 1) {
                    delete this.sessions[normalizedOptions];
                  } else {
                    where.splice(where.indexOf(session), 1);
                  }
                } else {
                  removeFromQueue();
                  const error2 = new Error("Session closed without receiving a SETTINGS frame");
                  error2.code = "HTTP2WRAPPER_NOSETTINGS";
                  for (let index = 0; index < listeners.length; index++) {
                    listeners[index].reject(error2);
                  }
                }
                this._processQueue();
              });
              const processListeners = () => {
                const queue = this.queue[normalizedOptions];
                if (!queue) {
                  return;
                }
                const originSet = session[kOriginSet];
                for (let index = 0; index < originSet.length; index++) {
                  const origin2 = originSet[index];
                  if (origin2 in queue) {
                    const { listeners: listeners2, completed } = queue[origin2];
                    let index2 = 0;
                    while (index2 < listeners2.length && isFree()) {
                      listeners2[index2].resolve(session);
                      index2++;
                    }
                    queue[origin2].listeners.splice(0, index2);
                    if (queue[origin2].listeners.length === 0 && !completed) {
                      delete queue[origin2];
                      if (--queue[kLength] === 0) {
                        delete this.queue[normalizedOptions];
                        break;
                      }
                    }
                    if (!isFree()) {
                      break;
                    }
                  }
                }
              };
              session.on("origin", () => {
                session[kOriginSet] = getOriginSet() || [];
                session[kGracefullyClosing] = false;
                closeSessionIfCovered(this.sessions[normalizedOptions], session);
                if (session[kGracefullyClosing] || !isFree()) {
                  return;
                }
                processListeners();
                if (!isFree()) {
                  return;
                }
                closeCoveredSessions(this.sessions[normalizedOptions], session);
              });
              session.once("remoteSettings", () => {
                if (entry.destroyed) {
                  const error2 = new Error("Agent has been destroyed");
                  for (let index = 0; index < listeners.length; index++) {
                    listeners[index].reject(error2);
                  }
                  session.destroy();
                  return;
                }
                if (session.setLocalWindowSize) {
                  session.setLocalWindowSize(1024 * 1024 * 4);
                }
                session[kOriginSet] = getOriginSet() || [];
                if (session.socket.encrypted) {
                  const mainOrigin = session[kOriginSet][0];
                  if (mainOrigin !== normalizedOrigin) {
                    const error2 = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);
                    for (let index = 0; index < listeners.length; index++) {
                      listeners[index].reject(error2);
                    }
                    session.destroy();
                    return;
                  }
                }
                removeFromQueue();
                {
                  const where = this.sessions;
                  if (normalizedOptions in where) {
                    const sessions = where[normalizedOptions];
                    sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                  } else {
                    where[normalizedOptions] = [session];
                  }
                }
                receivedSettings = true;
                this._emptySessionCount++;
                this.emit("session", session);
                this._accept(session, listeners, normalizedOrigin, options);
                if (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {
                  this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);
                }
                session.on("remoteSettings", () => {
                  if (!isFree()) {
                    return;
                  }
                  processListeners();
                  if (!isFree()) {
                    return;
                  }
                  closeCoveredSessions(this.sessions[normalizedOptions], session);
                });
              });
              session[kRequest] = session.request;
              session.request = (headers, streamOptions) => {
                if (session[kGracefullyClosing]) {
                  throw new Error("The session is gracefully closing. No new streams are allowed.");
                }
                const stream2 = session[kRequest](headers, streamOptions);
                session.ref();
                if (session[kCurrentStreamCount]++ === 0) {
                  this._emptySessionCount--;
                }
                stream2.once("close", () => {
                  if (--session[kCurrentStreamCount] === 0) {
                    this._emptySessionCount++;
                    session.unref();
                    if (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {
                      session.close();
                      return;
                    }
                  }
                  if (session.destroyed || session.closed) {
                    return;
                  }
                  if (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {
                    closeCoveredSessions(this.sessions[normalizedOptions], session);
                    processListeners();
                    if (session[kCurrentStreamCount] === 0) {
                      this._processQueue();
                    }
                  }
                });
                return stream2;
              };
            } catch (error2) {
              removeFromQueue();
              this._sessionCount--;
              for (let index = 0; index < listeners.length; index++) {
                listeners[index].reject(error2);
              }
            }
          };
          entry.listeners = listeners;
          entry.completed = false;
          entry.destroyed = false;
          this.queue[normalizedOptions][normalizedOrigin] = entry;
          this.queue[normalizedOptions][kLength]++;
          this._processQueue();
        });
      }
      request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject) => {
          this.getSession(origin, options, [{
            reject,
            resolve: (session) => {
              try {
                const stream2 = session.request(headers, streamOptions);
                delayAsyncDestroy(stream2);
                resolve(stream2);
              } catch (error2) {
                reject(error2);
              }
            }
          }]);
        });
      }
      async createConnection(origin, options) {
        return _Agent.connect(origin, options);
      }
      static connect(origin, options) {
        options.ALPNProtocols = ["h2"];
        const port = origin.port || 443;
        const host = origin.hostname;
        if (typeof options.servername === "undefined") {
          options.servername = host;
        }
        const socket = tls.connect(port, host, options);
        if (options.socket) {
          socket._peername = {
            family: void 0,
            address: void 0,
            port
          };
        }
        return socket;
      }
      closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {
        let closedCount = 0;
        const { sessions } = this;
        for (const key in sessions) {
          const thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++) {
            const session = thisSessions[index];
            if (session[kCurrentStreamCount] === 0) {
              closedCount++;
              session.close();
              if (closedCount >= maxCount) {
                return closedCount;
              }
            }
          }
        }
        return closedCount;
      }
      destroy(reason) {
        const { sessions, queue } = this;
        for (const key in sessions) {
          const thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++) {
            thisSessions[index].destroy(reason);
          }
        }
        for (const normalizedOptions in queue) {
          const entries2 = queue[normalizedOptions];
          for (const normalizedOrigin in entries2) {
            entries2[normalizedOrigin].destroyed = true;
          }
        }
        this.queue = {};
        this.tlsSessionCache.clear();
      }
      get emptySessionCount() {
        return this._emptySessionCount;
      }
      get pendingSessionCount() {
        return this._sessionCount - this._emptySessionCount;
      }
      get sessionCount() {
        return this._sessionCount;
      }
    };
    Agent.kCurrentStreamCount = kCurrentStreamCount;
    Agent.kGracefullyClosing = kGracefullyClosing;
    module.exports = {
      Agent,
      globalAgent: new Agent()
    };
  }
});

// node_modules/http2-wrapper/source/incoming-message.js
var require_incoming_message = __commonJS({
  "node_modules/http2-wrapper/source/incoming-message.js"(exports, module) {
    "use strict";
    var { Readable } = __require("stream");
    var IncomingMessage = class extends Readable {
      constructor(socket, highWaterMark) {
        super({
          emitClose: false,
          autoDestroy: true,
          highWaterMark
        });
        this.statusCode = null;
        this.statusMessage = "";
        this.httpVersion = "2.0";
        this.httpVersionMajor = 2;
        this.httpVersionMinor = 0;
        this.headers = {};
        this.trailers = {};
        this.req = null;
        this.aborted = false;
        this.complete = false;
        this.upgrade = null;
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.socket = socket;
        this._dumped = false;
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      _destroy(error2, callback) {
        if (!this.readableEnded) {
          this.aborted = true;
        }
        callback();
        this.req._request.destroy(error2);
      }
      setTimeout(ms, callback) {
        this.req.setTimeout(ms, callback);
        return this;
      }
      _dump() {
        if (!this._dumped) {
          this._dumped = true;
          this.removeAllListeners("data");
          this.resume();
        }
      }
      _read() {
        if (this.req) {
          this.req._request.resume();
        }
      }
    };
    module.exports = IncomingMessage;
  }
});

// node_modules/http2-wrapper/source/utils/proxy-events.js
var require_proxy_events = __commonJS({
  "node_modules/http2-wrapper/source/utils/proxy-events.js"(exports, module) {
    "use strict";
    module.exports = (from, to, events) => {
      for (const event of events) {
        from.on(event, (...args) => to.emit(event, ...args));
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/errors.js
var require_errors2 = __commonJS({
  "node_modules/http2-wrapper/source/utils/errors.js"(exports, module) {
    "use strict";
    var makeError = (Base, key, getMessage) => {
      module.exports[key] = class NodeError extends Base {
        constructor(...args) {
          super(typeof getMessage === "string" ? getMessage : getMessage(args));
          this.name = `${super.name} [${key}]`;
          this.code = key;
        }
      };
    };
    makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
      const type2 = args[0].includes(".") ? "property" : "argument";
      let valid = args[1];
      const isManyTypes = Array.isArray(valid);
      if (isManyTypes) {
        valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
      }
      return `The "${args[0]}" ${type2} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
    });
    makeError(
      TypeError,
      "ERR_INVALID_PROTOCOL",
      (args) => `Protocol "${args[0]}" not supported. Expected "${args[1]}"`
    );
    makeError(
      Error,
      "ERR_HTTP_HEADERS_SENT",
      (args) => `Cannot ${args[0]} headers after they are sent to the client`
    );
    makeError(
      TypeError,
      "ERR_INVALID_HTTP_TOKEN",
      (args) => `${args[0]} must be a valid HTTP token [${args[1]}]`
    );
    makeError(
      TypeError,
      "ERR_HTTP_INVALID_HEADER_VALUE",
      (args) => `Invalid value "${args[0]} for header "${args[1]}"`
    );
    makeError(
      TypeError,
      "ERR_INVALID_CHAR",
      (args) => `Invalid character in ${args[0]} [${args[1]}]`
    );
    makeError(
      Error,
      "ERR_HTTP2_NO_SOCKET_MANIPULATION",
      "HTTP/2 sockets should not be directly manipulated (e.g. read and written)"
    );
  }
});

// node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js
var require_is_request_pseudo_header = __commonJS({
  "node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(exports, module) {
    "use strict";
    module.exports = (header) => {
      switch (header) {
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
          return true;
        default:
          return false;
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/validate-header-name.js
var require_validate_header_name = __commonJS({
  "node_modules/http2-wrapper/source/utils/validate-header-name.js"(exports, module) {
    "use strict";
    var { ERR_INVALID_HTTP_TOKEN } = require_errors2();
    var isRequestPseudoHeader = require_is_request_pseudo_header();
    var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
    module.exports = (name) => {
      if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
        throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/validate-header-value.js
var require_validate_header_value = __commonJS({
  "node_modules/http2-wrapper/source/utils/validate-header-value.js"(exports, module) {
    "use strict";
    var {
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_INVALID_CHAR
    } = require_errors2();
    var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
    module.exports = (name, value) => {
      if (typeof value === "undefined") {
        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
      }
      if (isInvalidHeaderValue.test(value)) {
        throw new ERR_INVALID_CHAR("header content", name);
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/proxy-socket-handler.js
var require_proxy_socket_handler = __commonJS({
  "node_modules/http2-wrapper/source/utils/proxy-socket-handler.js"(exports, module) {
    "use strict";
    var { ERR_HTTP2_NO_SOCKET_MANIPULATION } = require_errors2();
    var proxySocketHandler = {
      has(stream2, property) {
        const reference = stream2.session === void 0 ? stream2 : stream2.session.socket;
        return property in stream2 || property in reference;
      },
      get(stream2, property) {
        switch (property) {
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            return stream2[property].bind(stream2);
          case "writable":
          case "destroyed":
            return stream2[property];
          case "readable":
            if (stream2.destroyed) {
              return false;
            }
            return stream2.readable;
          case "setTimeout": {
            const { session } = stream2;
            if (session !== void 0) {
              return session.setTimeout.bind(session);
            }
            return stream2.setTimeout.bind(stream2);
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            const reference = stream2.session === void 0 ? stream2 : stream2.session.socket;
            const value = reference[property];
            return typeof value === "function" ? value.bind(reference) : value;
          }
        }
      },
      getPrototypeOf(stream2) {
        if (stream2.session !== void 0) {
          return Reflect.getPrototypeOf(stream2.session.socket);
        }
        return Reflect.getPrototypeOf(stream2);
      },
      set(stream2, property, value) {
        switch (property) {
          case "writable":
          case "readable":
          case "destroyed":
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            stream2[property] = value;
            return true;
          case "setTimeout": {
            const { session } = stream2;
            if (session === void 0) {
              stream2.setTimeout = value;
            } else {
              session.setTimeout = value;
            }
            return true;
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            const reference = stream2.session === void 0 ? stream2 : stream2.session.socket;
            reference[property] = value;
            return true;
          }
        }
      }
    };
    module.exports = proxySocketHandler;
  }
});

// node_modules/http2-wrapper/source/client-request.js
var require_client_request = __commonJS({
  "node_modules/http2-wrapper/source/client-request.js"(exports, module) {
    "use strict";
    var { URL: URL3, urlToHttpOptions } = __require("url");
    var http22 = __require("http2");
    var { Writable } = __require("stream");
    var { Agent, globalAgent } = require_agent2();
    var IncomingMessage = require_incoming_message();
    var proxyEvents2 = require_proxy_events();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_PROTOCOL,
      ERR_HTTP_HEADERS_SENT
    } = require_errors2();
    var validateHeaderName = require_validate_header_name();
    var validateHeaderValue = require_validate_header_value();
    var proxySocketHandler = require_proxy_socket_handler();
    var {
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_AUTHORITY,
      HTTP2_METHOD_CONNECT
    } = http22.constants;
    var kHeaders = /* @__PURE__ */ Symbol("headers");
    var kOrigin = /* @__PURE__ */ Symbol("origin");
    var kSession = /* @__PURE__ */ Symbol("session");
    var kOptions = /* @__PURE__ */ Symbol("options");
    var kFlushedHeaders = /* @__PURE__ */ Symbol("flushedHeaders");
    var kJobs = /* @__PURE__ */ Symbol("jobs");
    var kPendingAgentPromise = /* @__PURE__ */ Symbol("pendingAgentPromise");
    var ClientRequest = class extends Writable {
      constructor(input, options, callback) {
        super({
          autoDestroy: false,
          emitClose: false
        });
        if (typeof input === "string") {
          input = urlToHttpOptions(new URL3(input));
        } else if (input instanceof URL3) {
          input = urlToHttpOptions(input);
        } else {
          input = { ...input };
        }
        if (typeof options === "function" || options === void 0) {
          callback = options;
          options = input;
        } else {
          options = Object.assign(input, options);
        }
        if (options.h2session) {
          this[kSession] = options.h2session;
          if (this[kSession].destroyed) {
            throw new Error("The session has been closed already");
          }
          this.protocol = this[kSession].socket.encrypted ? "https:" : "http:";
        } else if (options.agent === false) {
          this.agent = new Agent({ maxEmptySessions: 0 });
        } else if (typeof options.agent === "undefined" || options.agent === null) {
          this.agent = globalAgent;
        } else if (typeof options.agent.request === "function") {
          this.agent = options.agent;
        } else {
          throw new ERR_INVALID_ARG_TYPE("options.agent", ["http2wrapper.Agent-like Object", "undefined", "false"], options.agent);
        }
        if (this.agent) {
          this.protocol = this.agent.protocol;
        }
        if (options.protocol && options.protocol !== this.protocol) {
          throw new ERR_INVALID_PROTOCOL(options.protocol, this.protocol);
        }
        if (!options.port) {
          options.port = options.defaultPort || this.agent && this.agent.defaultPort || 443;
        }
        options.host = options.hostname || options.host || "localhost";
        delete options.hostname;
        const { timeout } = options;
        options.timeout = void 0;
        this[kHeaders] = /* @__PURE__ */ Object.create(null);
        this[kJobs] = [];
        this[kPendingAgentPromise] = void 0;
        this.socket = null;
        this.connection = null;
        this.method = options.method || "GET";
        if (!(this.method === "CONNECT" && (options.path === "/" || options.path === void 0))) {
          this.path = options.path;
        }
        this.res = null;
        this.aborted = false;
        this.reusedSocket = false;
        const { headers } = options;
        if (headers) {
          for (const header in headers) {
            this.setHeader(header, headers[header]);
          }
        }
        if (options.auth && !("authorization" in this[kHeaders])) {
          this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
        }
        options.session = options.tlsSession;
        options.path = options.socketPath;
        this[kOptions] = options;
        this[kOrigin] = new URL3(`${this.protocol}//${options.servername || options.host}:${options.port}`);
        const reuseSocket = options._reuseSocket;
        if (reuseSocket) {
          options.createConnection = (...args) => {
            if (reuseSocket.destroyed) {
              return this.agent.createConnection(...args);
            }
            return reuseSocket;
          };
          this.agent.getSession(this[kOrigin], this[kOptions]).catch(() => {
          });
        }
        if (timeout) {
          this.setTimeout(timeout);
        }
        if (callback) {
          this.once("response", callback);
        }
        this[kFlushedHeaders] = false;
      }
      get method() {
        return this[kHeaders][HTTP2_HEADER_METHOD];
      }
      set method(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
        }
      }
      get path() {
        const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
        return this[kHeaders][header];
      }
      set path(value) {
        if (value) {
          const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
          this[kHeaders][header] = value;
        }
      }
      get host() {
        return this[kOrigin].hostname;
      }
      set host(_value) {
      }
      get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
      }
      _write(chunk2, encoding, callback) {
        if (this._mustNotHaveABody) {
          callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
          return;
        }
        this.flushHeaders();
        const callWrite = () => this._request.write(chunk2, encoding, callback);
        if (this._request) {
          callWrite();
        } else {
          this[kJobs].push(callWrite);
        }
      }
      _final(callback) {
        this.flushHeaders();
        const callEnd = () => {
          if (this._mustNotHaveABody || this.method === "CONNECT") {
            callback();
            return;
          }
          this._request.end(callback);
        };
        if (this._request) {
          callEnd();
        } else {
          this[kJobs].push(callEnd);
        }
      }
      abort() {
        if (this.res && this.res.complete) {
          return;
        }
        if (!this.aborted) {
          process.nextTick(() => this.emit("abort"));
        }
        this.aborted = true;
        this.destroy();
      }
      async _destroy(error2, callback) {
        if (this.res) {
          this.res._dump();
        }
        if (this._request) {
          this._request.destroy();
        } else {
          process.nextTick(() => {
            this.emit("close");
          });
        }
        try {
          await this[kPendingAgentPromise];
        } catch (internalError) {
          if (this.aborted) {
            error2 = internalError;
          }
        }
        callback(error2);
      }
      async flushHeaders() {
        if (this[kFlushedHeaders] || this.destroyed) {
          return;
        }
        this[kFlushedHeaders] = true;
        const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
        const onStream = (stream2) => {
          this._request = stream2;
          if (this.destroyed) {
            stream2.destroy();
            return;
          }
          if (!isConnectMethod) {
            proxyEvents2(stream2, this, ["timeout", "continue"]);
          }
          stream2.once("error", (error2) => {
            this.destroy(error2);
          });
          stream2.once("aborted", () => {
            const { res } = this;
            if (res) {
              res.aborted = true;
              res.emit("aborted");
              res.destroy();
            } else {
              this.destroy(new Error("The server aborted the HTTP/2 stream"));
            }
          });
          const onResponse = (headers, flags, rawHeaders) => {
            const response = new IncomingMessage(this.socket, stream2.readableHighWaterMark);
            this.res = response;
            response.url = `${this[kOrigin].origin}${this.path}`;
            response.req = this;
            response.statusCode = headers[HTTP2_HEADER_STATUS];
            response.headers = headers;
            response.rawHeaders = rawHeaders;
            response.once("end", () => {
              response.complete = true;
              response.socket = null;
              response.connection = null;
            });
            if (isConnectMethod) {
              response.upgrade = true;
              if (this.emit("connect", response, stream2, Buffer.alloc(0))) {
                this.emit("close");
              } else {
                stream2.destroy();
              }
            } else {
              stream2.on("data", (chunk2) => {
                if (!response._dumped && !response.push(chunk2)) {
                  stream2.pause();
                }
              });
              stream2.once("end", () => {
                if (!this.aborted) {
                  response.push(null);
                }
              });
              if (!this.emit("response", response)) {
                response._dump();
              }
            }
          };
          stream2.once("response", onResponse);
          stream2.once("headers", (headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] }));
          stream2.once("trailers", (trailers, flags, rawTrailers) => {
            const { res } = this;
            if (res === null) {
              onResponse(trailers, flags, rawTrailers);
              return;
            }
            res.trailers = trailers;
            res.rawTrailers = rawTrailers;
          });
          stream2.once("close", () => {
            const { aborted, res } = this;
            if (res) {
              if (aborted) {
                res.aborted = true;
                res.emit("aborted");
                res.destroy();
              }
              const finish = () => {
                res.emit("close");
                this.destroy();
                this.emit("close");
              };
              if (res.readable) {
                res.once("end", finish);
              } else {
                finish();
              }
              return;
            }
            if (!this.destroyed) {
              this.destroy(new Error("The HTTP/2 stream has been early terminated"));
              this.emit("close");
              return;
            }
            this.destroy();
            this.emit("close");
          });
          this.socket = new Proxy(stream2, proxySocketHandler);
          for (const job of this[kJobs]) {
            job();
          }
          this[kJobs].length = 0;
          this.emit("socket", this.socket);
        };
        if (!(HTTP2_HEADER_AUTHORITY in this[kHeaders]) && !isConnectMethod) {
          this[kHeaders][HTTP2_HEADER_AUTHORITY] = this[kOrigin].host;
        }
        if (this[kSession]) {
          try {
            onStream(this[kSession].request(this[kHeaders]));
          } catch (error2) {
            this.destroy(error2);
          }
        } else {
          this.reusedSocket = true;
          try {
            const promise = this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);
            this[kPendingAgentPromise] = promise;
            onStream(await promise);
            this[kPendingAgentPromise] = false;
          } catch (error2) {
            this[kPendingAgentPromise] = false;
            this.destroy(error2);
          }
        }
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      getHeaderNames() {
        return Object.keys(this[kHeaders]);
      }
      hasHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return Boolean(this[kHeaders][name.toLowerCase()]);
      }
      getHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return this[kHeaders][name.toLowerCase()];
      }
      get headersSent() {
        return this[kFlushedHeaders];
      }
      removeHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("remove");
        }
        delete this[kHeaders][name.toLowerCase()];
      }
      setHeader(name, value) {
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("set");
        }
        validateHeaderName(name);
        validateHeaderValue(name, value);
        const lowercased = name.toLowerCase();
        if (lowercased === "connection") {
          if (value.toLowerCase() === "keep-alive") {
            return;
          }
          throw new Error(`Invalid 'connection' header: ${value}`);
        }
        if (lowercased === "host" && this.method === "CONNECT") {
          this[kHeaders][HTTP2_HEADER_AUTHORITY] = value;
        } else {
          this[kHeaders][lowercased] = value;
        }
      }
      setNoDelay() {
      }
      setSocketKeepAlive() {
      }
      setTimeout(ms, callback) {
        const applyTimeout = () => this._request.setTimeout(ms, callback);
        if (this._request) {
          applyTimeout();
        } else {
          this[kJobs].push(applyTimeout);
        }
        return this;
      }
      get maxHeadersCount() {
        if (!this.destroyed && this._request) {
          return this._request.session.localSettings.maxHeaderListSize;
        }
        return void 0;
      }
      set maxHeadersCount(_value) {
      }
    };
    module.exports = ClientRequest;
  }
});

// node_modules/resolve-alpn/index.js
var require_resolve_alpn = __commonJS({
  "node_modules/resolve-alpn/index.js"(exports, module) {
    "use strict";
    var tls = __require("tls");
    module.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
      let timeout = false;
      let socket;
      const callback = async () => {
        await socketPromise;
        socket.off("timeout", onTimeout);
        socket.off("error", reject);
        if (options.resolveSocket) {
          resolve({ alpnProtocol: socket.alpnProtocol, socket, timeout });
          if (timeout) {
            await Promise.resolve();
            socket.emit("timeout");
          }
        } else {
          socket.destroy();
          resolve({ alpnProtocol: socket.alpnProtocol, timeout });
        }
      };
      const onTimeout = async () => {
        timeout = true;
        callback();
      };
      const socketPromise = (async () => {
        try {
          socket = await connect(options, callback);
          socket.on("error", reject);
          socket.once("timeout", onTimeout);
        } catch (error2) {
          reject(error2);
        }
      })();
    });
  }
});

// node_modules/http2-wrapper/source/utils/calculate-server-name.js
var require_calculate_server_name = __commonJS({
  "node_modules/http2-wrapper/source/utils/calculate-server-name.js"(exports, module) {
    "use strict";
    var { isIP } = __require("net");
    var assert3 = __require("assert");
    var getHost = (host) => {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert3(idx2 !== -1);
        return host.slice(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) {
        return host;
      }
      return host.slice(0, idx);
    };
    module.exports = (host) => {
      const servername = getHost(host);
      if (isIP(servername)) {
        return "";
      }
      return servername;
    };
  }
});

// node_modules/http2-wrapper/source/auto.js
var require_auto = __commonJS({
  "node_modules/http2-wrapper/source/auto.js"(exports, module) {
    "use strict";
    var { URL: URL3, urlToHttpOptions } = __require("url");
    var http3 = __require("http");
    var https2 = __require("https");
    var resolveALPN = require_resolve_alpn();
    var QuickLRU = require_quick_lru();
    var { Agent, globalAgent } = require_agent2();
    var Http2ClientRequest = require_client_request();
    var calculateServerName = require_calculate_server_name();
    var delayAsyncDestroy = require_delay_async_destroy();
    var cache = new QuickLRU({ maxSize: 100 });
    var queue = /* @__PURE__ */ new Map();
    var installSocket = (agent, socket, options) => {
      socket._httpMessage = { shouldKeepAlive: true };
      const onFree = () => {
        agent.emit("free", socket, options);
      };
      socket.on("free", onFree);
      const onClose = () => {
        agent.removeSocket(socket, options);
      };
      socket.on("close", onClose);
      const onTimeout = () => {
        const { freeSockets } = agent;
        for (const sockets of Object.values(freeSockets)) {
          if (sockets.includes(socket)) {
            socket.destroy();
            return;
          }
        }
      };
      socket.on("timeout", onTimeout);
      const onRemove = () => {
        agent.removeSocket(socket, options);
        socket.off("close", onClose);
        socket.off("free", onFree);
        socket.off("timeout", onTimeout);
        socket.off("agentRemove", onRemove);
      };
      socket.on("agentRemove", onRemove);
      agent.emit("free", socket, options);
    };
    var createResolveProtocol = (cache2, queue2 = /* @__PURE__ */ new Map(), connect = void 0) => {
      return async (options) => {
        const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
        if (!cache2.has(name)) {
          if (queue2.has(name)) {
            const result = await queue2.get(name);
            return { alpnProtocol: result.alpnProtocol };
          }
          const { path: path2 } = options;
          options.path = options.socketPath;
          const resultPromise = resolveALPN(options, connect);
          queue2.set(name, resultPromise);
          try {
            const result = await resultPromise;
            cache2.set(name, result.alpnProtocol);
            queue2.delete(name);
            options.path = path2;
            return result;
          } catch (error2) {
            queue2.delete(name);
            options.path = path2;
            throw error2;
          }
        }
        return { alpnProtocol: cache2.get(name) };
      };
    };
    var defaultResolveProtocol = createResolveProtocol(cache, queue);
    module.exports = async (input, options, callback) => {
      if (typeof input === "string") {
        input = urlToHttpOptions(new URL3(input));
      } else if (input instanceof URL3) {
        input = urlToHttpOptions(input);
      } else {
        input = { ...input };
      }
      if (typeof options === "function" || options === void 0) {
        callback = options;
        options = input;
      } else {
        options = Object.assign(input, options);
      }
      options.ALPNProtocols = options.ALPNProtocols || ["h2", "http/1.1"];
      if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
        throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
      }
      options.protocol = options.protocol || "https:";
      const isHttps = options.protocol === "https:";
      options.host = options.hostname || options.host || "localhost";
      options.session = options.tlsSession;
      options.servername = options.servername || calculateServerName(options.headers && options.headers.host || options.host);
      options.port = options.port || (isHttps ? 443 : 80);
      options._defaultAgent = isHttps ? https2.globalAgent : http3.globalAgent;
      const resolveProtocol = options.resolveProtocol || defaultResolveProtocol;
      let { agent } = options;
      if (agent !== void 0 && agent !== false && agent.constructor.name !== "Object") {
        throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties");
      }
      if (isHttps) {
        options.resolveSocket = true;
        let { socket, alpnProtocol, timeout } = await resolveProtocol(options);
        if (timeout) {
          if (socket) {
            socket.destroy();
          }
          const error2 = new Error(`Timed out resolving ALPN: ${options.timeout} ms`);
          error2.code = "ETIMEDOUT";
          error2.ms = options.timeout;
          throw error2;
        }
        if (socket && options.createConnection) {
          socket.destroy();
          socket = void 0;
        }
        delete options.resolveSocket;
        const isHttp2 = alpnProtocol === "h2";
        if (agent) {
          agent = isHttp2 ? agent.http2 : agent.https;
          options.agent = agent;
        }
        if (agent === void 0) {
          agent = isHttp2 ? globalAgent : https2.globalAgent;
        }
        if (socket) {
          if (agent === false) {
            socket.destroy();
          } else {
            const defaultCreateConnection = (isHttp2 ? Agent : https2.Agent).prototype.createConnection;
            if (agent.createConnection === defaultCreateConnection) {
              if (isHttp2) {
                options._reuseSocket = socket;
              } else {
                installSocket(agent, socket, options);
              }
            } else {
              socket.destroy();
            }
          }
        }
        if (isHttp2) {
          return delayAsyncDestroy(new Http2ClientRequest(options, callback));
        }
      } else if (agent) {
        options.agent = agent.http;
      }
      if (options.headers) {
        options.headers = { ...options.headers };
        if (options.headers[":authority"]) {
          if (!options.headers.host) {
            options.headers.host = options.headers[":authority"];
          }
          delete options.headers[":authority"];
        }
        delete options.headers[":method"];
        delete options.headers[":scheme"];
        delete options.headers[":path"];
      }
      return delayAsyncDestroy(http3.request(options, callback));
    };
    module.exports.protocolCache = cache;
    module.exports.resolveProtocol = defaultResolveProtocol;
    module.exports.createResolveProtocol = createResolveProtocol;
  }
});

// node_modules/http2-wrapper/source/utils/js-stream-socket.js
var require_js_stream_socket = __commonJS({
  "node_modules/http2-wrapper/source/utils/js-stream-socket.js"(exports, module) {
    "use strict";
    var stream2 = __require("stream");
    var tls = __require("tls");
    var JSStreamSocket = new tls.TLSSocket(new stream2.PassThrough())._handle._parentWrap.constructor;
    module.exports = JSStreamSocket;
  }
});

// node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js
var require_unexpected_status_code_error = __commonJS({
  "node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js"(exports, module) {
    "use strict";
    var UnexpectedStatusCodeError = class extends Error {
      constructor(statusCode, statusMessage = "") {
        super(`The proxy server rejected the request with status code ${statusCode} (${statusMessage || "empty status message"})`);
        this.statusCode = statusCode;
        this.statusMessage = statusMessage;
      }
    };
    module.exports = UnexpectedStatusCodeError;
  }
});

// node_modules/http2-wrapper/source/utils/check-type.js
var require_check_type = __commonJS({
  "node_modules/http2-wrapper/source/utils/check-type.js"(exports, module) {
    "use strict";
    var checkType = (name, value, types2) => {
      const valid = types2.some((type2) => {
        const typeofType = typeof type2;
        if (typeofType === "string") {
          return typeof value === type2;
        }
        return value instanceof type2;
      });
      if (!valid) {
        const names = types2.map((type2) => typeof type2 === "string" ? type2 : type2.name);
        throw new TypeError(`Expected '${name}' to be a type of ${names.join(" or ")}, got ${typeof value}`);
      }
    };
    module.exports = checkType;
  }
});

// node_modules/http2-wrapper/source/proxies/initialize.js
var require_initialize = __commonJS({
  "node_modules/http2-wrapper/source/proxies/initialize.js"(exports, module) {
    "use strict";
    var { URL: URL3 } = __require("url");
    var checkType = require_check_type();
    module.exports = (self2, proxyOptions) => {
      checkType("proxyOptions", proxyOptions, ["object"]);
      checkType("proxyOptions.headers", proxyOptions.headers, ["object", "undefined"]);
      checkType("proxyOptions.raw", proxyOptions.raw, ["boolean", "undefined"]);
      checkType("proxyOptions.url", proxyOptions.url, [URL3, "string"]);
      const url = new URL3(proxyOptions.url);
      self2.proxyOptions = {
        raw: true,
        ...proxyOptions,
        headers: { ...proxyOptions.headers },
        url
      };
    };
  }
});

// node_modules/http2-wrapper/source/proxies/get-auth-headers.js
var require_get_auth_headers = __commonJS({
  "node_modules/http2-wrapper/source/proxies/get-auth-headers.js"(exports, module) {
    "use strict";
    module.exports = (self2) => {
      const { username, password } = self2.proxyOptions.url;
      if (username || password) {
        const data = `${username}:${password}`;
        const authorization = `Basic ${Buffer.from(data).toString("base64")}`;
        return {
          "proxy-authorization": authorization,
          authorization
        };
      }
      return {};
    };
  }
});

// node_modules/http2-wrapper/source/proxies/h1-over-h2.js
var require_h1_over_h2 = __commonJS({
  "node_modules/http2-wrapper/source/proxies/h1-over-h2.js"(exports, module) {
    "use strict";
    var tls = __require("tls");
    var http3 = __require("http");
    var https2 = __require("https");
    var JSStreamSocket = require_js_stream_socket();
    var { globalAgent } = require_agent2();
    var UnexpectedStatusCodeError = require_unexpected_status_code_error();
    var initialize = require_initialize();
    var getAuthorizationHeaders = require_get_auth_headers();
    var createConnection = (self2, options, callback) => {
      (async () => {
        try {
          const { proxyOptions } = self2;
          const { url, headers, raw } = proxyOptions;
          const stream2 = await globalAgent.request(url, proxyOptions, {
            ...getAuthorizationHeaders(self2),
            ...headers,
            ":method": "CONNECT",
            ":authority": `${options.host}:${options.port}`
          });
          stream2.once("error", callback);
          stream2.once("response", (headers2) => {
            const statusCode = headers2[":status"];
            if (statusCode !== 200) {
              callback(new UnexpectedStatusCodeError(statusCode, ""));
              return;
            }
            const encrypted = self2 instanceof https2.Agent;
            if (raw && encrypted) {
              options.socket = stream2;
              const secureStream = tls.connect(options);
              secureStream.once("close", () => {
                stream2.destroy();
              });
              callback(null, secureStream);
              return;
            }
            const socket = new JSStreamSocket(stream2);
            socket.encrypted = false;
            socket._handle.getpeername = (out) => {
              out.family = void 0;
              out.address = void 0;
              out.port = void 0;
            };
            callback(null, socket);
          });
        } catch (error2) {
          callback(error2);
        }
      })();
    };
    var HttpOverHttp2 = class extends http3.Agent {
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    };
    var HttpsOverHttp2 = class extends https2.Agent {
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    };
    module.exports = {
      HttpOverHttp2,
      HttpsOverHttp2
    };
  }
});

// node_modules/http2-wrapper/source/proxies/h2-over-hx.js
var require_h2_over_hx = __commonJS({
  "node_modules/http2-wrapper/source/proxies/h2-over-hx.js"(exports, module) {
    "use strict";
    var { Agent } = require_agent2();
    var JSStreamSocket = require_js_stream_socket();
    var UnexpectedStatusCodeError = require_unexpected_status_code_error();
    var initialize = require_initialize();
    var Http2OverHttpX = class extends Agent {
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      async createConnection(origin, options) {
        const authority = `${origin.hostname}:${origin.port || 443}`;
        const [stream2, statusCode, statusMessage] = await this._getProxyStream(authority);
        if (statusCode !== 200) {
          throw new UnexpectedStatusCodeError(statusCode, statusMessage);
        }
        if (this.proxyOptions.raw) {
          options.socket = stream2;
        } else {
          const socket = new JSStreamSocket(stream2);
          socket.encrypted = false;
          socket._handle.getpeername = (out) => {
            out.family = void 0;
            out.address = void 0;
            out.port = void 0;
          };
          return socket;
        }
        return super.createConnection(origin, options);
      }
    };
    module.exports = Http2OverHttpX;
  }
});

// node_modules/http2-wrapper/source/proxies/h2-over-h2.js
var require_h2_over_h2 = __commonJS({
  "node_modules/http2-wrapper/source/proxies/h2-over-h2.js"(exports, module) {
    "use strict";
    var { globalAgent } = require_agent2();
    var Http2OverHttpX = require_h2_over_hx();
    var getAuthorizationHeaders = require_get_auth_headers();
    var getStatusCode = (stream2) => new Promise((resolve, reject) => {
      stream2.once("error", reject);
      stream2.once("response", (headers) => {
        stream2.off("error", reject);
        resolve(headers[":status"]);
      });
    });
    var Http2OverHttp2 = class extends Http2OverHttpX {
      async _getProxyStream(authority) {
        const { proxyOptions } = this;
        const headers = {
          ...getAuthorizationHeaders(this),
          ...proxyOptions.headers,
          ":method": "CONNECT",
          ":authority": authority
        };
        const stream2 = await globalAgent.request(proxyOptions.url, proxyOptions, headers);
        const statusCode = await getStatusCode(stream2);
        return [stream2, statusCode, ""];
      }
    };
    module.exports = Http2OverHttp2;
  }
});

// node_modules/http2-wrapper/source/proxies/h2-over-h1.js
var require_h2_over_h1 = __commonJS({
  "node_modules/http2-wrapper/source/proxies/h2-over-h1.js"(exports, module) {
    "use strict";
    var http3 = __require("http");
    var https2 = __require("https");
    var Http2OverHttpX = require_h2_over_hx();
    var getAuthorizationHeaders = require_get_auth_headers();
    var getStream = (request) => new Promise((resolve, reject) => {
      const onConnect = (response, socket, head) => {
        socket.unshift(head);
        request.off("error", reject);
        resolve([socket, response.statusCode, response.statusMessage]);
      };
      request.once("error", reject);
      request.once("connect", onConnect);
    });
    var Http2OverHttp = class extends Http2OverHttpX {
      async _getProxyStream(authority) {
        const { proxyOptions } = this;
        const { url, headers } = this.proxyOptions;
        const network = url.protocol === "https:" ? https2 : http3;
        const request = network.request({
          ...proxyOptions,
          hostname: url.hostname,
          port: url.port,
          path: authority,
          headers: {
            ...getAuthorizationHeaders(this),
            ...headers,
            host: authority
          },
          method: "CONNECT"
        }).end();
        return getStream(request);
      }
    };
    module.exports = {
      Http2OverHttp,
      Http2OverHttps: Http2OverHttp
    };
  }
});

// node_modules/http2-wrapper/source/index.js
var require_source = __commonJS({
  "node_modules/http2-wrapper/source/index.js"(exports, module) {
    "use strict";
    var http22 = __require("http2");
    var {
      Agent,
      globalAgent
    } = require_agent2();
    var ClientRequest = require_client_request();
    var IncomingMessage = require_incoming_message();
    var auto = require_auto();
    var {
      HttpOverHttp2,
      HttpsOverHttp2
    } = require_h1_over_h2();
    var Http2OverHttp2 = require_h2_over_h2();
    var {
      Http2OverHttp,
      Http2OverHttps
    } = require_h2_over_h1();
    var validateHeaderName = require_validate_header_name();
    var validateHeaderValue = require_validate_header_value();
    var request = (url, options, callback) => new ClientRequest(url, options, callback);
    var get = (url, options, callback) => {
      const req = new ClientRequest(url, options, callback);
      req.end();
      return req;
    };
    module.exports = {
      ...http22,
      ClientRequest,
      IncomingMessage,
      Agent,
      globalAgent,
      request,
      get,
      auto,
      proxies: {
        HttpOverHttp2,
        HttpsOverHttp2,
        Http2OverHttp2,
        Http2OverHttp,
        Http2OverHttps
      },
      validateHeaderName,
      validateHeaderValue
    };
  }
});

// node_modules/@actions/glob/lib/internal-glob-options-helper.js
var require_internal_glob_options_helper = __commonJS({
  "node_modules/@actions/glob/lib/internal-glob-options-helper.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOptions = void 0;
    var core = __importStar2(require_core());
    function getOptions(copy2) {
      const result = {
        followSymbolicLinks: true,
        implicitDescendants: true,
        omitBrokenSymbolicLinks: true
      };
      if (copy2) {
        if (typeof copy2.followSymbolicLinks === "boolean") {
          result.followSymbolicLinks = copy2.followSymbolicLinks;
          core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
        }
        if (typeof copy2.implicitDescendants === "boolean") {
          result.implicitDescendants = copy2.implicitDescendants;
          core.debug(`implicitDescendants '${result.implicitDescendants}'`);
        }
        if (typeof copy2.omitBrokenSymbolicLinks === "boolean") {
          result.omitBrokenSymbolicLinks = copy2.omitBrokenSymbolicLinks;
          core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
        }
      }
      return result;
    }
    exports.getOptions = getOptions;
  }
});

// node_modules/@actions/glob/lib/internal-path-helper.js
var require_internal_path_helper = __commonJS({
  "node_modules/@actions/glob/lib/internal-path-helper.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeTrimTrailingSeparator = exports.normalizeSeparators = exports.hasRoot = exports.hasAbsoluteRoot = exports.ensureAbsoluteRoot = exports.dirname = void 0;
    var path2 = __importStar2(__require("path"));
    var assert_1 = __importDefault2(__require("assert"));
    var IS_WINDOWS = process.platform === "win32";
    function dirname(p) {
      p = safeTrimTrailingSeparator(p);
      if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
        return p;
      }
      let result = path2.dirname(p);
      if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
        result = safeTrimTrailingSeparator(result);
      }
      return result;
    }
    exports.dirname = dirname;
    function ensureAbsoluteRoot(root, itemPath) {
      assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
      assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
      if (hasAbsoluteRoot(itemPath)) {
        return itemPath;
      }
      if (IS_WINDOWS) {
        if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
          let cwd = process.cwd();
          assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
          if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
            if (itemPath.length === 2) {
              return `${itemPath[0]}:\\${cwd.substr(3)}`;
            } else {
              if (!cwd.endsWith("\\")) {
                cwd += "\\";
              }
              return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
            }
          } else {
            return `${itemPath[0]}:\\${itemPath.substr(2)}`;
          }
        } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
          const cwd = process.cwd();
          assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
          return `${cwd[0]}:\\${itemPath.substr(1)}`;
        }
      }
      assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
      if (root.endsWith("/") || IS_WINDOWS && root.endsWith("\\")) {
      } else {
        root += path2.sep;
      }
      return root + itemPath;
    }
    exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
    function hasAbsoluteRoot(itemPath) {
      assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
      itemPath = normalizeSeparators(itemPath);
      if (IS_WINDOWS) {
        return itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath);
      }
      return itemPath.startsWith("/");
    }
    exports.hasAbsoluteRoot = hasAbsoluteRoot;
    function hasRoot(itemPath) {
      assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
      itemPath = normalizeSeparators(itemPath);
      if (IS_WINDOWS) {
        return itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath);
      }
      return itemPath.startsWith("/");
    }
    exports.hasRoot = hasRoot;
    function normalizeSeparators(p) {
      p = p || "";
      if (IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        const isUnc = /^\\\\+[^\\]/.test(p);
        return (isUnc ? "\\" : "") + p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    exports.normalizeSeparators = normalizeSeparators;
    function safeTrimTrailingSeparator(p) {
      if (!p) {
        return "";
      }
      p = normalizeSeparators(p);
      if (!p.endsWith(path2.sep)) {
        return p;
      }
      if (p === path2.sep) {
        return p;
      }
      if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
        return p;
      }
      return p.substr(0, p.length - 1);
    }
    exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
  }
});

// node_modules/@actions/glob/lib/internal-match-kind.js
var require_internal_match_kind = __commonJS({
  "node_modules/@actions/glob/lib/internal-match-kind.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MatchKind = void 0;
    var MatchKind;
    (function(MatchKind2) {
      MatchKind2[MatchKind2["None"] = 0] = "None";
      MatchKind2[MatchKind2["Directory"] = 1] = "Directory";
      MatchKind2[MatchKind2["File"] = 2] = "File";
      MatchKind2[MatchKind2["All"] = 3] = "All";
    })(MatchKind = exports.MatchKind || (exports.MatchKind = {}));
  }
});

// node_modules/@actions/glob/lib/internal-pattern-helper.js
var require_internal_pattern_helper = __commonJS({
  "node_modules/@actions/glob/lib/internal-pattern-helper.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partialMatch = exports.match = exports.getSearchPaths = void 0;
    var pathHelper = __importStar2(require_internal_path_helper());
    var internal_match_kind_1 = require_internal_match_kind();
    var IS_WINDOWS = process.platform === "win32";
    function getSearchPaths(patterns) {
      patterns = patterns.filter((x) => !x.negate);
      const searchPathMap = {};
      for (const pattern of patterns) {
        const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
        searchPathMap[key] = "candidate";
      }
      const result = [];
      for (const pattern of patterns) {
        const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
        if (searchPathMap[key] === "included") {
          continue;
        }
        let foundAncestor = false;
        let tempKey = key;
        let parent = pathHelper.dirname(tempKey);
        while (parent !== tempKey) {
          if (searchPathMap[parent]) {
            foundAncestor = true;
            break;
          }
          tempKey = parent;
          parent = pathHelper.dirname(tempKey);
        }
        if (!foundAncestor) {
          result.push(pattern.searchPath);
          searchPathMap[key] = "included";
        }
      }
      return result;
    }
    exports.getSearchPaths = getSearchPaths;
    function match(patterns, itemPath) {
      let result = internal_match_kind_1.MatchKind.None;
      for (const pattern of patterns) {
        if (pattern.negate) {
          result &= ~pattern.match(itemPath);
        } else {
          result |= pattern.match(itemPath);
        }
      }
      return result;
    }
    exports.match = match;
    function partialMatch(patterns, itemPath) {
      return patterns.some((x) => !x.negate && x.partialMatch(itemPath));
    }
    exports.partialMatch = partialMatch;
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports, module) {
    "use strict";
    module.exports = function(xs, fn) {
      var res = [];
      for (var i2 = 0; i2 < xs.length; i2++) {
        var x = fn(xs[i2], i2);
        if (isArray2(x)) res.push.apply(res, x);
        else res.push(x);
      }
      return res;
    };
    var isArray2 = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a2, b, str) {
      if (a2 instanceof RegExp) a2 = maybeMatch(a2, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a2, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a2.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a2, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a2);
      var bi = str.indexOf(b, ai + 1);
      var i2 = ai;
      if (ai >= 0 && bi > 0) {
        if (a2 === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
          if (i2 == ai) {
            begs.push(i2);
            ai = str.indexOf(a2, i2 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i2 + 1);
          }
          i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module) {
    "use strict";
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i2, y) {
      return i2 <= y;
    }
    function gte(i2, y) {
      return i2 >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre)) return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,(?!,).*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n2;
      if (isSequence) {
        n2 = m.body.split(/\.\./);
      } else {
        n2 = parseCommaParts(m.body);
        if (n2.length === 1) {
          n2 = expand(n2[0], false).map(embrace);
          if (n2.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n2[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n2[0]);
        var y = numeric(n2[1]);
        var width = Math.max(n2[0].length, n2[1].length);
        var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n2.some(isPadded);
        N = [];
        for (var i2 = x; test(i2, y); i2 += incr) {
          var c3;
          if (isAlphaSequence) {
            c3 = String.fromCharCode(i2);
            if (c3 === "\\")
              c3 = "";
          } else {
            c3 = String(i2);
            if (pad) {
              var need = width - c3.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i2 < 0)
                  c3 = "-" + z + c3.slice(1);
                else
                  c3 = z + c3;
              }
            }
          }
          N.push(c3);
        }
      } else {
        N = concatMap(n2, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module) {
    "use strict";
    module.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path2 = (function() {
      try {
        return __require("path");
      } catch (e) {
      }
    })() || {
      sep: "/"
    };
    minimatch.sep = path2.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c3) {
        set[c3] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i2, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a2, b) {
      b = b || {};
      var t = {};
      Object.keys(a2).forEach(function(k) {
        t[k] = a2[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults2(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults2(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options) options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options) options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path2.sep !== "/") {
        pattern = pattern.split(path2.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug) this.debug = function debug2() {
        console.error.apply(console, arguments);
      };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate) return;
      for (var i2 = 0, l = pattern.length; i2 < l && pattern.charAt(i2) === "!"; i2++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset) this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "") return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i2 = 0, len = pattern.length, c3; i2 < len && (c3 = pattern.charAt(i2)); i2++) {
        this.debug("%s	%s %s %j", pattern, i2, re, c3);
        if (escaping && reSpecials[c3]) {
          re += "\\" + c3;
          escaping = false;
          continue;
        }
        switch (c3) {
          /* istanbul ignore next */
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re, c3);
            if (inClass) {
              this.debug("  in class");
              if (c3 === "!" && i2 === classStart + 1) c3 = "^";
              re += c3;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c3;
            if (options.noext) clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i2 - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          // these are mostly the same in regexp and glob
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c3;
              continue;
            }
            inClass = true;
            classStart = i2;
            reClassStart = re.length;
            re += c3;
            continue;
          case "]":
            if (i2 === classStart + 1 || !inClass) {
              re += "\\" + c3;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i2);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c3;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c3] && !(c3 === "^" && inClass)) {
              re += "\\";
            }
            re += c3;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n2 = negativeLists.length - 1; n2 > -1; n2--) {
        var nl = negativeLists[n2];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i2 = 0; i2 < openParensBefore; i2++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false) return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate) re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined") partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment) return false;
      if (this.empty) return f === "";
      if (f === "/" && partial) return true;
      var options = this.options;
      if (path2.sep !== "/") {
        f = f.split(path2.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i2;
      for (i2 = f.length - 1; i2 >= 0; i2--) {
        filename = f[i2];
        if (filename) break;
      }
      for (i2 = 0; i2 < set.length; i2++) {
        var pattern = set[i2];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) return true;
          return !this.negate;
        }
      }
      if (options.flipNegate) return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false) return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl) return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit) return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/@actions/glob/lib/internal-path.js
var require_internal_path = __commonJS({
  "node_modules/@actions/glob/lib/internal-path.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Path = void 0;
    var path2 = __importStar2(__require("path"));
    var pathHelper = __importStar2(require_internal_path_helper());
    var assert_1 = __importDefault2(__require("assert"));
    var IS_WINDOWS = process.platform === "win32";
    var Path = class {
      /**
       * Constructs a Path
       * @param itemPath Path or array of segments
       */
      constructor(itemPath) {
        this.segments = [];
        if (typeof itemPath === "string") {
          assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
          itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
          if (!pathHelper.hasRoot(itemPath)) {
            this.segments = itemPath.split(path2.sep);
          } else {
            let remaining = itemPath;
            let dir = pathHelper.dirname(remaining);
            while (dir !== remaining) {
              const basename = path2.basename(remaining);
              this.segments.unshift(basename);
              remaining = dir;
              dir = pathHelper.dirname(remaining);
            }
            this.segments.unshift(remaining);
          }
        } else {
          assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
          for (let i2 = 0; i2 < itemPath.length; i2++) {
            let segment = itemPath[i2];
            assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
            segment = pathHelper.normalizeSeparators(itemPath[i2]);
            if (i2 === 0 && pathHelper.hasRoot(segment)) {
              segment = pathHelper.safeTrimTrailingSeparator(segment);
              assert_1.default(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
              this.segments.push(segment);
            } else {
              assert_1.default(!segment.includes(path2.sep), `Parameter 'itemPath' contains unexpected path separators`);
              this.segments.push(segment);
            }
          }
        }
      }
      /**
       * Converts the path to it's string representation
       */
      toString() {
        let result = this.segments[0];
        let skipSlash = result.endsWith(path2.sep) || IS_WINDOWS && /^[A-Z]:$/i.test(result);
        for (let i2 = 1; i2 < this.segments.length; i2++) {
          if (skipSlash) {
            skipSlash = false;
          } else {
            result += path2.sep;
          }
          result += this.segments[i2];
        }
        return result;
      }
    };
    exports.Path = Path;
  }
});

// node_modules/@actions/glob/lib/internal-pattern.js
var require_internal_pattern = __commonJS({
  "node_modules/@actions/glob/lib/internal-pattern.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pattern = void 0;
    var os3 = __importStar2(__require("os"));
    var path2 = __importStar2(__require("path"));
    var pathHelper = __importStar2(require_internal_path_helper());
    var assert_1 = __importDefault2(__require("assert"));
    var minimatch_1 = require_minimatch();
    var internal_match_kind_1 = require_internal_match_kind();
    var internal_path_1 = require_internal_path();
    var IS_WINDOWS = process.platform === "win32";
    var Pattern = class _Pattern {
      constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
        this.negate = false;
        let pattern;
        if (typeof patternOrNegate === "string") {
          pattern = patternOrNegate.trim();
        } else {
          segments = segments || [];
          assert_1.default(segments.length, `Parameter 'segments' must not empty`);
          const root = _Pattern.getLiteral(segments[0]);
          assert_1.default(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
          pattern = new internal_path_1.Path(segments).toString().trim();
          if (patternOrNegate) {
            pattern = `!${pattern}`;
          }
        }
        while (pattern.startsWith("!")) {
          this.negate = !this.negate;
          pattern = pattern.substr(1).trim();
        }
        pattern = _Pattern.fixupPattern(pattern, homedir);
        this.segments = new internal_path_1.Path(pattern).segments;
        this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path2.sep);
        pattern = pathHelper.safeTrimTrailingSeparator(pattern);
        let foundGlob = false;
        const searchSegments = this.segments.map((x) => _Pattern.getLiteral(x)).filter((x) => !foundGlob && !(foundGlob = x === ""));
        this.searchPath = new internal_path_1.Path(searchSegments).toString();
        this.rootRegExp = new RegExp(_Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? "i" : "");
        this.isImplicitPattern = isImplicitPattern;
        const minimatchOptions = {
          dot: true,
          nobrace: true,
          nocase: IS_WINDOWS,
          nocomment: true,
          noext: true,
          nonegate: true
        };
        pattern = IS_WINDOWS ? pattern.replace(/\\/g, "/") : pattern;
        this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
      }
      /**
       * Matches the pattern against the specified path
       */
      match(itemPath) {
        if (this.segments[this.segments.length - 1] === "**") {
          itemPath = pathHelper.normalizeSeparators(itemPath);
          if (!itemPath.endsWith(path2.sep) && this.isImplicitPattern === false) {
            itemPath = `${itemPath}${path2.sep}`;
          }
        } else {
          itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        }
        if (this.minimatch.match(itemPath)) {
          return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
        }
        return internal_match_kind_1.MatchKind.None;
      }
      /**
       * Indicates whether the pattern may match descendants of the specified path
       */
      partialMatch(itemPath) {
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        if (pathHelper.dirname(itemPath) === itemPath) {
          return this.rootRegExp.test(itemPath);
        }
        return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
      }
      /**
       * Escapes glob patterns within a path
       */
      static globEscape(s) {
        return (IS_WINDOWS ? s : s.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
      }
      /**
       * Normalizes slashes and ensures absolute root
       */
      static fixupPattern(pattern, homedir) {
        assert_1.default(pattern, "pattern cannot be empty");
        const literalSegments = new internal_path_1.Path(pattern).segments.map((x) => _Pattern.getLiteral(x));
        assert_1.default(literalSegments.every((x, i2) => (x !== "." || i2 === 0) && x !== ".."), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
        assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
        pattern = pathHelper.normalizeSeparators(pattern);
        if (pattern === "." || pattern.startsWith(`.${path2.sep}`)) {
          pattern = _Pattern.globEscape(process.cwd()) + pattern.substr(1);
        } else if (pattern === "~" || pattern.startsWith(`~${path2.sep}`)) {
          homedir = homedir || os3.homedir();
          assert_1.default(homedir, "Unable to determine HOME directory");
          assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
          pattern = _Pattern.globEscape(homedir) + pattern.substr(1);
        } else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
          let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
          if (pattern.length > 2 && !root.endsWith("\\")) {
            root += "\\";
          }
          pattern = _Pattern.globEscape(root) + pattern.substr(2);
        } else if (IS_WINDOWS && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
          let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", "\\");
          if (!root.endsWith("\\")) {
            root += "\\";
          }
          pattern = _Pattern.globEscape(root) + pattern.substr(1);
        } else {
          pattern = pathHelper.ensureAbsoluteRoot(_Pattern.globEscape(process.cwd()), pattern);
        }
        return pathHelper.normalizeSeparators(pattern);
      }
      /**
       * Attempts to unescape a pattern segment to create a literal path segment.
       * Otherwise returns empty string.
       */
      static getLiteral(segment) {
        let literal = "";
        for (let i2 = 0; i2 < segment.length; i2++) {
          const c3 = segment[i2];
          if (c3 === "\\" && !IS_WINDOWS && i2 + 1 < segment.length) {
            literal += segment[++i2];
            continue;
          } else if (c3 === "*" || c3 === "?") {
            return "";
          } else if (c3 === "[" && i2 + 1 < segment.length) {
            let set = "";
            let closed = -1;
            for (let i22 = i2 + 1; i22 < segment.length; i22++) {
              const c22 = segment[i22];
              if (c22 === "\\" && !IS_WINDOWS && i22 + 1 < segment.length) {
                set += segment[++i22];
                continue;
              } else if (c22 === "]") {
                closed = i22;
                break;
              } else {
                set += c22;
              }
            }
            if (closed >= 0) {
              if (set.length > 1) {
                return "";
              }
              if (set) {
                literal += set;
                i2 = closed;
                continue;
              }
            }
          }
          literal += c3;
        }
        return literal;
      }
      /**
       * Escapes regexp special characters
       * https://javascript.info/regexp-escaping
       */
      static regExpEscape(s) {
        return s.replace(/[[\\^$.|?*+()]/g, "\\$&");
      }
    };
    exports.Pattern = Pattern;
  }
});

// node_modules/@actions/glob/lib/internal-search-state.js
var require_internal_search_state = __commonJS({
  "node_modules/@actions/glob/lib/internal-search-state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchState = void 0;
    var SearchState = class {
      constructor(path2, level) {
        this.path = path2;
        this.level = level;
      }
    };
    exports.SearchState = SearchState;
  }
});

// node_modules/@actions/glob/lib/internal-globber.js
var require_internal_globber = __commonJS({
  "node_modules/@actions/glob/lib/internal-globber.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __asyncValues2 = exports && exports.__asyncValues || function(o2) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o2[Symbol.asyncIterator], i2;
      return m ? m.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o2[n2] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o2[n2](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __await2 = exports && exports.__await || function(v) {
      return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
    };
    var __asyncGenerator2 = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n2) {
        if (g[n2]) i2[n2] = function(v) {
          return new Promise(function(a2, b) {
            q.push([n2, v, a2, b]) > 1 || resume(n2, v);
          });
        };
      }
      function resume(n2, v) {
        try {
          step(g[n2](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultGlobber = void 0;
    var core = __importStar2(require_core());
    var fs2 = __importStar2(__require("fs"));
    var globOptionsHelper = __importStar2(require_internal_glob_options_helper());
    var path2 = __importStar2(__require("path"));
    var patternHelper = __importStar2(require_internal_pattern_helper());
    var internal_match_kind_1 = require_internal_match_kind();
    var internal_pattern_1 = require_internal_pattern();
    var internal_search_state_1 = require_internal_search_state();
    var IS_WINDOWS = process.platform === "win32";
    var DefaultGlobber = class _DefaultGlobber {
      constructor(options) {
        this.patterns = [];
        this.searchPaths = [];
        this.options = globOptionsHelper.getOptions(options);
      }
      getSearchPaths() {
        return this.searchPaths.slice();
      }
      glob() {
        var e_1, _a;
        return __awaiter7(this, void 0, void 0, function* () {
          const result = [];
          try {
            for (var _b = __asyncValues2(this.globGenerator()), _c; _c = yield _b.next(), !_c.done; ) {
              const itemPath = _c.value;
              result.push(itemPath);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return result;
        });
      }
      globGenerator() {
        return __asyncGenerator2(this, arguments, function* globGenerator_1() {
          const options = globOptionsHelper.getOptions(this.options);
          const patterns = [];
          for (const pattern of this.patterns) {
            patterns.push(pattern);
            if (options.implicitDescendants && (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**")) {
              patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat("**")));
            }
          }
          const stack = [];
          for (const searchPath of patternHelper.getSearchPaths(patterns)) {
            core.debug(`Search path '${searchPath}'`);
            try {
              yield __await2(fs2.promises.lstat(searchPath));
            } catch (err) {
              if (err.code === "ENOENT") {
                continue;
              }
              throw err;
            }
            stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
          }
          const traversalChain = [];
          while (stack.length) {
            const item = stack.pop();
            const match = patternHelper.match(patterns, item.path);
            const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
            if (!match && !partialMatch) {
              continue;
            }
            const stats = yield __await2(
              _DefaultGlobber.stat(item, options, traversalChain)
              // Broken symlink, or symlink cycle detected, or no longer exists
            );
            if (!stats) {
              continue;
            }
            if (stats.isDirectory()) {
              if (match & internal_match_kind_1.MatchKind.Directory) {
                yield yield __await2(item.path);
              } else if (!partialMatch) {
                continue;
              }
              const childLevel = item.level + 1;
              const childItems = (yield __await2(fs2.promises.readdir(item.path))).map((x) => new internal_search_state_1.SearchState(path2.join(item.path, x), childLevel));
              stack.push(...childItems.reverse());
            } else if (match & internal_match_kind_1.MatchKind.File) {
              yield yield __await2(item.path);
            }
          }
        });
      }
      /**
       * Constructs a DefaultGlobber
       */
      static create(patterns, options) {
        return __awaiter7(this, void 0, void 0, function* () {
          const result = new _DefaultGlobber(options);
          if (IS_WINDOWS) {
            patterns = patterns.replace(/\r\n/g, "\n");
            patterns = patterns.replace(/\r/g, "\n");
          }
          const lines = patterns.split("\n").map((x) => x.trim());
          for (const line of lines) {
            if (!line || line.startsWith("#")) {
              continue;
            } else {
              result.patterns.push(new internal_pattern_1.Pattern(line));
            }
          }
          result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
          return result;
        });
      }
      static stat(item, options, traversalChain) {
        return __awaiter7(this, void 0, void 0, function* () {
          let stats;
          if (options.followSymbolicLinks) {
            try {
              stats = yield fs2.promises.stat(item.path);
            } catch (err) {
              if (err.code === "ENOENT") {
                if (options.omitBrokenSymbolicLinks) {
                  core.debug(`Broken symlink '${item.path}'`);
                  return void 0;
                }
                throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
              }
              throw err;
            }
          } else {
            stats = yield fs2.promises.lstat(item.path);
          }
          if (stats.isDirectory() && options.followSymbolicLinks) {
            const realPath = yield fs2.promises.realpath(item.path);
            while (traversalChain.length >= item.level) {
              traversalChain.pop();
            }
            if (traversalChain.some((x) => x === realPath)) {
              core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
              return void 0;
            }
            traversalChain.push(realPath);
          }
          return stats;
        });
      }
    };
    exports.DefaultGlobber = DefaultGlobber;
  }
});

// node_modules/@actions/glob/lib/glob.js
var require_glob = __commonJS({
  "node_modules/@actions/glob/lib/glob.js"(exports) {
    "use strict";
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var internal_globber_1 = require_internal_globber();
    function create2(patterns, options) {
      return __awaiter7(this, void 0, void 0, function* () {
        return yield internal_globber_1.DefaultGlobber.create(patterns, options);
      });
    }
    exports.create = create2;
  }
});

// node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/semver/semver.js"(exports, module) {
    "use strict";
    exports = module.exports = SemVer;
    var debug2;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;
    function tok(n2) {
      t[n2] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i3 = 0; i3 < safeRegexReplacements.length; i3++) {
        var token = safeRegexReplacements[i3][0];
        var max = safeRegexReplacements[i3][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i2 = 0; i2 < R; i2++) {
      debug2(i2, src[i2]);
      if (!re[i2]) {
        re[i2] = new RegExp(src[i2]);
        safeRe[i2] = new RegExp(makeSafeRe(src[i2]));
      }
    }
    var i2;
    exports.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug2("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i3 = 0;
      do {
        var a2 = this.prerelease[i3];
        var b = other.prerelease[i3];
        debug2("prerelease compare", i3, a2, b);
        if (a2 === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a2 === void 0) {
          return -1;
        } else if (a2 === b) {
          continue;
        } else {
          return compareIdentifiers(a2, b);
        }
      } while (++i3);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i3 = 0;
      do {
        var a2 = this.build[i3];
        var b = other.build[i3];
        debug2("prerelease compare", i3, a2, b);
        if (a2 === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a2 === void 0) {
          return -1;
        } else if (a2 === b) {
          continue;
        } else {
          return compareIdentifiers(a2, b);
        }
      } while (++i3);
    };
    SemVer.prototype.inc = function(release2, identifier) {
      switch (release2) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i3 = this.prerelease.length;
            while (--i3 >= 0) {
              if (typeof this.prerelease[i3] === "number") {
                this.prerelease[i3]++;
                i3 = -2;
              }
            }
            if (i3 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release2);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version, release2, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release2, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a2, b) {
      var anum = numeric.test(a2);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a2 = +a2;
        b = +b;
      }
      return a2 === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a2, b) {
      return compareIdentifiers(b, a2);
    }
    exports.major = major2;
    function major2(a2, loose) {
      return new SemVer(a2, loose).major;
    }
    exports.minor = minor2;
    function minor2(a2, loose) {
      return new SemVer(a2, loose).minor;
    }
    exports.patch = patch;
    function patch(a2, loose) {
      return new SemVer(a2, loose).patch;
    }
    exports.compare = compare;
    function compare(a2, b, loose) {
      return new SemVer(a2, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a2, b) {
      return compare(a2, b, true);
    }
    exports.compareBuild = compareBuild;
    function compareBuild(a2, b, loose) {
      var versionA = new SemVer(a2, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports.rcompare = rcompare;
    function rcompare(a2, b, loose) {
      return compare(b, a2, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a2, b) {
        return exports.compareBuild(a2, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a2, b) {
        return exports.compareBuild(b, a2, loose);
      });
    }
    exports.gt = gt;
    function gt(a2, b, loose) {
      return compare(a2, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a2, b, loose) {
      return compare(a2, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a2, b, loose) {
      return compare(a2, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a2, b, loose) {
      return compare(a2, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a2, b, loose) {
      return compare(a2, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a2, b, loose) {
      return compare(a2, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a2, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a2 === "object")
            a2 = a2.version;
          if (typeof b === "object")
            b = b.version;
          return a2 === b;
        case "!==":
          if (typeof a2 === "object")
            a2 = a2.version;
          if (typeof b === "object")
            b = b.version;
          return a2 !== b;
        case "":
        case "=":
        case "==":
          return eq(a2, b, loose);
        case "!=":
          return neq(a2, b, loose);
        case ">":
          return gt(a2, b, loose);
        case ">=":
          return gte(a2, b, loose);
        case "<":
          return lt(a2, b, loose);
        case "<=":
          return lte(a2, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c3) {
        return c3.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug2("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c3) {
          return c3.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug2("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug2("caret", comp, options);
      var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug2("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i3 = 0; i3 < this.set.length; i3++) {
        if (testSet(this.set[i3], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i3 = 0; i3 < set.length; i3++) {
        if (!set[i3].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i3 = 0; i3 < set.length; i3++) {
          debug2(set[i3].semver);
          if (set[i3].semver === ANY) {
            continue;
          }
          if (set[i3].semver.prerelease.length > 0) {
            var allowed = set[i3].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i3 = 0; i3 < range.set.length; ++i3) {
        var comparators = range.set[i3];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i3 = 0; i3 < range.set.length; ++i3) {
        var comparators = range.set[i3];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// node_modules/@actions/cache/lib/internal/constants.js
var require_constants6 = __commonJS({
  "node_modules/@actions/cache/lib/internal/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CacheFileSizeLimit = exports.ManifestFilename = exports.TarFilename = exports.SystemTarPathOnWindows = exports.GnuTarPathOnWindows = exports.SocketTimeout = exports.DefaultRetryDelay = exports.DefaultRetryAttempts = exports.ArchiveToolType = exports.CompressionMethod = exports.CacheFilename = void 0;
    var CacheFilename;
    (function(CacheFilename2) {
      CacheFilename2["Gzip"] = "cache.tgz";
      CacheFilename2["Zstd"] = "cache.tzst";
    })(CacheFilename || (exports.CacheFilename = CacheFilename = {}));
    var CompressionMethod;
    (function(CompressionMethod2) {
      CompressionMethod2["Gzip"] = "gzip";
      CompressionMethod2["ZstdWithoutLong"] = "zstd-without-long";
      CompressionMethod2["Zstd"] = "zstd";
    })(CompressionMethod || (exports.CompressionMethod = CompressionMethod = {}));
    var ArchiveToolType;
    (function(ArchiveToolType2) {
      ArchiveToolType2["GNU"] = "gnu";
      ArchiveToolType2["BSD"] = "bsd";
    })(ArchiveToolType || (exports.ArchiveToolType = ArchiveToolType = {}));
    exports.DefaultRetryAttempts = 2;
    exports.DefaultRetryDelay = 5e3;
    exports.SocketTimeout = 5e3;
    exports.GnuTarPathOnWindows = `${process.env["PROGRAMFILES"]}\\Git\\usr\\bin\\tar.exe`;
    exports.SystemTarPathOnWindows = `${process.env["SYSTEMDRIVE"]}\\Windows\\System32\\tar.exe`;
    exports.TarFilename = "cache.tar";
    exports.ManifestFilename = "manifest.txt";
    exports.CacheFileSizeLimit = 10 * Math.pow(1024, 3);
  }
});

// node_modules/@actions/cache/lib/internal/cacheUtils.js
var require_cacheUtils = __commonJS({
  "node_modules/@actions/cache/lib/internal/cacheUtils.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __asyncValues2 = exports && exports.__asyncValues || function(o2) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o2[Symbol.asyncIterator], i2;
      return m ? m.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o2[n2] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o2[n2](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRuntimeToken = exports.getCacheVersion = exports.assertDefined = exports.getGnuTarPathOnWindows = exports.getCacheFileName = exports.getCompressionMethod = exports.unlinkFile = exports.resolvePaths = exports.getArchiveFileSizeInBytes = exports.createTempDirectory = void 0;
    var core = __importStar2(require_core());
    var exec4 = __importStar2(require_exec());
    var glob = __importStar2(require_glob());
    var io = __importStar2(require_io());
    var crypto3 = __importStar2(__require("crypto"));
    var fs2 = __importStar2(__require("fs"));
    var path2 = __importStar2(__require("path"));
    var semver = __importStar2(require_semver());
    var util = __importStar2(__require("util"));
    var constants_1 = require_constants6();
    var versionSalt = "1.0";
    function createTempDirectory() {
      return __awaiter7(this, void 0, void 0, function* () {
        const IS_WINDOWS = process.platform === "win32";
        let tempDirectory = process.env["RUNNER_TEMP"] || "";
        if (!tempDirectory) {
          let baseLocation;
          if (IS_WINDOWS) {
            baseLocation = process.env["USERPROFILE"] || "C:\\";
          } else {
            if (process.platform === "darwin") {
              baseLocation = "/Users";
            } else {
              baseLocation = "/home";
            }
          }
          tempDirectory = path2.join(baseLocation, "actions", "temp");
        }
        const dest = path2.join(tempDirectory, crypto3.randomUUID());
        yield io.mkdirP(dest);
        return dest;
      });
    }
    exports.createTempDirectory = createTempDirectory;
    function getArchiveFileSizeInBytes(filePath) {
      return fs2.statSync(filePath).size;
    }
    exports.getArchiveFileSizeInBytes = getArchiveFileSizeInBytes;
    function resolvePaths(patterns) {
      var _a, e_1, _b, _c;
      var _d;
      return __awaiter7(this, void 0, void 0, function* () {
        const paths = [];
        const workspace = (_d = process.env["GITHUB_WORKSPACE"]) !== null && _d !== void 0 ? _d : process.cwd();
        const globber = yield glob.create(patterns.join("\n"), {
          implicitDescendants: false
        });
        try {
          for (var _e = true, _f = __asyncValues2(globber.globGenerator()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {
            _c = _g.value;
            _e = false;
            const file = _c;
            const relativeFile = path2.relative(workspace, file).replace(new RegExp(`\\${path2.sep}`, "g"), "/");
            core.debug(`Matched: ${relativeFile}`);
            if (relativeFile === "") {
              paths.push(".");
            } else {
              paths.push(`${relativeFile}`);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return paths;
      });
    }
    exports.resolvePaths = resolvePaths;
    function unlinkFile(filePath) {
      return __awaiter7(this, void 0, void 0, function* () {
        return util.promisify(fs2.unlink)(filePath);
      });
    }
    exports.unlinkFile = unlinkFile;
    function getVersion(app, additionalArgs = []) {
      return __awaiter7(this, void 0, void 0, function* () {
        let versionOutput = "";
        additionalArgs.push("--version");
        core.debug(`Checking ${app} ${additionalArgs.join(" ")}`);
        try {
          yield exec4.exec(`${app}`, additionalArgs, {
            ignoreReturnCode: true,
            silent: true,
            listeners: {
              stdout: (data) => versionOutput += data.toString(),
              stderr: (data) => versionOutput += data.toString()
            }
          });
        } catch (err) {
          core.debug(err.message);
        }
        versionOutput = versionOutput.trim();
        core.debug(versionOutput);
        return versionOutput;
      });
    }
    function getCompressionMethod() {
      return __awaiter7(this, void 0, void 0, function* () {
        const versionOutput = yield getVersion("zstd", ["--quiet"]);
        const version = semver.clean(versionOutput);
        core.debug(`zstd version: ${version}`);
        if (versionOutput === "") {
          return constants_1.CompressionMethod.Gzip;
        } else {
          return constants_1.CompressionMethod.ZstdWithoutLong;
        }
      });
    }
    exports.getCompressionMethod = getCompressionMethod;
    function getCacheFileName(compressionMethod) {
      return compressionMethod === constants_1.CompressionMethod.Gzip ? constants_1.CacheFilename.Gzip : constants_1.CacheFilename.Zstd;
    }
    exports.getCacheFileName = getCacheFileName;
    function getGnuTarPathOnWindows() {
      return __awaiter7(this, void 0, void 0, function* () {
        if (fs2.existsSync(constants_1.GnuTarPathOnWindows)) {
          return constants_1.GnuTarPathOnWindows;
        }
        const versionOutput = yield getVersion("tar");
        return versionOutput.toLowerCase().includes("gnu tar") ? io.which("tar") : "";
      });
    }
    exports.getGnuTarPathOnWindows = getGnuTarPathOnWindows;
    function assertDefined(name, value) {
      if (value === void 0) {
        throw Error(`Expected ${name} but value was undefiend`);
      }
      return value;
    }
    exports.assertDefined = assertDefined;
    function getCacheVersion(paths, compressionMethod, enableCrossOsArchive = false) {
      const components = paths.slice();
      if (compressionMethod) {
        components.push(compressionMethod);
      }
      if (process.platform === "win32" && !enableCrossOsArchive) {
        components.push("windows-only");
      }
      components.push(versionSalt);
      return crypto3.createHash("sha256").update(components.join("|")).digest("hex");
    }
    exports.getCacheVersion = getCacheVersion;
    function getRuntimeToken() {
      const token = process.env["ACTIONS_RUNTIME_TOKEN"];
      if (!token) {
        throw new Error("Unable to get the ACTIONS_RUNTIME_TOKEN env variable");
      }
      return token;
    }
    exports.getRuntimeToken = getRuntimeToken;
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values2,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t[p[i2]] = s[p[i2]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o2) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o2, p)) __createBinding(o2, m, p);
}
function __values2(o2) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o2[s], i2 = 0;
  if (m) return m.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m) return o2;
  var i2 = m.call(o2), r, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r = i2.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"])) m.call(i2);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s += arguments[i2].length;
  for (var r = Array(s), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k++)
      r[k] = a2[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n2, f) {
    if (g[n2]) {
      i2[n2] = function(v) {
        return new Promise(function(a2, b) {
          q.push([n2, v, a2, b]) > 1 || resume(n2, v);
        });
      };
      if (f) i2[n2] = f(i2[n2]);
    }
  }
  function resume(n2, v) {
    try {
      step(g[n2](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p;
  return i2 = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f) {
    i2[n2] = o2[n2] ? function(v) {
      return (p = !p) ? { value: __await(o2[n2](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o2[Symbol.asyncIterator], i2;
  return m ? m.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o2[n2](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path2, preserveJsx) {
  if (typeof path2 === "string" && /^\.\.?\//.test(path2)) {
    return path2.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path2;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    "use strict";
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s = arguments[i2];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    });
    __setModuleDefault = Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    };
    ownKeys = function(o2) {
      ownKeys = Object.getOwnPropertyNames || function(o3) {
        var ar = [];
        for (var k in o3) if (Object.prototype.hasOwnProperty.call(o3, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o2);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values: __values2,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/abort-controller/AbortError.js
var require_AbortError = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/abort-controller/AbortError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbortError = void 0;
    var AbortError3 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    exports.AbortError = AbortError3;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/log.js
var require_log = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.log = log;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_os_1 = __require("os");
    var node_util_1 = tslib_1.__importDefault(__require("util"));
    var node_process_1 = tslib_1.__importDefault(__require("process"));
    function log(message, ...args) {
      node_process_1.default.stderr.write(`${node_util_1.default.format(message, ...args)}${node_os_1.EOL}`);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/debug.js
var require_debug = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/debug.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var log_js_1 = require_log();
    var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
    var enabledString;
    var enabledNamespaces = [];
    var skippedNamespaces = [];
    var debuggers = [];
    if (debugEnvVariable) {
      enable(debugEnvVariable);
    }
    var debugObj = Object.assign((namespace) => {
      return createDebugger(namespace);
    }, {
      enable,
      enabled,
      disable,
      log: log_js_1.log
    });
    function enable(namespaces) {
      enabledString = namespaces;
      enabledNamespaces = [];
      skippedNamespaces = [];
      const namespaceList = namespaces.split(",").map((ns) => ns.trim());
      for (const ns of namespaceList) {
        if (ns.startsWith("-")) {
          skippedNamespaces.push(ns.substring(1));
        } else {
          enabledNamespaces.push(ns);
        }
      }
      for (const instance of debuggers) {
        instance.enabled = enabled(instance.namespace);
      }
    }
    function enabled(namespace) {
      if (namespace.endsWith("*")) {
        return true;
      }
      for (const skipped of skippedNamespaces) {
        if (namespaceMatches(namespace, skipped)) {
          return false;
        }
      }
      for (const enabledNamespace of enabledNamespaces) {
        if (namespaceMatches(namespace, enabledNamespace)) {
          return true;
        }
      }
      return false;
    }
    function namespaceMatches(namespace, patternToMatch) {
      if (patternToMatch.indexOf("*") === -1) {
        return namespace === patternToMatch;
      }
      let pattern = patternToMatch;
      if (patternToMatch.indexOf("**") !== -1) {
        const patternParts = [];
        let lastCharacter = "";
        for (const character of patternToMatch) {
          if (character === "*" && lastCharacter === "*") {
            continue;
          } else {
            lastCharacter = character;
            patternParts.push(character);
          }
        }
        pattern = patternParts.join("");
      }
      let namespaceIndex = 0;
      let patternIndex = 0;
      const patternLength = pattern.length;
      const namespaceLength = namespace.length;
      let lastWildcard = -1;
      let lastWildcardNamespace = -1;
      while (namespaceIndex < namespaceLength && patternIndex < patternLength) {
        if (pattern[patternIndex] === "*") {
          lastWildcard = patternIndex;
          patternIndex++;
          if (patternIndex === patternLength) {
            return true;
          }
          while (namespace[namespaceIndex] !== pattern[patternIndex]) {
            namespaceIndex++;
            if (namespaceIndex === namespaceLength) {
              return false;
            }
          }
          lastWildcardNamespace = namespaceIndex;
          namespaceIndex++;
          patternIndex++;
          continue;
        } else if (pattern[patternIndex] === namespace[namespaceIndex]) {
          patternIndex++;
          namespaceIndex++;
        } else if (lastWildcard >= 0) {
          patternIndex = lastWildcard + 1;
          namespaceIndex = lastWildcardNamespace + 1;
          if (namespaceIndex === namespaceLength) {
            return false;
          }
          while (namespace[namespaceIndex] !== pattern[patternIndex]) {
            namespaceIndex++;
            if (namespaceIndex === namespaceLength) {
              return false;
            }
          }
          lastWildcardNamespace = namespaceIndex;
          namespaceIndex++;
          patternIndex++;
          continue;
        } else {
          return false;
        }
      }
      const namespaceDone = namespaceIndex === namespace.length;
      const patternDone = patternIndex === pattern.length;
      const trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === "*";
      return namespaceDone && (patternDone || trailingWildCard);
    }
    function disable() {
      const result = enabledString || "";
      enable("");
      return result;
    }
    function createDebugger(namespace) {
      const newDebugger = Object.assign(debug2, {
        enabled: enabled(namespace),
        destroy,
        log: debugObj.log,
        namespace,
        extend
      });
      function debug2(...args) {
        if (!newDebugger.enabled) {
          return;
        }
        if (args.length > 0) {
          args[0] = `${namespace} ${args[0]}`;
        }
        newDebugger.log(...args);
      }
      debuggers.push(newDebugger);
      return newDebugger;
    }
    function destroy() {
      const index = debuggers.indexOf(this);
      if (index >= 0) {
        debuggers.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace) {
      const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
      newDebugger.log = this.log;
      return newDebugger;
    }
    exports.default = debugObj;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/logger.js
var require_logger = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSpecRuntimeLogger = void 0;
    exports.createLoggerContext = createLoggerContext;
    exports.setLogLevel = setLogLevel;
    exports.getLogLevel = getLogLevel;
    exports.createClientLogger = createClientLogger;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var debug_js_1 = tslib_1.__importDefault(require_debug());
    var TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    var levelMap = {
      verbose: 400,
      info: 300,
      warning: 200,
      error: 100
    };
    function patchLogMethod(parent, child) {
      child.log = (...args) => {
        parent.log(...args);
      };
    }
    function isTypeSpecRuntimeLogLevel(level) {
      return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
    }
    function createLoggerContext(options) {
      const registeredLoggers = /* @__PURE__ */ new Set();
      const logLevelFromEnv = typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName] || void 0;
      let logLevel;
      const clientLogger = (0, debug_js_1.default)(options.namespace);
      clientLogger.log = (...args) => {
        debug_js_1.default.log(...args);
      };
      function contextSetLogLevel(level) {
        if (level && !isTypeSpecRuntimeLogLevel(level)) {
          throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
        }
        logLevel = level;
        const enabledNamespaces = [];
        for (const logger of registeredLoggers) {
          if (shouldEnable(logger)) {
            enabledNamespaces.push(logger.namespace);
          }
        }
        debug_js_1.default.enable(enabledNamespaces.join(","));
      }
      if (logLevelFromEnv) {
        if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
          contextSetLogLevel(logLevelFromEnv);
        } else {
          console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
        }
      }
      function shouldEnable(logger) {
        return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);
      }
      function createLogger(parent, level) {
        const logger = Object.assign(parent.extend(level), {
          level
        });
        patchLogMethod(parent, logger);
        if (shouldEnable(logger)) {
          const enabledNamespaces = debug_js_1.default.disable();
          debug_js_1.default.enable(enabledNamespaces + "," + logger.namespace);
        }
        registeredLoggers.add(logger);
        return logger;
      }
      function contextGetLogLevel() {
        return logLevel;
      }
      function contextCreateClientLogger(namespace) {
        const clientRootLogger = clientLogger.extend(namespace);
        patchLogMethod(clientLogger, clientRootLogger);
        return {
          error: createLogger(clientRootLogger, "error"),
          warning: createLogger(clientRootLogger, "warning"),
          info: createLogger(clientRootLogger, "info"),
          verbose: createLogger(clientRootLogger, "verbose")
        };
      }
      return {
        setLogLevel: contextSetLogLevel,
        getLogLevel: contextGetLogLevel,
        createClientLogger: contextCreateClientLogger,
        logger: clientLogger
      };
    }
    var context = createLoggerContext({
      logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
      namespace: "typeSpecRuntime"
    });
    exports.TypeSpecRuntimeLogger = context.logger;
    function setLogLevel(logLevel) {
      context.setLogLevel(logLevel);
    }
    function getLogLevel() {
      return context.getLogLevel();
    }
    function createClientLogger(namespace) {
      return context.createClientLogger(namespace);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/httpHeaders.js
var require_httpHeaders = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/httpHeaders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHttpHeaders = createHttpHeaders;
    function normalizeName(name) {
      return name.toLowerCase();
    }
    function* headerIterator(map) {
      for (const entry of map.values()) {
        yield [entry.name, entry.value];
      }
    }
    var HttpHeadersImpl = class {
      _headersMap;
      constructor(rawHeaders) {
        this._headersMap = /* @__PURE__ */ new Map();
        if (rawHeaders) {
          for (const headerName of Object.keys(rawHeaders)) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param name - The name of the header to set. This value is case-insensitive.
       * @param value - The value of the header to set.
       */
      set(name, value) {
        this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param name - The name of the header. This value is case-insensitive.
       */
      get(name) {
        return this._headersMap.get(normalizeName(name))?.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       * @param name - The name of the header to set. This value is case-insensitive.
       */
      has(name) {
        return this._headersMap.has(normalizeName(name));
      }
      /**
       * Remove the header with the provided headerName.
       * @param name - The name of the header to remove.
       */
      delete(name) {
        this._headersMap.delete(normalizeName(name));
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const entry of this._headersMap.values()) {
            result[entry.name] = entry.value;
          }
        } else {
          for (const [normalizedName, entry] of this._headersMap) {
            result[normalizedName] = entry.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
      }
      /**
       * Iterate over tuples of header [name, value] pairs.
       */
      [Symbol.iterator]() {
        return headerIterator(this._headersMap);
      }
    };
    function createHttpHeaders(rawHeaders) {
      return new HttpHeadersImpl(rawHeaders);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/schemes.js
var require_schemes = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/schemes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/oauth2Flows.js
var require_oauth2Flows = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/oauth2Flows.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/uuidUtils.js
var require_uuidUtils = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/uuidUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomUUID = randomUUID3;
    function randomUUID3() {
      return crypto.randomUUID();
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipelineRequest.js
var require_pipelineRequest = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/pipelineRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPipelineRequest = createPipelineRequest;
    var httpHeaders_js_1 = require_httpHeaders();
    var uuidUtils_js_1 = require_uuidUtils();
    var PipelineRequestImpl = class {
      url;
      method;
      headers;
      timeout;
      withCredentials;
      body;
      multipartBody;
      formData;
      streamResponseStatusCodes;
      enableBrowserStreams;
      proxySettings;
      disableKeepAlive;
      abortSignal;
      requestId;
      allowInsecureConnection;
      onUploadProgress;
      onDownloadProgress;
      requestOverrides;
      authSchemes;
      constructor(options) {
        this.url = options.url;
        this.body = options.body;
        this.headers = options.headers ?? (0, httpHeaders_js_1.createHttpHeaders)();
        this.method = options.method ?? "GET";
        this.timeout = options.timeout ?? 0;
        this.multipartBody = options.multipartBody;
        this.formData = options.formData;
        this.disableKeepAlive = options.disableKeepAlive ?? false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = options.withCredentials ?? false;
        this.abortSignal = options.abortSignal;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || (0, uuidUtils_js_1.randomUUID)();
        this.allowInsecureConnection = options.allowInsecureConnection ?? false;
        this.enableBrowserStreams = options.enableBrowserStreams ?? false;
        this.requestOverrides = options.requestOverrides;
        this.authSchemes = options.authSchemes;
      }
    };
    function createPipelineRequest(options) {
      return new PipelineRequestImpl(options);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/pipeline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEmptyPipeline = createEmptyPipeline;
    var ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
    var HttpPipeline = class _HttpPipeline {
      _policies = [];
      _orderedPolicies;
      constructor(policies) {
        this._policies = policies?.slice(0) ?? [];
        this._orderedPolicies = void 0;
      }
      addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
          throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
          throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
          throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
          policy,
          options
        });
        this._orderedPolicies = void 0;
      }
      removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
          if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
            removedPolicies.push(policyDescriptor.policy);
            return false;
          } else {
            return true;
          }
        });
        this._orderedPolicies = void 0;
        return removedPolicies;
      }
      sendRequest(httpClient, request) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
          return (req) => {
            return policy.sendRequest(req, next);
          };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request);
      }
      getOrderedPolicies() {
        if (!this._orderedPolicies) {
          this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
      }
      clone() {
        return new _HttpPipeline(this._policies);
      }
      static create() {
        return new _HttpPipeline();
      }
      orderPolicies() {
        const result = [];
        const policyMap = /* @__PURE__ */ new Map();
        function createPhase(name) {
          return {
            name,
            policies: /* @__PURE__ */ new Set(),
            hasRun: false,
            hasAfterPolicies: false
          };
        }
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        function getPhase(phase) {
          if (phase === "Retry") {
            return retryPhase;
          } else if (phase === "Serialize") {
            return serializePhase;
          } else if (phase === "Deserialize") {
            return deserializePhase;
          } else if (phase === "Sign") {
            return signPhase;
          } else {
            return noPhase;
          }
        }
        for (const descriptor of this._policies) {
          const policy = descriptor.policy;
          const options = descriptor.options;
          const policyName = policy.name;
          if (policyMap.has(policyName)) {
            throw new Error("Duplicate policy names not allowed in pipeline");
          }
          const node = {
            policy,
            dependsOn: /* @__PURE__ */ new Set(),
            dependants: /* @__PURE__ */ new Set()
          };
          if (options.afterPhase) {
            node.afterPhase = getPhase(options.afterPhase);
            node.afterPhase.hasAfterPolicies = true;
          }
          policyMap.set(policyName, node);
          const phase = getPhase(options.phase);
          phase.policies.add(node);
        }
        for (const descriptor of this._policies) {
          const { policy, options } = descriptor;
          const policyName = policy.name;
          const node = policyMap.get(policyName);
          if (!node) {
            throw new Error(`Missing node for policy ${policyName}`);
          }
          if (options.afterPolicies) {
            for (const afterPolicyName of options.afterPolicies) {
              const afterNode = policyMap.get(afterPolicyName);
              if (afterNode) {
                node.dependsOn.add(afterNode);
                afterNode.dependants.add(node);
              }
            }
          }
          if (options.beforePolicies) {
            for (const beforePolicyName of options.beforePolicies) {
              const beforeNode = policyMap.get(beforePolicyName);
              if (beforeNode) {
                beforeNode.dependsOn.add(node);
                node.dependants.add(beforeNode);
              }
            }
          }
        }
        function walkPhase(phase) {
          phase.hasRun = true;
          for (const node of phase.policies) {
            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
              continue;
            }
            if (node.dependsOn.size === 0) {
              result.push(node.policy);
              for (const dependant of node.dependants) {
                dependant.dependsOn.delete(node);
              }
              policyMap.delete(node.policy.name);
              phase.policies.delete(node);
            }
          }
        }
        function walkPhases() {
          for (const phase of orderedPhases) {
            walkPhase(phase);
            if (phase.policies.size > 0 && phase !== noPhase) {
              if (!noPhase.hasRun) {
                walkPhase(noPhase);
              }
              return;
            }
            if (phase.hasAfterPolicies) {
              walkPhase(noPhase);
            }
          }
        }
        let iteration = 0;
        while (policyMap.size > 0) {
          iteration++;
          const initialResultLength = result.length;
          walkPhases();
          if (result.length <= initialResultLength && iteration > 1) {
            throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
          }
        }
        return result;
      }
    };
    function createEmptyPipeline() {
      return HttpPipeline.create();
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/object.js
var require_object = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObject = isObject2;
    function isObject2(input) {
      return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/error.js
var require_error = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isError = isError2;
    var object_js_1 = require_object();
    function isError2(e) {
      if ((0, object_js_1.isObject)(e)) {
        const hasName = typeof e.name === "string";
        const hasMessage = typeof e.message === "string";
        return hasName && hasMessage;
      }
      return false;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/inspect.js
var require_inspect = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/inspect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.custom = void 0;
    var node_util_1 = __require("util");
    exports.custom = node_util_1.inspect.custom;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sanitizer.js
var require_sanitizer = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sanitizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sanitizer = void 0;
    var object_js_1 = require_object();
    var RedactedString = "REDACTED";
    var defaultAllowedHeaderNames = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    var defaultAllowedQueryParameters = ["api-version"];
    var Sanitizer = class {
      allowedHeaderNames;
      allowedQueryParameters;
      constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n2) => n2.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      /**
       * Sanitizes an object for logging.
       * @param obj - The object to sanitize
       * @returns - The sanitized object as a string
       */
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return {
              ...value,
              name: value.name,
              message: value.message
            };
          }
          if (key === "headers") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || (0, object_js_1.isObject)(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      /**
       * Sanitizes a URL for logging.
       * @param value - The URL to sanitize
       * @returns - The sanitized URL as a string
       */
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null || value === "") {
          return value;
        }
        const url = new URL(value);
        if (!url.search) {
          return value;
        }
        for (const [key] of url.searchParams) {
          if (!this.allowedQueryParameters.has(key.toLowerCase())) {
            url.searchParams.set(key, RedactedString);
          }
        }
        return url.toString();
      }
      sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
          if (this.allowedHeaderNames.has(key.toLowerCase())) {
            sanitized[key] = obj[key];
          } else {
            sanitized[key] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (this.allowedQueryParameters.has(k.toLowerCase())) {
            sanitized[k] = value[k];
          } else {
            sanitized[k] = RedactedString;
          }
        }
        return sanitized;
      }
    };
    exports.Sanitizer = Sanitizer;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/restError.js
var require_restError = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/restError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RestError = void 0;
    exports.isRestError = isRestError;
    var error_js_1 = require_error();
    var inspect_js_1 = require_inspect();
    var sanitizer_js_1 = require_sanitizer();
    var errorSanitizer = new sanitizer_js_1.Sanitizer();
    var RestError = class _RestError extends Error {
      /**
       * Something went wrong when making the request.
       * This means the actual request failed for some reason,
       * such as a DNS issue or the connection being lost.
       */
      static REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
      /**
       * This means that parsing the response from the server failed.
       * It may have been malformed.
       */
      static PARSE_ERROR = "PARSE_ERROR";
      /**
       * The code of the error itself (use statics on RestError if possible.)
       */
      code;
      /**
       * The HTTP status code of the request (if applicable.)
       */
      statusCode;
      /**
       * The request that was made.
       * This property is non-enumerable.
       */
      request;
      /**
       * The response received (if any.)
       * This property is non-enumerable.
       */
      response;
      /**
       * Bonus property set by the throw site.
       */
      details;
      constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        Object.defineProperty(this, "request", { value: options.request, enumerable: false });
        Object.defineProperty(this, "response", { value: options.response, enumerable: false });
        const agent = this.request?.agent ? {
          maxFreeSockets: this.request.agent.maxFreeSockets,
          maxSockets: this.request.agent.maxSockets
        } : void 0;
        Object.defineProperty(this, inspect_js_1.custom, {
          value: () => {
            return `RestError: ${this.message} 
 ${errorSanitizer.sanitize({
              ...this,
              request: { ...this.request, agent },
              response: this.response
            })}`;
          },
          enumerable: false
        });
        Object.setPrototypeOf(this, _RestError.prototype);
      }
    };
    exports.RestError = RestError;
    function isRestError(e) {
      if (e instanceof RestError) {
        return true;
      }
      return (0, error_js_1.isError)(e) && e.name === "RestError";
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/bytesEncoding.js
var require_bytesEncoding = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/bytesEncoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint8ArrayToString = uint8ArrayToString;
    exports.stringToUint8Array = stringToUint8Array;
    function uint8ArrayToString(bytes, format) {
      return Buffer.from(bytes).toString(format);
    }
    function stringToUint8Array(value, format) {
      return Buffer.from(value, format);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/log.js
var require_log2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = void 0;
    var logger_js_1 = require_logger();
    exports.logger = (0, logger_js_1.createClientLogger)("ts-http-runtime");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/nodeHttpClient.js
var require_nodeHttpClient = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/nodeHttpClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBodyLength = getBodyLength;
    exports.createNodeHttpClient = createNodeHttpClient;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_http_1 = tslib_1.__importDefault(__require("http"));
    var node_https_1 = tslib_1.__importDefault(__require("https"));
    var node_zlib_1 = tslib_1.__importDefault(__require("zlib"));
    var node_stream_1 = __require("stream");
    var AbortError_js_1 = require_AbortError();
    var httpHeaders_js_1 = require_httpHeaders();
    var restError_js_1 = require_restError();
    var log_js_1 = require_log2();
    var sanitizer_js_1 = require_sanitizer();
    var DEFAULT_TLS_SETTINGS = {};
    function isReadableStream2(body) {
      return body && typeof body.pipe === "function";
    }
    function isStreamComplete(stream2) {
      if (stream2.readable === false) {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        const handler = () => {
          resolve();
          stream2.removeListener("close", handler);
          stream2.removeListener("end", handler);
          stream2.removeListener("error", handler);
        };
        stream2.on("close", handler);
        stream2.on("end", handler);
        stream2.on("error", handler);
      });
    }
    function isArrayBuffer2(body) {
      return body && typeof body.byteLength === "number";
    }
    var ReportTransform = class extends node_stream_1.Transform {
      loadedBytes = 0;
      progressCallback;
      // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
      _transform(chunk2, _encoding, callback) {
        this.push(chunk2);
        this.loadedBytes += chunk2.length;
        try {
          this.progressCallback({ loadedBytes: this.loadedBytes });
          callback();
        } catch (e) {
          callback(e);
        }
      }
      constructor(progressCallback) {
        super();
        this.progressCallback = progressCallback;
      }
    };
    var NodeHttpClient = class {
      cachedHttpAgent;
      cachedHttpsAgents = /* @__PURE__ */ new WeakMap();
      /**
       * Makes a request over an underlying transport layer and returns the response.
       * @param request - The request to be made.
       */
      async sendRequest(request) {
        const abortController = new AbortController();
        let abortListener;
        if (request.abortSignal) {
          if (request.abortSignal.aborted) {
            throw new AbortError_js_1.AbortError("The operation was aborted. Request has already been canceled.");
          }
          abortListener = (event) => {
            if (event.type === "abort") {
              abortController.abort();
            }
          };
          request.abortSignal.addEventListener("abort", abortListener);
        }
        let timeoutId;
        if (request.timeout > 0) {
          timeoutId = setTimeout(() => {
            const sanitizer = new sanitizer_js_1.Sanitizer();
            log_js_1.logger.info(`request to '${sanitizer.sanitizeUrl(request.url)}' timed out. canceling...`);
            abortController.abort();
          }, request.timeout);
        }
        const acceptEncoding = request.headers.get("Accept-Encoding");
        const shouldDecompress = acceptEncoding?.includes("gzip") || acceptEncoding?.includes("deflate");
        let body = typeof request.body === "function" ? request.body() : request.body;
        if (body && !request.headers.has("Content-Length")) {
          const bodyLength = getBodyLength(body);
          if (bodyLength !== null) {
            request.headers.set("Content-Length", bodyLength);
          }
        }
        let responseStream;
        try {
          if (body && request.onUploadProgress) {
            const onUploadProgress = request.onUploadProgress;
            const uploadReportStream = new ReportTransform(onUploadProgress);
            uploadReportStream.on("error", (e) => {
              log_js_1.logger.error("Error in upload progress", e);
            });
            if (isReadableStream2(body)) {
              body.pipe(uploadReportStream);
            } else {
              uploadReportStream.end(body);
            }
            body = uploadReportStream;
          }
          const res = await this.makeRequest(request, abortController, body);
          if (timeoutId !== void 0) {
            clearTimeout(timeoutId);
          }
          const headers = getResponseHeaders(res);
          const status = res.statusCode ?? 0;
          const response = {
            status,
            headers,
            request
          };
          if (request.method === "HEAD") {
            res.resume();
            return response;
          }
          responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
          const onDownloadProgress = request.onDownloadProgress;
          if (onDownloadProgress) {
            const downloadReportStream = new ReportTransform(onDownloadProgress);
            downloadReportStream.on("error", (e) => {
              log_js_1.logger.error("Error in download progress", e);
            });
            responseStream.pipe(downloadReportStream);
            responseStream = downloadReportStream;
          }
          if (
            // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
            request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) || request.streamResponseStatusCodes?.has(response.status)
          ) {
            response.readableStreamBody = responseStream;
          } else {
            response.bodyAsText = await streamToText(responseStream);
          }
          return response;
        } finally {
          if (request.abortSignal && abortListener) {
            let uploadStreamDone = Promise.resolve();
            if (isReadableStream2(body)) {
              uploadStreamDone = isStreamComplete(body);
            }
            let downloadStreamDone = Promise.resolve();
            if (isReadableStream2(responseStream)) {
              downloadStreamDone = isStreamComplete(responseStream);
            }
            Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
              if (abortListener) {
                request.abortSignal?.removeEventListener("abort", abortListener);
              }
            }).catch((e) => {
              log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e);
            });
          }
        }
      }
      makeRequest(request, abortController, body) {
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) {
          throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        }
        const agent = request.agent ?? this.getOrCreateAgent(request, isInsecure);
        const options = {
          agent,
          hostname: url.hostname,
          path: `${url.pathname}${url.search}`,
          port: url.port,
          method: request.method,
          headers: request.headers.toJSON({ preserveCase: true }),
          ...request.requestOverrides
        };
        return new Promise((resolve, reject) => {
          const req = isInsecure ? node_http_1.default.request(options, resolve) : node_https_1.default.request(options, resolve);
          req.once("error", (err) => {
            reject(new restError_js_1.RestError(err.message, { code: err.code ?? restError_js_1.RestError.REQUEST_SEND_ERROR, request }));
          });
          abortController.signal.addEventListener("abort", () => {
            const abortError = new AbortError_js_1.AbortError("The operation was aborted. Rejecting from abort signal callback while making request.");
            req.destroy(abortError);
            reject(abortError);
          });
          if (body && isReadableStream2(body)) {
            body.pipe(req);
          } else if (body) {
            if (typeof body === "string" || Buffer.isBuffer(body)) {
              req.end(body);
            } else if (isArrayBuffer2(body)) {
              req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
            } else {
              log_js_1.logger.error("Unrecognized body type", body);
              reject(new restError_js_1.RestError("Unrecognized body type"));
            }
          } else {
            req.end();
          }
        });
      }
      getOrCreateAgent(request, isInsecure) {
        const disableKeepAlive = request.disableKeepAlive;
        if (isInsecure) {
          if (disableKeepAlive) {
            return node_http_1.default.globalAgent;
          }
          if (!this.cachedHttpAgent) {
            this.cachedHttpAgent = new node_http_1.default.Agent({ keepAlive: true });
          }
          return this.cachedHttpAgent;
        } else {
          if (disableKeepAlive && !request.tlsSettings) {
            return node_https_1.default.globalAgent;
          }
          const tlsSettings = request.tlsSettings ?? DEFAULT_TLS_SETTINGS;
          let agent = this.cachedHttpsAgents.get(tlsSettings);
          if (agent && agent.options.keepAlive === !disableKeepAlive) {
            return agent;
          }
          log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent");
          agent = new node_https_1.default.Agent({
            // keepAlive is true if disableKeepAlive is false.
            keepAlive: !disableKeepAlive,
            // Since we are spreading, if no tslSettings were provided, nothing is added to the agent options.
            ...tlsSettings
          });
          this.cachedHttpsAgents.set(tlsSettings, agent);
          return agent;
        }
      }
    };
    function getResponseHeaders(res) {
      const headers = (0, httpHeaders_js_1.createHttpHeaders)();
      for (const header of Object.keys(res.headers)) {
        const value = res.headers[header];
        if (Array.isArray(value)) {
          if (value.length > 0) {
            headers.set(header, value[0]);
          }
        } else if (value) {
          headers.set(header, value);
        }
      }
      return headers;
    }
    function getDecodedResponseStream(stream2, headers) {
      const contentEncoding = headers.get("Content-Encoding");
      if (contentEncoding === "gzip") {
        const unzip = node_zlib_1.default.createGunzip();
        stream2.pipe(unzip);
        return unzip;
      } else if (contentEncoding === "deflate") {
        const inflate = node_zlib_1.default.createInflate();
        stream2.pipe(inflate);
        return inflate;
      }
      return stream2;
    }
    function streamToText(stream2) {
      return new Promise((resolve, reject) => {
        const buffer = [];
        stream2.on("data", (chunk2) => {
          if (Buffer.isBuffer(chunk2)) {
            buffer.push(chunk2);
          } else {
            buffer.push(Buffer.from(chunk2));
          }
        });
        stream2.on("end", () => {
          resolve(Buffer.concat(buffer).toString("utf8"));
        });
        stream2.on("error", (e) => {
          if (e && e?.name === "AbortError") {
            reject(e);
          } else {
            reject(new restError_js_1.RestError(`Error reading response as text: ${e.message}`, {
              code: restError_js_1.RestError.PARSE_ERROR
            }));
          }
        });
      });
    }
    function getBodyLength(body) {
      if (!body) {
        return 0;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (isReadableStream2(body)) {
        return null;
      } else if (isArrayBuffer2(body)) {
        return body.byteLength;
      } else if (typeof body === "string") {
        return Buffer.from(body).length;
      } else {
        return null;
      }
    }
    function createNodeHttpClient() {
      return new NodeHttpClient();
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/defaultHttpClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDefaultHttpClient = createDefaultHttpClient;
    var nodeHttpClient_js_1 = require_nodeHttpClient();
    function createDefaultHttpClient() {
      return (0, nodeHttpClient_js_1.createNodeHttpClient)();
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/logPolicy.js
var require_logPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/logPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logPolicyName = void 0;
    exports.logPolicy = logPolicy;
    var log_js_1 = require_log2();
    var sanitizer_js_1 = require_sanitizer();
    exports.logPolicyName = "logPolicy";
    function logPolicy(options = {}) {
      const logger = options.logger ?? log_js_1.logger.info;
      const sanitizer = new sanitizer_js_1.Sanitizer({
        additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
      });
      return {
        name: exports.logPolicyName,
        async sendRequest(request, next) {
          if (!logger.enabled) {
            return next(request);
          }
          logger(`Request: ${sanitizer.sanitize(request)}`);
          const response = await next(request);
          logger(`Response status code: ${response.status}`);
          logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
          return response;
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/redirectPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.redirectPolicyName = void 0;
    exports.redirectPolicy = redirectPolicy;
    exports.redirectPolicyName = "redirectPolicy";
    var allowedRedirect = ["GET", "HEAD"];
    function redirectPolicy(options = {}) {
      const { maxRetries = 20 } = options;
      return {
        name: exports.redirectPolicyName,
        async sendRequest(request, next) {
          const response = await next(request);
          return handleRedirect(next, response, maxRetries);
        }
      };
    }
    async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
      const { request, status, headers } = response;
      const locationHeader = headers.get("location");
      if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
        const url = new URL(locationHeader, request.url);
        request.url = url.toString();
        if (status === 303) {
          request.method = "GET";
          request.headers.delete("Content-Length");
          delete request.body;
        }
        request.headers.delete("Authorization");
        const res = await next(request);
        return handleRedirect(next, res, maxRetries, currentRetries + 1);
      }
      return response;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgentPlatform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHeaderName = getHeaderName;
    exports.setPlatformSpecificData = setPlatformSpecificData;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_os_1 = tslib_1.__importDefault(__require("os"));
    var node_process_1 = tslib_1.__importDefault(__require("process"));
    function getHeaderName() {
      return "User-Agent";
    }
    async function setPlatformSpecificData(map) {
      if (node_process_1.default && node_process_1.default.versions) {
        const osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`;
        const versions = node_process_1.default.versions;
        if (versions.bun) {
          map.set("Bun", `${versions.bun} (${osInfo})`);
        } else if (versions.deno) {
          map.set("Deno", `${versions.deno} (${osInfo})`);
        } else if (versions.node) {
          map.set("Node", `${versions.node} (${osInfo})`);
        }
      }
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/constants.js
var require_constants7 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = void 0;
    exports.SDK_VERSION = "0.3.2";
    exports.DEFAULT_RETRY_POLICY_COUNT = 3;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgent.js
var require_userAgent = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUserAgentHeaderName = getUserAgentHeaderName;
    exports.getUserAgentValue = getUserAgentValue;
    var userAgentPlatform_js_1 = require_userAgentPlatform();
    var constants_js_1 = require_constants7();
    function getUserAgentString(telemetryInfo) {
      const parts = [];
      for (const [key, value] of telemetryInfo) {
        const token = value ? `${key}/${value}` : key;
        parts.push(token);
      }
      return parts.join(" ");
    }
    function getUserAgentHeaderName() {
      return (0, userAgentPlatform_js_1.getHeaderName)();
    }
    async function getUserAgentValue(prefix) {
      const runtimeInfo = /* @__PURE__ */ new Map();
      runtimeInfo.set("ts-http-runtime", constants_js_1.SDK_VERSION);
      await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
      const defaultAgent = getUserAgentString(runtimeInfo);
      const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
      return userAgentValue;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/userAgentPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.userAgentPolicyName = void 0;
    exports.userAgentPolicy = userAgentPolicy;
    var userAgent_js_1 = require_userAgent();
    var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
    exports.userAgentPolicyName = "userAgentPolicy";
    function userAgentPolicy(options = {}) {
      const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
      return {
        name: exports.userAgentPolicyName,
        async sendRequest(request, next) {
          if (!request.headers.has(UserAgentHeaderName)) {
            request.headers.set(UserAgentHeaderName, await userAgentValue);
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/decompressResponsePolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decompressResponsePolicyName = void 0;
    exports.decompressResponsePolicy = decompressResponsePolicy;
    exports.decompressResponsePolicyName = "decompressResponsePolicy";
    function decompressResponsePolicy() {
      return {
        name: exports.decompressResponsePolicyName,
        async sendRequest(request, next) {
          if (request.method !== "HEAD") {
            request.headers.set("Accept-Encoding", "gzip,deflate");
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/random.js
var require_random = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
    function getRandomIntegerInclusive(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      const offset = Math.floor(Math.random() * (max - min + 1));
      return offset + min;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/delay.js
var require_delay = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calculateRetryDelay = calculateRetryDelay2;
    var random_js_1 = require_random();
    function calculateRetryDelay2(retryAttempt, config) {
      const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
      const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
      const retryAfterInMs = clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
      return { retryAfterInMs };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/helpers.js
var require_helpers = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = delay3;
    exports.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
    var AbortError_js_1 = require_AbortError();
    var StandardAbortMessage = "The operation was aborted.";
    function delay3(delayInMs, value, options) {
      return new Promise((resolve, reject) => {
        let timer2 = void 0;
        let onAborted = void 0;
        const rejectOnAbort = () => {
          return reject(new AbortError_js_1.AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage));
        };
        const removeListeners = () => {
          if (options?.abortSignal && onAborted) {
            options.abortSignal.removeEventListener("abort", onAborted);
          }
        };
        onAborted = () => {
          if (timer2) {
            clearTimeout(timer2);
          }
          removeListeners();
          return rejectOnAbort();
        };
        if (options?.abortSignal && options.abortSignal.aborted) {
          return rejectOnAbort();
        }
        timer2 = setTimeout(() => {
          removeListeners();
          resolve(value);
        }, delayInMs);
        if (options?.abortSignal) {
          options.abortSignal.addEventListener("abort", onAborted);
        }
      });
    }
    function parseHeaderValueAsNumber(response, headerName) {
      const value = response.headers.get(headerName);
      if (!value)
        return;
      const valueAsNum = Number(value);
      if (Number.isNaN(valueAsNum))
        return;
      return valueAsNum;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/throttlingRetryStrategy.js
var require_throttlingRetryStrategy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/throttlingRetryStrategy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isThrottlingRetryResponse = isThrottlingRetryResponse;
    exports.throttlingRetryStrategy = throttlingRetryStrategy;
    var helpers_js_1 = require_helpers();
    var RetryAfterHeader = "Retry-After";
    var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
    function getRetryAfterInMs(response) {
      if (!(response && [429, 503].includes(response.status)))
        return void 0;
      try {
        for (const header of AllRetryAfterHeaders) {
          const retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response, header);
          if (retryAfterValue === 0 || retryAfterValue) {
            const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
            return retryAfterValue * multiplyingFactor;
          }
        }
        const retryAfterHeader = response.headers.get(RetryAfterHeader);
        if (!retryAfterHeader)
          return;
        const date = Date.parse(retryAfterHeader);
        const diff = date - Date.now();
        return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
      } catch {
        return void 0;
      }
    }
    function isThrottlingRetryResponse(response) {
      return Number.isFinite(getRetryAfterInMs(response));
    }
    function throttlingRetryStrategy() {
      return {
        name: "throttlingRetryStrategy",
        retry({ response }) {
          const retryAfterInMs = getRetryAfterInMs(response);
          if (!Number.isFinite(retryAfterInMs)) {
            return { skipStrategy: true };
          }
          return {
            retryAfterInMs
          };
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/exponentialRetryStrategy.js
var require_exponentialRetryStrategy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/exponentialRetryStrategy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exponentialRetryStrategy = exponentialRetryStrategy;
    exports.isExponentialRetryResponse = isExponentialRetryResponse;
    exports.isSystemError = isSystemError;
    var delay_js_1 = require_delay();
    var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
    var DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
    var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
    function exponentialRetryStrategy(options = {}) {
      const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;
      const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
      return {
        name: "exponentialRetryStrategy",
        retry({ retryCount, response, responseError }) {
          const matchedSystemError = isSystemError(responseError);
          const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
          const isExponential = isExponentialRetryResponse(response);
          const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
          const unknownResponse = response && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response) || !isExponential);
          if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
            return { skipStrategy: true };
          }
          if (responseError && !matchedSystemError && !isExponential) {
            return { errorToThrow: responseError };
          }
          return (0, delay_js_1.calculateRetryDelay)(retryCount, {
            retryDelayInMs: retryInterval,
            maxRetryDelayInMs: maxRetryInterval
          });
        }
      };
    }
    function isExponentialRetryResponse(response) {
      return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
    }
    function isSystemError(err) {
      if (!err) {
        return false;
      }
      return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/retryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retryPolicy = retryPolicy;
    var helpers_js_1 = require_helpers();
    var AbortError_js_1 = require_AbortError();
    var logger_js_1 = require_logger();
    var constants_js_1 = require_constants7();
    var retryPolicyLogger = (0, logger_js_1.createClientLogger)("ts-http-runtime retryPolicy");
    var retryPolicyName = "retryPolicy";
    function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
      const logger = options.logger || retryPolicyLogger;
      return {
        name: retryPolicyName,
        async sendRequest(request, next) {
          let response;
          let responseError;
          let retryCount = -1;
          retryRequest: while (true) {
            retryCount += 1;
            response = void 0;
            responseError = void 0;
            try {
              logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
              response = await next(request);
              logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
            } catch (e) {
              logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
              responseError = e;
              if (!e || responseError.name !== "RestError") {
                throw e;
              }
              response = responseError.response;
            }
            if (request.abortSignal?.aborted) {
              logger.error(`Retry ${retryCount}: Request aborted.`);
              const abortError = new AbortError_js_1.AbortError();
              throw abortError;
            }
            if (retryCount >= (options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT)) {
              logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
              if (responseError) {
                throw responseError;
              } else if (response) {
                return response;
              } else {
                throw new Error("Maximum retries reached with no response or error to throw");
              }
            }
            logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
            strategiesLoop: for (const strategy of strategies) {
              const strategyLogger = strategy.logger || logger;
              strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
              const modifiers = strategy.retry({
                retryCount,
                response,
                responseError
              });
              if (modifiers.skipStrategy) {
                strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                continue strategiesLoop;
              }
              const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
              if (errorToThrow) {
                strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                throw errorToThrow;
              }
              if (retryAfterInMs || retryAfterInMs === 0) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                await (0, helpers_js_1.delay)(retryAfterInMs, void 0, { abortSignal: request.abortSignal });
                continue retryRequest;
              }
              if (redirectTo) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                request.url = redirectTo;
                continue retryRequest;
              }
            }
            if (responseError) {
              logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
              throw responseError;
            }
            if (response) {
              logger.info(`None of the retry strategies could work with the received response. Returning it.`);
              return response;
            }
          }
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/defaultRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultRetryPolicyName = void 0;
    exports.defaultRetryPolicy = defaultRetryPolicy;
    var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
    var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
    var retryPolicy_js_1 = require_retryPolicy();
    var constants_js_1 = require_constants7();
    exports.defaultRetryPolicyName = "defaultRetryPolicy";
    function defaultRetryPolicy(options = {}) {
      return {
        name: exports.defaultRetryPolicyName,
        sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options)], {
          maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/checkEnvironment.js
var require_checkEnvironment = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/checkEnvironment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isDeno = exports.isWebWorker = exports.isBrowser = void 0;
    exports.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    exports.isWebWorker = typeof self === "object" && typeof self?.importScripts === "function" && (self.constructor?.name === "DedicatedWorkerGlobalScope" || self.constructor?.name === "ServiceWorkerGlobalScope" || self.constructor?.name === "SharedWorkerGlobalScope");
    exports.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    exports.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    exports.isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean(globalThis.process.versions?.node);
    exports.isNodeRuntime = exports.isNodeLike && !exports.isBun && !exports.isDeno;
    exports.isReactNative = typeof navigator !== "undefined" && navigator?.product === "ReactNative";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/formDataPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formDataPolicyName = void 0;
    exports.formDataPolicy = formDataPolicy;
    var bytesEncoding_js_1 = require_bytesEncoding();
    var checkEnvironment_js_1 = require_checkEnvironment();
    var httpHeaders_js_1 = require_httpHeaders();
    exports.formDataPolicyName = "formDataPolicy";
    function formDataToFormDataMap(formData) {
      const formDataMap = {};
      for (const [key, value] of formData.entries()) {
        formDataMap[key] ??= [];
        formDataMap[key].push(value);
      }
      return formDataMap;
    }
    function formDataPolicy() {
      return {
        name: exports.formDataPolicyName,
        async sendRequest(request, next) {
          if (checkEnvironment_js_1.isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
            request.formData = formDataToFormDataMap(request.body);
            request.body = void 0;
          }
          if (request.formData) {
            const contentType = request.headers.get("Content-Type");
            if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
              request.body = wwwFormUrlEncode(request.formData);
            } else {
              await prepareFormData(request.formData, request);
            }
            request.formData = void 0;
          }
          return next(request);
        }
      };
    }
    function wwwFormUrlEncode(formData) {
      const urlSearchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(formData)) {
        if (Array.isArray(value)) {
          for (const subValue of value) {
            urlSearchParams.append(key, subValue.toString());
          }
        } else {
          urlSearchParams.append(key, value.toString());
        }
      }
      return urlSearchParams.toString();
    }
    async function prepareFormData(formData, request) {
      const contentType = request.headers.get("Content-Type");
      if (contentType && !contentType.startsWith("multipart/form-data")) {
        return;
      }
      request.headers.set("Content-Type", contentType ?? "multipart/form-data");
      const parts = [];
      for (const [fieldName, values] of Object.entries(formData)) {
        for (const value of Array.isArray(values) ? values : [values]) {
          if (typeof value === "string") {
            parts.push({
              headers: (0, httpHeaders_js_1.createHttpHeaders)({
                "Content-Disposition": `form-data; name="${fieldName}"`
              }),
              body: (0, bytesEncoding_js_1.stringToUint8Array)(value, "utf-8")
            });
          } else if (value === void 0 || value === null || typeof value !== "object") {
            throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
          } else {
            const fileName = value.name || "blob";
            const headers = (0, httpHeaders_js_1.createHttpHeaders)();
            headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
            headers.set("Content-Type", value.type || "application/octet-stream");
            parts.push({
              headers,
              body: value
            });
          }
        }
      }
      request.multipartBody = { parts };
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h2 = m * 60;
    var d = h2 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    "use strict";
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c3);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os3 = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os3.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream2) {
      const level = supportsColor(stream2, stream2 && stream2.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module) {
    "use strict";
    var tty = __require("tty");
    var util = __require("util");
    exports.init = init2;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c3 = this.color;
        const colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug2.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/agent-base/dist/helpers.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.req = exports.json = exports.toBuffer = void 0;
    var http3 = __importStar2(__require("http"));
    var https2 = __importStar2(__require("https"));
    async function toBuffer(stream2) {
      let length = 0;
      const chunks = [];
      for await (const chunk2 of stream2) {
        length += chunk2.length;
        chunks.push(chunk2);
      }
      return Buffer.concat(chunks, length);
    }
    exports.toBuffer = toBuffer;
    async function json(stream2) {
      const buf = await toBuffer(stream2);
      const str = buf.toString("utf8");
      try {
        return JSON.parse(str);
      } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
      }
    }
    exports.json = json;
    function req(url, opts = {}) {
      const href = typeof url === "string" ? url : url.href;
      const req2 = (href.startsWith("https:") ? https2 : http3).request(url, opts);
      const promise = new Promise((resolve, reject) => {
        req2.once("response", resolve).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    exports.req = req;
  }
});

// node_modules/agent-base/dist/index.js
var require_dist = __commonJS({
  "node_modules/agent-base/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Agent = void 0;
    var net2 = __importStar2(__require("net"));
    var http3 = __importStar2(__require("http"));
    var https_1 = __require("https");
    __exportStar2(require_helpers2(), exports);
    var INTERNAL = /* @__PURE__ */ Symbol("AgentBaseInternalState");
    var Agent = class extends http3.Agent {
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options) {
        if (options) {
          if (typeof options.secureEndpoint === "boolean") {
            return options.secureEndpoint;
          }
          if (typeof options.protocol === "string") {
            return options.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        const fakeSocket = new net2.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
          return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options) {
        const secureEndpoint = this.isSecureEndpoint(options);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options);
        }
        return super.getName(options);
      }
      createSocket(req, options, cb) {
        const connectOpts = {
          ...options,
          secureEndpoint: this.isSecureEndpoint(options)
        };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name, fakeSocket);
          if (socket instanceof http3.Agent) {
            try {
              return socket.addRequest(req, connectOpts);
            } catch (err) {
              return cb(err);
            }
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options, cb);
        }, (err) => {
          this.decrementSockets(name, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v;
        }
      }
      get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v;
        }
      }
    };
    exports.Agent = Agent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseProxyResponse = void 0;
    var debug_1 = __importDefault2(require_src());
    var debug2 = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug2("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug2("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug2("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug2("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports.parseProxyResponse = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpsProxyAgent = void 0;
    var net2 = __importStar2(__require("net"));
    var tls = __importStar2(__require("tls"));
    var assert_1 = __importDefault2(__require("assert"));
    var debug_1 = __importDefault2(require_src());
    var agent_base_1 = require_dist();
    var url_1 = __require("url");
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug2 = (0, debug_1.default)("https-proxy-agent");
    var setServernameFromNonIpHost = (options) => {
      if (options.servername === void 0 && options.host && !net2.isIP(options.host)) {
        return {
          ...options,
          servername: options.host
        };
      }
      return options;
    };
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug2("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug2("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
        } else {
          debug2("Creating `net.Socket`: %o", this.connectOpts);
          socket = net2.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net2.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r
`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect);
        this.emit("proxyConnect", connect, req);
        if (connect.statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug2("Upgrading socket connection to TLS");
            return tls.connect({
              ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
              socket
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net2.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug2("Replaying proxy buffer for failed request");
          (0, assert_1.default)(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent.protocols = ["http", "https"];
    exports.HttpsProxyAgent = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/http-proxy-agent/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpProxyAgent = void 0;
    var net2 = __importStar2(__require("net"));
    var tls = __importStar2(__require("tls"));
    var debug_1 = __importDefault2(require_src());
    var events_1 = __require("events");
    var agent_base_1 = require_dist();
    var url_1 = __require("url");
    var debug2 = (0, debug_1.default)("http-proxy-agent");
    var HttpProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug2("Creating new HttpProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      addRequest(req, opts) {
        req._header = null;
        this.setRequestProps(req, opts);
        super.addRequest(req, opts);
      }
      setRequestProps(req, opts) {
        const { proxy } = this;
        const protocol = opts.secureEndpoint ? "https:" : "http:";
        const hostname2 = req.getHeader("host") || "localhost";
        const base = `${protocol}//${hostname2}`;
        const url = new url_1.URL(req.path, base);
        if (opts.port !== 80) {
          url.port = String(opts.port);
        }
        req.path = String(url);
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          const value = headers[name];
          if (value) {
            req.setHeader(name, value);
          }
        }
      }
      async connect(req, opts) {
        req._header = null;
        if (!req.path.includes("://")) {
          this.setRequestProps(req, opts);
        }
        let first;
        let endOfHeaders;
        debug2("Regenerating stored HTTP header string for request");
        req._implicitHeader();
        if (req.outputData && req.outputData.length > 0) {
          debug2("Patching connection write() output buffer with updated header");
          first = req.outputData[0].data;
          endOfHeaders = first.indexOf("\r\n\r\n") + 4;
          req.outputData[0].data = req._header + first.substring(endOfHeaders);
          debug2("Output buffer: %o", req.outputData[0].data);
        }
        let socket;
        if (this.proxy.protocol === "https:") {
          debug2("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(this.connectOpts);
        } else {
          debug2("Creating `net.Socket`: %o", this.connectOpts);
          socket = net2.connect(this.connectOpts);
        }
        await (0, events_1.once)(socket, "connect");
        return socket;
      }
    };
    HttpProxyAgent.protocols = ["http", "https"];
    exports.HttpProxyAgent = HttpProxyAgent;
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/proxyPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalNoProxyList = exports.proxyPolicyName = void 0;
    exports.loadNoProxy = loadNoProxy;
    exports.getDefaultProxySettings = getDefaultProxySettings;
    exports.proxyPolicy = proxyPolicy;
    var https_proxy_agent_1 = require_dist2();
    var http_proxy_agent_1 = require_dist3();
    var log_js_1 = require_log2();
    var HTTPS_PROXY = "HTTPS_PROXY";
    var HTTP_PROXY = "HTTP_PROXY";
    var ALL_PROXY = "ALL_PROXY";
    var NO_PROXY = "NO_PROXY";
    exports.proxyPolicyName = "proxyPolicy";
    exports.globalNoProxyList = [];
    var noProxyListLoaded = false;
    var globalBypassedMap = /* @__PURE__ */ new Map();
    function getEnvironmentValue(name) {
      if (process.env[name]) {
        return process.env[name];
      } else if (process.env[name.toLowerCase()]) {
        return process.env[name.toLowerCase()];
      }
      return void 0;
    }
    function loadEnvironmentProxyValue() {
      if (!process) {
        return void 0;
      }
      const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
      const allProxy = getEnvironmentValue(ALL_PROXY);
      const httpProxy = getEnvironmentValue(HTTP_PROXY);
      return httpsProxy || allProxy || httpProxy;
    }
    function isBypassed(uri, noProxyList, bypassedMap) {
      if (noProxyList.length === 0) {
        return false;
      }
      const host = new URL(uri).hostname;
      if (bypassedMap?.has(host)) {
        return bypassedMap.get(host);
      }
      let isBypassedFlag = false;
      for (const pattern of noProxyList) {
        if (pattern[0] === ".") {
          if (host.endsWith(pattern)) {
            isBypassedFlag = true;
          } else {
            if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
              isBypassedFlag = true;
            }
          }
        } else {
          if (host === pattern) {
            isBypassedFlag = true;
          }
        }
      }
      bypassedMap?.set(host, isBypassedFlag);
      return isBypassedFlag;
    }
    function loadNoProxy() {
      const noProxy = getEnvironmentValue(NO_PROXY);
      noProxyListLoaded = true;
      if (noProxy) {
        return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
      }
      return [];
    }
    function getDefaultProxySettings(proxyUrl) {
      if (!proxyUrl) {
        proxyUrl = loadEnvironmentProxyValue();
        if (!proxyUrl) {
          return void 0;
        }
      }
      const parsedUrl = new URL(proxyUrl);
      const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
      return {
        host: schema + parsedUrl.hostname,
        port: Number.parseInt(parsedUrl.port || "80"),
        username: parsedUrl.username,
        password: parsedUrl.password
      };
    }
    function getDefaultProxySettingsInternal() {
      const envProxy = loadEnvironmentProxyValue();
      return envProxy ? new URL(envProxy) : void 0;
    }
    function getUrlFromProxySettings(settings) {
      let parsedProxyUrl;
      try {
        parsedProxyUrl = new URL(settings.host);
      } catch {
        throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
      }
      parsedProxyUrl.port = String(settings.port);
      if (settings.username) {
        parsedProxyUrl.username = settings.username;
      }
      if (settings.password) {
        parsedProxyUrl.password = settings.password;
      }
      return parsedProxyUrl;
    }
    function setProxyAgentOnRequest(request, cachedAgents, proxyUrl) {
      if (request.agent) {
        return;
      }
      const url = new URL(request.url);
      const isInsecure = url.protocol !== "https:";
      if (request.tlsSettings) {
        log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
      }
      const headers = request.headers.toJSON();
      if (isInsecure) {
        if (!cachedAgents.httpProxyAgent) {
          cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers });
        }
        request.agent = cachedAgents.httpProxyAgent;
      } else {
        if (!cachedAgents.httpsProxyAgent) {
          cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers });
        }
        request.agent = cachedAgents.httpsProxyAgent;
      }
    }
    function proxyPolicy(proxySettings, options) {
      if (!noProxyListLoaded) {
        exports.globalNoProxyList.push(...loadNoProxy());
      }
      const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
      const cachedAgents = {};
      return {
        name: exports.proxyPolicyName,
        async sendRequest(request, next) {
          if (!request.proxySettings && defaultProxy && !isBypassed(request.url, options?.customNoProxyList ?? exports.globalNoProxyList, options?.customNoProxyList ? void 0 : globalBypassedMap)) {
            setProxyAgentOnRequest(request, cachedAgents, defaultProxy);
          } else if (request.proxySettings) {
            setProxyAgentOnRequest(request, cachedAgents, getUrlFromProxySettings(request.proxySettings));
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/agentPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.agentPolicyName = void 0;
    exports.agentPolicy = agentPolicy;
    exports.agentPolicyName = "agentPolicy";
    function agentPolicy(agent) {
      return {
        name: exports.agentPolicyName,
        sendRequest: async (req, next) => {
          if (!req.agent) {
            req.agent = agent;
          }
          return next(req);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/tlsPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tlsPolicyName = void 0;
    exports.tlsPolicy = tlsPolicy;
    exports.tlsPolicyName = "tlsPolicy";
    function tlsPolicy(tlsSettings) {
      return {
        name: exports.tlsPolicyName,
        sendRequest: async (req, next) => {
          if (!req.tlsSettings) {
            req.tlsSettings = tlsSettings;
          }
          return next(req);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/typeGuards.js
var require_typeGuards = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/typeGuards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNodeReadableStream = isNodeReadableStream;
    exports.isWebReadableStream = isWebReadableStream;
    exports.isBinaryBody = isBinaryBody;
    exports.isReadableStream = isReadableStream2;
    exports.isBlob = isBlob2;
    function isNodeReadableStream(x) {
      return Boolean(x && typeof x["pipe"] === "function");
    }
    function isWebReadableStream(x) {
      return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
    }
    function isBinaryBody(body) {
      return body !== void 0 && (body instanceof Uint8Array || isReadableStream2(body) || typeof body === "function" || body instanceof Blob);
    }
    function isReadableStream2(x) {
      return isNodeReadableStream(x) || isWebReadableStream(x);
    }
    function isBlob2(x) {
      return typeof x.stream === "function";
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/concat.js
var require_concat = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = concat;
    var stream_1 = __require("stream");
    var typeGuards_js_1 = require_typeGuards();
    async function* streamAsyncIterator() {
      const reader = this.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            return;
          }
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
    function makeAsyncIterable(webStream) {
      if (!webStream[Symbol.asyncIterator]) {
        webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
      }
      if (!webStream.values) {
        webStream.values = streamAsyncIterator.bind(webStream);
      }
    }
    function ensureNodeStream(stream2) {
      if (stream2 instanceof ReadableStream) {
        makeAsyncIterable(stream2);
        return stream_1.Readable.fromWeb(stream2);
      } else {
        return stream2;
      }
    }
    function toStream(source) {
      if (source instanceof Uint8Array) {
        return stream_1.Readable.from(Buffer.from(source));
      } else if ((0, typeGuards_js_1.isBlob)(source)) {
        return ensureNodeStream(source.stream());
      } else {
        return ensureNodeStream(source);
      }
    }
    async function concat(sources) {
      return function() {
        const streams = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
        return stream_1.Readable.from((async function* () {
          for (const stream2 of streams) {
            for await (const chunk2 of stream2) {
              yield chunk2;
            }
          }
        })());
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/multipartPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multipartPolicyName = void 0;
    exports.multipartPolicy = multipartPolicy;
    var bytesEncoding_js_1 = require_bytesEncoding();
    var typeGuards_js_1 = require_typeGuards();
    var uuidUtils_js_1 = require_uuidUtils();
    var concat_js_1 = require_concat();
    function generateBoundary() {
      return `----AzSDKFormBoundary${(0, uuidUtils_js_1.randomUUID)()}`;
    }
    function encodeHeaders(headers) {
      let result = "";
      for (const [key, value] of headers) {
        result += `${key}: ${value}\r
`;
      }
      return result;
    }
    function getLength(source) {
      if (source instanceof Uint8Array) {
        return source.byteLength;
      } else if ((0, typeGuards_js_1.isBlob)(source)) {
        return source.size === -1 ? void 0 : source.size;
      } else {
        return void 0;
      }
    }
    function getTotalLength(sources) {
      let total = 0;
      for (const source of sources) {
        const partLength = getLength(source);
        if (partLength === void 0) {
          return void 0;
        } else {
          total += partLength;
        }
      }
      return total;
    }
    async function buildRequestBody(request, parts, boundary) {
      const sources = [
        (0, bytesEncoding_js_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
        ...parts.flatMap((part) => [
          (0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
          (0, bytesEncoding_js_1.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"),
          (0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
          part.body,
          (0, bytesEncoding_js_1.stringToUint8Array)(`\r
--${boundary}`, "utf-8")
        ]),
        (0, bytesEncoding_js_1.stringToUint8Array)("--\r\n\r\n", "utf-8")
      ];
      const contentLength = getTotalLength(sources);
      if (contentLength) {
        request.headers.set("Content-Length", contentLength);
      }
      request.body = await (0, concat_js_1.concat)(sources);
    }
    exports.multipartPolicyName = "multipartPolicy";
    var maxBoundaryLength = 70;
    var validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
    function assertValidBoundary(boundary) {
      if (boundary.length > maxBoundaryLength) {
        throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
      }
      if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
        throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
      }
    }
    function multipartPolicy() {
      return {
        name: exports.multipartPolicyName,
        async sendRequest(request, next) {
          if (!request.multipartBody) {
            return next(request);
          }
          if (request.body) {
            throw new Error("multipartBody and regular body cannot be set at the same time");
          }
          let boundary = request.multipartBody.boundary;
          const contentTypeHeader = request.headers.get("Content-Type") ?? "multipart/mixed";
          const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
          if (!parsedHeader) {
            throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
          }
          const [, contentType, parsedBoundary] = parsedHeader;
          if (parsedBoundary && boundary && parsedBoundary !== boundary) {
            throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
          }
          boundary ??= parsedBoundary;
          if (boundary) {
            assertValidBoundary(boundary);
          } else {
            boundary = generateBoundary();
          }
          request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
          await buildRequestBody(request, request.multipartBody.parts, boundary);
          request.multipartBody = void 0;
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/createPipelineFromOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPipelineFromOptions = createPipelineFromOptions;
    var logPolicy_js_1 = require_logPolicy();
    var pipeline_js_1 = require_pipeline();
    var redirectPolicy_js_1 = require_redirectPolicy();
    var userAgentPolicy_js_1 = require_userAgentPolicy();
    var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
    var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
    var formDataPolicy_js_1 = require_formDataPolicy();
    var checkEnvironment_js_1 = require_checkEnvironment();
    var proxyPolicy_js_1 = require_proxyPolicy();
    var agentPolicy_js_1 = require_agentPolicy();
    var tlsPolicy_js_1 = require_tlsPolicy();
    var multipartPolicy_js_1 = require_multipartPolicy();
    function createPipelineFromOptions(options) {
      const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
      if (checkEnvironment_js_1.isNodeLike) {
        if (options.agent) {
          pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
        }
        if (options.tlsOptions) {
          pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
        }
        pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
        pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
      }
      pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
      pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
      pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
      pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
      if (checkEnvironment_js_1.isNodeLike) {
        pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
      }
      pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
      return pipeline;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/apiVersionPolicy.js
var require_apiVersionPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/apiVersionPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apiVersionPolicyName = void 0;
    exports.apiVersionPolicy = apiVersionPolicy;
    exports.apiVersionPolicyName = "ApiVersionPolicy";
    function apiVersionPolicy(options) {
      return {
        name: exports.apiVersionPolicyName,
        sendRequest: (req, next) => {
          const url = new URL(req.url);
          if (!url.searchParams.get("api-version") && options.apiVersion) {
            req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
          }
          return next(req);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/credentials.js
var require_credentials = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/credentials.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isOAuth2TokenCredential = isOAuth2TokenCredential;
    exports.isBearerTokenCredential = isBearerTokenCredential;
    exports.isBasicCredential = isBasicCredential;
    exports.isApiKeyCredential = isApiKeyCredential;
    function isOAuth2TokenCredential(credential) {
      return "getOAuth2Token" in credential;
    }
    function isBearerTokenCredential(credential) {
      return "getBearerToken" in credential;
    }
    function isBasicCredential(credential) {
      return "username" in credential && "password" in credential;
    }
    function isApiKeyCredential(credential) {
      return "key" in credential;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/checkInsecureConnection.js
var require_checkInsecureConnection = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/checkInsecureConnection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureSecureConnection = ensureSecureConnection;
    var log_js_1 = require_log2();
    var insecureConnectionWarningEmmitted = false;
    function allowInsecureConnection(request, options) {
      if (options.allowInsecureConnection && request.allowInsecureConnection) {
        const url = new URL(request.url);
        if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
          return true;
        }
      }
      return false;
    }
    function emitInsecureConnectionWarning() {
      const warning2 = "Sending token over insecure transport. Assume any token issued is compromised.";
      log_js_1.logger.warning(warning2);
      if (typeof process?.emitWarning === "function" && !insecureConnectionWarningEmmitted) {
        insecureConnectionWarningEmmitted = true;
        process.emitWarning(warning2);
      }
    }
    function ensureSecureConnection(request, options) {
      if (!request.url.toLowerCase().startsWith("https://")) {
        if (allowInsecureConnection(request, options)) {
          emitInsecureConnectionWarning();
        } else {
          throw new Error("Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.");
        }
      }
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/apiKeyAuthenticationPolicy.js
var require_apiKeyAuthenticationPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/apiKeyAuthenticationPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apiKeyAuthenticationPolicyName = void 0;
    exports.apiKeyAuthenticationPolicy = apiKeyAuthenticationPolicy;
    var checkInsecureConnection_js_1 = require_checkInsecureConnection();
    exports.apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
    function apiKeyAuthenticationPolicy(options) {
      return {
        name: exports.apiKeyAuthenticationPolicyName,
        async sendRequest(request, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
          const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "apiKey");
          if (!scheme) {
            return next(request);
          }
          if (scheme.apiKeyLocation !== "header") {
            throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
          }
          request.headers.set(scheme.name, options.credential.key);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/basicAuthenticationPolicy.js
var require_basicAuthenticationPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/basicAuthenticationPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.basicAuthenticationPolicyName = void 0;
    exports.basicAuthenticationPolicy = basicAuthenticationPolicy;
    var bytesEncoding_js_1 = require_bytesEncoding();
    var checkInsecureConnection_js_1 = require_checkInsecureConnection();
    exports.basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
    function basicAuthenticationPolicy(options) {
      return {
        name: exports.basicAuthenticationPolicyName,
        async sendRequest(request, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
          const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "basic");
          if (!scheme) {
            return next(request);
          }
          const { username, password } = options.credential;
          const headerValue = (0, bytesEncoding_js_1.uint8ArrayToString)((0, bytesEncoding_js_1.stringToUint8Array)(`${username}:${password}`, "utf-8"), "base64");
          request.headers.set("Authorization", `Basic ${headerValue}`);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/bearerAuthenticationPolicy.js
var require_bearerAuthenticationPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/bearerAuthenticationPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bearerAuthenticationPolicyName = void 0;
    exports.bearerAuthenticationPolicy = bearerAuthenticationPolicy;
    var checkInsecureConnection_js_1 = require_checkInsecureConnection();
    exports.bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
    function bearerAuthenticationPolicy(options) {
      return {
        name: exports.bearerAuthenticationPolicyName,
        async sendRequest(request, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
          const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "bearer");
          if (!scheme) {
            return next(request);
          }
          const token = await options.credential.getBearerToken({
            abortSignal: request.abortSignal
          });
          request.headers.set("Authorization", `Bearer ${token}`);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/oauth2AuthenticationPolicy.js
var require_oauth2AuthenticationPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/oauth2AuthenticationPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.oauth2AuthenticationPolicyName = void 0;
    exports.oauth2AuthenticationPolicy = oauth2AuthenticationPolicy;
    var checkInsecureConnection_js_1 = require_checkInsecureConnection();
    exports.oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
    function oauth2AuthenticationPolicy(options) {
      return {
        name: exports.oauth2AuthenticationPolicyName,
        async sendRequest(request, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
          const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "oauth2");
          if (!scheme) {
            return next(request);
          }
          const token = await options.credential.getOAuth2Token(scheme.flows, {
            abortSignal: request.abortSignal
          });
          request.headers.set("Authorization", `Bearer ${token}`);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/clientHelpers.js
var require_clientHelpers = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/clientHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDefaultPipeline = createDefaultPipeline;
    exports.getCachedDefaultHttpsClient = getCachedDefaultHttpsClient;
    var defaultHttpClient_js_1 = require_defaultHttpClient();
    var createPipelineFromOptions_js_1 = require_createPipelineFromOptions();
    var apiVersionPolicy_js_1 = require_apiVersionPolicy();
    var credentials_js_1 = require_credentials();
    var apiKeyAuthenticationPolicy_js_1 = require_apiKeyAuthenticationPolicy();
    var basicAuthenticationPolicy_js_1 = require_basicAuthenticationPolicy();
    var bearerAuthenticationPolicy_js_1 = require_bearerAuthenticationPolicy();
    var oauth2AuthenticationPolicy_js_1 = require_oauth2AuthenticationPolicy();
    var cachedHttpClient;
    function createDefaultPipeline(options = {}) {
      const pipeline = (0, createPipelineFromOptions_js_1.createPipelineFromOptions)(options);
      pipeline.addPolicy((0, apiVersionPolicy_js_1.apiVersionPolicy)(options));
      const { credential, authSchemes, allowInsecureConnection } = options;
      if (credential) {
        if ((0, credentials_js_1.isApiKeyCredential)(credential)) {
          pipeline.addPolicy((0, apiKeyAuthenticationPolicy_js_1.apiKeyAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
        } else if ((0, credentials_js_1.isBasicCredential)(credential)) {
          pipeline.addPolicy((0, basicAuthenticationPolicy_js_1.basicAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
        } else if ((0, credentials_js_1.isBearerTokenCredential)(credential)) {
          pipeline.addPolicy((0, bearerAuthenticationPolicy_js_1.bearerAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
        } else if ((0, credentials_js_1.isOAuth2TokenCredential)(credential)) {
          pipeline.addPolicy((0, oauth2AuthenticationPolicy_js_1.oauth2AuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
        }
      }
      return pipeline;
    }
    function getCachedDefaultHttpsClient() {
      if (!cachedHttpClient) {
        cachedHttpClient = (0, defaultHttpClient_js_1.createDefaultHttpClient)();
      }
      return cachedHttpClient;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/multipart.js
var require_multipart2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/multipart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildBodyPart = buildBodyPart;
    exports.buildMultipartBody = buildMultipartBody;
    var restError_js_1 = require_restError();
    var httpHeaders_js_1 = require_httpHeaders();
    var bytesEncoding_js_1 = require_bytesEncoding();
    var typeGuards_js_1 = require_typeGuards();
    function getHeaderValue(descriptor, headerName) {
      if (descriptor.headers) {
        const actualHeaderName = Object.keys(descriptor.headers).find((x) => x.toLowerCase() === headerName.toLowerCase());
        if (actualHeaderName) {
          return descriptor.headers[actualHeaderName];
        }
      }
      return void 0;
    }
    function getPartContentType(descriptor) {
      const contentTypeHeader = getHeaderValue(descriptor, "content-type");
      if (contentTypeHeader) {
        return contentTypeHeader;
      }
      if (descriptor.contentType === null) {
        return void 0;
      }
      if (descriptor.contentType) {
        return descriptor.contentType;
      }
      const { body } = descriptor;
      if (body === null || body === void 0) {
        return void 0;
      }
      if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
        return "text/plain; charset=UTF-8";
      }
      if (body instanceof Blob) {
        return body.type || "application/octet-stream";
      }
      if ((0, typeGuards_js_1.isBinaryBody)(body)) {
        return "application/octet-stream";
      }
      return "application/json";
    }
    function escapeDispositionField(value) {
      return JSON.stringify(value);
    }
    function getContentDisposition(descriptor) {
      const contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
      if (contentDispositionHeader) {
        return contentDispositionHeader;
      }
      if (descriptor.dispositionType === void 0 && descriptor.name === void 0 && descriptor.filename === void 0) {
        return void 0;
      }
      const dispositionType = descriptor.dispositionType ?? "form-data";
      let disposition = dispositionType;
      if (descriptor.name) {
        disposition += `; name=${escapeDispositionField(descriptor.name)}`;
      }
      let filename = void 0;
      if (descriptor.filename) {
        filename = descriptor.filename;
      } else if (typeof File !== "undefined" && descriptor.body instanceof File) {
        const filenameFromFile = descriptor.body.name;
        if (filenameFromFile !== "") {
          filename = filenameFromFile;
        }
      }
      if (filename) {
        disposition += `; filename=${escapeDispositionField(filename)}`;
      }
      return disposition;
    }
    function normalizeBody(body, contentType) {
      if (body === void 0) {
        return new Uint8Array([]);
      }
      if ((0, typeGuards_js_1.isBinaryBody)(body)) {
        return body;
      }
      if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
        return (0, bytesEncoding_js_1.stringToUint8Array)(String(body), "utf-8");
      }
      if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) {
        return (0, bytesEncoding_js_1.stringToUint8Array)(JSON.stringify(body), "utf-8");
      }
      throw new restError_js_1.RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
    }
    function buildBodyPart(descriptor) {
      const contentType = getPartContentType(descriptor);
      const contentDisposition = getContentDisposition(descriptor);
      const headers = (0, httpHeaders_js_1.createHttpHeaders)(descriptor.headers ?? {});
      if (contentType) {
        headers.set("content-type", contentType);
      }
      if (contentDisposition) {
        headers.set("content-disposition", contentDisposition);
      }
      const body = normalizeBody(descriptor.body, contentType);
      return {
        headers,
        body
      };
    }
    function buildMultipartBody(parts) {
      return { parts: parts.map(buildBodyPart) };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/sendRequest.js
var require_sendRequest = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/sendRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendRequest = sendRequest;
    var restError_js_1 = require_restError();
    var httpHeaders_js_1 = require_httpHeaders();
    var pipelineRequest_js_1 = require_pipelineRequest();
    var clientHelpers_js_1 = require_clientHelpers();
    var typeGuards_js_1 = require_typeGuards();
    var multipart_js_1 = require_multipart2();
    async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
      const httpClient = customHttpClient ?? (0, clientHelpers_js_1.getCachedDefaultHttpsClient)();
      const request = buildPipelineRequest(method, url, options);
      try {
        const response = await pipeline.sendRequest(httpClient, request);
        const headers = response.headers.toJSON();
        const stream2 = response.readableStreamBody ?? response.browserStreamBody;
        const parsedBody = options.responseAsStream || stream2 !== void 0 ? void 0 : getResponseBody(response);
        const body = stream2 ?? parsedBody;
        if (options?.onResponse) {
          options.onResponse({ ...response, request, rawHeaders: headers, parsedBody });
        }
        return {
          request,
          headers,
          status: `${response.status}`,
          body
        };
      } catch (e) {
        if ((0, restError_js_1.isRestError)(e) && e.response && options.onResponse) {
          const { response } = e;
          const rawHeaders = response.headers.toJSON();
          options?.onResponse({ ...response, request, rawHeaders }, e);
        }
        throw e;
      }
    }
    function getRequestContentType(options = {}) {
      return options.contentType ?? options.headers?.["content-type"] ?? getContentType(options.body);
    }
    function getContentType(body) {
      if (ArrayBuffer.isView(body)) {
        return "application/octet-stream";
      }
      if (typeof body === "string") {
        try {
          JSON.parse(body);
          return "application/json";
        } catch (error2) {
          return void 0;
        }
      }
      return "application/json";
    }
    function buildPipelineRequest(method, url, options = {}) {
      const requestContentType = getRequestContentType(options);
      const { body, multipartBody } = getRequestBody(options.body, requestContentType);
      const hasContent = body !== void 0 || multipartBody !== void 0;
      const headers = (0, httpHeaders_js_1.createHttpHeaders)({
        ...options.headers ? options.headers : {},
        accept: options.accept ?? options.headers?.accept ?? "application/json",
        ...hasContent && requestContentType && {
          "content-type": requestContentType
        }
      });
      return (0, pipelineRequest_js_1.createPipelineRequest)({
        url,
        method,
        body,
        multipartBody,
        headers,
        allowInsecureConnection: options.allowInsecureConnection,
        abortSignal: options.abortSignal,
        onUploadProgress: options.onUploadProgress,
        onDownloadProgress: options.onDownloadProgress,
        timeout: options.timeout,
        enableBrowserStreams: true,
        streamResponseStatusCodes: options.responseAsStream ? /* @__PURE__ */ new Set([Number.POSITIVE_INFINITY]) : void 0
      });
    }
    function getRequestBody(body, contentType = "") {
      if (body === void 0) {
        return { body: void 0 };
      }
      if (typeof FormData !== "undefined" && body instanceof FormData) {
        return { body };
      }
      if ((0, typeGuards_js_1.isReadableStream)(body)) {
        return { body };
      }
      if (ArrayBuffer.isView(body)) {
        return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
      }
      const firstType = contentType.split(";")[0];
      switch (firstType) {
        case "application/json":
          return { body: JSON.stringify(body) };
        case "multipart/form-data":
          if (Array.isArray(body)) {
            return { multipartBody: (0, multipart_js_1.buildMultipartBody)(body) };
          }
          return { body: JSON.stringify(body) };
        case "text/plain":
          return { body: String(body) };
        default:
          if (typeof body === "string") {
            return { body };
          }
          return { body: JSON.stringify(body) };
      }
    }
    function getResponseBody(response) {
      const contentType = response.headers.get("content-type") ?? "";
      const firstType = contentType.split(";")[0];
      const bodyToParse = response.bodyAsText ?? "";
      if (firstType === "text/plain") {
        return String(bodyToParse);
      }
      try {
        return bodyToParse ? JSON.parse(bodyToParse) : void 0;
      } catch (error2) {
        if (firstType === "application/json") {
          throw createParseError(response, error2);
        }
        return String(bodyToParse);
      }
    }
    function createParseError(response, err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
      const errCode = err.code ?? restError_js_1.RestError.PARSE_ERROR;
      return new restError_js_1.RestError(msg, {
        code: errCode,
        statusCode: response.status,
        request: response.request,
        response
      });
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/urlHelpers.js
var require_urlHelpers = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/urlHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildRequestUrl = buildRequestUrl;
    exports.buildBaseUrl = buildBaseUrl;
    exports.replaceAll = replaceAll;
    function isQueryParameterWithOptions(x) {
      const value = x.value;
      return value !== void 0 && value.toString !== void 0 && typeof value.toString === "function";
    }
    function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {
      if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
        return routePath;
      }
      endpoint = buildBaseUrl(endpoint, options);
      routePath = buildRoutePath(routePath, pathParameters, options);
      const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);
      const url = new URL(requestUrl);
      return url.toString().replace(/([^:]\/)\/+/g, "$1");
    }
    function getQueryParamValue(key, allowReserved, style, param) {
      let separator;
      if (style === "pipeDelimited") {
        separator = "|";
      } else if (style === "spaceDelimited") {
        separator = "%20";
      } else {
        separator = ",";
      }
      let paramValues;
      if (Array.isArray(param)) {
        paramValues = param;
      } else if (typeof param === "object" && param.toString === Object.prototype.toString) {
        paramValues = Object.entries(param).flat();
      } else {
        paramValues = [param];
      }
      const value = paramValues.map((p) => {
        if (p === null || p === void 0) {
          return "";
        }
        if (!p.toString || typeof p.toString !== "function") {
          throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
        }
        const rawValue = p.toISOString !== void 0 ? p.toISOString() : p.toString();
        return allowReserved ? rawValue : encodeURIComponent(rawValue);
      }).join(separator);
      return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;
    }
    function appendQueryParams(url, options = {}) {
      if (!options.queryParameters) {
        return url;
      }
      const parsedUrl = new URL(url);
      const queryParams = options.queryParameters;
      const paramStrings = [];
      for (const key of Object.keys(queryParams)) {
        const param = queryParams[key];
        if (param === void 0 || param === null) {
          continue;
        }
        const hasMetadata = isQueryParameterWithOptions(param);
        const rawValue = hasMetadata ? param.value : param;
        const explode = hasMetadata ? param.explode ?? false : false;
        const style = hasMetadata && param.style ? param.style : "form";
        if (explode) {
          if (Array.isArray(rawValue)) {
            for (const item of rawValue) {
              paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, item));
            }
          } else if (typeof rawValue === "object") {
            for (const [actualKey, value] of Object.entries(rawValue)) {
              paramStrings.push(getQueryParamValue(actualKey, options.skipUrlEncoding ?? false, style, value));
            }
          } else {
            throw new Error("explode can only be set to true for objects and arrays");
          }
        } else {
          paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, rawValue));
        }
      }
      if (parsedUrl.search !== "") {
        parsedUrl.search += "&";
      }
      parsedUrl.search += paramStrings.join("&");
      return parsedUrl.toString();
    }
    function buildBaseUrl(endpoint, options) {
      if (!options.pathParameters) {
        return endpoint;
      }
      const pathParams = options.pathParameters;
      for (const [key, param] of Object.entries(pathParams)) {
        if (param === void 0 || param === null) {
          throw new Error(`Path parameters ${key} must not be undefined or null`);
        }
        if (!param.toString || typeof param.toString !== "function") {
          throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
        }
        let value = param.toISOString !== void 0 ? param.toISOString() : String(param);
        if (!options.skipUrlEncoding) {
          value = encodeURIComponent(param);
        }
        endpoint = replaceAll(endpoint, `{${key}}`, value) ?? "";
      }
      return endpoint;
    }
    function buildRoutePath(routePath, pathParameters, options = {}) {
      for (const pathParam of pathParameters) {
        const allowReserved = typeof pathParam === "object" && (pathParam.allowReserved ?? false);
        let value = typeof pathParam === "object" ? pathParam.value : pathParam;
        if (!options.skipUrlEncoding && !allowReserved) {
          value = encodeURIComponent(value);
        }
        routePath = routePath.replace(/\{[\w-]+\}/, String(value));
      }
      return routePath;
    }
    function replaceAll(value, searchValue, replaceValue) {
      return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/getClient.js
var require_getClient = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/getClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getClient = getClient;
    var clientHelpers_js_1 = require_clientHelpers();
    var sendRequest_js_1 = require_sendRequest();
    var urlHelpers_js_1 = require_urlHelpers();
    var checkEnvironment_js_1 = require_checkEnvironment();
    function getClient(endpoint, clientOptions = {}) {
      const pipeline = clientOptions.pipeline ?? (0, clientHelpers_js_1.createDefaultPipeline)(clientOptions);
      if (clientOptions.additionalPolicies?.length) {
        for (const { policy, position } of clientOptions.additionalPolicies) {
          const afterPhase = position === "perRetry" ? "Sign" : void 0;
          pipeline.addPolicy(policy, {
            afterPhase
          });
        }
      }
      const { allowInsecureConnection, httpClient } = clientOptions;
      const endpointUrl = clientOptions.endpoint ?? endpoint;
      const client = (path2, ...args) => {
        const getUrl = (requestOptions) => (0, urlHelpers_js_1.buildRequestUrl)(endpointUrl, path2, args, { allowInsecureConnection, ...requestOptions });
        return {
          get: (requestOptions = {}) => {
            return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          post: (requestOptions = {}) => {
            return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          put: (requestOptions = {}) => {
            return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          patch: (requestOptions = {}) => {
            return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          delete: (requestOptions = {}) => {
            return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          head: (requestOptions = {}) => {
            return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          options: (requestOptions = {}) => {
            return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          trace: (requestOptions = {}) => {
            return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          }
        };
      };
      return {
        path: client,
        pathUnchecked: client,
        pipeline
      };
    }
    function buildOperation(method, url, pipeline, options, allowInsecureConnection, httpClient) {
      allowInsecureConnection = options.allowInsecureConnection ?? allowInsecureConnection;
      return {
        then: function(onFulfilled, onrejected) {
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection }, httpClient).then(onFulfilled, onrejected);
        },
        async asBrowserStream() {
          if (checkEnvironment_js_1.isNodeLike) {
            throw new Error("`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.");
          } else {
            return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: true }, httpClient);
          }
        },
        async asNodeStream() {
          if (checkEnvironment_js_1.isNodeLike) {
            return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: true }, httpClient);
          } else {
            throw new Error("`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.");
          }
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/operationOptionHelpers.js
var require_operationOptionHelpers = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/operationOptionHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.operationOptionsToRequestParameters = operationOptionsToRequestParameters;
    function operationOptionsToRequestParameters(options) {
      return {
        allowInsecureConnection: options.requestOptions?.allowInsecureConnection,
        timeout: options.requestOptions?.timeout,
        skipUrlEncoding: options.requestOptions?.skipUrlEncoding,
        abortSignal: options.abortSignal,
        onUploadProgress: options.requestOptions?.onUploadProgress,
        onDownloadProgress: options.requestOptions?.onDownloadProgress,
        headers: { ...options.requestOptions?.headers },
        onResponse: options.onResponse
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/restError.js
var require_restError2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/restError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRestError = createRestError;
    var restError_js_1 = require_restError();
    var httpHeaders_js_1 = require_httpHeaders();
    function createRestError(messageOrResponse, response) {
      const resp = typeof messageOrResponse === "string" ? response : messageOrResponse;
      const internalError = resp.body?.error ?? resp.body;
      const message = typeof messageOrResponse === "string" ? messageOrResponse : internalError?.message ?? `Unexpected status code: ${resp.status}`;
      return new restError_js_1.RestError(message, {
        statusCode: statusCodeToNumber(resp.status),
        code: internalError?.code,
        request: resp.request,
        response: toPipelineResponse(resp)
      });
    }
    function toPipelineResponse(response) {
      return {
        headers: (0, httpHeaders_js_1.createHttpHeaders)(response.headers),
        request: response.request,
        status: statusCodeToNumber(response.status) ?? -1
      };
    }
    function statusCodeToNumber(statusCode) {
      const status = Number.parseInt(statusCode);
      return Number.isNaN(status) ? void 0 : status;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRestError = exports.operationOptionsToRequestParameters = exports.getClient = exports.createDefaultHttpClient = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isRestError = exports.RestError = exports.createEmptyPipeline = exports.createPipelineRequest = exports.createHttpHeaders = exports.TypeSpecRuntimeLogger = exports.setLogLevel = exports.getLogLevel = exports.createClientLogger = exports.AbortError = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var AbortError_js_1 = require_AbortError();
    Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
      return AbortError_js_1.AbortError;
    } });
    var logger_js_1 = require_logger();
    Object.defineProperty(exports, "createClientLogger", { enumerable: true, get: function() {
      return logger_js_1.createClientLogger;
    } });
    Object.defineProperty(exports, "getLogLevel", { enumerable: true, get: function() {
      return logger_js_1.getLogLevel;
    } });
    Object.defineProperty(exports, "setLogLevel", { enumerable: true, get: function() {
      return logger_js_1.setLogLevel;
    } });
    Object.defineProperty(exports, "TypeSpecRuntimeLogger", { enumerable: true, get: function() {
      return logger_js_1.TypeSpecRuntimeLogger;
    } });
    var httpHeaders_js_1 = require_httpHeaders();
    Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
      return httpHeaders_js_1.createHttpHeaders;
    } });
    tslib_1.__exportStar(require_schemes(), exports);
    tslib_1.__exportStar(require_oauth2Flows(), exports);
    var pipelineRequest_js_1 = require_pipelineRequest();
    Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
      return pipelineRequest_js_1.createPipelineRequest;
    } });
    var pipeline_js_1 = require_pipeline();
    Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
      return pipeline_js_1.createEmptyPipeline;
    } });
    var restError_js_1 = require_restError();
    Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
      return restError_js_1.RestError;
    } });
    Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
      return restError_js_1.isRestError;
    } });
    var bytesEncoding_js_1 = require_bytesEncoding();
    Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
      return bytesEncoding_js_1.stringToUint8Array;
    } });
    Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
      return bytesEncoding_js_1.uint8ArrayToString;
    } });
    var defaultHttpClient_js_1 = require_defaultHttpClient();
    Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
      return defaultHttpClient_js_1.createDefaultHttpClient;
    } });
    var getClient_js_1 = require_getClient();
    Object.defineProperty(exports, "getClient", { enumerable: true, get: function() {
      return getClient_js_1.getClient;
    } });
    var operationOptionHelpers_js_1 = require_operationOptionHelpers();
    Object.defineProperty(exports, "operationOptionsToRequestParameters", { enumerable: true, get: function() {
      return operationOptionHelpers_js_1.operationOptionsToRequestParameters;
    } });
    var restError_js_2 = require_restError2();
    Object.defineProperty(exports, "createRestError", { enumerable: true, get: function() {
      return restError_js_2.createRestError;
    } });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipeline.js
var require_pipeline2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/pipeline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEmptyPipeline = createEmptyPipeline;
    var ts_http_runtime_1 = require_commonjs();
    function createEmptyPipeline() {
      return (0, ts_http_runtime_1.createEmptyPipeline)();
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/internal.js
var require_internal = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLoggerContext = void 0;
    var logger_js_1 = require_logger();
    Object.defineProperty(exports, "createLoggerContext", { enumerable: true, get: function() {
      return logger_js_1.createLoggerContext;
    } });
  }
});

// node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "node_modules/@azure/logger/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AzureLogger = void 0;
    exports.setLogLevel = setLogLevel;
    exports.getLogLevel = getLogLevel;
    exports.createClientLogger = createClientLogger;
    var logger_1 = require_internal();
    var context = (0, logger_1.createLoggerContext)({
      logLevelEnvVarName: "AZURE_LOG_LEVEL",
      namespace: "azure"
    });
    exports.AzureLogger = context.logger;
    function setLogLevel(level) {
      context.setLogLevel(level);
    }
    function getLogLevel() {
      return context.getLogLevel();
    }
    function createClientLogger(namespace) {
      return context.createClientLogger(namespace);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/log.js
var require_log3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = void 0;
    var logger_1 = require_commonjs2();
    exports.logger = (0, logger_1.createClientLogger)("core-rest-pipeline");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/exponentialRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exponentialRetryPolicyName = void 0;
    exports.exponentialRetryPolicy = exponentialRetryPolicy;
    var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
    var retryPolicy_js_1 = require_retryPolicy();
    var constants_js_1 = require_constants7();
    exports.exponentialRetryPolicyName = "exponentialRetryPolicy";
    function exponentialRetryPolicy(options = {}) {
      return (0, retryPolicy_js_1.retryPolicy)([
        (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
          ...options,
          ignoreSystemErrors: true
        })
      ], {
        maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      });
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/systemErrorRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.systemErrorRetryPolicyName = void 0;
    exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
    var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
    var retryPolicy_js_1 = require_retryPolicy();
    var constants_js_1 = require_constants7();
    exports.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
    function systemErrorRetryPolicy(options = {}) {
      return {
        name: exports.systemErrorRetryPolicyName,
        sendRequest: (0, retryPolicy_js_1.retryPolicy)([
          (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
            ...options,
            ignoreHttpStatusCodes: true
          })
        ], {
          maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/throttlingRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttlingRetryPolicyName = void 0;
    exports.throttlingRetryPolicy = throttlingRetryPolicy;
    var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
    var retryPolicy_js_1 = require_retryPolicy();
    var constants_js_1 = require_constants7();
    exports.throttlingRetryPolicyName = "throttlingRetryPolicy";
    function throttlingRetryPolicy(options = {}) {
      return {
        name: exports.throttlingRetryPolicyName,
        sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], {
          maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/internal.js
var require_internal2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.userAgentPolicyName = exports.userAgentPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.retryPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.defaultRetryPolicyName = exports.defaultRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.agentPolicyName = exports.agentPolicy = void 0;
    var agentPolicy_js_1 = require_agentPolicy();
    Object.defineProperty(exports, "agentPolicy", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicy;
    } });
    Object.defineProperty(exports, "agentPolicyName", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicyName;
    } });
    var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
    Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicy;
    } });
    Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicyName;
    } });
    var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
    Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
      return defaultRetryPolicy_js_1.defaultRetryPolicy;
    } });
    Object.defineProperty(exports, "defaultRetryPolicyName", { enumerable: true, get: function() {
      return defaultRetryPolicy_js_1.defaultRetryPolicyName;
    } });
    var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy();
    Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
    } });
    Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
    } });
    var retryPolicy_js_1 = require_retryPolicy();
    Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
      return retryPolicy_js_1.retryPolicy;
    } });
    var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy();
    Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
    } });
    Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
    } });
    var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy();
    Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
    } });
    Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
    } });
    var formDataPolicy_js_1 = require_formDataPolicy();
    Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicy;
    } });
    Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicyName;
    } });
    var logPolicy_js_1 = require_logPolicy();
    Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicy;
    } });
    Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicyName;
    } });
    var multipartPolicy_js_1 = require_multipartPolicy();
    Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicy;
    } });
    Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicyName;
    } });
    var proxyPolicy_js_1 = require_proxyPolicy();
    Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicy;
    } });
    Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicyName;
    } });
    Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
      return proxyPolicy_js_1.getDefaultProxySettings;
    } });
    var redirectPolicy_js_1 = require_redirectPolicy();
    Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicy;
    } });
    Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicyName;
    } });
    var tlsPolicy_js_1 = require_tlsPolicy();
    Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicy;
    } });
    Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicyName;
    } });
    var userAgentPolicy_js_1 = require_userAgentPolicy();
    Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicy;
    } });
    Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicyName;
    } });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/logPolicy.js
var require_logPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/logPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logPolicyName = void 0;
    exports.logPolicy = logPolicy;
    var log_js_1 = require_log3();
    var policies_1 = require_internal2();
    exports.logPolicyName = policies_1.logPolicyName;
    function logPolicy(options = {}) {
      return (0, policies_1.logPolicy)({
        logger: log_js_1.logger.info,
        ...options
      });
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/redirectPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.redirectPolicyName = void 0;
    exports.redirectPolicy = redirectPolicy;
    var policies_1 = require_internal2();
    exports.redirectPolicyName = policies_1.redirectPolicyName;
    function redirectPolicy(options = {}) {
      return (0, policies_1.redirectPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgentPlatform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHeaderName = getHeaderName;
    exports.setPlatformSpecificData = setPlatformSpecificData;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_os_1 = tslib_1.__importDefault(__require("os"));
    var node_process_1 = tslib_1.__importDefault(__require("process"));
    function getHeaderName() {
      return "User-Agent";
    }
    async function setPlatformSpecificData(map) {
      if (node_process_1.default && node_process_1.default.versions) {
        const osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`;
        const versions = node_process_1.default.versions;
        if (versions.bun) {
          map.set("Bun", `${versions.bun} (${osInfo})`);
        } else if (versions.deno) {
          map.set("Deno", `${versions.deno} (${osInfo})`);
        } else if (versions.node) {
          map.set("Node", `${versions.node} (${osInfo})`);
        }
      }
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/constants.js
var require_constants8 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = void 0;
    exports.SDK_VERSION = "1.22.2";
    exports.DEFAULT_RETRY_POLICY_COUNT = 3;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgent.js
var require_userAgent2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUserAgentHeaderName = getUserAgentHeaderName;
    exports.getUserAgentValue = getUserAgentValue;
    var userAgentPlatform_js_1 = require_userAgentPlatform2();
    var constants_js_1 = require_constants8();
    function getUserAgentString(telemetryInfo) {
      const parts = [];
      for (const [key, value] of telemetryInfo) {
        const token = value ? `${key}/${value}` : key;
        parts.push(token);
      }
      return parts.join(" ");
    }
    function getUserAgentHeaderName() {
      return (0, userAgentPlatform_js_1.getHeaderName)();
    }
    async function getUserAgentValue(prefix) {
      const runtimeInfo = /* @__PURE__ */ new Map();
      runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION);
      await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
      const defaultAgent = getUserAgentString(runtimeInfo);
      const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
      return userAgentValue;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/userAgentPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.userAgentPolicyName = void 0;
    exports.userAgentPolicy = userAgentPolicy;
    var userAgent_js_1 = require_userAgent2();
    var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
    exports.userAgentPolicyName = "userAgentPolicy";
    function userAgentPolicy(options = {}) {
      const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
      return {
        name: exports.userAgentPolicyName,
        async sendRequest(request, next) {
          if (!request.headers.has(UserAgentHeaderName)) {
            request.headers.set(UserAgentHeaderName, await userAgentValue);
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeSha256Hmac = computeSha256Hmac;
    exports.computeSha256Hash = computeSha256Hash;
    var node_crypto_1 = __require("crypto");
    async function computeSha256Hmac(key, stringToSign, encoding) {
      const decodedKey = Buffer.from(key, "base64");
      return (0, node_crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
    }
    async function computeSha256Hash(content, encoding) {
      return (0, node_crypto_1.createHash)("sha256").update(content).digest(encoding);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/internal.js
var require_internal3 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sanitizer = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isWebWorker = exports.isReactNative = exports.isDeno = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isBrowser = exports.randomUUID = exports.computeSha256Hmac = exports.computeSha256Hash = exports.isError = exports.isObject = exports.getRandomIntegerInclusive = exports.calculateRetryDelay = void 0;
    var delay_js_1 = require_delay();
    Object.defineProperty(exports, "calculateRetryDelay", { enumerable: true, get: function() {
      return delay_js_1.calculateRetryDelay;
    } });
    var random_js_1 = require_random();
    Object.defineProperty(exports, "getRandomIntegerInclusive", { enumerable: true, get: function() {
      return random_js_1.getRandomIntegerInclusive;
    } });
    var object_js_1 = require_object();
    Object.defineProperty(exports, "isObject", { enumerable: true, get: function() {
      return object_js_1.isObject;
    } });
    var error_js_1 = require_error();
    Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
      return error_js_1.isError;
    } });
    var sha256_js_1 = require_sha256();
    Object.defineProperty(exports, "computeSha256Hash", { enumerable: true, get: function() {
      return sha256_js_1.computeSha256Hash;
    } });
    Object.defineProperty(exports, "computeSha256Hmac", { enumerable: true, get: function() {
      return sha256_js_1.computeSha256Hmac;
    } });
    var uuidUtils_js_1 = require_uuidUtils();
    Object.defineProperty(exports, "randomUUID", { enumerable: true, get: function() {
      return uuidUtils_js_1.randomUUID;
    } });
    var checkEnvironment_js_1 = require_checkEnvironment();
    Object.defineProperty(exports, "isBrowser", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isBrowser;
    } });
    Object.defineProperty(exports, "isBun", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isBun;
    } });
    Object.defineProperty(exports, "isNodeLike", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isNodeLike;
    } });
    Object.defineProperty(exports, "isNodeRuntime", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isNodeRuntime;
    } });
    Object.defineProperty(exports, "isDeno", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isDeno;
    } });
    Object.defineProperty(exports, "isReactNative", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isReactNative;
    } });
    Object.defineProperty(exports, "isWebWorker", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isWebWorker;
    } });
    var bytesEncoding_js_1 = require_bytesEncoding();
    Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
      return bytesEncoding_js_1.stringToUint8Array;
    } });
    Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
      return bytesEncoding_js_1.uint8ArrayToString;
    } });
    var sanitizer_js_1 = require_sanitizer();
    Object.defineProperty(exports, "Sanitizer", { enumerable: true, get: function() {
      return sanitizer_js_1.Sanitizer;
    } });
  }
});

// node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/aborterUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cancelablePromiseRace = cancelablePromiseRace;
    async function cancelablePromiseRace(abortablePromiseBuilders, options) {
      const aborter = new AbortController();
      function abortHandler() {
        aborter.abort();
      }
      options?.abortSignal?.addEventListener("abort", abortHandler);
      try {
        return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
      } finally {
        aborter.abort();
        options?.abortSignal?.removeEventListener("abort", abortHandler);
      }
    }
  }
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError2 = __commonJS({
  "node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbortError = void 0;
    var AbortError3 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    exports.AbortError = AbortError3;
  }
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs3 = __commonJS({
  "node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbortError = void 0;
    var AbortError_js_1 = require_AbortError2();
    Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
      return AbortError_js_1.AbortError;
    } });
  }
});

// node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAbortablePromise = createAbortablePromise;
    var abort_controller_1 = require_commonjs3();
    function createAbortablePromise(buildPromise, options) {
      const { cleanupBeforeAbort, abortSignal: abortSignal2, abortErrorMsg } = options ?? {};
      return new Promise((resolve, reject) => {
        function rejectOnAbort() {
          reject(new abort_controller_1.AbortError(abortErrorMsg ?? "The operation was aborted."));
        }
        function removeListeners() {
          abortSignal2?.removeEventListener("abort", onAbort);
        }
        function onAbort() {
          cleanupBeforeAbort?.();
          removeListeners();
          rejectOnAbort();
        }
        if (abortSignal2?.aborted) {
          return rejectOnAbort();
        }
        try {
          buildPromise((x) => {
            removeListeners();
            resolve(x);
          }, (x) => {
            removeListeners();
            reject(x);
          });
        } catch (err) {
          reject(err);
        }
        abortSignal2?.addEventListener("abort", onAbort);
      });
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay2 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = delay3;
    exports.calculateRetryDelay = calculateRetryDelay2;
    var createAbortablePromise_js_1 = require_createAbortablePromise();
    var util_1 = require_internal3();
    var StandardAbortMessage = "The delay was aborted.";
    function delay3(timeInMs, options) {
      let token;
      const { abortSignal: abortSignal2, abortErrorMsg } = options ?? {};
      return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
        token = setTimeout(resolve, timeInMs);
      }, {
        cleanupBeforeAbort: () => clearTimeout(token),
        abortSignal: abortSignal2,
        abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
      });
    }
    function calculateRetryDelay2(retryAttempt, config) {
      const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
      const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
      const retryAfterInMs = clampedDelay / 2 + (0, util_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
      return { retryAfterInMs };
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/error.js
var require_error2 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getErrorMessage = getErrorMessage;
    var util_1 = require_internal3();
    function getErrorMessage(e) {
      if ((0, util_1.isError)(e)) {
        return e.message;
      } else {
        let stringified;
        try {
          if (typeof e === "object" && e) {
            stringified = JSON.stringify(e);
          } else {
            stringified = String(e);
          }
        } catch (err) {
          stringified = "[unable to stringify input]";
        }
        return `Unknown error ${stringified}`;
      }
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards2 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/typeGuards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDefined = isDefined;
    exports.isObjectWithProperties = isObjectWithProperties;
    exports.objectHasProperty = objectHasProperty;
    function isDefined(thing) {
      return typeof thing !== "undefined" && thing !== null;
    }
    function isObjectWithProperties(thing, properties) {
      if (!isDefined(thing) || typeof thing !== "object") {
        return false;
      }
      for (const property of properties) {
        if (!objectHasProperty(thing, property)) {
          return false;
        }
      }
      return true;
    }
    function objectHasProperty(thing, property) {
      return isDefined(thing) && typeof thing === "object" && property in thing;
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs4 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWebWorker = exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isDeno = exports.isBun = exports.isBrowser = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.getErrorMessage = exports.delay = exports.createAbortablePromise = exports.cancelablePromiseRace = void 0;
    exports.calculateRetryDelay = calculateRetryDelay2;
    exports.computeSha256Hash = computeSha256Hash;
    exports.computeSha256Hmac = computeSha256Hmac;
    exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
    exports.isError = isError2;
    exports.isObject = isObject2;
    exports.randomUUID = randomUUID3;
    exports.uint8ArrayToString = uint8ArrayToString;
    exports.stringToUint8Array = stringToUint8Array;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var tspRuntime = tslib_1.__importStar(require_internal3());
    var aborterUtils_js_1 = require_aborterUtils();
    Object.defineProperty(exports, "cancelablePromiseRace", { enumerable: true, get: function() {
      return aborterUtils_js_1.cancelablePromiseRace;
    } });
    var createAbortablePromise_js_1 = require_createAbortablePromise();
    Object.defineProperty(exports, "createAbortablePromise", { enumerable: true, get: function() {
      return createAbortablePromise_js_1.createAbortablePromise;
    } });
    var delay_js_1 = require_delay2();
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return delay_js_1.delay;
    } });
    var error_js_1 = require_error2();
    Object.defineProperty(exports, "getErrorMessage", { enumerable: true, get: function() {
      return error_js_1.getErrorMessage;
    } });
    var typeGuards_js_1 = require_typeGuards2();
    Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
      return typeGuards_js_1.isDefined;
    } });
    Object.defineProperty(exports, "isObjectWithProperties", { enumerable: true, get: function() {
      return typeGuards_js_1.isObjectWithProperties;
    } });
    Object.defineProperty(exports, "objectHasProperty", { enumerable: true, get: function() {
      return typeGuards_js_1.objectHasProperty;
    } });
    function calculateRetryDelay2(retryAttempt, config) {
      return tspRuntime.calculateRetryDelay(retryAttempt, config);
    }
    function computeSha256Hash(content, encoding) {
      return tspRuntime.computeSha256Hash(content, encoding);
    }
    function computeSha256Hmac(key, stringToSign, encoding) {
      return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
    }
    function getRandomIntegerInclusive(min, max) {
      return tspRuntime.getRandomIntegerInclusive(min, max);
    }
    function isError2(e) {
      return tspRuntime.isError(e);
    }
    function isObject2(input) {
      return tspRuntime.isObject(input);
    }
    function randomUUID3() {
      return tspRuntime.randomUUID();
    }
    exports.isBrowser = tspRuntime.isBrowser;
    exports.isBun = tspRuntime.isBun;
    exports.isDeno = tspRuntime.isDeno;
    exports.isNode = tspRuntime.isNodeLike;
    exports.isNodeLike = tspRuntime.isNodeLike;
    exports.isNodeRuntime = tspRuntime.isNodeRuntime;
    exports.isReactNative = tspRuntime.isReactNative;
    exports.isWebWorker = tspRuntime.isWebWorker;
    function uint8ArrayToString(bytes, format) {
      return tspRuntime.uint8ArrayToString(bytes, format);
    }
    function stringToUint8Array(value, format) {
      return tspRuntime.stringToUint8Array(value, format);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/file.js
var require_file2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasRawContent = hasRawContent;
    exports.getRawContent = getRawContent;
    exports.createFileFromStream = createFileFromStream;
    exports.createFile = createFile;
    var core_util_1 = require_commonjs4();
    function isNodeReadableStream(x) {
      return Boolean(x && typeof x["pipe"] === "function");
    }
    var unimplementedMethods = {
      arrayBuffer: () => {
        throw new Error("Not implemented");
      },
      bytes: () => {
        throw new Error("Not implemented");
      },
      slice: () => {
        throw new Error("Not implemented");
      },
      text: () => {
        throw new Error("Not implemented");
      }
    };
    var rawContent = /* @__PURE__ */ Symbol("rawContent");
    function hasRawContent(x) {
      return typeof x[rawContent] === "function";
    }
    function getRawContent(blob) {
      if (hasRawContent(blob)) {
        return blob[rawContent]();
      } else {
        return blob;
      }
    }
    function createFileFromStream(stream2, name, options = {}) {
      return {
        ...unimplementedMethods,
        type: options.type ?? "",
        lastModified: options.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
        webkitRelativePath: options.webkitRelativePath ?? "",
        size: options.size ?? -1,
        name,
        stream: () => {
          const s = stream2();
          if (isNodeReadableStream(s)) {
            throw new Error("Not supported: a Node stream was provided as input to createFileFromStream.");
          }
          return s;
        },
        [rawContent]: stream2
      };
    }
    function createFile(content, name, options = {}) {
      if (core_util_1.isNodeLike) {
        return {
          ...unimplementedMethods,
          type: options.type ?? "",
          lastModified: options.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
          webkitRelativePath: options.webkitRelativePath ?? "",
          size: content.byteLength,
          name,
          arrayBuffer: async () => content.buffer,
          stream: () => new Blob([toArrayBuffer(content)]).stream(),
          [rawContent]: () => content
        };
      } else {
        return new File([toArrayBuffer(content)], name, options);
      }
    }
    function toArrayBuffer(source) {
      if ("resize" in source.buffer) {
        return source;
      }
      return source.map((x) => x);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/multipartPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multipartPolicyName = void 0;
    exports.multipartPolicy = multipartPolicy;
    var policies_1 = require_internal2();
    var file_js_1 = require_file2();
    exports.multipartPolicyName = policies_1.multipartPolicyName;
    function multipartPolicy() {
      const tspPolicy = (0, policies_1.multipartPolicy)();
      return {
        name: exports.multipartPolicyName,
        sendRequest: async (request, next) => {
          if (request.multipartBody) {
            for (const part of request.multipartBody.parts) {
              if ((0, file_js_1.hasRawContent)(part.body)) {
                part.body = (0, file_js_1.getRawContent)(part.body);
              }
            }
          }
          return tspPolicy.sendRequest(request, next);
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/decompressResponsePolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decompressResponsePolicyName = void 0;
    exports.decompressResponsePolicy = decompressResponsePolicy;
    var policies_1 = require_internal2();
    exports.decompressResponsePolicyName = policies_1.decompressResponsePolicyName;
    function decompressResponsePolicy() {
      return (0, policies_1.decompressResponsePolicy)();
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/defaultRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultRetryPolicyName = void 0;
    exports.defaultRetryPolicy = defaultRetryPolicy;
    var policies_1 = require_internal2();
    exports.defaultRetryPolicyName = policies_1.defaultRetryPolicyName;
    function defaultRetryPolicy(options = {}) {
      return (0, policies_1.defaultRetryPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/formDataPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formDataPolicyName = void 0;
    exports.formDataPolicy = formDataPolicy;
    var policies_1 = require_internal2();
    exports.formDataPolicyName = policies_1.formDataPolicyName;
    function formDataPolicy() {
      return (0, policies_1.formDataPolicy)();
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/proxyPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.proxyPolicyName = void 0;
    exports.getDefaultProxySettings = getDefaultProxySettings;
    exports.proxyPolicy = proxyPolicy;
    var policies_1 = require_internal2();
    exports.proxyPolicyName = policies_1.proxyPolicyName;
    function getDefaultProxySettings(proxyUrl) {
      return (0, policies_1.getDefaultProxySettings)(proxyUrl);
    }
    function proxyPolicy(proxySettings, options) {
      return (0, policies_1.proxyPolicy)(proxySettings, options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/setClientRequestIdPolicy.js
var require_setClientRequestIdPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/setClientRequestIdPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setClientRequestIdPolicyName = void 0;
    exports.setClientRequestIdPolicy = setClientRequestIdPolicy;
    exports.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
    function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
      return {
        name: exports.setClientRequestIdPolicyName,
        async sendRequest(request, next) {
          if (!request.headers.has(requestIdHeaderName)) {
            request.headers.set(requestIdHeaderName, request.requestId);
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/agentPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.agentPolicyName = void 0;
    exports.agentPolicy = agentPolicy;
    var policies_1 = require_internal2();
    exports.agentPolicyName = policies_1.agentPolicyName;
    function agentPolicy(agent) {
      return (0, policies_1.agentPolicy)(agent);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tlsPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tlsPolicyName = void 0;
    exports.tlsPolicy = tlsPolicy;
    var policies_1 = require_internal2();
    exports.tlsPolicyName = policies_1.tlsPolicyName;
    function tlsPolicy(tlsSettings) {
      return (0, policies_1.tlsPolicy)(tlsSettings);
    }
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js
var require_tracingContext = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TracingContextImpl = exports.knownContextKeys = void 0;
    exports.createTracingContext = createTracingContext;
    exports.knownContextKeys = {
      span: /* @__PURE__ */ Symbol.for("@azure/core-tracing span"),
      namespace: /* @__PURE__ */ Symbol.for("@azure/core-tracing namespace")
    };
    function createTracingContext(options = {}) {
      let context = new TracingContextImpl(options.parentContext);
      if (options.span) {
        context = context.setValue(exports.knownContextKeys.span, options.span);
      }
      if (options.namespace) {
        context = context.setValue(exports.knownContextKeys.namespace, options.namespace);
      }
      return context;
    }
    var TracingContextImpl = class _TracingContextImpl {
      _contextMap;
      constructor(initialContext) {
        this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
      }
      setValue(key, value) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
      }
      getValue(key) {
        return this._contextMap.get(key);
      }
      deleteValue(key) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
      }
    };
    exports.TracingContextImpl = TracingContextImpl;
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/state.js
var require_state = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.state = void 0;
    exports.state = {
      instrumenterImplementation: void 0
    };
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js
var require_instrumenter = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDefaultTracingSpan = createDefaultTracingSpan;
    exports.createDefaultInstrumenter = createDefaultInstrumenter;
    exports.useInstrumenter = useInstrumenter;
    exports.getInstrumenter = getInstrumenter;
    var tracingContext_js_1 = require_tracingContext();
    var state_js_1 = require_state();
    function createDefaultTracingSpan() {
      return {
        end: () => {
        },
        isRecording: () => false,
        recordException: () => {
        },
        setAttribute: () => {
        },
        setStatus: () => {
        },
        addEvent: () => {
        }
      };
    }
    function createDefaultInstrumenter() {
      return {
        createRequestHeaders: () => {
          return {};
        },
        parseTraceparentHeader: () => {
          return void 0;
        },
        startSpan: (_name, spanOptions) => {
          return {
            span: createDefaultTracingSpan(),
            tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
          };
        },
        withContext(_context, callback, ...callbackArgs) {
          return callback(...callbackArgs);
        }
      };
    }
    function useInstrumenter(instrumenter) {
      state_js_1.state.instrumenterImplementation = instrumenter;
    }
    function getInstrumenter() {
      if (!state_js_1.state.instrumenterImplementation) {
        state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
      }
      return state_js_1.state.instrumenterImplementation;
    }
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js
var require_tracingClient = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTracingClient = createTracingClient;
    var instrumenter_js_1 = require_instrumenter();
    var tracingContext_js_1 = require_tracingContext();
    function createTracingClient(options) {
      const { namespace, packageName, packageVersion } = options;
      function startSpan(name, operationOptions, spanOptions) {
        const startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, {
          ...spanOptions,
          packageName,
          packageVersion,
          tracingContext: operationOptions?.tracingOptions?.tracingContext
        });
        let tracingContext = startSpanResult.tracingContext;
        const span = startSpanResult.span;
        if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace)) {
          tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
        }
        span.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
        const updatedOptions = Object.assign({}, operationOptions, {
          tracingOptions: { ...operationOptions?.tracingOptions, tracingContext }
        });
        return {
          span,
          updatedOptions
        };
      }
      async function withSpan(name, operationOptions, callback, spanOptions) {
        const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
        try {
          const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
          span.setStatus({ status: "success" });
          return result;
        } catch (err) {
          span.setStatus({ status: "error", error: err });
          throw err;
        } finally {
          span.end();
        }
      }
      function withContext(context, callback, ...callbackArgs) {
        return (0, instrumenter_js_1.getInstrumenter)().withContext(context, callback, ...callbackArgs);
      }
      function parseTraceparentHeader(traceparentHeader) {
        return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
      }
      function createRequestHeaders(tracingContext) {
        return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
      }
      return {
        startSpan,
        withSpan,
        withContext,
        parseTraceparentHeader,
        createRequestHeaders
      };
    }
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/index.js
var require_commonjs5 = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTracingClient = exports.useInstrumenter = void 0;
    var instrumenter_js_1 = require_instrumenter();
    Object.defineProperty(exports, "useInstrumenter", { enumerable: true, get: function() {
      return instrumenter_js_1.useInstrumenter;
    } });
    var tracingClient_js_1 = require_tracingClient();
    Object.defineProperty(exports, "createTracingClient", { enumerable: true, get: function() {
      return tracingClient_js_1.createTracingClient;
    } });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/restError.js
var require_restError3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/restError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RestError = void 0;
    exports.isRestError = isRestError;
    var ts_http_runtime_1 = require_commonjs();
    exports.RestError = ts_http_runtime_1.RestError;
    function isRestError(e) {
      return (0, ts_http_runtime_1.isRestError)(e);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tracingPolicy.js
var require_tracingPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tracingPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tracingPolicyName = void 0;
    exports.tracingPolicy = tracingPolicy;
    var core_tracing_1 = require_commonjs5();
    var constants_js_1 = require_constants8();
    var userAgent_js_1 = require_userAgent2();
    var log_js_1 = require_log3();
    var core_util_1 = require_commonjs4();
    var restError_js_1 = require_restError3();
    var util_1 = require_internal3();
    exports.tracingPolicyName = "tracingPolicy";
    function tracingPolicy(options = {}) {
      const userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
      const sanitizer = new util_1.Sanitizer({
        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
      });
      const tracingClient = tryCreateTracingClient();
      return {
        name: exports.tracingPolicyName,
        async sendRequest(request, next) {
          if (!tracingClient) {
            return next(request);
          }
          const userAgent = await userAgentPromise;
          const spanAttributes = {
            "http.url": sanitizer.sanitizeUrl(request.url),
            "http.method": request.method,
            "http.user_agent": userAgent,
            requestId: request.requestId
          };
          if (userAgent) {
            spanAttributes["http.user_agent"] = userAgent;
          }
          const { span, tracingContext } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};
          if (!span || !tracingContext) {
            return next(request);
          }
          try {
            const response = await tracingClient.withContext(tracingContext, next, request);
            tryProcessResponse(span, response);
            return response;
          } catch (err) {
            tryProcessError(span, err);
            throw err;
          }
        }
      };
    }
    function tryCreateTracingClient() {
      try {
        return (0, core_tracing_1.createTracingClient)({
          namespace: "",
          packageName: "@azure/core-rest-pipeline",
          packageVersion: constants_js_1.SDK_VERSION
        });
      } catch (e) {
        log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e)}`);
        return void 0;
      }
    }
    function tryCreateSpan(tracingClient, request, spanAttributes) {
      try {
        const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
          spanKind: "client",
          spanAttributes
        });
        if (!span.isRecording()) {
          span.end();
          return void 0;
        }
        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
        for (const [key, value] of Object.entries(headers)) {
          request.headers.set(key, value);
        }
        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
      } catch (e) {
        log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
        return void 0;
      }
    }
    function tryProcessError(span, error2) {
      try {
        span.setStatus({
          status: "error",
          error: (0, core_util_1.isError)(error2) ? error2 : void 0
        });
        if ((0, restError_js_1.isRestError)(error2) && error2.statusCode) {
          span.setAttribute("http.status_code", error2.statusCode);
        }
        span.end();
      } catch (e) {
        log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      }
    }
    function tryProcessResponse(span, response) {
      try {
        span.setAttribute("http.status_code", response.status);
        const serviceRequestId = response.headers.get("x-ms-request-id");
        if (serviceRequestId) {
          span.setAttribute("serviceRequestId", serviceRequestId);
        }
        if (response.status >= 400) {
          span.setStatus({
            status: "error"
          });
        }
        span.end();
      } catch (e) {
        log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      }
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/wrapAbortSignal.js
var require_wrapAbortSignal = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/wrapAbortSignal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapAbortSignalLike = wrapAbortSignalLike;
    function wrapAbortSignalLike(abortSignalLike) {
      if (abortSignalLike instanceof AbortSignal) {
        return { abortSignal: abortSignalLike };
      }
      if (abortSignalLike.aborted) {
        return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
      }
      const controller = new AbortController();
      let needsCleanup = true;
      function cleanup() {
        if (needsCleanup) {
          abortSignalLike.removeEventListener("abort", listener);
          needsCleanup = false;
        }
      }
      function listener() {
        controller.abort(abortSignalLike.reason);
        cleanup();
      }
      abortSignalLike.addEventListener("abort", listener);
      return { abortSignal: controller.signal, cleanup };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/wrapAbortSignalLikePolicy.js
var require_wrapAbortSignalLikePolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/wrapAbortSignalLikePolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapAbortSignalLikePolicyName = void 0;
    exports.wrapAbortSignalLikePolicy = wrapAbortSignalLikePolicy;
    var wrapAbortSignal_js_1 = require_wrapAbortSignal();
    exports.wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
    function wrapAbortSignalLikePolicy() {
      return {
        name: exports.wrapAbortSignalLikePolicyName,
        sendRequest: async (request, next) => {
          if (!request.abortSignal) {
            return next(request);
          }
          const { abortSignal: abortSignal2, cleanup } = (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal);
          request.abortSignal = abortSignal2;
          try {
            return await next(request);
          } finally {
            cleanup?.();
          }
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/createPipelineFromOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPipelineFromOptions = createPipelineFromOptions;
    var logPolicy_js_1 = require_logPolicy2();
    var pipeline_js_1 = require_pipeline2();
    var redirectPolicy_js_1 = require_redirectPolicy2();
    var userAgentPolicy_js_1 = require_userAgentPolicy2();
    var multipartPolicy_js_1 = require_multipartPolicy2();
    var decompressResponsePolicy_js_1 = require_decompressResponsePolicy2();
    var defaultRetryPolicy_js_1 = require_defaultRetryPolicy2();
    var formDataPolicy_js_1 = require_formDataPolicy2();
    var core_util_1 = require_commonjs4();
    var proxyPolicy_js_1 = require_proxyPolicy2();
    var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
    var agentPolicy_js_1 = require_agentPolicy2();
    var tlsPolicy_js_1 = require_tlsPolicy2();
    var tracingPolicy_js_1 = require_tracingPolicy();
    var wrapAbortSignalLikePolicy_js_1 = require_wrapAbortSignalLikePolicy();
    function createPipelineFromOptions(options) {
      const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
      if (core_util_1.isNodeLike) {
        if (options.agent) {
          pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
        }
        if (options.tlsOptions) {
          pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
        }
        pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
        pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
      }
      pipeline.addPolicy((0, wrapAbortSignalLikePolicy_js_1.wrapAbortSignalLikePolicy)());
      pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
      pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
      pipeline.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)(options.telemetryOptions?.clientRequestIdHeaderName));
      pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
      pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
      pipeline.addPolicy((0, tracingPolicy_js_1.tracingPolicy)({ ...options.userAgentOptions, ...options.loggingOptions }), {
        afterPhase: "Retry"
      });
      if (core_util_1.isNodeLike) {
        pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
      }
      pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
      return pipeline;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/defaultHttpClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDefaultHttpClient = createDefaultHttpClient;
    var ts_http_runtime_1 = require_commonjs();
    var wrapAbortSignal_js_1 = require_wrapAbortSignal();
    function createDefaultHttpClient() {
      const client = (0, ts_http_runtime_1.createDefaultHttpClient)();
      return {
        async sendRequest(request) {
          const { abortSignal: abortSignal2, cleanup } = request.abortSignal ? (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal) : {};
          try {
            request.abortSignal = abortSignal2;
            return await client.sendRequest(request);
          } finally {
            cleanup?.();
          }
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/httpHeaders.js
var require_httpHeaders2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/httpHeaders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHttpHeaders = createHttpHeaders;
    var ts_http_runtime_1 = require_commonjs();
    function createHttpHeaders(rawHeaders) {
      return (0, ts_http_runtime_1.createHttpHeaders)(rawHeaders);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipelineRequest.js
var require_pipelineRequest2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/pipelineRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPipelineRequest = createPipelineRequest;
    var ts_http_runtime_1 = require_commonjs();
    function createPipelineRequest(options) {
      return (0, ts_http_runtime_1.createPipelineRequest)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/exponentialRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exponentialRetryPolicyName = void 0;
    exports.exponentialRetryPolicy = exponentialRetryPolicy;
    var policies_1 = require_internal2();
    exports.exponentialRetryPolicyName = policies_1.exponentialRetryPolicyName;
    function exponentialRetryPolicy(options = {}) {
      return (0, policies_1.exponentialRetryPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/systemErrorRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.systemErrorRetryPolicyName = void 0;
    exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
    var policies_1 = require_internal2();
    exports.systemErrorRetryPolicyName = policies_1.systemErrorRetryPolicyName;
    function systemErrorRetryPolicy(options = {}) {
      return (0, policies_1.systemErrorRetryPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/throttlingRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttlingRetryPolicyName = void 0;
    exports.throttlingRetryPolicy = throttlingRetryPolicy;
    var policies_1 = require_internal2();
    exports.throttlingRetryPolicyName = policies_1.throttlingRetryPolicyName;
    function throttlingRetryPolicy(options = {}) {
      return (0, policies_1.throttlingRetryPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/retryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retryPolicy = retryPolicy;
    var logger_1 = require_commonjs2();
    var constants_js_1 = require_constants8();
    var policies_1 = require_internal2();
    var retryPolicyLogger = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
    function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
      return (0, policies_1.retryPolicy)(strategies, {
        logger: retryPolicyLogger,
        ...options
      });
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/tokenCycler.js
var require_tokenCycler = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/tokenCycler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_CYCLER_OPTIONS = void 0;
    exports.createTokenCycler = createTokenCycler;
    var core_util_1 = require_commonjs4();
    exports.DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      // Force waiting for a refresh 1s before the token expires
      retryIntervalInMs: 3e3,
      // Allow refresh attempts every 3s
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
    async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
      async function tryGetAccessToken() {
        if (Date.now() < refreshTimeout) {
          try {
            return await getAccessToken();
          } catch {
            return null;
          }
        } else {
          const finalToken = await getAccessToken();
          if (finalToken === null) {
            throw new Error("Failed to refresh access token.");
          }
          return finalToken;
        }
      }
      let token = await tryGetAccessToken();
      while (token === null) {
        await (0, core_util_1.delay)(retryIntervalInMs);
        token = await tryGetAccessToken();
      }
      return token;
    }
    function createTokenCycler(credential, tokenCyclerOptions) {
      let refreshWorker = null;
      let token = null;
      let tenantId;
      const options = {
        ...exports.DEFAULT_CYCLER_OPTIONS,
        ...tokenCyclerOptions
      };
      const cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */
        get isRefreshing() {
          return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */
        get shouldRefresh() {
          if (cycler.isRefreshing) {
            return false;
          }
          if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now()) {
            return true;
          }
          return (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now();
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */
        get mustRefresh() {
          return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
        }
      };
      function refresh(scopes, getTokenOptions) {
        if (!cycler.isRefreshing) {
          const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
          refreshWorker = beginRefresh(
            tryGetAccessToken,
            options.retryIntervalInMs,
            // If we don't have a token, then we should timeout immediately
            token?.expiresOnTimestamp ?? Date.now()
          ).then((_token) => {
            refreshWorker = null;
            token = _token;
            tenantId = getTokenOptions.tenantId;
            return token;
          }).catch((reason) => {
            refreshWorker = null;
            token = null;
            tenantId = void 0;
            throw reason;
          });
        }
        return refreshWorker;
      }
      return async (scopes, tokenOptions) => {
        const hasClaimChallenge = Boolean(tokenOptions.claims);
        const tenantIdChanged = tenantId !== tokenOptions.tenantId;
        if (hasClaimChallenge) {
          token = null;
        }
        const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
        if (mustRefresh) {
          return refresh(scopes, tokenOptions);
        }
        if (cycler.shouldRefresh) {
          refresh(scopes, tokenOptions);
        }
        return token;
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/bearerTokenAuthenticationPolicy.js
var require_bearerTokenAuthenticationPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/bearerTokenAuthenticationPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bearerTokenAuthenticationPolicyName = void 0;
    exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
    exports.parseChallenges = parseChallenges;
    var tokenCycler_js_1 = require_tokenCycler();
    var log_js_1 = require_log3();
    var restError_js_1 = require_restError3();
    exports.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
    async function trySendRequest(request, next) {
      try {
        return [await next(request), void 0];
      } catch (e) {
        if ((0, restError_js_1.isRestError)(e) && e.response) {
          return [e.response, e];
        } else {
          throw e;
        }
      }
    }
    async function defaultAuthorizeRequest(options) {
      const { scopes, getAccessToken, request } = options;
      const getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions,
        enableCae: true
      };
      const accessToken = await getAccessToken(scopes, getTokenOptions);
      if (accessToken) {
        options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
      }
    }
    function isChallengeResponse(response) {
      return response.status === 401 && response.headers.has("WWW-Authenticate");
    }
    async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
      const { scopes } = onChallengeOptions;
      const accessToken = await onChallengeOptions.getAccessToken(scopes, {
        enableCae: true,
        claims: caeClaims
      });
      if (!accessToken) {
        return false;
      }
      onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
      return true;
    }
    function bearerTokenAuthenticationPolicy(options) {
      const { credential, scopes, challengeCallbacks } = options;
      const logger = options.logger || log_js_1.logger;
      const callbacks = {
        authorizeRequest: challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,
        authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks)
      };
      const getAccessToken = credential ? (0, tokenCycler_js_1.createTokenCycler)(
        credential
        /* , options */
      ) : () => Promise.resolve(null);
      return {
        name: exports.bearerTokenAuthenticationPolicyName,
        /**
         * If there's no challenge parameter:
         * - It will try to retrieve the token using the cache, or the credential's getToken.
         * - Then it will try the next policy with or without the retrieved token.
         *
         * It uses the challenge parameters to:
         * - Skip a first attempt to get the token from the credential if there's no cached token,
         *   since it expects the token to be retrievable only after the challenge.
         * - Prepare the outgoing request if the `prepareRequest` method has been provided.
         * - Send an initial request to receive the challenge if it fails.
         * - Process a challenge if the response contains it.
         * - Retrieve a token with the challenge information, then re-send the request.
         */
        async sendRequest(request, next) {
          if (!request.url.toLowerCase().startsWith("https://")) {
            throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
          }
          await callbacks.authorizeRequest({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request,
            getAccessToken,
            logger
          });
          let response;
          let error2;
          let shouldSendRequest;
          [response, error2] = await trySendRequest(request, next);
          if (isChallengeResponse(response)) {
            let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
            if (claims) {
              let parsedClaim;
              try {
                parsedClaim = atob(claims);
              } catch (e) {
                logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                return response;
              }
              shouldSendRequest = await authorizeRequestOnCaeChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                response,
                request,
                getAccessToken,
                logger
              }, parsedClaim);
              if (shouldSendRequest) {
                [response, error2] = await trySendRequest(request, next);
              }
            } else if (callbacks.authorizeRequestOnChallenge) {
              shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                request,
                response,
                getAccessToken,
                logger
              });
              if (shouldSendRequest) {
                [response, error2] = await trySendRequest(request, next);
              }
              if (isChallengeResponse(response)) {
                claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
                if (claims) {
                  let parsedClaim;
                  try {
                    parsedClaim = atob(claims);
                  } catch (e) {
                    logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                    return response;
                  }
                  shouldSendRequest = await authorizeRequestOnCaeChallenge({
                    scopes: Array.isArray(scopes) ? scopes : [scopes],
                    response,
                    request,
                    getAccessToken,
                    logger
                  }, parsedClaim);
                  if (shouldSendRequest) {
                    [response, error2] = await trySendRequest(request, next);
                  }
                }
              }
            }
          }
          if (error2) {
            throw error2;
          } else {
            return response;
          }
        }
      };
    }
    function parseChallenges(challenges) {
      const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
      const paramRegex = /(\w+)="([^"]*)"/g;
      const parsedChallenges = [];
      let match;
      while ((match = challengeRegex.exec(challenges)) !== null) {
        const scheme = match[1];
        const paramsString = match[2];
        const params = {};
        let paramMatch;
        while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
          params[paramMatch[1]] = paramMatch[2];
        }
        parsedChallenges.push({ scheme, params });
      }
      return parsedChallenges;
    }
    function getCaeChallengeClaims(challenges) {
      if (!challenges) {
        return;
      }
      const parsedChallenges = parseChallenges(challenges);
      return parsedChallenges.find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")?.params.claims;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/ndJsonPolicy.js
var require_ndJsonPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/ndJsonPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ndJsonPolicyName = void 0;
    exports.ndJsonPolicy = ndJsonPolicy;
    exports.ndJsonPolicyName = "ndJsonPolicy";
    function ndJsonPolicy() {
      return {
        name: exports.ndJsonPolicyName,
        async sendRequest(request, next) {
          if (typeof request.body === "string" && request.body.startsWith("[")) {
            const body = JSON.parse(request.body);
            if (Array.isArray(body)) {
              request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
            }
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/auxiliaryAuthenticationHeaderPolicy.js
var require_auxiliaryAuthenticationHeaderPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/auxiliaryAuthenticationHeaderPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.auxiliaryAuthenticationHeaderPolicyName = void 0;
    exports.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
    var tokenCycler_js_1 = require_tokenCycler();
    var log_js_1 = require_log3();
    exports.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
    var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
    async function sendAuthorizeRequest(options) {
      const { scopes, getAccessToken, request } = options;
      const getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions
      };
      return (await getAccessToken(scopes, getTokenOptions))?.token ?? "";
    }
    function auxiliaryAuthenticationHeaderPolicy(options) {
      const { credentials, scopes } = options;
      const logger = options.logger || log_js_1.logger;
      const tokenCyclerMap = /* @__PURE__ */ new WeakMap();
      return {
        name: exports.auxiliaryAuthenticationHeaderPolicyName,
        async sendRequest(request, next) {
          if (!request.url.toLowerCase().startsWith("https://")) {
            throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
          }
          if (!credentials || credentials.length === 0) {
            logger.info(`${exports.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
            return next(request);
          }
          const tokenPromises = [];
          for (const credential of credentials) {
            let getAccessToken = tokenCyclerMap.get(credential);
            if (!getAccessToken) {
              getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential);
              tokenCyclerMap.set(credential, getAccessToken);
            }
            tokenPromises.push(sendAuthorizeRequest({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              request,
              getAccessToken,
              logger
            }));
          }
          const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
          if (auxiliaryTokens.length === 0) {
            logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
            return next(request);
          }
          request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/index.js
var require_commonjs6 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileFromStream = exports.createFile = exports.agentPolicyName = exports.agentPolicy = exports.auxiliaryAuthenticationHeaderPolicyName = exports.auxiliaryAuthenticationHeaderPolicy = exports.ndJsonPolicyName = exports.ndJsonPolicy = exports.bearerTokenAuthenticationPolicyName = exports.bearerTokenAuthenticationPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.userAgentPolicyName = exports.userAgentPolicy = exports.defaultRetryPolicy = exports.tracingPolicyName = exports.tracingPolicy = exports.retryPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.setClientRequestIdPolicyName = exports.setClientRequestIdPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.isRestError = exports.RestError = exports.createPipelineRequest = exports.createHttpHeaders = exports.createDefaultHttpClient = exports.createPipelineFromOptions = exports.createEmptyPipeline = void 0;
    var pipeline_js_1 = require_pipeline2();
    Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
      return pipeline_js_1.createEmptyPipeline;
    } });
    var createPipelineFromOptions_js_1 = require_createPipelineFromOptions2();
    Object.defineProperty(exports, "createPipelineFromOptions", { enumerable: true, get: function() {
      return createPipelineFromOptions_js_1.createPipelineFromOptions;
    } });
    var defaultHttpClient_js_1 = require_defaultHttpClient2();
    Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
      return defaultHttpClient_js_1.createDefaultHttpClient;
    } });
    var httpHeaders_js_1 = require_httpHeaders2();
    Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
      return httpHeaders_js_1.createHttpHeaders;
    } });
    var pipelineRequest_js_1 = require_pipelineRequest2();
    Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
      return pipelineRequest_js_1.createPipelineRequest;
    } });
    var restError_js_1 = require_restError3();
    Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
      return restError_js_1.RestError;
    } });
    Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
      return restError_js_1.isRestError;
    } });
    var decompressResponsePolicy_js_1 = require_decompressResponsePolicy2();
    Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicy;
    } });
    Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicyName;
    } });
    var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy2();
    Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
    } });
    Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
    } });
    var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
    Object.defineProperty(exports, "setClientRequestIdPolicy", { enumerable: true, get: function() {
      return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy;
    } });
    Object.defineProperty(exports, "setClientRequestIdPolicyName", { enumerable: true, get: function() {
      return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName;
    } });
    var logPolicy_js_1 = require_logPolicy2();
    Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicy;
    } });
    Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicyName;
    } });
    var multipartPolicy_js_1 = require_multipartPolicy2();
    Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicy;
    } });
    Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicyName;
    } });
    var proxyPolicy_js_1 = require_proxyPolicy2();
    Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicy;
    } });
    Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicyName;
    } });
    Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
      return proxyPolicy_js_1.getDefaultProxySettings;
    } });
    var redirectPolicy_js_1 = require_redirectPolicy2();
    Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicy;
    } });
    Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicyName;
    } });
    var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy2();
    Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
    } });
    Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
    } });
    var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy2();
    Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
    } });
    Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
    } });
    var retryPolicy_js_1 = require_retryPolicy2();
    Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
      return retryPolicy_js_1.retryPolicy;
    } });
    var tracingPolicy_js_1 = require_tracingPolicy();
    Object.defineProperty(exports, "tracingPolicy", { enumerable: true, get: function() {
      return tracingPolicy_js_1.tracingPolicy;
    } });
    Object.defineProperty(exports, "tracingPolicyName", { enumerable: true, get: function() {
      return tracingPolicy_js_1.tracingPolicyName;
    } });
    var defaultRetryPolicy_js_1 = require_defaultRetryPolicy2();
    Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
      return defaultRetryPolicy_js_1.defaultRetryPolicy;
    } });
    var userAgentPolicy_js_1 = require_userAgentPolicy2();
    Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicy;
    } });
    Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicyName;
    } });
    var tlsPolicy_js_1 = require_tlsPolicy2();
    Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicy;
    } });
    Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicyName;
    } });
    var formDataPolicy_js_1 = require_formDataPolicy2();
    Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicy;
    } });
    Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicyName;
    } });
    var bearerTokenAuthenticationPolicy_js_1 = require_bearerTokenAuthenticationPolicy();
    Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", { enumerable: true, get: function() {
      return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy;
    } });
    Object.defineProperty(exports, "bearerTokenAuthenticationPolicyName", { enumerable: true, get: function() {
      return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName;
    } });
    var ndJsonPolicy_js_1 = require_ndJsonPolicy();
    Object.defineProperty(exports, "ndJsonPolicy", { enumerable: true, get: function() {
      return ndJsonPolicy_js_1.ndJsonPolicy;
    } });
    Object.defineProperty(exports, "ndJsonPolicyName", { enumerable: true, get: function() {
      return ndJsonPolicy_js_1.ndJsonPolicyName;
    } });
    var auxiliaryAuthenticationHeaderPolicy_js_1 = require_auxiliaryAuthenticationHeaderPolicy();
    Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicy", { enumerable: true, get: function() {
      return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy;
    } });
    Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicyName", { enumerable: true, get: function() {
      return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName;
    } });
    var agentPolicy_js_1 = require_agentPolicy2();
    Object.defineProperty(exports, "agentPolicy", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicy;
    } });
    Object.defineProperty(exports, "agentPolicyName", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicyName;
    } });
    var file_js_1 = require_file2();
    Object.defineProperty(exports, "createFile", { enumerable: true, get: function() {
      return file_js_1.createFile;
    } });
    Object.defineProperty(exports, "createFileFromStream", { enumerable: true, get: function() {
      return file_js_1.createFileFromStream;
    } });
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js
var require_azureKeyCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AzureKeyCredential = void 0;
    var AzureKeyCredential = class {
      _key;
      /**
       * The value of the key to be used in authentication
       */
      get key() {
        return this._key;
      }
      /**
       * Create an instance of an AzureKeyCredential for use
       * with a service client.
       *
       * @param key - The initial value of the key to use in authentication
       */
      constructor(key) {
        if (!key) {
          throw new Error("key must be a non-empty string");
        }
        this._key = key;
      }
      /**
       * Change the value of the key.
       *
       * Updates will take effect upon the next request after
       * updating the key value.
       *
       * @param newKey - The new key value to be used
       */
      update(newKey) {
        this._key = newKey;
      }
    };
    exports.AzureKeyCredential = AzureKeyCredential;
  }
});

// node_modules/@azure/core-auth/dist/commonjs/keyCredential.js
var require_keyCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/keyCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isKeyCredential = isKeyCredential;
    var core_util_1 = require_commonjs4();
    function isKeyCredential(credential) {
      return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js
var require_azureNamedKeyCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AzureNamedKeyCredential = void 0;
    exports.isNamedKeyCredential = isNamedKeyCredential;
    var core_util_1 = require_commonjs4();
    var AzureNamedKeyCredential = class {
      _key;
      _name;
      /**
       * The value of the key to be used in authentication.
       */
      get key() {
        return this._key;
      }
      /**
       * The value of the name to be used in authentication.
       */
      get name() {
        return this._name;
      }
      /**
       * Create an instance of an AzureNamedKeyCredential for use
       * with a service client.
       *
       * @param name - The initial value of the name to use in authentication.
       * @param key - The initial value of the key to use in authentication.
       */
      constructor(name, key) {
        if (!name || !key) {
          throw new TypeError("name and key must be non-empty strings");
        }
        this._name = name;
        this._key = key;
      }
      /**
       * Change the value of the key.
       *
       * Updates will take effect upon the next request after
       * updating the key value.
       *
       * @param newName - The new name value to be used.
       * @param newKey - The new key value to be used.
       */
      update(newName, newKey) {
        if (!newName || !newKey) {
          throw new TypeError("newName and newKey must be non-empty strings");
        }
        this._name = newName;
        this._key = newKey;
      }
    };
    exports.AzureNamedKeyCredential = AzureNamedKeyCredential;
    function isNamedKeyCredential(credential) {
      return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js
var require_azureSASCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AzureSASCredential = void 0;
    exports.isSASCredential = isSASCredential;
    var core_util_1 = require_commonjs4();
    var AzureSASCredential = class {
      _signature;
      /**
       * The value of the shared access signature to be used in authentication
       */
      get signature() {
        return this._signature;
      }
      /**
       * Create an instance of an AzureSASCredential for use
       * with a service client.
       *
       * @param signature - The initial value of the shared access signature to use in authentication
       */
      constructor(signature) {
        if (!signature) {
          throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = signature;
      }
      /**
       * Change the value of the signature.
       *
       * Updates will take effect upon the next request after
       * updating the signature value.
       *
       * @param newSignature - The new shared access signature value to be used
       */
      update(newSignature) {
        if (!newSignature) {
          throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = newSignature;
      }
    };
    exports.AzureSASCredential = AzureSASCredential;
    function isSASCredential(credential) {
      return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js
var require_tokenCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBearerToken = isBearerToken;
    exports.isPopToken = isPopToken;
    exports.isTokenCredential = isTokenCredential;
    function isBearerToken(accessToken) {
      return !accessToken.tokenType || accessToken.tokenType === "Bearer";
    }
    function isPopToken(accessToken) {
      return accessToken.tokenType === "pop";
    }
    function isTokenCredential(credential) {
      const castCredential = credential;
      return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/index.js
var require_commonjs7 = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTokenCredential = exports.isSASCredential = exports.AzureSASCredential = exports.isNamedKeyCredential = exports.AzureNamedKeyCredential = exports.isKeyCredential = exports.AzureKeyCredential = void 0;
    var azureKeyCredential_js_1 = require_azureKeyCredential();
    Object.defineProperty(exports, "AzureKeyCredential", { enumerable: true, get: function() {
      return azureKeyCredential_js_1.AzureKeyCredential;
    } });
    var keyCredential_js_1 = require_keyCredential();
    Object.defineProperty(exports, "isKeyCredential", { enumerable: true, get: function() {
      return keyCredential_js_1.isKeyCredential;
    } });
    var azureNamedKeyCredential_js_1 = require_azureNamedKeyCredential();
    Object.defineProperty(exports, "AzureNamedKeyCredential", { enumerable: true, get: function() {
      return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
    } });
    Object.defineProperty(exports, "isNamedKeyCredential", { enumerable: true, get: function() {
      return azureNamedKeyCredential_js_1.isNamedKeyCredential;
    } });
    var azureSASCredential_js_1 = require_azureSASCredential();
    Object.defineProperty(exports, "AzureSASCredential", { enumerable: true, get: function() {
      return azureSASCredential_js_1.AzureSASCredential;
    } });
    Object.defineProperty(exports, "isSASCredential", { enumerable: true, get: function() {
      return azureSASCredential_js_1.isSASCredential;
    } });
    var tokenCredential_js_1 = require_tokenCredential();
    Object.defineProperty(exports, "isTokenCredential", { enumerable: true, get: function() {
      return tokenCredential_js_1.isTokenCredential;
    } });
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/disableKeepAlivePolicy.js
var require_disableKeepAlivePolicy = __commonJS({
  "node_modules/@azure/core-http-compat/dist/commonjs/policies/disableKeepAlivePolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.disableKeepAlivePolicyName = void 0;
    exports.createDisableKeepAlivePolicy = createDisableKeepAlivePolicy;
    exports.pipelineContainsDisableKeepAlivePolicy = pipelineContainsDisableKeepAlivePolicy;
    exports.disableKeepAlivePolicyName = "DisableKeepAlivePolicy";
    function createDisableKeepAlivePolicy() {
      return {
        name: exports.disableKeepAlivePolicyName,
        async sendRequest(request, next) {
          request.disableKeepAlive = true;
          return next(request);
        }
      };
    }
    function pipelineContainsDisableKeepAlivePolicy(pipeline) {
      return pipeline.getOrderedPolicies().some((policy) => policy.name === exports.disableKeepAlivePolicyName);
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/base64.js
var require_base64 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeString = encodeString;
    exports.encodeByteArray = encodeByteArray;
    exports.decodeString = decodeString;
    exports.decodeStringToString = decodeStringToString;
    function encodeString(value) {
      return Buffer.from(value).toString("base64");
    }
    function encodeByteArray(value) {
      const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
      return bufferValue.toString("base64");
    }
    function decodeString(value) {
      return Buffer.from(value, "base64");
    }
    function decodeStringToString(value) {
      return Buffer.from(value, "base64").toString();
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaces.js
var require_interfaces = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XML_CHARKEY = exports.XML_ATTRKEY = void 0;
    exports.XML_ATTRKEY = "$";
    exports.XML_CHARKEY = "_";
  }
});

// node_modules/@azure/core-client/dist/commonjs/utils.js
var require_utils3 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPrimitiveBody = isPrimitiveBody;
    exports.isDuration = isDuration;
    exports.isValidUuid = isValidUuid;
    exports.flattenResponse = flattenResponse;
    function isPrimitiveBody(value, mapperTypeName) {
      return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !== null || value === void 0 || value === null);
    }
    var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function isDuration(value) {
      return validateISODuration.test(value);
    }
    var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
    function isValidUuid(uuid) {
      return validUuidRegex.test(uuid);
    }
    function handleNullableResponseAndWrappableBody(responseObject) {
      const combinedHeadersAndBody = {
        ...responseObject.headers,
        ...responseObject.body
      };
      if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
        return responseObject.shouldWrapBody ? { body: null } : null;
      } else {
        return responseObject.shouldWrapBody ? {
          ...responseObject.headers,
          body: responseObject.body
        } : combinedHeadersAndBody;
      }
    }
    function flattenResponse(fullResponse, responseSpec) {
      const parsedHeaders = fullResponse.parsedHeaders;
      if (fullResponse.request.method === "HEAD") {
        return {
          ...parsedHeaders,
          body: fullResponse.parsedBody
        };
      }
      const bodyMapper = responseSpec && responseSpec.bodyMapper;
      const isNullable = Boolean(bodyMapper?.nullable);
      const expectedBodyTypeName = bodyMapper?.type.name;
      if (expectedBodyTypeName === "Stream") {
        return {
          ...parsedHeaders,
          blobBody: fullResponse.blobBody,
          readableStreamBody: fullResponse.readableStreamBody
        };
      }
      const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
      const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
      if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
        const arrayResponse = fullResponse.parsedBody ?? [];
        for (const key of Object.keys(modelProperties)) {
          if (modelProperties[key].serializedName) {
            arrayResponse[key] = fullResponse.parsedBody?.[key];
          }
        }
        if (parsedHeaders) {
          for (const key of Object.keys(parsedHeaders)) {
            arrayResponse[key] = parsedHeaders[key];
          }
        }
        return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
      }
      return handleNullableResponseAndWrappableBody({
        body: fullResponse.parsedBody,
        headers: parsedHeaders,
        hasNullableType: isNullable,
        shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
      });
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializer.js
var require_serializer = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/serializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapperTypeNames = void 0;
    exports.createSerializer = createSerializer;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var base64 = tslib_1.__importStar(require_base64());
    var interfaces_js_1 = require_interfaces();
    var utils_js_1 = require_utils3();
    var SerializerImpl = class {
      modelMappers;
      isXML;
      constructor(modelMappers = {}, isXML = false) {
        this.modelMappers = modelMappers;
        this.isXML = isXML;
      }
      /**
       * @deprecated Removing the constraints validation on client side.
       */
      validateConstraints(mapper, value, objectName) {
        const failValidation = (constraintName, constraintValue) => {
          throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
        };
        if (mapper.constraints && value !== void 0 && value !== null) {
          const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
          if (ExclusiveMaximum !== void 0 && value >= ExclusiveMaximum) {
            failValidation("ExclusiveMaximum", ExclusiveMaximum);
          }
          if (ExclusiveMinimum !== void 0 && value <= ExclusiveMinimum) {
            failValidation("ExclusiveMinimum", ExclusiveMinimum);
          }
          if (InclusiveMaximum !== void 0 && value > InclusiveMaximum) {
            failValidation("InclusiveMaximum", InclusiveMaximum);
          }
          if (InclusiveMinimum !== void 0 && value < InclusiveMinimum) {
            failValidation("InclusiveMinimum", InclusiveMinimum);
          }
          if (MaxItems !== void 0 && value.length > MaxItems) {
            failValidation("MaxItems", MaxItems);
          }
          if (MaxLength !== void 0 && value.length > MaxLength) {
            failValidation("MaxLength", MaxLength);
          }
          if (MinItems !== void 0 && value.length < MinItems) {
            failValidation("MinItems", MinItems);
          }
          if (MinLength !== void 0 && value.length < MinLength) {
            failValidation("MinLength", MinLength);
          }
          if (MultipleOf !== void 0 && value % MultipleOf !== 0) {
            failValidation("MultipleOf", MultipleOf);
          }
          if (Pattern) {
            const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
            if (typeof value !== "string" || value.match(pattern) === null) {
              failValidation("Pattern", Pattern);
            }
          }
          if (UniqueItems && value.some((item, i2, ar) => ar.indexOf(item) !== i2)) {
            failValidation("UniqueItems", UniqueItems);
          }
        }
      }
      /**
       * Serialize the given object based on its metadata defined in the mapper
       *
       * @param mapper - The mapper which defines the metadata of the serializable object
       *
       * @param object - A valid Javascript object to be serialized
       *
       * @param objectName - Name of the serialized object
       *
       * @param options - additional options to serialization
       *
       * @returns A valid serialized Javascript object
       */
      serialize(mapper, object, objectName, options = { xml: {} }) {
        const updatedOptions = {
          xml: {
            rootName: options.xml.rootName ?? "",
            includeRoot: options.xml.includeRoot ?? false,
            xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
          }
        };
        let payload = {};
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Sequence$/i) !== null) {
          payload = [];
        }
        if (mapper.isConstant) {
          object = mapper.defaultValue;
        }
        const { required, nullable } = mapper;
        if (required && nullable && object === void 0) {
          throw new Error(`${objectName} cannot be undefined.`);
        }
        if (required && !nullable && (object === void 0 || object === null)) {
          throw new Error(`${objectName} cannot be null or undefined.`);
        }
        if (!required && nullable === false && object === null) {
          throw new Error(`${objectName} cannot be null.`);
        }
        if (object === void 0 || object === null) {
          payload = object;
        } else {
          if (mapperType.match(/^any$/i) !== null) {
            payload = object;
          } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
            payload = serializeBasicTypes(mapperType, objectName, object);
          } else if (mapperType.match(/^Enum$/i) !== null) {
            const enumMapper = mapper;
            payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
          } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
            payload = serializeDateTypes(mapperType, object, objectName);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = serializeByteArrayType(objectName, object);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = serializeBase64UrlType(objectName, object);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Composite$/i) !== null) {
            payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          }
        }
        return payload;
      }
      /**
       * Deserialize the given object based on its metadata defined in the mapper
       *
       * @param mapper - The mapper which defines the metadata of the serializable object
       *
       * @param responseBody - A valid Javascript entity to be deserialized
       *
       * @param objectName - Name of the deserialized object
       *
       * @param options - Controls behavior of XML parser and builder.
       *
       * @returns A valid deserialized Javascript object
       */
      deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
        const updatedOptions = {
          xml: {
            rootName: options.xml.rootName ?? "",
            includeRoot: options.xml.includeRoot ?? false,
            xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
          },
          ignoreUnknownProperties: options.ignoreUnknownProperties ?? false
        };
        if (responseBody === void 0 || responseBody === null) {
          if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
            responseBody = [];
          }
          if (mapper.defaultValue !== void 0) {
            responseBody = mapper.defaultValue;
          }
          return responseBody;
        }
        let payload;
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Composite$/i) !== null) {
          payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
        } else {
          if (this.isXML) {
            const xmlCharKey = updatedOptions.xml.xmlCharKey;
            if (responseBody[interfaces_js_1.XML_ATTRKEY] !== void 0 && responseBody[xmlCharKey] !== void 0) {
              responseBody = responseBody[xmlCharKey];
            }
          }
          if (mapperType.match(/^Number$/i) !== null) {
            payload = parseFloat(responseBody);
            if (isNaN(payload)) {
              payload = responseBody;
            }
          } else if (mapperType.match(/^Boolean$/i) !== null) {
            if (responseBody === "true") {
              payload = true;
            } else if (responseBody === "false") {
              payload = false;
            } else {
              payload = responseBody;
            }
          } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
            payload = responseBody;
          } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
            payload = new Date(responseBody);
          } else if (mapperType.match(/^UnixTime$/i) !== null) {
            payload = unixTimeToDate(responseBody);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = base64.decodeString(responseBody);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = base64UrlToByteArray(responseBody);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
          }
        }
        if (mapper.isConstant) {
          payload = mapper.defaultValue;
        }
        return payload;
      }
    };
    function createSerializer(modelMappers = {}, isXML = false) {
      return new SerializerImpl(modelMappers, isXML);
    }
    function trimEnd(str, ch) {
      let len = str.length;
      while (len - 1 >= 0 && str[len - 1] === ch) {
        --len;
      }
      return str.substr(0, len);
    }
    function bufferToBase64Url(buffer) {
      if (!buffer) {
        return void 0;
      }
      if (!(buffer instanceof Uint8Array)) {
        throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
      }
      const str = base64.encodeByteArray(buffer);
      return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function base64UrlToByteArray(str) {
      if (!str) {
        return void 0;
      }
      if (str && typeof str.valueOf() !== "string") {
        throw new Error("Please provide an input of type string for converting to Uint8Array");
      }
      str = str.replace(/-/g, "+").replace(/_/g, "/");
      return base64.decodeString(str);
    }
    function splitSerializeName(prop) {
      const classes = [];
      let partialclass = "";
      if (prop) {
        const subwords = prop.split(".");
        for (const item of subwords) {
          if (item.charAt(item.length - 1) === "\\") {
            partialclass += item.substr(0, item.length - 1) + ".";
          } else {
            partialclass += item;
            classes.push(partialclass);
            partialclass = "";
          }
        }
      }
      return classes;
    }
    function dateToUnixTime(d) {
      if (!d) {
        return void 0;
      }
      if (typeof d.valueOf() === "string") {
        d = new Date(d);
      }
      return Math.floor(d.getTime() / 1e3);
    }
    function unixTimeToDate(n2) {
      if (!n2) {
        return void 0;
      }
      return new Date(n2 * 1e3);
    }
    function serializeBasicTypes(typeName, objectName, value) {
      if (value !== null && value !== void 0) {
        if (typeName.match(/^Number$/i) !== null) {
          if (typeof value !== "number") {
            throw new Error(`${objectName} with value ${value} must be of type number.`);
          }
        } else if (typeName.match(/^String$/i) !== null) {
          if (typeof value.valueOf() !== "string") {
            throw new Error(`${objectName} with value "${value}" must be of type string.`);
          }
        } else if (typeName.match(/^Uuid$/i) !== null) {
          if (!(typeof value.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value))) {
            throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
          }
        } else if (typeName.match(/^Boolean$/i) !== null) {
          if (typeof value !== "boolean") {
            throw new Error(`${objectName} with value ${value} must be of type boolean.`);
          }
        } else if (typeName.match(/^Stream$/i) !== null) {
          const objectType = typeof value;
          if (objectType !== "string" && typeof value.pipe !== "function" && // NodeJS.ReadableStream
          typeof value.tee !== "function" && // browser ReadableStream
          !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && // File objects count as a type of Blob, so we want to use instanceof explicitly
          !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
            throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
          }
        }
      }
      return value;
    }
    function serializeEnumType(objectName, allowedValues, value) {
      if (!allowedValues) {
        throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
      }
      const isPresent = allowedValues.some((item) => {
        if (typeof item.valueOf() === "string") {
          return item.toLowerCase() === value.toLowerCase();
        }
        return item === value;
      });
      if (!isPresent) {
        throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
      }
      return value;
    }
    function serializeByteArrayType(objectName, value) {
      if (value !== void 0 && value !== null) {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`${objectName} must be of type Uint8Array.`);
        }
        value = base64.encodeByteArray(value);
      }
      return value;
    }
    function serializeBase64UrlType(objectName, value) {
      if (value !== void 0 && value !== null) {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`${objectName} must be of type Uint8Array.`);
        }
        value = bufferToBase64Url(value);
      }
      return value;
    }
    function serializeDateTypes(typeName, value, objectName) {
      if (value !== void 0 && value !== null) {
        if (typeName.match(/^Date$/i) !== null) {
          if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
            throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
          }
          value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
        } else if (typeName.match(/^DateTime$/i) !== null) {
          if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
            throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
          }
          value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
        } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
          if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
            throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
          }
          value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
        } else if (typeName.match(/^UnixTime$/i) !== null) {
          if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
            throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
          }
          value = dateToUnixTime(value);
        } else if (typeName.match(/^TimeSpan$/i) !== null) {
          if (!(0, utils_js_1.isDuration)(value)) {
            throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
          }
        }
      }
      return value;
    }
    function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
      if (!Array.isArray(object)) {
        throw new Error(`${objectName} must be of type Array.`);
      }
      let elementType = mapper.type.element;
      if (!elementType || typeof elementType !== "object") {
        throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
      }
      if (elementType.type.name === "Composite" && elementType.type.className) {
        elementType = serializer.modelMappers[elementType.type.className] ?? elementType;
      }
      const tempArray = [];
      for (let i2 = 0; i2 < object.length; i2++) {
        const serializedValue = serializer.serialize(elementType, object[i2], objectName, options);
        if (isXml && elementType.xmlNamespace) {
          const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
          if (elementType.type.name === "Composite") {
            tempArray[i2] = { ...serializedValue };
            tempArray[i2][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
          } else {
            tempArray[i2] = {};
            tempArray[i2][options.xml.xmlCharKey] = serializedValue;
            tempArray[i2][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
          }
        } else {
          tempArray[i2] = serializedValue;
        }
      }
      return tempArray;
    }
    function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
      if (typeof object !== "object") {
        throw new Error(`${objectName} must be of type object.`);
      }
      const valueType = mapper.type.value;
      if (!valueType || typeof valueType !== "object") {
        throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
      }
      const tempDictionary = {};
      for (const key of Object.keys(object)) {
        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
      }
      if (isXml && mapper.xmlNamespace) {
        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
        const result = tempDictionary;
        result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
        return result;
      }
      return tempDictionary;
    }
    function resolveAdditionalProperties(serializer, mapper, objectName) {
      const additionalProperties = mapper.type.additionalProperties;
      if (!additionalProperties && mapper.type.className) {
        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        return modelMapper?.type.additionalProperties;
      }
      return additionalProperties;
    }
    function resolveReferencedMapper(serializer, mapper, objectName) {
      const className = mapper.type.className;
      if (!className) {
        throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
      }
      return serializer.modelMappers[className];
    }
    function resolveModelProperties(serializer, mapper, objectName) {
      let modelProps = mapper.type.modelProperties;
      if (!modelProps) {
        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        if (!modelMapper) {
          throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
        }
        modelProps = modelMapper?.type.modelProperties;
        if (!modelProps) {
          throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
        }
      }
      return modelProps;
    }
    function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
      if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
        mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
      }
      if (object !== void 0 && object !== null) {
        const payload = {};
        const modelProps = resolveModelProperties(serializer, mapper, objectName);
        for (const key of Object.keys(modelProps)) {
          const propertyMapper = modelProps[key];
          if (propertyMapper.readOnly) {
            continue;
          }
          let propName;
          let parentObject = payload;
          if (serializer.isXML) {
            if (propertyMapper.xmlIsWrapped) {
              propName = propertyMapper.xmlName;
            } else {
              propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
            }
          } else {
            const paths = splitSerializeName(propertyMapper.serializedName);
            propName = paths.pop();
            for (const pathName of paths) {
              const childObject = parentObject[pathName];
              if ((childObject === void 0 || childObject === null) && (object[key] !== void 0 && object[key] !== null || propertyMapper.defaultValue !== void 0)) {
                parentObject[pathName] = {};
              }
              parentObject = parentObject[pathName];
            }
          }
          if (parentObject !== void 0 && parentObject !== null) {
            if (isXml && mapper.xmlNamespace) {
              const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
              parentObject[interfaces_js_1.XML_ATTRKEY] = {
                ...parentObject[interfaces_js_1.XML_ATTRKEY],
                [xmlnsKey]: mapper.xmlNamespace
              };
            }
            const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
            let toSerialize = object[key];
            const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
            if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === void 0 || toSerialize === null)) {
              toSerialize = mapper.serializedName;
            }
            const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
            if (serializedValue !== void 0 && propName !== void 0 && propName !== null) {
              const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
              if (isXml && propertyMapper.xmlIsAttribute) {
                parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {};
                parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
              } else if (isXml && propertyMapper.xmlIsWrapped) {
                parentObject[propName] = { [propertyMapper.xmlElementName]: value };
              } else {
                parentObject[propName] = value;
              }
            }
          }
        }
        const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
        if (additionalPropertiesMapper) {
          const propNames = Object.keys(modelProps);
          for (const clientPropName in object) {
            const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
            if (isAdditionalProperty) {
              payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
            }
          }
        }
        return payload;
      }
      return object;
    }
    function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
      if (!isXml || !propertyMapper.xmlNamespace) {
        return serializedValue;
      }
      const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
      const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
      if (["Composite"].includes(propertyMapper.type.name)) {
        if (serializedValue[interfaces_js_1.XML_ATTRKEY]) {
          return serializedValue;
        } else {
          const result2 = { ...serializedValue };
          result2[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
          return result2;
        }
      }
      const result = {};
      result[options.xml.xmlCharKey] = serializedValue;
      result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
      return result;
    }
    function isSpecialXmlProperty(propertyName, options) {
      return [interfaces_js_1.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
    }
    function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
      const xmlCharKey = options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY;
      if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
        mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
      }
      const modelProps = resolveModelProperties(serializer, mapper, objectName);
      let instance = {};
      const handledPropertyNames = [];
      for (const key of Object.keys(modelProps)) {
        const propertyMapper = modelProps[key];
        const paths = splitSerializeName(modelProps[key].serializedName);
        handledPropertyNames.push(paths[0]);
        const { serializedName, xmlName, xmlElementName } = propertyMapper;
        let propertyObjectName = objectName;
        if (serializedName !== "" && serializedName !== void 0) {
          propertyObjectName = objectName + "." + serializedName;
        }
        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          const dictionary = {};
          for (const headerKey of Object.keys(responseBody)) {
            if (headerKey.startsWith(headerCollectionPrefix)) {
              dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
            }
            handledPropertyNames.push(headerKey);
          }
          instance[key] = dictionary;
        } else if (serializer.isXML) {
          if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY]) {
            instance[key] = serializer.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options);
          } else if (propertyMapper.xmlIsMsText) {
            if (responseBody[xmlCharKey] !== void 0) {
              instance[key] = responseBody[xmlCharKey];
            } else if (typeof responseBody === "string") {
              instance[key] = responseBody;
            }
          } else {
            const propertyName = xmlElementName || xmlName || serializedName;
            if (propertyMapper.xmlIsWrapped) {
              const wrapped = responseBody[xmlName];
              const elementList = wrapped?.[xmlElementName] ?? [];
              instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
              handledPropertyNames.push(xmlName);
            } else {
              const property = responseBody[propertyName];
              instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
              handledPropertyNames.push(propertyName);
            }
          }
        } else {
          let propertyInstance;
          let res = responseBody;
          let steps = 0;
          for (const item of paths) {
            if (!res)
              break;
            steps++;
            res = res[item];
          }
          if (res === null && steps < paths.length) {
            res = void 0;
          }
          propertyInstance = res;
          const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
          if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === void 0 || propertyInstance === null)) {
            propertyInstance = mapper.serializedName;
          }
          let serializedValue;
          if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
            propertyInstance = responseBody[key];
            const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
            for (const [k, v] of Object.entries(instance)) {
              if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
                arrayInstance[k] = v;
              }
            }
            instance = arrayInstance;
          } else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) {
            serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
            instance[key] = serializedValue;
          }
        }
      }
      const additionalPropertiesMapper = mapper.type.additionalProperties;
      if (additionalPropertiesMapper) {
        const isAdditionalProperty = (responsePropName) => {
          for (const clientPropName in modelProps) {
            const paths = splitSerializeName(modelProps[clientPropName].serializedName);
            if (paths[0] === responsePropName) {
              return false;
            }
          }
          return true;
        };
        for (const responsePropName in responseBody) {
          if (isAdditionalProperty(responsePropName)) {
            instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
          }
        }
      } else if (responseBody && !options.ignoreUnknownProperties) {
        for (const key of Object.keys(responseBody)) {
          if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {
            instance[key] = responseBody[key];
          }
        }
      }
      return instance;
    }
    function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
      const value = mapper.type.value;
      if (!value || typeof value !== "object") {
        throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
      }
      if (responseBody) {
        const tempDictionary = {};
        for (const key of Object.keys(responseBody)) {
          tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
        }
        return tempDictionary;
      }
      return responseBody;
    }
    function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
      let element = mapper.type.element;
      if (!element || typeof element !== "object") {
        throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
      }
      if (responseBody) {
        if (!Array.isArray(responseBody)) {
          responseBody = [responseBody];
        }
        if (element.type.name === "Composite" && element.type.className) {
          element = serializer.modelMappers[element.type.className] ?? element;
        }
        const tempArray = [];
        for (let i2 = 0; i2 < responseBody.length; i2++) {
          tempArray[i2] = serializer.deserialize(element, responseBody[i2], `${objectName}[${i2}]`, options);
        }
        return tempArray;
      }
      return responseBody;
    }
    function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
      const typeNamesToCheck = [typeName];
      while (typeNamesToCheck.length) {
        const currentName = typeNamesToCheck.shift();
        const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
        if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
          return discriminators[indexDiscriminator];
        } else {
          for (const [name, mapper] of Object.entries(discriminators)) {
            if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
              typeNamesToCheck.push(mapper.type.className);
            }
          }
        }
      }
      return void 0;
    }
    function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
      const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
      if (polymorphicDiscriminator) {
        let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
        if (discriminatorName) {
          if (polymorphicPropertyName === "serializedName") {
            discriminatorName = discriminatorName.replace(/\\/gi, "");
          }
          const discriminatorValue = object[discriminatorName];
          const typeName = mapper.type.uberParent ?? mapper.type.className;
          if (typeof discriminatorValue === "string" && typeName) {
            const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
            if (polymorphicMapper) {
              mapper = polymorphicMapper;
            }
          }
        }
      }
      return mapper;
    }
    function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
      return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
    }
    function getPolymorphicDiscriminatorSafely(serializer, typeName) {
      return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
    }
    exports.MapperTypeNames = {
      Base64Url: "Base64Url",
      Boolean: "Boolean",
      ByteArray: "ByteArray",
      Composite: "Composite",
      Date: "Date",
      DateTime: "DateTime",
      DateTimeRfc1123: "DateTimeRfc1123",
      Dictionary: "Dictionary",
      Enum: "Enum",
      Number: "Number",
      Object: "Object",
      Sequence: "Sequence",
      String: "String",
      Stream: "Stream",
      TimeSpan: "TimeSpan",
      UnixTime: "UnixTime"
    };
  }
});

// node_modules/@azure/core-client/dist/commonjs/state.js
var require_state2 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.state = void 0;
    exports.state = {
      operationRequestMap: /* @__PURE__ */ new WeakMap()
    };
  }
});

// node_modules/@azure/core-client/dist/commonjs/operationHelpers.js
var require_operationHelpers = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/operationHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
    exports.getOperationRequestInfo = getOperationRequestInfo;
    var state_js_1 = require_state2();
    function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
      let parameterPath = parameter.parameterPath;
      const parameterMapper = parameter.mapper;
      let value;
      if (typeof parameterPath === "string") {
        parameterPath = [parameterPath];
      }
      if (Array.isArray(parameterPath)) {
        if (parameterPath.length > 0) {
          if (parameterMapper.isConstant) {
            value = parameterMapper.defaultValue;
          } else {
            let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
            if (!propertySearchResult.propertyFound && fallbackObject) {
              propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
            }
            let useDefaultValue = false;
            if (!propertySearchResult.propertyFound) {
              useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
            }
            value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
          }
        }
      } else {
        if (parameterMapper.required) {
          value = {};
        }
        for (const propertyName in parameterPath) {
          const propertyMapper = parameterMapper.type.modelProperties[propertyName];
          const propertyPath = parameterPath[propertyName];
          const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
            parameterPath: propertyPath,
            mapper: propertyMapper
          }, fallbackObject);
          if (propertyValue !== void 0) {
            if (!value) {
              value = {};
            }
            value[propertyName] = propertyValue;
          }
        }
      }
      return value;
    }
    function getPropertyFromParameterPath(parent, parameterPath) {
      const result = { propertyFound: false };
      let i2 = 0;
      for (; i2 < parameterPath.length; ++i2) {
        const parameterPathPart = parameterPath[i2];
        if (parent && parameterPathPart in parent) {
          parent = parent[parameterPathPart];
        } else {
          break;
        }
      }
      if (i2 === parameterPath.length) {
        result.propertyValue = parent;
        result.propertyFound = true;
      }
      return result;
    }
    var originalRequestSymbol = /* @__PURE__ */ Symbol.for("@azure/core-client original request");
    function hasOriginalRequest(request) {
      return originalRequestSymbol in request;
    }
    function getOperationRequestInfo(request) {
      if (hasOriginalRequest(request)) {
        return getOperationRequestInfo(request[originalRequestSymbol]);
      }
      let info2 = state_js_1.state.operationRequestMap.get(request);
      if (!info2) {
        info2 = {};
        state_js_1.state.operationRequestMap.set(request, info2);
      }
      return info2;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/deserializationPolicy.js
var require_deserializationPolicy = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/deserializationPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializationPolicyName = void 0;
    exports.deserializationPolicy = deserializationPolicy;
    var interfaces_js_1 = require_interfaces();
    var core_rest_pipeline_1 = require_commonjs6();
    var serializer_js_1 = require_serializer();
    var operationHelpers_js_1 = require_operationHelpers();
    var defaultJsonContentTypes = ["application/json", "text/json"];
    var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
    exports.deserializationPolicyName = "deserializationPolicy";
    function deserializationPolicy(options = {}) {
      const jsonContentTypes = options.expectedContentTypes?.json ?? defaultJsonContentTypes;
      const xmlContentTypes = options.expectedContentTypes?.xml ?? defaultXmlContentTypes;
      const parseXML = options.parseXML;
      const serializerOptions = options.serializerOptions;
      const updatedOptions = {
        xml: {
          rootName: serializerOptions?.xml.rootName ?? "",
          includeRoot: serializerOptions?.xml.includeRoot ?? false,
          xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        }
      };
      return {
        name: exports.deserializationPolicyName,
        async sendRequest(request, next) {
          const response = await next(request);
          return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
        }
      };
    }
    function getOperationResponseMap(parsedResponse) {
      let result;
      const request = parsedResponse.request;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
      const operationSpec = operationInfo?.operationSpec;
      if (operationSpec) {
        if (!operationInfo?.operationResponseGetter) {
          result = operationSpec.responses[parsedResponse.status];
        } else {
          result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);
        }
      }
      return result;
    }
    function shouldDeserializeResponse(parsedResponse) {
      const request = parsedResponse.request;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
      const shouldDeserialize = operationInfo?.shouldDeserialize;
      let result;
      if (shouldDeserialize === void 0) {
        result = true;
      } else if (typeof shouldDeserialize === "boolean") {
        result = shouldDeserialize;
      } else {
        result = shouldDeserialize(parsedResponse);
      }
      return result;
    }
    async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
      const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
      if (!shouldDeserializeResponse(parsedResponse)) {
        return parsedResponse;
      }
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request);
      const operationSpec = operationInfo?.operationSpec;
      if (!operationSpec || !operationSpec.responses) {
        return parsedResponse;
      }
      const responseSpec = getOperationResponseMap(parsedResponse);
      const { error: error2, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
      if (error2) {
        throw error2;
      } else if (shouldReturnResponse) {
        return parsedResponse;
      }
      if (responseSpec) {
        if (responseSpec.bodyMapper) {
          let valueToDeserialize = parsedResponse.parsedBody;
          if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
            valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
          }
          try {
            parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
          } catch (deserializeError) {
            const restError = new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
              statusCode: parsedResponse.status,
              request: parsedResponse.request,
              response: parsedResponse
            });
            throw restError;
          }
        } else if (operationSpec.httpMethod === "HEAD") {
          parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
        }
        if (responseSpec.headersMapper) {
          parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
        }
      }
      return parsedResponse;
    }
    function isOperationSpecEmpty(operationSpec) {
      const expectedStatusCodes = Object.keys(operationSpec.responses);
      return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
    }
    function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
      const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
      const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
      if (isExpectedStatusCode) {
        if (responseSpec) {
          if (!responseSpec.isError) {
            return { error: null, shouldReturnResponse: false };
          }
        } else {
          return { error: null, shouldReturnResponse: false };
        }
      }
      const errorResponseSpec = responseSpec ?? operationSpec.responses.default;
      const initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(parsedResponse.status) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
      const error2 = new core_rest_pipeline_1.RestError(initialErrorMessage, {
        statusCode: parsedResponse.status,
        request: parsedResponse.request,
        response: parsedResponse
      });
      if (!errorResponseSpec && !(parsedResponse.parsedBody?.error?.code && parsedResponse.parsedBody?.error?.message)) {
        throw error2;
      }
      const defaultBodyMapper = errorResponseSpec?.bodyMapper;
      const defaultHeadersMapper = errorResponseSpec?.headersMapper;
      try {
        if (parsedResponse.parsedBody) {
          const parsedBody = parsedResponse.parsedBody;
          let deserializedError;
          if (defaultBodyMapper) {
            let valueToDeserialize = parsedBody;
            if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
              valueToDeserialize = [];
              const elementName = defaultBodyMapper.xmlElementName;
              if (typeof parsedBody === "object" && elementName) {
                valueToDeserialize = parsedBody[elementName];
              }
            }
            deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
          }
          const internalError = parsedBody.error || deserializedError || parsedBody;
          error2.code = internalError.code;
          if (internalError.message) {
            error2.message = internalError.message;
          }
          if (defaultBodyMapper) {
            error2.response.parsedBody = deserializedError;
          }
        }
        if (parsedResponse.headers && defaultHeadersMapper) {
          error2.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
        }
      } catch (defaultError) {
        error2.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
      }
      return { error: error2, shouldReturnResponse: false };
    }
    async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
      if (!operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) && operationResponse.bodyAsText) {
        const text = operationResponse.bodyAsText;
        const contentType = operationResponse.headers.get("Content-Type") || "";
        const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
        try {
          if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
            operationResponse.parsedBody = JSON.parse(text);
            return operationResponse;
          } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
            if (!parseXML) {
              throw new Error("Parsing XML not supported.");
            }
            const body = await parseXML(text, opts.xml);
            operationResponse.parsedBody = body;
            return operationResponse;
          }
        } catch (err) {
          const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
          const errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
          const e = new core_rest_pipeline_1.RestError(msg, {
            code: errCode,
            statusCode: operationResponse.status,
            request: operationResponse.request,
            response: operationResponse
          });
          throw e;
        }
      }
      return operationResponse;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaceHelpers.js
var require_interfaceHelpers = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/interfaceHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
    exports.getPathStringFromParameter = getPathStringFromParameter;
    var serializer_js_1 = require_serializer();
    function getStreamingResponseStatusCodes(operationSpec) {
      const result = /* @__PURE__ */ new Set();
      for (const statusCode in operationSpec.responses) {
        const operationResponse = operationSpec.responses[statusCode];
        if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream) {
          result.add(Number(statusCode));
        }
      }
      return result;
    }
    function getPathStringFromParameter(parameter) {
      const { parameterPath, mapper } = parameter;
      let result;
      if (typeof parameterPath === "string") {
        result = parameterPath;
      } else if (Array.isArray(parameterPath)) {
        result = parameterPath.join(".");
      } else {
        result = mapper.serializedName;
      }
      return result;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializationPolicy.js
var require_serializationPolicy = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/serializationPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializationPolicyName = void 0;
    exports.serializationPolicy = serializationPolicy;
    exports.serializeHeaders = serializeHeaders;
    exports.serializeRequestBody = serializeRequestBody;
    var interfaces_js_1 = require_interfaces();
    var operationHelpers_js_1 = require_operationHelpers();
    var serializer_js_1 = require_serializer();
    var interfaceHelpers_js_1 = require_interfaceHelpers();
    exports.serializationPolicyName = "serializationPolicy";
    function serializationPolicy(options = {}) {
      const stringifyXML = options.stringifyXML;
      return {
        name: exports.serializationPolicyName,
        async sendRequest(request, next) {
          const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
          const operationSpec = operationInfo?.operationSpec;
          const operationArguments = operationInfo?.operationArguments;
          if (operationSpec && operationArguments) {
            serializeHeaders(request, operationArguments, operationSpec);
            serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
          }
          return next(request);
        }
      };
    }
    function serializeHeaders(request, operationArguments, operationSpec) {
      if (operationSpec.headerParameters) {
        for (const headerParameter of operationSpec.headerParameters) {
          let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
          if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
            headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
            const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
            if (headerCollectionPrefix) {
              for (const key of Object.keys(headerValue)) {
                request.headers.set(headerCollectionPrefix + key, headerValue[key]);
              }
            } else {
              request.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
            }
          }
        }
      }
      const customHeaders = operationArguments.options?.requestOptions?.customHeaders;
      if (customHeaders) {
        for (const customHeaderName of Object.keys(customHeaders)) {
          request.headers.set(customHeaderName, customHeaders[customHeaderName]);
        }
      }
    }
    function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function() {
      throw new Error("XML serialization unsupported!");
    }) {
      const serializerOptions = operationArguments.options?.serializerOptions;
      const updatedOptions = {
        xml: {
          rootName: serializerOptions?.xml.rootName ?? "",
          includeRoot: serializerOptions?.xml.includeRoot ?? false,
          xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        }
      };
      const xmlCharKey = updatedOptions.xml.xmlCharKey;
      if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
        request.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
        const bodyMapper = operationSpec.requestBody.mapper;
        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
        const typeName = bodyMapper.type.name;
        try {
          if (request.body !== void 0 && request.body !== null || nullable && request.body === null || required) {
            const requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
            request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
            const isStream2 = typeName === serializer_js_1.MapperTypeNames.Stream;
            if (operationSpec.isXML) {
              const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
              const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
              if (typeName === serializer_js_1.MapperTypeNames.Sequence) {
                request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
              } else if (!isStream2) {
                request.body = stringifyXML(value, {
                  rootName: xmlName || serializedName,
                  xmlCharKey
                });
              }
            } else if (typeName === serializer_js_1.MapperTypeNames.String && (operationSpec.contentType?.match("text/plain") || operationSpec.mediaType === "text")) {
              return;
            } else if (!isStream2) {
              request.body = JSON.stringify(request.body);
            }
          }
        } catch (error2) {
          throw new Error(`Error "${error2.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
        }
      } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
        request.formData = {};
        for (const formDataParameter of operationSpec.formDataParameters) {
          const formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
          if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
            const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
            request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
          }
        }
      }
    }
    function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
      if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
        const result = {};
        result[options.xml.xmlCharKey] = serializedValue;
        result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
        return result;
      }
      return serializedValue;
    }
    function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
      if (!Array.isArray(obj)) {
        obj = [obj];
      }
      if (!xmlNamespaceKey || !xmlNamespace) {
        return { [elementName]: obj };
      }
      const result = { [elementName]: obj };
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
      return result;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/pipeline.js
var require_pipeline3 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/pipeline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createClientPipeline = createClientPipeline;
    var deserializationPolicy_js_1 = require_deserializationPolicy();
    var core_rest_pipeline_1 = require_commonjs6();
    var serializationPolicy_js_1 = require_serializationPolicy();
    function createClientPipeline(options = {}) {
      const pipeline = (0, core_rest_pipeline_1.createPipelineFromOptions)(options ?? {});
      if (options.credentialOptions) {
        pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
          credential: options.credentialOptions.credential,
          scopes: options.credentialOptions.credentialScopes
        }));
      }
      pipeline.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options.serializationOptions), { phase: "Serialize" });
      pipeline.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options.deserializationOptions), {
        phase: "Deserialize"
      });
      return pipeline;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/httpClientCache.js
var require_httpClientCache = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/httpClientCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
    var core_rest_pipeline_1 = require_commonjs6();
    var cachedHttpClient;
    function getCachedDefaultHttpClient() {
      if (!cachedHttpClient) {
        cachedHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
      }
      return cachedHttpClient;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/urlHelpers.js
var require_urlHelpers2 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/urlHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRequestUrl = getRequestUrl;
    exports.appendQueryParams = appendQueryParams;
    var operationHelpers_js_1 = require_operationHelpers();
    var interfaceHelpers_js_1 = require_interfaceHelpers();
    var CollectionFormatToDelimiterMap = {
      CSV: ",",
      SSV: " ",
      Multi: "Multi",
      TSV: "	",
      Pipes: "|"
    };
    function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
      const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
      let isAbsolutePath = false;
      let requestUrl = replaceAll(baseUri, urlReplacements);
      if (operationSpec.path) {
        let path2 = replaceAll(operationSpec.path, urlReplacements);
        if (operationSpec.path === "/{nextLink}" && path2.startsWith("/")) {
          path2 = path2.substring(1);
        }
        if (isAbsoluteUrl(path2)) {
          requestUrl = path2;
          isAbsolutePath = true;
        } else {
          requestUrl = appendPath(requestUrl, path2);
        }
      }
      const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
      requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
      return requestUrl;
    }
    function replaceAll(input, replacements) {
      let result = input;
      for (const [searchValue, replaceValue] of replacements) {
        result = result.split(searchValue).join(replaceValue);
      }
      return result;
    }
    function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
      const result = /* @__PURE__ */ new Map();
      if (operationSpec.urlParameters?.length) {
        for (const urlParameter of operationSpec.urlParameters) {
          let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
          const parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
          urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
          if (!urlParameter.skipEncoding) {
            urlParameterValue = encodeURIComponent(urlParameterValue);
          }
          result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
        }
      }
      return result;
    }
    function isAbsoluteUrl(url) {
      return url.includes("://");
    }
    function appendPath(url, pathToAppend) {
      if (!pathToAppend) {
        return url;
      }
      const parsedUrl = new URL(url);
      let newPath = parsedUrl.pathname;
      if (!newPath.endsWith("/")) {
        newPath = `${newPath}/`;
      }
      if (pathToAppend.startsWith("/")) {
        pathToAppend = pathToAppend.substring(1);
      }
      const searchStart = pathToAppend.indexOf("?");
      if (searchStart !== -1) {
        const path2 = pathToAppend.substring(0, searchStart);
        const search = pathToAppend.substring(searchStart + 1);
        newPath = newPath + path2;
        if (search) {
          parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
        }
      } else {
        newPath = newPath + pathToAppend;
      }
      parsedUrl.pathname = newPath;
      return parsedUrl.toString();
    }
    function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
      const result = /* @__PURE__ */ new Map();
      const sequenceParams = /* @__PURE__ */ new Set();
      if (operationSpec.queryParameters?.length) {
        for (const queryParameter of operationSpec.queryParameters) {
          if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
            sequenceParams.add(queryParameter.mapper.serializedName);
          }
          let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
          if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
            queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
            const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
            if (Array.isArray(queryParameterValue)) {
              queryParameterValue = queryParameterValue.map((item) => {
                if (item === null || item === void 0) {
                  return "";
                }
                return item;
              });
            }
            if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
              continue;
            } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
              queryParameterValue = queryParameterValue.join(delimiter);
            }
            if (!queryParameter.skipEncoding) {
              if (Array.isArray(queryParameterValue)) {
                queryParameterValue = queryParameterValue.map((item) => {
                  return encodeURIComponent(item);
                });
              } else {
                queryParameterValue = encodeURIComponent(queryParameterValue);
              }
            }
            if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
              queryParameterValue = queryParameterValue.join(delimiter);
            }
            result.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
          }
        }
      }
      return {
        queryParams: result,
        sequenceParams
      };
    }
    function simpleParseQueryParams(queryString) {
      const result = /* @__PURE__ */ new Map();
      if (!queryString || queryString[0] !== "?") {
        return result;
      }
      queryString = queryString.slice(1);
      const pairs = queryString.split("&");
      for (const pair of pairs) {
        const [name, value] = pair.split("=", 2);
        const existingValue = result.get(name);
        if (existingValue) {
          if (Array.isArray(existingValue)) {
            existingValue.push(value);
          } else {
            result.set(name, [existingValue, value]);
          }
        } else {
          result.set(name, value);
        }
      }
      return result;
    }
    function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
      if (queryParams.size === 0) {
        return url;
      }
      const parsedUrl = new URL(url);
      const combinedParams = simpleParseQueryParams(parsedUrl.search);
      for (const [name, value] of queryParams) {
        const existingValue = combinedParams.get(name);
        if (Array.isArray(existingValue)) {
          if (Array.isArray(value)) {
            existingValue.push(...value);
            const valueSet = new Set(existingValue);
            combinedParams.set(name, Array.from(valueSet));
          } else {
            existingValue.push(value);
          }
        } else if (existingValue) {
          if (Array.isArray(value)) {
            value.unshift(existingValue);
          } else if (sequenceParams.has(name)) {
            combinedParams.set(name, [existingValue, value]);
          }
          if (!noOverwrite) {
            combinedParams.set(name, value);
          }
        } else {
          combinedParams.set(name, value);
        }
      }
      const searchPieces = [];
      for (const [name, value] of combinedParams) {
        if (typeof value === "string") {
          searchPieces.push(`${name}=${value}`);
        } else if (Array.isArray(value)) {
          for (const subValue of value) {
            searchPieces.push(`${name}=${subValue}`);
          }
        } else {
          searchPieces.push(`${name}=${value}`);
        }
      }
      parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
      return parsedUrl.toString();
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/log.js
var require_log4 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = void 0;
    var logger_1 = require_commonjs2();
    exports.logger = (0, logger_1.createClientLogger)("core-client");
  }
});

// node_modules/@azure/core-client/dist/commonjs/serviceClient.js
var require_serviceClient = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/serviceClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServiceClient = void 0;
    var core_rest_pipeline_1 = require_commonjs6();
    var pipeline_js_1 = require_pipeline3();
    var utils_js_1 = require_utils3();
    var httpClientCache_js_1 = require_httpClientCache();
    var operationHelpers_js_1 = require_operationHelpers();
    var urlHelpers_js_1 = require_urlHelpers2();
    var interfaceHelpers_js_1 = require_interfaceHelpers();
    var log_js_1 = require_log4();
    var ServiceClient = class {
      /**
       * If specified, this is the base URI that requests will be made against for this ServiceClient.
       * If it is not specified, then all OperationSpecs must contain a baseUrl property.
       */
      _endpoint;
      /**
       * The default request content type for the service.
       * Used if no requestContentType is present on an OperationSpec.
       */
      _requestContentType;
      /**
       * Set to true if the request is sent over HTTP instead of HTTPS
       */
      _allowInsecureConnection;
      /**
       * The HTTP client that will be used to send requests.
       */
      _httpClient;
      /**
       * The pipeline used by this client to make requests
       */
      pipeline;
      /**
       * The ServiceClient constructor
       * @param options - The service client options that govern the behavior of the client.
       */
      constructor(options = {}) {
        this._requestContentType = options.requestContentType;
        this._endpoint = options.endpoint ?? options.baseUri;
        if (options.baseUri) {
          log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        }
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)();
        this.pipeline = options.pipeline || createDefaultPipeline(options);
        if (options.additionalPolicies?.length) {
          for (const { policy, position } of options.additionalPolicies) {
            const afterPhase = position === "perRetry" ? "Sign" : void 0;
            this.pipeline.addPolicy(policy, {
              afterPhase
            });
          }
        }
      }
      /**
       * Send the provided httpRequest.
       */
      async sendRequest(request) {
        return this.pipeline.sendRequest(this._httpClient, request);
      }
      /**
       * Send an HTTP request that is populated using the provided OperationSpec.
       * @typeParam T - The typed result of the request, based on the OperationSpec.
       * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
       * @param operationSpec - The OperationSpec to use to populate the httpRequest.
       */
      async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint = operationSpec.baseUrl || this._endpoint;
        if (!endpoint) {
          throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        }
        const url = (0, urlHelpers_js_1.getRequestUrl)(endpoint, operationSpec, operationArguments, this);
        const request = (0, core_rest_pipeline_1.createPipelineRequest)({
          url
        });
        request.method = operationSpec.httpMethod;
        const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType = operationSpec.contentType || this._requestContentType;
        if (contentType && operationSpec.requestBody) {
          request.headers.set("Content-Type", contentType);
        }
        const options = operationArguments.options;
        if (options) {
          const requestOptions = options.requestOptions;
          if (requestOptions) {
            if (requestOptions.timeout) {
              request.timeout = requestOptions.timeout;
            }
            if (requestOptions.onUploadProgress) {
              request.onUploadProgress = requestOptions.onUploadProgress;
            }
            if (requestOptions.onDownloadProgress) {
              request.onDownloadProgress = requestOptions.onDownloadProgress;
            }
            if (requestOptions.shouldDeserialize !== void 0) {
              operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
            }
            if (requestOptions.allowInsecureConnection) {
              request.allowInsecureConnection = true;
            }
          }
          if (options.abortSignal) {
            request.abortSignal = options.abortSignal;
          }
          if (options.tracingOptions) {
            request.tracingOptions = options.tracingOptions;
          }
        }
        if (this._allowInsecureConnection) {
          request.allowInsecureConnection = true;
        }
        if (request.streamResponseStatusCodes === void 0) {
          request.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
        }
        try {
          const rawResponse = await this.sendRequest(request);
          const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
          if (options?.onResponse) {
            options.onResponse(rawResponse, flatResponse);
          }
          return flatResponse;
        } catch (error2) {
          if (typeof error2 === "object" && error2?.response) {
            const rawResponse = error2.response;
            const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error2.statusCode] || operationSpec.responses["default"]);
            error2.details = flatResponse;
            if (options?.onResponse) {
              options.onResponse(rawResponse, flatResponse, error2);
            }
          }
          throw error2;
        }
      }
    };
    exports.ServiceClient = ServiceClient;
    function createDefaultPipeline(options) {
      const credentialScopes = getCredentialScopes(options);
      const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
      return (0, pipeline_js_1.createClientPipeline)({
        ...options,
        credentialOptions
      });
    }
    function getCredentialScopes(options) {
      if (options.credentialScopes) {
        return options.credentialScopes;
      }
      if (options.endpoint) {
        return `${options.endpoint}/.default`;
      }
      if (options.baseUri) {
        return `${options.baseUri}/.default`;
      }
      if (options.credential && !options.credentialScopes) {
        throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
      }
      return void 0;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnClaimChallenge.js
var require_authorizeRequestOnClaimChallenge = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnClaimChallenge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCAEChallenge = parseCAEChallenge;
    exports.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
    var log_js_1 = require_log4();
    var base64_js_1 = require_base64();
    function parseCAEChallenge(challenges) {
      const bearerChallenges = `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x);
      return bearerChallenges.map((challenge) => {
        const challengeParts = `${challenge.trim()}, `.split('", ').filter((x) => x);
        const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="')));
        return keyValuePairs.reduce((a2, b) => ({ ...a2, ...b }), {});
      });
    }
    async function authorizeRequestOnClaimChallenge(onChallengeOptions) {
      const { scopes, response } = onChallengeOptions;
      const logger = onChallengeOptions.logger || log_js_1.logger;
      const challenge = response.headers.get("WWW-Authenticate");
      if (!challenge) {
        logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
        return false;
      }
      const challenges = parseCAEChallenge(challenge) || [];
      const parsedChallenge = challenges.find((x) => x.claims);
      if (!parsedChallenge) {
        logger.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
        return false;
      }
      const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
        claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims)
      });
      if (!accessToken) {
        return false;
      }
      onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
      return true;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnTenantChallenge.js
var require_authorizeRequestOnTenantChallenge = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnTenantChallenge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authorizeRequestOnTenantChallenge = void 0;
    var Constants = {
      DefaultScope: "/.default",
      /**
       * Defines constants for use with HTTP headers.
       */
      HeaderConstants: {
        /**
         * The Authorization header.
         */
        AUTHORIZATION: "authorization"
      }
    };
    function isUuid(text) {
      return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
    }
    var authorizeRequestOnTenantChallenge = async (challengeOptions) => {
      const requestOptions = requestToOptions(challengeOptions.request);
      const challenge = getChallenge(challengeOptions.response);
      if (challenge) {
        const challengeInfo = parseChallenge(challenge);
        const challengeScopes = buildScopes(challengeOptions, challengeInfo);
        const tenantId = extractTenantId(challengeInfo);
        if (!tenantId) {
          return false;
        }
        const accessToken = await challengeOptions.getAccessToken(challengeScopes, {
          ...requestOptions,
          tenantId
        });
        if (!accessToken) {
          return false;
        }
        challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
        return true;
      }
      return false;
    };
    exports.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge;
    function extractTenantId(challengeInfo) {
      const parsedAuthUri = new URL(challengeInfo.authorization_uri);
      const pathSegments = parsedAuthUri.pathname.split("/");
      const tenantId = pathSegments[1];
      if (tenantId && isUuid(tenantId)) {
        return tenantId;
      }
      return void 0;
    }
    function buildScopes(challengeOptions, challengeInfo) {
      if (!challengeInfo.resource_id) {
        return challengeOptions.scopes;
      }
      const challengeScopes = new URL(challengeInfo.resource_id);
      challengeScopes.pathname = Constants.DefaultScope;
      let scope = challengeScopes.toString();
      if (scope === "https://disk.azure.com/.default") {
        scope = "https://disk.azure.com//.default";
      }
      return [scope];
    }
    function getChallenge(response) {
      const challenge = response.headers.get("WWW-Authenticate");
      if (response.status === 401 && challenge) {
        return challenge;
      }
      return;
    }
    function parseChallenge(challenge) {
      const bearerChallenge = challenge.slice("Bearer ".length);
      const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x) => x);
      const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
      return keyValuePairs.reduce((a2, b) => ({ ...a2, ...b }), {});
    }
    function requestToOptions(request) {
      return {
        abortSignal: request.abortSignal,
        requestOptions: {
          timeout: request.timeout
        },
        tracingOptions: request.tracingOptions
      };
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/index.js
var require_commonjs8 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authorizeRequestOnTenantChallenge = exports.authorizeRequestOnClaimChallenge = exports.serializationPolicyName = exports.serializationPolicy = exports.deserializationPolicyName = exports.deserializationPolicy = exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.createClientPipeline = exports.ServiceClient = exports.MapperTypeNames = exports.createSerializer = void 0;
    var serializer_js_1 = require_serializer();
    Object.defineProperty(exports, "createSerializer", { enumerable: true, get: function() {
      return serializer_js_1.createSerializer;
    } });
    Object.defineProperty(exports, "MapperTypeNames", { enumerable: true, get: function() {
      return serializer_js_1.MapperTypeNames;
    } });
    var serviceClient_js_1 = require_serviceClient();
    Object.defineProperty(exports, "ServiceClient", { enumerable: true, get: function() {
      return serviceClient_js_1.ServiceClient;
    } });
    var pipeline_js_1 = require_pipeline3();
    Object.defineProperty(exports, "createClientPipeline", { enumerable: true, get: function() {
      return pipeline_js_1.createClientPipeline;
    } });
    var interfaces_js_1 = require_interfaces();
    Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
      return interfaces_js_1.XML_ATTRKEY;
    } });
    Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
      return interfaces_js_1.XML_CHARKEY;
    } });
    var deserializationPolicy_js_1 = require_deserializationPolicy();
    Object.defineProperty(exports, "deserializationPolicy", { enumerable: true, get: function() {
      return deserializationPolicy_js_1.deserializationPolicy;
    } });
    Object.defineProperty(exports, "deserializationPolicyName", { enumerable: true, get: function() {
      return deserializationPolicy_js_1.deserializationPolicyName;
    } });
    var serializationPolicy_js_1 = require_serializationPolicy();
    Object.defineProperty(exports, "serializationPolicy", { enumerable: true, get: function() {
      return serializationPolicy_js_1.serializationPolicy;
    } });
    Object.defineProperty(exports, "serializationPolicyName", { enumerable: true, get: function() {
      return serializationPolicy_js_1.serializationPolicyName;
    } });
    var authorizeRequestOnClaimChallenge_js_1 = require_authorizeRequestOnClaimChallenge();
    Object.defineProperty(exports, "authorizeRequestOnClaimChallenge", { enumerable: true, get: function() {
      return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge;
    } });
    var authorizeRequestOnTenantChallenge_js_1 = require_authorizeRequestOnTenantChallenge();
    Object.defineProperty(exports, "authorizeRequestOnTenantChallenge", { enumerable: true, get: function() {
      return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge;
    } });
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/util.js
var require_util8 = __commonJS({
  "node_modules/@azure/core-http-compat/dist/commonjs/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpHeaders = void 0;
    exports.toPipelineRequest = toPipelineRequest;
    exports.toWebResourceLike = toWebResourceLike;
    exports.toHttpHeadersLike = toHttpHeadersLike;
    var core_rest_pipeline_1 = require_commonjs6();
    var originalRequestSymbol = /* @__PURE__ */ Symbol("Original PipelineRequest");
    var originalClientRequestSymbol = /* @__PURE__ */ Symbol.for("@azure/core-client original request");
    function toPipelineRequest(webResource, options = {}) {
      const compatWebResource = webResource;
      const request = compatWebResource[originalRequestSymbol];
      const headers = (0, core_rest_pipeline_1.createHttpHeaders)(webResource.headers.toJson({ preserveCase: true }));
      if (request) {
        request.headers = headers;
        return request;
      } else {
        const newRequest = (0, core_rest_pipeline_1.createPipelineRequest)({
          url: webResource.url,
          method: webResource.method,
          headers,
          withCredentials: webResource.withCredentials,
          timeout: webResource.timeout,
          requestId: webResource.requestId,
          abortSignal: webResource.abortSignal,
          body: webResource.body,
          formData: webResource.formData,
          disableKeepAlive: !!webResource.keepAlive,
          onDownloadProgress: webResource.onDownloadProgress,
          onUploadProgress: webResource.onUploadProgress,
          proxySettings: webResource.proxySettings,
          streamResponseStatusCodes: webResource.streamResponseStatusCodes,
          agent: webResource.agent,
          requestOverrides: webResource.requestOverrides
        });
        if (options.originalRequest) {
          newRequest[originalClientRequestSymbol] = options.originalRequest;
        }
        return newRequest;
      }
    }
    function toWebResourceLike(request, options) {
      const originalRequest = options?.originalRequest ?? request;
      const webResource = {
        url: request.url,
        method: request.method,
        headers: toHttpHeadersLike(request.headers),
        withCredentials: request.withCredentials,
        timeout: request.timeout,
        requestId: request.headers.get("x-ms-client-request-id") || request.requestId,
        abortSignal: request.abortSignal,
        body: request.body,
        formData: request.formData,
        keepAlive: !!request.disableKeepAlive,
        onDownloadProgress: request.onDownloadProgress,
        onUploadProgress: request.onUploadProgress,
        proxySettings: request.proxySettings,
        streamResponseStatusCodes: request.streamResponseStatusCodes,
        agent: request.agent,
        requestOverrides: request.requestOverrides,
        clone() {
          throw new Error("Cannot clone a non-proxied WebResourceLike");
        },
        prepare() {
          throw new Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
        },
        validateRequestProperties() {
        }
      };
      if (options?.createProxy) {
        return new Proxy(webResource, {
          get(target, prop, receiver) {
            if (prop === originalRequestSymbol) {
              return request;
            } else if (prop === "clone") {
              return () => {
                return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {
                  createProxy: true,
                  originalRequest
                });
              };
            }
            return Reflect.get(target, prop, receiver);
          },
          set(target, prop, value, receiver) {
            if (prop === "keepAlive") {
              request.disableKeepAlive = !value;
            }
            const passThroughProps = [
              "url",
              "method",
              "withCredentials",
              "timeout",
              "requestId",
              "abortSignal",
              "body",
              "formData",
              "onDownloadProgress",
              "onUploadProgress",
              "proxySettings",
              "streamResponseStatusCodes",
              "agent",
              "requestOverrides"
            ];
            if (typeof prop === "string" && passThroughProps.includes(prop)) {
              request[prop] = value;
            }
            return Reflect.set(target, prop, value, receiver);
          }
        });
      } else {
        return webResource;
      }
    }
    function toHttpHeadersLike(headers) {
      return new HttpHeaders(headers.toJSON({ preserveCase: true }));
    }
    function getHeaderKey(headerName) {
      return headerName.toLowerCase();
    }
    var HttpHeaders = class _HttpHeaders {
      _headersMap;
      constructor(rawHeaders) {
        this._headersMap = {};
        if (rawHeaders) {
          for (const headerName in rawHeaders) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param headerName - The name of the header to set. This value is case-insensitive.
       * @param headerValue - The value of the header to set.
       */
      set(headerName, headerValue) {
        this._headersMap[getHeaderKey(headerName)] = {
          name: headerName,
          value: headerValue.toString()
        };
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param headerName - The name of the header.
       */
      get(headerName) {
        const header = this._headersMap[getHeaderKey(headerName)];
        return !header ? void 0 : header.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       */
      contains(headerName) {
        return !!this._headersMap[getHeaderKey(headerName)];
      }
      /**
       * Remove the header with the provided headerName. Return whether or not the header existed and
       * was removed.
       * @param headerName - The name of the header to remove.
       */
      remove(headerName) {
        const result = this.contains(headerName);
        delete this._headersMap[getHeaderKey(headerName)];
        return result;
      }
      /**
       * Get the headers that are contained this collection as an object.
       */
      rawHeaders() {
        return this.toJson({ preserveCase: true });
      }
      /**
       * Get the headers that are contained in this collection as an array.
       */
      headersArray() {
        const headers = [];
        for (const headerKey in this._headersMap) {
          headers.push(this._headersMap[headerKey]);
        }
        return headers;
      }
      /**
       * Get the header names that are contained in this collection.
       */
      headerNames() {
        const headerNames = [];
        const headers = this.headersArray();
        for (let i2 = 0; i2 < headers.length; ++i2) {
          headerNames.push(headers[i2].name);
        }
        return headerNames;
      }
      /**
       * Get the header values that are contained in this collection.
       */
      headerValues() {
        const headerValues = [];
        const headers = this.headersArray();
        for (let i2 = 0; i2 < headers.length; ++i2) {
          headerValues.push(headers[i2].value);
        }
        return headerValues;
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJson(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const headerKey in this._headersMap) {
            const header = this._headersMap[headerKey];
            result[header.name] = header.value;
          }
        } else {
          for (const headerKey in this._headersMap) {
            const header = this._headersMap[headerKey];
            result[getHeaderKey(header.name)] = header.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJson({ preserveCase: true }));
      }
      /**
       * Create a deep clone/copy of this HttpHeaders collection.
       */
      clone() {
        const resultPreservingCasing = {};
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          resultPreservingCasing[header.name] = header.value;
        }
        return new _HttpHeaders(resultPreservingCasing);
      }
    };
    exports.HttpHeaders = HttpHeaders;
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/response.js
var require_response2 = __commonJS({
  "node_modules/@azure/core-http-compat/dist/commonjs/response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCompatResponse = toCompatResponse;
    exports.toPipelineResponse = toPipelineResponse;
    var core_rest_pipeline_1 = require_commonjs6();
    var util_js_1 = require_util8();
    var originalResponse = /* @__PURE__ */ Symbol("Original FullOperationResponse");
    function toCompatResponse(response, options) {
      let request = (0, util_js_1.toWebResourceLike)(response.request);
      let headers = (0, util_js_1.toHttpHeadersLike)(response.headers);
      if (options?.createProxy) {
        return new Proxy(response, {
          get(target, prop, receiver) {
            if (prop === "headers") {
              return headers;
            } else if (prop === "request") {
              return request;
            } else if (prop === originalResponse) {
              return response;
            }
            return Reflect.get(target, prop, receiver);
          },
          set(target, prop, value, receiver) {
            if (prop === "headers") {
              headers = value;
            } else if (prop === "request") {
              request = value;
            }
            return Reflect.set(target, prop, value, receiver);
          }
        });
      } else {
        return {
          ...response,
          request,
          headers
        };
      }
    }
    function toPipelineResponse(compatResponse) {
      const extendedCompatResponse = compatResponse;
      const response = extendedCompatResponse[originalResponse];
      const headers = (0, core_rest_pipeline_1.createHttpHeaders)(compatResponse.headers.toJson({ preserveCase: true }));
      if (response) {
        response.headers = headers;
        return response;
      } else {
        return {
          ...compatResponse,
          headers,
          request: (0, util_js_1.toPipelineRequest)(compatResponse.request)
        };
      }
    }
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/extendedClient.js
var require_extendedClient = __commonJS({
  "node_modules/@azure/core-http-compat/dist/commonjs/extendedClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendedServiceClient = void 0;
    var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
    var core_rest_pipeline_1 = require_commonjs6();
    var core_client_1 = require_commonjs8();
    var response_js_1 = require_response2();
    var ExtendedServiceClient = class extends core_client_1.ServiceClient {
      constructor(options) {
        super(options);
        if (options.keepAliveOptions?.enable === false && !(0, disableKeepAlivePolicy_js_1.pipelineContainsDisableKeepAlivePolicy)(this.pipeline)) {
          this.pipeline.addPolicy((0, disableKeepAlivePolicy_js_1.createDisableKeepAlivePolicy)());
        }
        if (options.redirectOptions?.handleRedirects === false) {
          this.pipeline.removePolicy({
            name: core_rest_pipeline_1.redirectPolicyName
          });
        }
      }
      /**
       * Compatible send operation request function.
       *
       * @param operationArguments - Operation arguments
       * @param operationSpec - Operation Spec
       * @returns
       */
      async sendOperationRequest(operationArguments, operationSpec) {
        const userProvidedCallBack = operationArguments?.options?.onResponse;
        let lastResponse;
        function onResponse(rawResponse, flatResponse, error2) {
          lastResponse = rawResponse;
          if (userProvidedCallBack) {
            userProvidedCallBack(rawResponse, flatResponse, error2);
          }
        }
        operationArguments.options = {
          ...operationArguments.options,
          onResponse
        };
        const result = await super.sendOperationRequest(operationArguments, operationSpec);
        if (lastResponse) {
          Object.defineProperty(result, "_response", {
            value: (0, response_js_1.toCompatResponse)(lastResponse)
          });
        }
        return result;
      }
    };
    exports.ExtendedServiceClient = ExtendedServiceClient;
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/requestPolicyFactoryPolicy.js
var require_requestPolicyFactoryPolicy = __commonJS({
  "node_modules/@azure/core-http-compat/dist/commonjs/policies/requestPolicyFactoryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestPolicyFactoryPolicyName = exports.HttpPipelineLogLevel = void 0;
    exports.createRequestPolicyFactoryPolicy = createRequestPolicyFactoryPolicy;
    var util_js_1 = require_util8();
    var response_js_1 = require_response2();
    var HttpPipelineLogLevel;
    (function(HttpPipelineLogLevel2) {
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["ERROR"] = 1] = "ERROR";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["INFO"] = 3] = "INFO";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["OFF"] = 0] = "OFF";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["WARNING"] = 2] = "WARNING";
    })(HttpPipelineLogLevel || (exports.HttpPipelineLogLevel = HttpPipelineLogLevel = {}));
    var mockRequestPolicyOptions = {
      log(_logLevel, _message) {
      },
      shouldLog(_logLevel) {
        return false;
      }
    };
    exports.requestPolicyFactoryPolicyName = "RequestPolicyFactoryPolicy";
    function createRequestPolicyFactoryPolicy(factories) {
      const orderedFactories = factories.slice().reverse();
      return {
        name: exports.requestPolicyFactoryPolicyName,
        async sendRequest(request, next) {
          let httpPipeline = {
            async sendRequest(httpRequest) {
              const response2 = await next((0, util_js_1.toPipelineRequest)(httpRequest));
              return (0, response_js_1.toCompatResponse)(response2, { createProxy: true });
            }
          };
          for (const factory of orderedFactories) {
            httpPipeline = factory.create(httpPipeline, mockRequestPolicyOptions);
          }
          const webResourceLike = (0, util_js_1.toWebResourceLike)(request, { createProxy: true });
          const response = await httpPipeline.sendRequest(webResourceLike);
          return (0, response_js_1.toPipelineResponse)(response);
        }
      };
    }
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/httpClientAdapter.js
var require_httpClientAdapter = __commonJS({
  "node_modules/@azure/core-http-compat/dist/commonjs/httpClientAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertHttpClient = convertHttpClient;
    var response_js_1 = require_response2();
    var util_js_1 = require_util8();
    function convertHttpClient(requestPolicyClient) {
      return {
        sendRequest: async (request) => {
          const response = await requestPolicyClient.sendRequest((0, util_js_1.toWebResourceLike)(request, { createProxy: true }));
          return (0, response_js_1.toPipelineResponse)(response);
        }
      };
    }
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/index.js
var require_commonjs9 = __commonJS({
  "node_modules/@azure/core-http-compat/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHttpHeadersLike = exports.convertHttpClient = exports.disableKeepAlivePolicyName = exports.HttpPipelineLogLevel = exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.ExtendedServiceClient = void 0;
    var extendedClient_js_1 = require_extendedClient();
    Object.defineProperty(exports, "ExtendedServiceClient", { enumerable: true, get: function() {
      return extendedClient_js_1.ExtendedServiceClient;
    } });
    var requestPolicyFactoryPolicy_js_1 = require_requestPolicyFactoryPolicy();
    Object.defineProperty(exports, "requestPolicyFactoryPolicyName", { enumerable: true, get: function() {
      return requestPolicyFactoryPolicy_js_1.requestPolicyFactoryPolicyName;
    } });
    Object.defineProperty(exports, "createRequestPolicyFactoryPolicy", { enumerable: true, get: function() {
      return requestPolicyFactoryPolicy_js_1.createRequestPolicyFactoryPolicy;
    } });
    Object.defineProperty(exports, "HttpPipelineLogLevel", { enumerable: true, get: function() {
      return requestPolicyFactoryPolicy_js_1.HttpPipelineLogLevel;
    } });
    var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
    Object.defineProperty(exports, "disableKeepAlivePolicyName", { enumerable: true, get: function() {
      return disableKeepAlivePolicy_js_1.disableKeepAlivePolicyName;
    } });
    var httpClientAdapter_js_1 = require_httpClientAdapter();
    Object.defineProperty(exports, "convertHttpClient", { enumerable: true, get: function() {
      return httpClientAdapter_js_1.convertHttpClient;
    } });
    var util_js_1 = require_util8();
    Object.defineProperty(exports, "toHttpHeadersLike", { enumerable: true, get: function() {
      return util_js_1.toHttpHeadersLike;
    } });
  }
});

// node_modules/fast-xml-parser/lib/fxp.cjs
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/lib/fxp.cjs"(exports, module) {
    "use strict";
    (() => {
      "use strict";
      var t = { d: (e2, i3) => {
        for (var n3 in i3) t.o(i3, n3) && !t.o(e2, n3) && Object.defineProperty(e2, n3, { enumerable: true, get: i3[n3] });
      }, o: (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r: (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      } }, e = {};
      t.r(e), t.d(e, { XMLBuilder: () => lt, XMLParser: () => tt, XMLValidator: () => pt });
      const i2 = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", n2 = new RegExp("^[" + i2 + "][" + i2 + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
      function s(t2, e2) {
        const i3 = [];
        let n3 = e2.exec(t2);
        for (; n3; ) {
          const s2 = [];
          s2.startIndex = e2.lastIndex - n3[0].length;
          const r2 = n3.length;
          for (let t3 = 0; t3 < r2; t3++) s2.push(n3[t3]);
          i3.push(s2), n3 = e2.exec(t2);
        }
        return i3;
      }
      const r = function(t2) {
        return !(null == n2.exec(t2));
      }, o2 = { allowBooleanAttributes: false, unpairedTags: [] };
      function a2(t2, e2) {
        e2 = Object.assign({}, o2, e2);
        const i3 = [];
        let n3 = false, s2 = false;
        "\uFEFF" === t2[0] && (t2 = t2.substr(1));
        for (let o3 = 0; o3 < t2.length; o3++) if ("<" === t2[o3] && "?" === t2[o3 + 1]) {
          if (o3 += 2, o3 = u2(t2, o3), o3.err) return o3;
        } else {
          if ("<" !== t2[o3]) {
            if (l(t2[o3])) continue;
            return x("InvalidChar", "char '" + t2[o3] + "' is not expected.", b(t2, o3));
          }
          {
            let a3 = o3;
            if (o3++, "!" === t2[o3]) {
              o3 = h2(t2, o3);
              continue;
            }
            {
              let d2 = false;
              "/" === t2[o3] && (d2 = true, o3++);
              let p2 = "";
              for (; o3 < t2.length && ">" !== t2[o3] && " " !== t2[o3] && "	" !== t2[o3] && "\n" !== t2[o3] && "\r" !== t2[o3]; o3++) p2 += t2[o3];
              if (p2 = p2.trim(), "/" === p2[p2.length - 1] && (p2 = p2.substring(0, p2.length - 1), o3--), !r(p2)) {
                let e3;
                return e3 = 0 === p2.trim().length ? "Invalid space after '<'." : "Tag '" + p2 + "' is an invalid name.", x("InvalidTag", e3, b(t2, o3));
              }
              const c4 = f(t2, o3);
              if (false === c4) return x("InvalidAttr", "Attributes for '" + p2 + "' have open quote.", b(t2, o3));
              let N2 = c4.value;
              if (o3 = c4.index, "/" === N2[N2.length - 1]) {
                const i4 = o3 - N2.length;
                N2 = N2.substring(0, N2.length - 1);
                const s3 = g(N2, e2);
                if (true !== s3) return x(s3.err.code, s3.err.msg, b(t2, i4 + s3.err.line));
                n3 = true;
              } else if (d2) {
                if (!c4.tagClosed) return x("InvalidTag", "Closing tag '" + p2 + "' doesn't have proper closing.", b(t2, o3));
                if (N2.trim().length > 0) return x("InvalidTag", "Closing tag '" + p2 + "' can't have attributes or invalid starting.", b(t2, a3));
                if (0 === i3.length) return x("InvalidTag", "Closing tag '" + p2 + "' has not been opened.", b(t2, a3));
                {
                  const e3 = i3.pop();
                  if (p2 !== e3.tagName) {
                    let i4 = b(t2, e3.tagStartPos);
                    return x("InvalidTag", "Expected closing tag '" + e3.tagName + "' (opened in line " + i4.line + ", col " + i4.col + ") instead of closing tag '" + p2 + "'.", b(t2, a3));
                  }
                  0 == i3.length && (s2 = true);
                }
              } else {
                const r2 = g(N2, e2);
                if (true !== r2) return x(r2.err.code, r2.err.msg, b(t2, o3 - N2.length + r2.err.line));
                if (true === s2) return x("InvalidXml", "Multiple possible root nodes found.", b(t2, o3));
                -1 !== e2.unpairedTags.indexOf(p2) || i3.push({ tagName: p2, tagStartPos: a3 }), n3 = true;
              }
              for (o3++; o3 < t2.length; o3++) if ("<" === t2[o3]) {
                if ("!" === t2[o3 + 1]) {
                  o3++, o3 = h2(t2, o3);
                  continue;
                }
                if ("?" !== t2[o3 + 1]) break;
                if (o3 = u2(t2, ++o3), o3.err) return o3;
              } else if ("&" === t2[o3]) {
                const e3 = m(t2, o3);
                if (-1 == e3) return x("InvalidChar", "char '&' is not expected.", b(t2, o3));
                o3 = e3;
              } else if (true === s2 && !l(t2[o3])) return x("InvalidXml", "Extra text at the end", b(t2, o3));
              "<" === t2[o3] && o3--;
            }
          }
        }
        return n3 ? 1 == i3.length ? x("InvalidTag", "Unclosed tag '" + i3[0].tagName + "'.", b(t2, i3[0].tagStartPos)) : !(i3.length > 0) || x("InvalidXml", "Invalid '" + JSON.stringify(i3.map(((t3) => t3.tagName)), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : x("InvalidXml", "Start tag expected.", 1);
      }
      function l(t2) {
        return " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2;
      }
      function u2(t2, e2) {
        const i3 = e2;
        for (; e2 < t2.length; e2++) if ("?" != t2[e2] && " " != t2[e2]) ;
        else {
          const n3 = t2.substr(i3, e2 - i3);
          if (e2 > 5 && "xml" === n3) return x("InvalidXml", "XML declaration allowed only at the start of the document.", b(t2, e2));
          if ("?" == t2[e2] && ">" == t2[e2 + 1]) {
            e2++;
            break;
          }
        }
        return e2;
      }
      function h2(t2, e2) {
        if (t2.length > e2 + 5 && "-" === t2[e2 + 1] && "-" === t2[e2 + 2]) {
          for (e2 += 3; e2 < t2.length; e2++) if ("-" === t2[e2] && "-" === t2[e2 + 1] && ">" === t2[e2 + 2]) {
            e2 += 2;
            break;
          }
        } else if (t2.length > e2 + 8 && "D" === t2[e2 + 1] && "O" === t2[e2 + 2] && "C" === t2[e2 + 3] && "T" === t2[e2 + 4] && "Y" === t2[e2 + 5] && "P" === t2[e2 + 6] && "E" === t2[e2 + 7]) {
          let i3 = 1;
          for (e2 += 8; e2 < t2.length; e2++) if ("<" === t2[e2]) i3++;
          else if (">" === t2[e2] && (i3--, 0 === i3)) break;
        } else if (t2.length > e2 + 9 && "[" === t2[e2 + 1] && "C" === t2[e2 + 2] && "D" === t2[e2 + 3] && "A" === t2[e2 + 4] && "T" === t2[e2 + 5] && "A" === t2[e2 + 6] && "[" === t2[e2 + 7]) {
          for (e2 += 8; e2 < t2.length; e2++) if ("]" === t2[e2] && "]" === t2[e2 + 1] && ">" === t2[e2 + 2]) {
            e2 += 2;
            break;
          }
        }
        return e2;
      }
      const d = '"', p = "'";
      function f(t2, e2) {
        let i3 = "", n3 = "", s2 = false;
        for (; e2 < t2.length; e2++) {
          if (t2[e2] === d || t2[e2] === p) "" === n3 ? n3 = t2[e2] : n3 !== t2[e2] || (n3 = "");
          else if (">" === t2[e2] && "" === n3) {
            s2 = true;
            break;
          }
          i3 += t2[e2];
        }
        return "" === n3 && { value: i3, index: e2, tagClosed: s2 };
      }
      const c3 = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function g(t2, e2) {
        const i3 = s(t2, c3), n3 = {};
        for (let t3 = 0; t3 < i3.length; t3++) {
          if (0 === i3[t3][1].length) return x("InvalidAttr", "Attribute '" + i3[t3][2] + "' has no space in starting.", E(i3[t3]));
          if (void 0 !== i3[t3][3] && void 0 === i3[t3][4]) return x("InvalidAttr", "Attribute '" + i3[t3][2] + "' is without value.", E(i3[t3]));
          if (void 0 === i3[t3][3] && !e2.allowBooleanAttributes) return x("InvalidAttr", "boolean attribute '" + i3[t3][2] + "' is not allowed.", E(i3[t3]));
          const s2 = i3[t3][2];
          if (!N(s2)) return x("InvalidAttr", "Attribute '" + s2 + "' is an invalid name.", E(i3[t3]));
          if (n3.hasOwnProperty(s2)) return x("InvalidAttr", "Attribute '" + s2 + "' is repeated.", E(i3[t3]));
          n3[s2] = 1;
        }
        return true;
      }
      function m(t2, e2) {
        if (";" === t2[++e2]) return -1;
        if ("#" === t2[e2]) return (function(t3, e3) {
          let i4 = /\d/;
          for ("x" === t3[e3] && (e3++, i4 = /[\da-fA-F]/); e3 < t3.length; e3++) {
            if (";" === t3[e3]) return e3;
            if (!t3[e3].match(i4)) break;
          }
          return -1;
        })(t2, ++e2);
        let i3 = 0;
        for (; e2 < t2.length; e2++, i3++) if (!(t2[e2].match(/\w/) && i3 < 20)) {
          if (";" === t2[e2]) break;
          return -1;
        }
        return e2;
      }
      function x(t2, e2, i3) {
        return { err: { code: t2, msg: e2, line: i3.line || i3, col: i3.col } };
      }
      function N(t2) {
        return r(t2);
      }
      function b(t2, e2) {
        const i3 = t2.substring(0, e2).split(/\r?\n/);
        return { line: i3.length, col: i3[i3.length - 1].length + 1 };
      }
      function E(t2) {
        return t2.startIndex + t2[1].length;
      }
      const v = { preserveOrder: false, attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, removeNSPrefix: false, allowBooleanAttributes: false, parseTagValue: true, parseAttributeValue: false, trimValues: true, cdataPropName: false, numberParseOptions: { hex: true, leadingZeros: true, eNotation: true }, tagValueProcessor: function(t2, e2) {
        return e2;
      }, attributeValueProcessor: function(t2, e2) {
        return e2;
      }, stopNodes: [], alwaysCreateTextNode: false, isArray: () => false, commentPropName: false, unpairedTags: [], processEntities: true, htmlEntities: false, ignoreDeclaration: false, ignorePiTags: false, transformTagName: false, transformAttributeName: false, updateTag: function(t2, e2, i3) {
        return t2;
      }, captureMetaData: false };
      let T;
      T = "function" != typeof Symbol ? "@@xmlMetadata" : /* @__PURE__ */ Symbol("XML Node Metadata");
      class y {
        constructor(t2) {
          this.tagname = t2, this.child = [], this[":@"] = {};
        }
        add(t2, e2) {
          "__proto__" === t2 && (t2 = "#__proto__"), this.child.push({ [t2]: e2 });
        }
        addChild(t2, e2) {
          "__proto__" === t2.tagname && (t2.tagname = "#__proto__"), t2[":@"] && Object.keys(t2[":@"]).length > 0 ? this.child.push({ [t2.tagname]: t2.child, ":@": t2[":@"] }) : this.child.push({ [t2.tagname]: t2.child }), void 0 !== e2 && (this.child[this.child.length - 1][T] = { startIndex: e2 });
        }
        static getMetaDataSymbol() {
          return T;
        }
      }
      class w {
        constructor(t2) {
          this.suppressValidationErr = !t2;
        }
        readDocType(t2, e2) {
          const i3 = {};
          if ("O" !== t2[e2 + 3] || "C" !== t2[e2 + 4] || "T" !== t2[e2 + 5] || "Y" !== t2[e2 + 6] || "P" !== t2[e2 + 7] || "E" !== t2[e2 + 8]) throw new Error("Invalid Tag instead of DOCTYPE");
          {
            e2 += 9;
            let n3 = 1, s2 = false, r2 = false, o3 = "";
            for (; e2 < t2.length; e2++) if ("<" !== t2[e2] || r2) if (">" === t2[e2]) {
              if (r2 ? "-" === t2[e2 - 1] && "-" === t2[e2 - 2] && (r2 = false, n3--) : n3--, 0 === n3) break;
            } else "[" === t2[e2] ? s2 = true : o3 += t2[e2];
            else {
              if (s2 && P(t2, "!ENTITY", e2)) {
                let n4, s3;
                e2 += 7, [n4, s3, e2] = this.readEntityExp(t2, e2 + 1, this.suppressValidationErr), -1 === s3.indexOf("&") && (i3[n4] = { regx: RegExp(`&${n4};`, "g"), val: s3 });
              } else if (s2 && P(t2, "!ELEMENT", e2)) {
                e2 += 8;
                const { index: i4 } = this.readElementExp(t2, e2 + 1);
                e2 = i4;
              } else if (s2 && P(t2, "!ATTLIST", e2)) e2 += 8;
              else if (s2 && P(t2, "!NOTATION", e2)) {
                e2 += 9;
                const { index: i4 } = this.readNotationExp(t2, e2 + 1, this.suppressValidationErr);
                e2 = i4;
              } else {
                if (!P(t2, "!--", e2)) throw new Error("Invalid DOCTYPE");
                r2 = true;
              }
              n3++, o3 = "";
            }
            if (0 !== n3) throw new Error("Unclosed DOCTYPE");
          }
          return { entities: i3, i: e2 };
        }
        readEntityExp(t2, e2) {
          e2 = I(t2, e2);
          let i3 = "";
          for (; e2 < t2.length && !/\s/.test(t2[e2]) && '"' !== t2[e2] && "'" !== t2[e2]; ) i3 += t2[e2], e2++;
          if (O(i3), e2 = I(t2, e2), !this.suppressValidationErr) {
            if ("SYSTEM" === t2.substring(e2, e2 + 6).toUpperCase()) throw new Error("External entities are not supported");
            if ("%" === t2[e2]) throw new Error("Parameter entities are not supported");
          }
          let n3 = "";
          return [e2, n3] = this.readIdentifierVal(t2, e2, "entity"), [i3, n3, --e2];
        }
        readNotationExp(t2, e2) {
          e2 = I(t2, e2);
          let i3 = "";
          for (; e2 < t2.length && !/\s/.test(t2[e2]); ) i3 += t2[e2], e2++;
          !this.suppressValidationErr && O(i3), e2 = I(t2, e2);
          const n3 = t2.substring(e2, e2 + 6).toUpperCase();
          if (!this.suppressValidationErr && "SYSTEM" !== n3 && "PUBLIC" !== n3) throw new Error(`Expected SYSTEM or PUBLIC, found "${n3}"`);
          e2 += n3.length, e2 = I(t2, e2);
          let s2 = null, r2 = null;
          if ("PUBLIC" === n3) [e2, s2] = this.readIdentifierVal(t2, e2, "publicIdentifier"), '"' !== t2[e2 = I(t2, e2)] && "'" !== t2[e2] || ([e2, r2] = this.readIdentifierVal(t2, e2, "systemIdentifier"));
          else if ("SYSTEM" === n3 && ([e2, r2] = this.readIdentifierVal(t2, e2, "systemIdentifier"), !this.suppressValidationErr && !r2)) throw new Error("Missing mandatory system identifier for SYSTEM notation");
          return { notationName: i3, publicIdentifier: s2, systemIdentifier: r2, index: --e2 };
        }
        readIdentifierVal(t2, e2, i3) {
          let n3 = "";
          const s2 = t2[e2];
          if ('"' !== s2 && "'" !== s2) throw new Error(`Expected quoted string, found "${s2}"`);
          for (e2++; e2 < t2.length && t2[e2] !== s2; ) n3 += t2[e2], e2++;
          if (t2[e2] !== s2) throw new Error(`Unterminated ${i3} value`);
          return [++e2, n3];
        }
        readElementExp(t2, e2) {
          e2 = I(t2, e2);
          let i3 = "";
          for (; e2 < t2.length && !/\s/.test(t2[e2]); ) i3 += t2[e2], e2++;
          if (!this.suppressValidationErr && !r(i3)) throw new Error(`Invalid element name: "${i3}"`);
          let n3 = "";
          if ("E" === t2[e2 = I(t2, e2)] && P(t2, "MPTY", e2)) e2 += 4;
          else if ("A" === t2[e2] && P(t2, "NY", e2)) e2 += 2;
          else if ("(" === t2[e2]) {
            for (e2++; e2 < t2.length && ")" !== t2[e2]; ) n3 += t2[e2], e2++;
            if (")" !== t2[e2]) throw new Error("Unterminated content model");
          } else if (!this.suppressValidationErr) throw new Error(`Invalid Element Expression, found "${t2[e2]}"`);
          return { elementName: i3, contentModel: n3.trim(), index: e2 };
        }
        readAttlistExp(t2, e2) {
          e2 = I(t2, e2);
          let i3 = "";
          for (; e2 < t2.length && !/\s/.test(t2[e2]); ) i3 += t2[e2], e2++;
          O(i3), e2 = I(t2, e2);
          let n3 = "";
          for (; e2 < t2.length && !/\s/.test(t2[e2]); ) n3 += t2[e2], e2++;
          if (!O(n3)) throw new Error(`Invalid attribute name: "${n3}"`);
          e2 = I(t2, e2);
          let s2 = "";
          if ("NOTATION" === t2.substring(e2, e2 + 8).toUpperCase()) {
            if (s2 = "NOTATION", "(" !== t2[e2 = I(t2, e2 += 8)]) throw new Error(`Expected '(', found "${t2[e2]}"`);
            e2++;
            let i4 = [];
            for (; e2 < t2.length && ")" !== t2[e2]; ) {
              let n4 = "";
              for (; e2 < t2.length && "|" !== t2[e2] && ")" !== t2[e2]; ) n4 += t2[e2], e2++;
              if (n4 = n4.trim(), !O(n4)) throw new Error(`Invalid notation name: "${n4}"`);
              i4.push(n4), "|" === t2[e2] && (e2++, e2 = I(t2, e2));
            }
            if (")" !== t2[e2]) throw new Error("Unterminated list of notations");
            e2++, s2 += " (" + i4.join("|") + ")";
          } else {
            for (; e2 < t2.length && !/\s/.test(t2[e2]); ) s2 += t2[e2], e2++;
            const i4 = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
            if (!this.suppressValidationErr && !i4.includes(s2.toUpperCase())) throw new Error(`Invalid attribute type: "${s2}"`);
          }
          e2 = I(t2, e2);
          let r2 = "";
          return "#REQUIRED" === t2.substring(e2, e2 + 8).toUpperCase() ? (r2 = "#REQUIRED", e2 += 8) : "#IMPLIED" === t2.substring(e2, e2 + 7).toUpperCase() ? (r2 = "#IMPLIED", e2 += 7) : [e2, r2] = this.readIdentifierVal(t2, e2, "ATTLIST"), { elementName: i3, attributeName: n3, attributeType: s2, defaultValue: r2, index: e2 };
        }
      }
      const I = (t2, e2) => {
        for (; e2 < t2.length && /\s/.test(t2[e2]); ) e2++;
        return e2;
      };
      function P(t2, e2, i3) {
        for (let n3 = 0; n3 < e2.length; n3++) if (e2[n3] !== t2[i3 + n3 + 1]) return false;
        return true;
      }
      function O(t2) {
        if (r(t2)) return t2;
        throw new Error(`Invalid entity name ${t2}`);
      }
      const A = /^[-+]?0x[a-fA-F0-9]+$/, S = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, C = { hex: true, leadingZeros: true, decimalPoint: ".", eNotation: true };
      const V = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
      function $(t2) {
        return "function" == typeof t2 ? t2 : Array.isArray(t2) ? (e2) => {
          for (const i3 of t2) {
            if ("string" == typeof i3 && e2 === i3) return true;
            if (i3 instanceof RegExp && i3.test(e2)) return true;
          }
        } : () => false;
      }
      class D {
        constructor(t2) {
          if (this.options = t2, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "\xA2" }, pound: { regex: /&(pound|#163);/g, val: "\xA3" }, yen: { regex: /&(yen|#165);/g, val: "\xA5" }, euro: { regex: /&(euro|#8364);/g, val: "\u20AC" }, copyright: { regex: /&(copy|#169);/g, val: "\xA9" }, reg: { regex: /&(reg|#174);/g, val: "\xAE" }, inr: { regex: /&(inr|#8377);/g, val: "\u20B9" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (t3, e2) => String.fromCodePoint(Number.parseInt(e2, 10)) }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t3, e2) => String.fromCodePoint(Number.parseInt(e2, 16)) } }, this.addExternalEntities = j, this.parseXml = L, this.parseTextData = M, this.resolveNameSpace = F, this.buildAttributesMap = k, this.isItStopNode = Y, this.replaceEntitiesValue = B, this.readStopNodeData = W, this.saveTextToParentTag = R, this.addChild = U, this.ignoreAttributesFn = $(this.options.ignoreAttributes), this.options.stopNodes && this.options.stopNodes.length > 0) {
            this.stopNodesExact = /* @__PURE__ */ new Set(), this.stopNodesWildcard = /* @__PURE__ */ new Set();
            for (let t3 = 0; t3 < this.options.stopNodes.length; t3++) {
              const e2 = this.options.stopNodes[t3];
              "string" == typeof e2 && (e2.startsWith("*.") ? this.stopNodesWildcard.add(e2.substring(2)) : this.stopNodesExact.add(e2));
            }
          }
        }
      }
      function j(t2) {
        const e2 = Object.keys(t2);
        for (let i3 = 0; i3 < e2.length; i3++) {
          const n3 = e2[i3];
          this.lastEntities[n3] = { regex: new RegExp("&" + n3 + ";", "g"), val: t2[n3] };
        }
      }
      function M(t2, e2, i3, n3, s2, r2, o3) {
        if (void 0 !== t2 && (this.options.trimValues && !n3 && (t2 = t2.trim()), t2.length > 0)) {
          o3 || (t2 = this.replaceEntitiesValue(t2));
          const n4 = this.options.tagValueProcessor(e2, t2, i3, s2, r2);
          return null == n4 ? t2 : typeof n4 != typeof t2 || n4 !== t2 ? n4 : this.options.trimValues || t2.trim() === t2 ? q(t2, this.options.parseTagValue, this.options.numberParseOptions) : t2;
        }
      }
      function F(t2) {
        if (this.options.removeNSPrefix) {
          const e2 = t2.split(":"), i3 = "/" === t2.charAt(0) ? "/" : "";
          if ("xmlns" === e2[0]) return "";
          2 === e2.length && (t2 = i3 + e2[1]);
        }
        return t2;
      }
      const _ = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function k(t2, e2) {
        if (true !== this.options.ignoreAttributes && "string" == typeof t2) {
          const i3 = s(t2, _), n3 = i3.length, r2 = {};
          for (let t3 = 0; t3 < n3; t3++) {
            const n4 = this.resolveNameSpace(i3[t3][1]);
            if (this.ignoreAttributesFn(n4, e2)) continue;
            let s2 = i3[t3][4], o3 = this.options.attributeNamePrefix + n4;
            if (n4.length) if (this.options.transformAttributeName && (o3 = this.options.transformAttributeName(o3)), "__proto__" === o3 && (o3 = "#__proto__"), void 0 !== s2) {
              this.options.trimValues && (s2 = s2.trim()), s2 = this.replaceEntitiesValue(s2);
              const t4 = this.options.attributeValueProcessor(n4, s2, e2);
              r2[o3] = null == t4 ? s2 : typeof t4 != typeof s2 || t4 !== s2 ? t4 : q(s2, this.options.parseAttributeValue, this.options.numberParseOptions);
            } else this.options.allowBooleanAttributes && (r2[o3] = true);
          }
          if (!Object.keys(r2).length) return;
          if (this.options.attributesGroupName) {
            const t3 = {};
            return t3[this.options.attributesGroupName] = r2, t3;
          }
          return r2;
        }
      }
      const L = function(t2) {
        t2 = t2.replace(/\r\n?/g, "\n");
        const e2 = new y("!xml");
        let i3 = e2, n3 = "", s2 = "";
        const r2 = new w(this.options.processEntities);
        for (let o3 = 0; o3 < t2.length; o3++) if ("<" === t2[o3]) if ("/" === t2[o3 + 1]) {
          const e3 = G(t2, ">", o3, "Closing Tag is not closed.");
          let r3 = t2.substring(o3 + 2, e3).trim();
          if (this.options.removeNSPrefix) {
            const t3 = r3.indexOf(":");
            -1 !== t3 && (r3 = r3.substr(t3 + 1));
          }
          this.options.transformTagName && (r3 = this.options.transformTagName(r3)), i3 && (n3 = this.saveTextToParentTag(n3, i3, s2));
          const a3 = s2.substring(s2.lastIndexOf(".") + 1);
          if (r3 && -1 !== this.options.unpairedTags.indexOf(r3)) throw new Error(`Unpaired tag can not be used as closing tag: </${r3}>`);
          let l2 = 0;
          a3 && -1 !== this.options.unpairedTags.indexOf(a3) ? (l2 = s2.lastIndexOf(".", s2.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l2 = s2.lastIndexOf("."), s2 = s2.substring(0, l2), i3 = this.tagsNodeStack.pop(), n3 = "", o3 = e3;
        } else if ("?" === t2[o3 + 1]) {
          let e3 = X(t2, o3, false, "?>");
          if (!e3) throw new Error("Pi Tag is not closed.");
          if (n3 = this.saveTextToParentTag(n3, i3, s2), this.options.ignoreDeclaration && "?xml" === e3.tagName || this.options.ignorePiTags) ;
          else {
            const t3 = new y(e3.tagName);
            t3.add(this.options.textNodeName, ""), e3.tagName !== e3.tagExp && e3.attrExpPresent && (t3[":@"] = this.buildAttributesMap(e3.tagExp, s2)), this.addChild(i3, t3, s2, o3);
          }
          o3 = e3.closeIndex + 1;
        } else if ("!--" === t2.substr(o3 + 1, 3)) {
          const e3 = G(t2, "-->", o3 + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const r3 = t2.substring(o3 + 4, e3 - 2);
            n3 = this.saveTextToParentTag(n3, i3, s2), i3.add(this.options.commentPropName, [{ [this.options.textNodeName]: r3 }]);
          }
          o3 = e3;
        } else if ("!D" === t2.substr(o3 + 1, 2)) {
          const e3 = r2.readDocType(t2, o3);
          this.docTypeEntities = e3.entities, o3 = e3.i;
        } else if ("![" === t2.substr(o3 + 1, 2)) {
          const e3 = G(t2, "]]>", o3, "CDATA is not closed.") - 2, r3 = t2.substring(o3 + 9, e3);
          n3 = this.saveTextToParentTag(n3, i3, s2);
          let a3 = this.parseTextData(r3, i3.tagname, s2, true, false, true, true);
          null == a3 && (a3 = ""), this.options.cdataPropName ? i3.add(this.options.cdataPropName, [{ [this.options.textNodeName]: r3 }]) : i3.add(this.options.textNodeName, a3), o3 = e3 + 2;
        } else {
          let r3 = X(t2, o3, this.options.removeNSPrefix), a3 = r3.tagName;
          const l2 = r3.rawTagName;
          let u3 = r3.tagExp, h3 = r3.attrExpPresent, d2 = r3.closeIndex;
          if (this.options.transformTagName) {
            const t3 = this.options.transformTagName(a3);
            u3 === a3 && (u3 = t3), a3 = t3;
          }
          i3 && n3 && "!xml" !== i3.tagname && (n3 = this.saveTextToParentTag(n3, i3, s2, false));
          const p2 = i3;
          p2 && -1 !== this.options.unpairedTags.indexOf(p2.tagname) && (i3 = this.tagsNodeStack.pop(), s2 = s2.substring(0, s2.lastIndexOf("."))), a3 !== e2.tagname && (s2 += s2 ? "." + a3 : a3);
          const f2 = o3;
          if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, s2, a3)) {
            let e3 = "";
            if (u3.length > 0 && u3.lastIndexOf("/") === u3.length - 1) "/" === a3[a3.length - 1] ? (a3 = a3.substr(0, a3.length - 1), s2 = s2.substr(0, s2.length - 1), u3 = a3) : u3 = u3.substr(0, u3.length - 1), o3 = r3.closeIndex;
            else if (-1 !== this.options.unpairedTags.indexOf(a3)) o3 = r3.closeIndex;
            else {
              const i4 = this.readStopNodeData(t2, l2, d2 + 1);
              if (!i4) throw new Error(`Unexpected end of ${l2}`);
              o3 = i4.i, e3 = i4.tagContent;
            }
            const n4 = new y(a3);
            a3 !== u3 && h3 && (n4[":@"] = this.buildAttributesMap(u3, s2)), e3 && (e3 = this.parseTextData(e3, a3, s2, true, h3, true, true)), s2 = s2.substr(0, s2.lastIndexOf(".")), n4.add(this.options.textNodeName, e3), this.addChild(i3, n4, s2, f2);
          } else {
            if (u3.length > 0 && u3.lastIndexOf("/") === u3.length - 1) {
              if ("/" === a3[a3.length - 1] ? (a3 = a3.substr(0, a3.length - 1), s2 = s2.substr(0, s2.length - 1), u3 = a3) : u3 = u3.substr(0, u3.length - 1), this.options.transformTagName) {
                const t4 = this.options.transformTagName(a3);
                u3 === a3 && (u3 = t4), a3 = t4;
              }
              const t3 = new y(a3);
              a3 !== u3 && h3 && (t3[":@"] = this.buildAttributesMap(u3, s2)), this.addChild(i3, t3, s2, f2), s2 = s2.substr(0, s2.lastIndexOf("."));
            } else {
              const t3 = new y(a3);
              this.tagsNodeStack.push(i3), a3 !== u3 && h3 && (t3[":@"] = this.buildAttributesMap(u3, s2)), this.addChild(i3, t3, s2, f2), i3 = t3;
            }
            n3 = "", o3 = d2;
          }
        }
        else n3 += t2[o3];
        return e2.child;
      };
      function U(t2, e2, i3, n3) {
        this.options.captureMetaData || (n3 = void 0);
        const s2 = this.options.updateTag(e2.tagname, i3, e2[":@"]);
        false === s2 || ("string" == typeof s2 ? (e2.tagname = s2, t2.addChild(e2, n3)) : t2.addChild(e2, n3));
      }
      const B = function(t2) {
        if (this.options.processEntities) {
          for (let e2 in this.docTypeEntities) {
            const i3 = this.docTypeEntities[e2];
            t2 = t2.replace(i3.regx, i3.val);
          }
          for (let e2 in this.lastEntities) {
            const i3 = this.lastEntities[e2];
            t2 = t2.replace(i3.regex, i3.val);
          }
          if (this.options.htmlEntities) for (let e2 in this.htmlEntities) {
            const i3 = this.htmlEntities[e2];
            t2 = t2.replace(i3.regex, i3.val);
          }
          t2 = t2.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return t2;
      };
      function R(t2, e2, i3, n3) {
        return t2 && (void 0 === n3 && (n3 = 0 === e2.child.length), void 0 !== (t2 = this.parseTextData(t2, e2.tagname, i3, false, !!e2[":@"] && 0 !== Object.keys(e2[":@"]).length, n3)) && "" !== t2 && e2.add(this.options.textNodeName, t2), t2 = ""), t2;
      }
      function Y(t2, e2, i3, n3) {
        return !(!e2 || !e2.has(n3)) || !(!t2 || !t2.has(i3));
      }
      function G(t2, e2, i3, n3) {
        const s2 = t2.indexOf(e2, i3);
        if (-1 === s2) throw new Error(n3);
        return s2 + e2.length - 1;
      }
      function X(t2, e2, i3, n3 = ">") {
        const s2 = (function(t3, e3, i4 = ">") {
          let n4, s3 = "";
          for (let r3 = e3; r3 < t3.length; r3++) {
            let e4 = t3[r3];
            if (n4) e4 === n4 && (n4 = "");
            else if ('"' === e4 || "'" === e4) n4 = e4;
            else if (e4 === i4[0]) {
              if (!i4[1]) return { data: s3, index: r3 };
              if (t3[r3 + 1] === i4[1]) return { data: s3, index: r3 };
            } else "	" === e4 && (e4 = " ");
            s3 += e4;
          }
        })(t2, e2 + 1, n3);
        if (!s2) return;
        let r2 = s2.data;
        const o3 = s2.index, a3 = r2.search(/\s/);
        let l2 = r2, u3 = true;
        -1 !== a3 && (l2 = r2.substring(0, a3), r2 = r2.substring(a3 + 1).trimStart());
        const h3 = l2;
        if (i3) {
          const t3 = l2.indexOf(":");
          -1 !== t3 && (l2 = l2.substr(t3 + 1), u3 = l2 !== s2.data.substr(t3 + 1));
        }
        return { tagName: l2, tagExp: r2, closeIndex: o3, attrExpPresent: u3, rawTagName: h3 };
      }
      function W(t2, e2, i3) {
        const n3 = i3;
        let s2 = 1;
        for (; i3 < t2.length; i3++) if ("<" === t2[i3]) if ("/" === t2[i3 + 1]) {
          const r2 = G(t2, ">", i3, `${e2} is not closed`);
          if (t2.substring(i3 + 2, r2).trim() === e2 && (s2--, 0 === s2)) return { tagContent: t2.substring(n3, i3), i: r2 };
          i3 = r2;
        } else if ("?" === t2[i3 + 1]) i3 = G(t2, "?>", i3 + 1, "StopNode is not closed.");
        else if ("!--" === t2.substr(i3 + 1, 3)) i3 = G(t2, "-->", i3 + 3, "StopNode is not closed.");
        else if ("![" === t2.substr(i3 + 1, 2)) i3 = G(t2, "]]>", i3, "StopNode is not closed.") - 2;
        else {
          const n4 = X(t2, i3, ">");
          n4 && ((n4 && n4.tagName) === e2 && "/" !== n4.tagExp[n4.tagExp.length - 1] && s2++, i3 = n4.closeIndex);
        }
      }
      function q(t2, e2, i3) {
        if (e2 && "string" == typeof t2) {
          const e3 = t2.trim();
          return "true" === e3 || "false" !== e3 && (function(t3, e4 = {}) {
            if (e4 = Object.assign({}, C, e4), !t3 || "string" != typeof t3) return t3;
            let i4 = t3.trim();
            if (void 0 !== e4.skipLike && e4.skipLike.test(i4)) return t3;
            if ("0" === t3) return 0;
            if (e4.hex && A.test(i4)) return (function(t4) {
              if (parseInt) return parseInt(t4, 16);
              if (Number.parseInt) return Number.parseInt(t4, 16);
              if (window && window.parseInt) return window.parseInt(t4, 16);
              throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
            })(i4);
            if (-1 !== i4.search(/.+[eE].+/)) return (function(t4, e5, i5) {
              if (!i5.eNotation) return t4;
              const n4 = e5.match(V);
              if (n4) {
                let s2 = n4[1] || "";
                const r2 = -1 === n4[3].indexOf("e") ? "E" : "e", o3 = n4[2], a3 = s2 ? t4[o3.length + 1] === r2 : t4[o3.length] === r2;
                return o3.length > 1 && a3 ? t4 : 1 !== o3.length || !n4[3].startsWith(`.${r2}`) && n4[3][0] !== r2 ? i5.leadingZeros && !a3 ? (e5 = (n4[1] || "") + n4[3], Number(e5)) : t4 : Number(e5);
              }
              return t4;
            })(t3, i4, e4);
            {
              const s2 = S.exec(i4);
              if (s2) {
                const r2 = s2[1] || "", o3 = s2[2];
                let a3 = (n3 = s2[3]) && -1 !== n3.indexOf(".") ? ("." === (n3 = n3.replace(/0+$/, "")) ? n3 = "0" : "." === n3[0] ? n3 = "0" + n3 : "." === n3[n3.length - 1] && (n3 = n3.substring(0, n3.length - 1)), n3) : n3;
                const l2 = r2 ? "." === t3[o3.length + 1] : "." === t3[o3.length];
                if (!e4.leadingZeros && (o3.length > 1 || 1 === o3.length && !l2)) return t3;
                {
                  const n4 = Number(i4), s3 = String(n4);
                  if (0 === n4 || -0 === n4) return n4;
                  if (-1 !== s3.search(/[eE]/)) return e4.eNotation ? n4 : t3;
                  if (-1 !== i4.indexOf(".")) return "0" === s3 || s3 === a3 || s3 === `${r2}${a3}` ? n4 : t3;
                  let l3 = o3 ? a3 : i4;
                  return o3 ? l3 === s3 || r2 + l3 === s3 ? n4 : t3 : l3 === s3 || l3 === r2 + s3 ? n4 : t3;
                }
              }
              return t3;
            }
            var n3;
          })(t2, i3);
        }
        return void 0 !== t2 ? t2 : "";
      }
      const Z = y.getMetaDataSymbol();
      function K(t2, e2) {
        return Q(t2, e2);
      }
      function Q(t2, e2, i3) {
        let n3;
        const s2 = {};
        for (let r2 = 0; r2 < t2.length; r2++) {
          const o3 = t2[r2], a3 = z(o3);
          let l2 = "";
          if (l2 = void 0 === i3 ? a3 : i3 + "." + a3, a3 === e2.textNodeName) void 0 === n3 ? n3 = o3[a3] : n3 += "" + o3[a3];
          else {
            if (void 0 === a3) continue;
            if (o3[a3]) {
              let t3 = Q(o3[a3], e2, l2);
              const i4 = H(t3, e2);
              void 0 !== o3[Z] && (t3[Z] = o3[Z]), o3[":@"] ? J(t3, o3[":@"], l2, e2) : 1 !== Object.keys(t3).length || void 0 === t3[e2.textNodeName] || e2.alwaysCreateTextNode ? 0 === Object.keys(t3).length && (e2.alwaysCreateTextNode ? t3[e2.textNodeName] = "" : t3 = "") : t3 = t3[e2.textNodeName], void 0 !== s2[a3] && s2.hasOwnProperty(a3) ? (Array.isArray(s2[a3]) || (s2[a3] = [s2[a3]]), s2[a3].push(t3)) : e2.isArray(a3, l2, i4) ? s2[a3] = [t3] : s2[a3] = t3;
            }
          }
        }
        return "string" == typeof n3 ? n3.length > 0 && (s2[e2.textNodeName] = n3) : void 0 !== n3 && (s2[e2.textNodeName] = n3), s2;
      }
      function z(t2) {
        const e2 = Object.keys(t2);
        for (let t3 = 0; t3 < e2.length; t3++) {
          const i3 = e2[t3];
          if (":@" !== i3) return i3;
        }
      }
      function J(t2, e2, i3, n3) {
        if (e2) {
          const s2 = Object.keys(e2), r2 = s2.length;
          for (let o3 = 0; o3 < r2; o3++) {
            const r3 = s2[o3];
            n3.isArray(r3, i3 + "." + r3, true, true) ? t2[r3] = [e2[r3]] : t2[r3] = e2[r3];
          }
        }
      }
      function H(t2, e2) {
        const { textNodeName: i3 } = e2, n3 = Object.keys(t2).length;
        return 0 === n3 || !(1 !== n3 || !t2[i3] && "boolean" != typeof t2[i3] && 0 !== t2[i3]);
      }
      class tt {
        constructor(t2) {
          this.externalEntities = {}, this.options = (function(t3) {
            return Object.assign({}, v, t3);
          })(t2);
        }
        parse(t2, e2) {
          if ("string" != typeof t2 && t2.toString) t2 = t2.toString();
          else if ("string" != typeof t2) throw new Error("XML data is accepted in String or Bytes[] form.");
          if (e2) {
            true === e2 && (e2 = {});
            const i4 = a2(t2, e2);
            if (true !== i4) throw Error(`${i4.err.msg}:${i4.err.line}:${i4.err.col}`);
          }
          const i3 = new D(this.options);
          i3.addExternalEntities(this.externalEntities);
          const n3 = i3.parseXml(t2);
          return this.options.preserveOrder || void 0 === n3 ? n3 : K(n3, this.options);
        }
        addEntity(t2, e2) {
          if (-1 !== e2.indexOf("&")) throw new Error("Entity value can't have '&'");
          if (-1 !== t2.indexOf("&") || -1 !== t2.indexOf(";")) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          if ("&" === e2) throw new Error("An entity with value '&' is not permitted");
          this.externalEntities[t2] = e2;
        }
        static getMetaDataSymbol() {
          return y.getMetaDataSymbol();
        }
      }
      function et(t2, e2) {
        let i3 = "";
        return e2.format && e2.indentBy.length > 0 && (i3 = "\n"), it(t2, e2, "", i3);
      }
      function it(t2, e2, i3, n3) {
        let s2 = "", r2 = false;
        for (let o3 = 0; o3 < t2.length; o3++) {
          const a3 = t2[o3], l2 = nt(a3);
          if (void 0 === l2) continue;
          let u3 = "";
          if (u3 = 0 === i3.length ? l2 : `${i3}.${l2}`, l2 === e2.textNodeName) {
            let t3 = a3[l2];
            rt(u3, e2) || (t3 = e2.tagValueProcessor(l2, t3), t3 = ot(t3, e2)), r2 && (s2 += n3), s2 += t3, r2 = false;
            continue;
          }
          if (l2 === e2.cdataPropName) {
            r2 && (s2 += n3), s2 += `<![CDATA[${a3[l2][0][e2.textNodeName]}]]>`, r2 = false;
            continue;
          }
          if (l2 === e2.commentPropName) {
            s2 += n3 + `<!--${a3[l2][0][e2.textNodeName]}-->`, r2 = true;
            continue;
          }
          if ("?" === l2[0]) {
            const t3 = st(a3[":@"], e2), i4 = "?xml" === l2 ? "" : n3;
            let o4 = a3[l2][0][e2.textNodeName];
            o4 = 0 !== o4.length ? " " + o4 : "", s2 += i4 + `<${l2}${o4}${t3}?>`, r2 = true;
            continue;
          }
          let h3 = n3;
          "" !== h3 && (h3 += e2.indentBy);
          const d2 = n3 + `<${l2}${st(a3[":@"], e2)}`, p2 = it(a3[l2], e2, u3, h3);
          -1 !== e2.unpairedTags.indexOf(l2) ? e2.suppressUnpairedNode ? s2 += d2 + ">" : s2 += d2 + "/>" : p2 && 0 !== p2.length || !e2.suppressEmptyNode ? p2 && p2.endsWith(">") ? s2 += d2 + `>${p2}${n3}</${l2}>` : (s2 += d2 + ">", p2 && "" !== n3 && (p2.includes("/>") || p2.includes("</")) ? s2 += n3 + e2.indentBy + p2 + n3 : s2 += p2, s2 += `</${l2}>`) : s2 += d2 + "/>", r2 = true;
        }
        return s2;
      }
      function nt(t2) {
        const e2 = Object.keys(t2);
        for (let i3 = 0; i3 < e2.length; i3++) {
          const n3 = e2[i3];
          if (t2.hasOwnProperty(n3) && ":@" !== n3) return n3;
        }
      }
      function st(t2, e2) {
        let i3 = "";
        if (t2 && !e2.ignoreAttributes) for (let n3 in t2) {
          if (!t2.hasOwnProperty(n3)) continue;
          let s2 = e2.attributeValueProcessor(n3, t2[n3]);
          s2 = ot(s2, e2), true === s2 && e2.suppressBooleanAttributes ? i3 += ` ${n3.substr(e2.attributeNamePrefix.length)}` : i3 += ` ${n3.substr(e2.attributeNamePrefix.length)}="${s2}"`;
        }
        return i3;
      }
      function rt(t2, e2) {
        let i3 = (t2 = t2.substr(0, t2.length - e2.textNodeName.length - 1)).substr(t2.lastIndexOf(".") + 1);
        for (let n3 in e2.stopNodes) if (e2.stopNodes[n3] === t2 || e2.stopNodes[n3] === "*." + i3) return true;
        return false;
      }
      function ot(t2, e2) {
        if (t2 && t2.length > 0 && e2.processEntities) for (let i3 = 0; i3 < e2.entities.length; i3++) {
          const n3 = e2.entities[i3];
          t2 = t2.replace(n3.regex, n3.val);
        }
        return t2;
      }
      const at = { attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, cdataPropName: false, format: false, indentBy: "  ", suppressEmptyNode: false, suppressUnpairedNode: true, suppressBooleanAttributes: true, tagValueProcessor: function(t2, e2) {
        return e2;
      }, attributeValueProcessor: function(t2, e2) {
        return e2;
      }, preserveOrder: false, commentPropName: false, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: true, stopNodes: [], oneListGroup: false };
      function lt(t2) {
        this.options = Object.assign({}, at, t2), true === this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
          return false;
        } : (this.ignoreAttributesFn = $(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = dt), this.processTextOrObjNode = ut, this.options.format ? (this.indentate = ht, this.tagEndChar = ">\n", this.newLine = "\n") : (this.indentate = function() {
          return "";
        }, this.tagEndChar = ">", this.newLine = "");
      }
      function ut(t2, e2, i3, n3) {
        const s2 = this.j2x(t2, i3 + 1, n3.concat(e2));
        return void 0 !== t2[this.options.textNodeName] && 1 === Object.keys(t2).length ? this.buildTextValNode(t2[this.options.textNodeName], e2, s2.attrStr, i3) : this.buildObjectNode(s2.val, e2, s2.attrStr, i3);
      }
      function ht(t2) {
        return this.options.indentBy.repeat(t2);
      }
      function dt(t2) {
        return !(!t2.startsWith(this.options.attributeNamePrefix) || t2 === this.options.textNodeName) && t2.substr(this.attrPrefixLen);
      }
      lt.prototype.build = function(t2) {
        return this.options.preserveOrder ? et(t2, this.options) : (Array.isArray(t2) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t2 = { [this.options.arrayNodeName]: t2 }), this.j2x(t2, 0, []).val);
      }, lt.prototype.j2x = function(t2, e2, i3) {
        let n3 = "", s2 = "";
        const r2 = i3.join(".");
        for (let o3 in t2) if (Object.prototype.hasOwnProperty.call(t2, o3)) if (void 0 === t2[o3]) this.isAttribute(o3) && (s2 += "");
        else if (null === t2[o3]) this.isAttribute(o3) || o3 === this.options.cdataPropName ? s2 += "" : "?" === o3[0] ? s2 += this.indentate(e2) + "<" + o3 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o3 + "/" + this.tagEndChar;
        else if (t2[o3] instanceof Date) s2 += this.buildTextValNode(t2[o3], o3, "", e2);
        else if ("object" != typeof t2[o3]) {
          const i4 = this.isAttribute(o3);
          if (i4 && !this.ignoreAttributesFn(i4, r2)) n3 += this.buildAttrPairStr(i4, "" + t2[o3]);
          else if (!i4) if (o3 === this.options.textNodeName) {
            let e3 = this.options.tagValueProcessor(o3, "" + t2[o3]);
            s2 += this.replaceEntitiesValue(e3);
          } else s2 += this.buildTextValNode(t2[o3], o3, "", e2);
        } else if (Array.isArray(t2[o3])) {
          const n4 = t2[o3].length;
          let r3 = "", a3 = "";
          for (let l2 = 0; l2 < n4; l2++) {
            const n5 = t2[o3][l2];
            if (void 0 === n5) ;
            else if (null === n5) "?" === o3[0] ? s2 += this.indentate(e2) + "<" + o3 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o3 + "/" + this.tagEndChar;
            else if ("object" == typeof n5) if (this.options.oneListGroup) {
              const t3 = this.j2x(n5, e2 + 1, i3.concat(o3));
              r3 += t3.val, this.options.attributesGroupName && n5.hasOwnProperty(this.options.attributesGroupName) && (a3 += t3.attrStr);
            } else r3 += this.processTextOrObjNode(n5, o3, e2, i3);
            else if (this.options.oneListGroup) {
              let t3 = this.options.tagValueProcessor(o3, n5);
              t3 = this.replaceEntitiesValue(t3), r3 += t3;
            } else r3 += this.buildTextValNode(n5, o3, "", e2);
          }
          this.options.oneListGroup && (r3 = this.buildObjectNode(r3, o3, a3, e2)), s2 += r3;
        } else if (this.options.attributesGroupName && o3 === this.options.attributesGroupName) {
          const e3 = Object.keys(t2[o3]), i4 = e3.length;
          for (let s3 = 0; s3 < i4; s3++) n3 += this.buildAttrPairStr(e3[s3], "" + t2[o3][e3[s3]]);
        } else s2 += this.processTextOrObjNode(t2[o3], o3, e2, i3);
        return { attrStr: n3, val: s2 };
      }, lt.prototype.buildAttrPairStr = function(t2, e2) {
        return e2 = this.options.attributeValueProcessor(t2, "" + e2), e2 = this.replaceEntitiesValue(e2), this.options.suppressBooleanAttributes && "true" === e2 ? " " + t2 : " " + t2 + '="' + e2 + '"';
      }, lt.prototype.buildObjectNode = function(t2, e2, i3, n3) {
        if ("" === t2) return "?" === e2[0] ? this.indentate(n3) + "<" + e2 + i3 + "?" + this.tagEndChar : this.indentate(n3) + "<" + e2 + i3 + this.closeTag(e2) + this.tagEndChar;
        {
          let s2 = "</" + e2 + this.tagEndChar, r2 = "";
          return "?" === e2[0] && (r2 = "?", s2 = ""), !i3 && "" !== i3 || -1 !== t2.indexOf("<") ? false !== this.options.commentPropName && e2 === this.options.commentPropName && 0 === r2.length ? this.indentate(n3) + `<!--${t2}-->` + this.newLine : this.indentate(n3) + "<" + e2 + i3 + r2 + this.tagEndChar + t2 + this.indentate(n3) + s2 : this.indentate(n3) + "<" + e2 + i3 + r2 + ">" + t2 + s2;
        }
      }, lt.prototype.closeTag = function(t2) {
        let e2 = "";
        return -1 !== this.options.unpairedTags.indexOf(t2) ? this.options.suppressUnpairedNode || (e2 = "/") : e2 = this.options.suppressEmptyNode ? "/" : `></${t2}`, e2;
      }, lt.prototype.buildTextValNode = function(t2, e2, i3, n3) {
        if (false !== this.options.cdataPropName && e2 === this.options.cdataPropName) return this.indentate(n3) + `<![CDATA[${t2}]]>` + this.newLine;
        if (false !== this.options.commentPropName && e2 === this.options.commentPropName) return this.indentate(n3) + `<!--${t2}-->` + this.newLine;
        if ("?" === e2[0]) return this.indentate(n3) + "<" + e2 + i3 + "?" + this.tagEndChar;
        {
          let s2 = this.options.tagValueProcessor(e2, t2);
          return s2 = this.replaceEntitiesValue(s2), "" === s2 ? this.indentate(n3) + "<" + e2 + i3 + this.closeTag(e2) + this.tagEndChar : this.indentate(n3) + "<" + e2 + i3 + ">" + s2 + "</" + e2 + this.tagEndChar;
        }
      }, lt.prototype.replaceEntitiesValue = function(t2) {
        if (t2 && t2.length > 0 && this.options.processEntities) for (let e2 = 0; e2 < this.options.entities.length; e2++) {
          const i3 = this.options.entities[e2];
          t2 = t2.replace(i3.regex, i3.val);
        }
        return t2;
      };
      const pt = { validate: a2 };
      module.exports = e;
    })();
  }
});

// node_modules/@azure/core-xml/dist/commonjs/xml.common.js
var require_xml_common = __commonJS({
  "node_modules/@azure/core-xml/dist/commonjs/xml.common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XML_CHARKEY = exports.XML_ATTRKEY = void 0;
    exports.XML_ATTRKEY = "$";
    exports.XML_CHARKEY = "_";
  }
});

// node_modules/@azure/core-xml/dist/commonjs/xml.js
var require_xml = __commonJS({
  "node_modules/@azure/core-xml/dist/commonjs/xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringifyXML = stringifyXML;
    exports.parseXML = parseXML;
    var fast_xml_parser_1 = require_fxp();
    var xml_common_js_1 = require_xml_common();
    function getCommonOptions(options) {
      var _a;
      return {
        attributesGroupName: xml_common_js_1.XML_ATTRKEY,
        textNodeName: (_a = options.xmlCharKey) !== null && _a !== void 0 ? _a : xml_common_js_1.XML_CHARKEY,
        ignoreAttributes: false,
        suppressBooleanAttributes: false
      };
    }
    function getSerializerOptions(options = {}) {
      var _a, _b;
      return Object.assign(Object.assign({}, getCommonOptions(options)), { attributeNamePrefix: "@_", format: true, suppressEmptyNode: true, indentBy: "", rootNodeName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "root", cdataPropName: (_b = options.cdataPropName) !== null && _b !== void 0 ? _b : "__cdata" });
    }
    function getParserOptions(options = {}) {
      return Object.assign(Object.assign({}, getCommonOptions(options)), { parseAttributeValue: false, parseTagValue: false, attributeNamePrefix: "", stopNodes: options.stopNodes, processEntities: true, trimValues: false });
    }
    function stringifyXML(obj, opts = {}) {
      const parserOptions = getSerializerOptions(opts);
      const j2x = new fast_xml_parser_1.XMLBuilder(parserOptions);
      const node = { [parserOptions.rootNodeName]: obj };
      const xmlData = j2x.build(node);
      return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${xmlData}`.replace(/\n/g, "");
    }
    async function parseXML(str, opts = {}) {
      if (!str) {
        throw new Error("Document is empty");
      }
      const validation = fast_xml_parser_1.XMLValidator.validate(str);
      if (validation !== true) {
        throw validation;
      }
      const parser = new fast_xml_parser_1.XMLParser(getParserOptions(opts));
      const parsedXml = parser.parse(str);
      if (parsedXml["?xml"]) {
        delete parsedXml["?xml"];
      }
      if (!opts.includeRoot) {
        for (const key of Object.keys(parsedXml)) {
          const value = parsedXml[key];
          return typeof value === "object" ? Object.assign({}, value) : value;
        }
      }
      return parsedXml;
    }
  }
});

// node_modules/@azure/core-xml/dist/commonjs/index.js
var require_commonjs10 = __commonJS({
  "node_modules/@azure/core-xml/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.parseXML = exports.stringifyXML = void 0;
    var xml_js_1 = require_xml();
    Object.defineProperty(exports, "stringifyXML", { enumerable: true, get: function() {
      return xml_js_1.stringifyXML;
    } });
    Object.defineProperty(exports, "parseXML", { enumerable: true, get: function() {
      return xml_js_1.parseXML;
    } });
    var xml_common_js_1 = require_xml_common();
    Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
      return xml_common_js_1.XML_ATTRKEY;
    } });
    Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
      return xml_common_js_1.XML_CHARKEY;
    } });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/log.js
var require_log5 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = void 0;
    var logger_1 = require_commonjs2();
    exports.logger = (0, logger_1.createClientLogger)("storage-blob");
  }
});

// node_modules/@azure/storage-blob/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError3 = __commonJS({
  "node_modules/@azure/storage-blob/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbortError = void 0;
    var AbortError3 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    exports.AbortError = AbortError3;
  }
});

// node_modules/@azure/storage-blob/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs11 = __commonJS({
  "node_modules/@azure/storage-blob/node_modules/@azure/abort-controller/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbortError = void 0;
    var AbortError_js_1 = require_AbortError3();
    Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
      return AbortError_js_1.AbortError;
    } });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/RequestPolicy.js
var require_RequestPolicy = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/RequestPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseRequestPolicy = void 0;
    var BaseRequestPolicy = class {
      _nextPolicy;
      _options;
      /**
       * The main method to implement that manipulates a request/response.
       */
      constructor(_nextPolicy, _options2) {
        this._nextPolicy = _nextPolicy;
        this._options = _options2;
      }
      /**
       * Get whether or not a log with the provided log level should be logged.
       * @param logLevel - The log level of the log that will be logged.
       * @returns Whether or not a log with the provided log level should be logged.
       */
      shouldLog(logLevel) {
        return this._options.shouldLog(logLevel);
      }
      /**
       * Attempt to log the provided message to the provided logger. If no logger was provided or if
       * the log level does not meat the logger's threshold, then nothing will be logged.
       * @param logLevel - The log level of this log.
       * @param message - The message of this log.
       */
      log(logLevel, message) {
        this._options.log(logLevel, message);
      }
    };
    exports.BaseRequestPolicy = BaseRequestPolicy;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/constants.js
var require_constants9 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/utils/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PathStylePorts = exports.BlobDoesNotUseCustomerSpecifiedEncryption = exports.BlobUsesCustomerSpecifiedEncryptionMsg = exports.StorageBlobLoggingAllowedQueryParameters = exports.StorageBlobLoggingAllowedHeaderNames = exports.DevelopmentConnectionString = exports.EncryptionAlgorithmAES25 = exports.HTTP_VERSION_1_1 = exports.HTTP_LINE_ENDING = exports.BATCH_MAX_PAYLOAD_IN_BYTES = exports.BATCH_MAX_REQUEST = exports.SIZE_1_MB = exports.ETagAny = exports.ETagNone = exports.HeaderConstants = exports.HTTPURLConnection = exports.URLConstants = exports.StorageOAuthScopes = exports.REQUEST_TIMEOUT = exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = exports.BLOCK_BLOB_MAX_BLOCKS = exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = exports.SERVICE_VERSION = exports.SDK_VERSION = void 0;
    exports.SDK_VERSION = "12.29.1";
    exports.SERVICE_VERSION = "2025-11-05";
    exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 256 * 1024 * 1024;
    exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4e3 * 1024 * 1024;
    exports.BLOCK_BLOB_MAX_BLOCKS = 5e4;
    exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8 * 1024 * 1024;
    exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4 * 1024 * 1024;
    exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
    exports.REQUEST_TIMEOUT = 100 * 1e3;
    exports.StorageOAuthScopes = "https://storage.azure.com/.default";
    exports.URLConstants = {
      Parameters: {
        FORCE_BROWSER_NO_CACHE: "_",
        SIGNATURE: "sig",
        SNAPSHOT: "snapshot",
        VERSIONID: "versionid",
        TIMEOUT: "timeout"
      }
    };
    exports.HTTPURLConnection = {
      HTTP_ACCEPTED: 202,
      HTTP_CONFLICT: 409,
      HTTP_NOT_FOUND: 404,
      HTTP_PRECON_FAILED: 412,
      HTTP_RANGE_NOT_SATISFIABLE: 416
    };
    exports.HeaderConstants = {
      AUTHORIZATION: "Authorization",
      AUTHORIZATION_SCHEME: "Bearer",
      CONTENT_ENCODING: "Content-Encoding",
      CONTENT_ID: "Content-ID",
      CONTENT_LANGUAGE: "Content-Language",
      CONTENT_LENGTH: "Content-Length",
      CONTENT_MD5: "Content-Md5",
      CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
      CONTENT_TYPE: "Content-Type",
      COOKIE: "Cookie",
      DATE: "date",
      IF_MATCH: "if-match",
      IF_MODIFIED_SINCE: "if-modified-since",
      IF_NONE_MATCH: "if-none-match",
      IF_UNMODIFIED_SINCE: "if-unmodified-since",
      PREFIX_FOR_STORAGE: "x-ms-",
      RANGE: "Range",
      USER_AGENT: "User-Agent",
      X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
      X_MS_COPY_SOURCE: "x-ms-copy-source",
      X_MS_DATE: "x-ms-date",
      X_MS_ERROR_CODE: "x-ms-error-code",
      X_MS_VERSION: "x-ms-version",
      X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
    };
    exports.ETagNone = "";
    exports.ETagAny = "*";
    exports.SIZE_1_MB = 1 * 1024 * 1024;
    exports.BATCH_MAX_REQUEST = 256;
    exports.BATCH_MAX_PAYLOAD_IN_BYTES = 4 * exports.SIZE_1_MB;
    exports.HTTP_LINE_ENDING = "\r\n";
    exports.HTTP_VERSION_1_1 = "HTTP/1.1";
    exports.EncryptionAlgorithmAES25 = "AES256";
    exports.DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
    exports.StorageBlobLoggingAllowedHeaderNames = [
      "Access-Control-Allow-Origin",
      "Cache-Control",
      "Content-Length",
      "Content-Type",
      "Date",
      "Request-Id",
      "traceparent",
      "Transfer-Encoding",
      "User-Agent",
      "x-ms-client-request-id",
      "x-ms-date",
      "x-ms-error-code",
      "x-ms-request-id",
      "x-ms-return-client-request-id",
      "x-ms-version",
      "Accept-Ranges",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-MD5",
      "Content-Range",
      "ETag",
      "Last-Modified",
      "Server",
      "Vary",
      "x-ms-content-crc64",
      "x-ms-copy-action",
      "x-ms-copy-completion-time",
      "x-ms-copy-id",
      "x-ms-copy-progress",
      "x-ms-copy-status",
      "x-ms-has-immutability-policy",
      "x-ms-has-legal-hold",
      "x-ms-lease-state",
      "x-ms-lease-status",
      "x-ms-range",
      "x-ms-request-server-encrypted",
      "x-ms-server-encrypted",
      "x-ms-snapshot",
      "x-ms-source-range",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "x-ms-access-tier",
      "x-ms-access-tier-change-time",
      "x-ms-access-tier-inferred",
      "x-ms-account-kind",
      "x-ms-archive-status",
      "x-ms-blob-append-offset",
      "x-ms-blob-cache-control",
      "x-ms-blob-committed-block-count",
      "x-ms-blob-condition-appendpos",
      "x-ms-blob-condition-maxsize",
      "x-ms-blob-content-disposition",
      "x-ms-blob-content-encoding",
      "x-ms-blob-content-language",
      "x-ms-blob-content-length",
      "x-ms-blob-content-md5",
      "x-ms-blob-content-type",
      "x-ms-blob-public-access",
      "x-ms-blob-sequence-number",
      "x-ms-blob-type",
      "x-ms-copy-destination-snapshot",
      "x-ms-creation-time",
      "x-ms-default-encryption-scope",
      "x-ms-delete-snapshots",
      "x-ms-delete-type-permanent",
      "x-ms-deny-encryption-scope-override",
      "x-ms-encryption-algorithm",
      "x-ms-if-sequence-number-eq",
      "x-ms-if-sequence-number-le",
      "x-ms-if-sequence-number-lt",
      "x-ms-incremental-copy",
      "x-ms-lease-action",
      "x-ms-lease-break-period",
      "x-ms-lease-duration",
      "x-ms-lease-id",
      "x-ms-lease-time",
      "x-ms-page-write",
      "x-ms-proposed-lease-id",
      "x-ms-range-get-content-md5",
      "x-ms-rehydrate-priority",
      "x-ms-sequence-number-action",
      "x-ms-sku-name",
      "x-ms-source-content-md5",
      "x-ms-source-if-match",
      "x-ms-source-if-modified-since",
      "x-ms-source-if-none-match",
      "x-ms-source-if-unmodified-since",
      "x-ms-tag-count",
      "x-ms-encryption-key-sha256",
      "x-ms-copy-source-error-code",
      "x-ms-copy-source-status-code",
      "x-ms-if-tags",
      "x-ms-source-if-tags"
    ];
    exports.StorageBlobLoggingAllowedQueryParameters = [
      "comp",
      "maxresults",
      "rscc",
      "rscd",
      "rsce",
      "rscl",
      "rsct",
      "se",
      "si",
      "sip",
      "sp",
      "spr",
      "sr",
      "srt",
      "ss",
      "st",
      "sv",
      "include",
      "marker",
      "prefix",
      "copyid",
      "restype",
      "blockid",
      "blocklisttype",
      "delimiter",
      "prevsnapshot",
      "ske",
      "skoid",
      "sks",
      "skt",
      "sktid",
      "skv",
      "snapshot"
    ];
    exports.BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
    exports.BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
    exports.PathStylePorts = [
      "10000",
      "10001",
      "10002",
      "10003",
      "10004",
      "10100",
      "10101",
      "10102",
      "10103",
      "10104",
      "11000",
      "11001",
      "11002",
      "11003",
      "11004",
      "11100",
      "11101",
      "11102",
      "11103",
      "11104"
    ];
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/utils.common.js
var require_utils_common = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/utils/utils.common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeURLPath = escapeURLPath;
    exports.getValueInConnString = getValueInConnString;
    exports.extractConnectionStringParts = extractConnectionStringParts;
    exports.appendToURLPath = appendToURLPath;
    exports.setURLParameter = setURLParameter;
    exports.getURLParameter = getURLParameter;
    exports.setURLHost = setURLHost;
    exports.getURLPath = getURLPath;
    exports.getURLScheme = getURLScheme;
    exports.getURLPathAndQuery = getURLPathAndQuery;
    exports.getURLQueries = getURLQueries;
    exports.appendToURLQuery = appendToURLQuery;
    exports.truncatedISO8061Date = truncatedISO8061Date;
    exports.base64encode = base64encode2;
    exports.base64decode = base64decode2;
    exports.generateBlockID = generateBlockID;
    exports.delay = delay3;
    exports.padStart = padStart;
    exports.sanitizeURL = sanitizeURL;
    exports.sanitizeHeaders = sanitizeHeaders;
    exports.iEqual = iEqual;
    exports.getAccountNameFromUrl = getAccountNameFromUrl;
    exports.isIpEndpointStyle = isIpEndpointStyle;
    exports.toBlobTagsString = toBlobTagsString;
    exports.toBlobTags = toBlobTags;
    exports.toTags = toTags;
    exports.toQuerySerialization = toQuerySerialization;
    exports.parseObjectReplicationRecord = parseObjectReplicationRecord;
    exports.attachCredential = attachCredential;
    exports.httpAuthorizationToString = httpAuthorizationToString;
    exports.BlobNameToString = BlobNameToString;
    exports.ConvertInternalResponseOfListBlobFlat = ConvertInternalResponseOfListBlobFlat;
    exports.ConvertInternalResponseOfListBlobHierarchy = ConvertInternalResponseOfListBlobHierarchy;
    exports.ExtractPageRangeInfoItems = ExtractPageRangeInfoItems;
    exports.EscapePath = EscapePath;
    exports.assertResponse = assertResponse;
    var core_rest_pipeline_1 = require_commonjs6();
    var core_util_1 = require_commonjs4();
    var constants_js_1 = require_constants9();
    function escapeURLPath(url) {
      const urlParsed = new URL(url);
      let path2 = urlParsed.pathname;
      path2 = path2 || "/";
      path2 = escape(path2);
      urlParsed.pathname = path2;
      return urlParsed.toString();
    }
    function getProxyUriFromDevConnString(connectionString) {
      let proxyUri = "";
      if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
        const matchCredentials = connectionString.split(";");
        for (const element of matchCredentials) {
          if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
            proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
          }
        }
      }
      return proxyUri;
    }
    function getValueInConnString(connectionString, argument) {
      const elements = connectionString.split(";");
      for (const element of elements) {
        if (element.trim().startsWith(argument)) {
          return element.trim().match(argument + "=(.*)")[1];
        }
      }
      return "";
    }
    function extractConnectionStringParts(connectionString) {
      let proxyUri = "";
      if (connectionString.startsWith("UseDevelopmentStorage=true")) {
        proxyUri = getProxyUriFromDevConnString(connectionString);
        connectionString = constants_js_1.DevelopmentConnectionString;
      }
      let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
      blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
      if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
        let defaultEndpointsProtocol = "";
        let accountName = "";
        let accountKey = Buffer.from("accountKey", "base64");
        let endpointSuffix = "";
        accountName = getValueInConnString(connectionString, "AccountName");
        accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
        if (!blobEndpoint) {
          defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
          const protocol = defaultEndpointsProtocol.toLowerCase();
          if (protocol !== "https" && protocol !== "http") {
            throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
          }
          endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
          if (!endpointSuffix) {
            throw new Error("Invalid EndpointSuffix in the provided Connection String");
          }
          blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
        }
        if (!accountName) {
          throw new Error("Invalid AccountName in the provided Connection String");
        } else if (accountKey.length === 0) {
          throw new Error("Invalid AccountKey in the provided Connection String");
        }
        return {
          kind: "AccountConnString",
          url: blobEndpoint,
          accountName,
          accountKey,
          proxyUri
        };
      } else {
        let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
        let accountName = getValueInConnString(connectionString, "AccountName");
        if (!accountName) {
          accountName = getAccountNameFromUrl(blobEndpoint);
        }
        if (!blobEndpoint) {
          throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
        } else if (!accountSas) {
          throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
        }
        if (accountSas.startsWith("?")) {
          accountSas = accountSas.substring(1);
        }
        return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
      }
    }
    function escape(text) {
      return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
    }
    function appendToURLPath(url, name) {
      const urlParsed = new URL(url);
      let path2 = urlParsed.pathname;
      path2 = path2 ? path2.endsWith("/") ? `${path2}${name}` : `${path2}/${name}` : name;
      urlParsed.pathname = path2;
      return urlParsed.toString();
    }
    function setURLParameter(url, name, value) {
      const urlParsed = new URL(url);
      const encodedName = encodeURIComponent(name);
      const encodedValue = value ? encodeURIComponent(value) : void 0;
      const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
      const searchPieces = [];
      for (const pair of searchString.slice(1).split("&")) {
        if (pair) {
          const [key] = pair.split("=", 2);
          if (key !== encodedName) {
            searchPieces.push(pair);
          }
        }
      }
      if (encodedValue) {
        searchPieces.push(`${encodedName}=${encodedValue}`);
      }
      urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
      return urlParsed.toString();
    }
    function getURLParameter(url, name) {
      const urlParsed = new URL(url);
      return urlParsed.searchParams.get(name) ?? void 0;
    }
    function setURLHost(url, host) {
      const urlParsed = new URL(url);
      urlParsed.hostname = host;
      return urlParsed.toString();
    }
    function getURLPath(url) {
      try {
        const urlParsed = new URL(url);
        return urlParsed.pathname;
      } catch (e) {
        return void 0;
      }
    }
    function getURLScheme(url) {
      try {
        const urlParsed = new URL(url);
        return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
      } catch (e) {
        return void 0;
      }
    }
    function getURLPathAndQuery(url) {
      const urlParsed = new URL(url);
      const pathString = urlParsed.pathname;
      if (!pathString) {
        throw new RangeError("Invalid url without valid path.");
      }
      let queryString = urlParsed.search || "";
      queryString = queryString.trim();
      if (queryString !== "") {
        queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
      }
      return `${pathString}${queryString}`;
    }
    function getURLQueries(url) {
      let queryString = new URL(url).search;
      if (!queryString) {
        return {};
      }
      queryString = queryString.trim();
      queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
      let querySubStrings = queryString.split("&");
      querySubStrings = querySubStrings.filter((value) => {
        const indexOfEqual = value.indexOf("=");
        const lastIndexOfEqual = value.lastIndexOf("=");
        return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
      });
      const queries = {};
      for (const querySubString of querySubStrings) {
        const splitResults = querySubString.split("=");
        const key = splitResults[0];
        const value = splitResults[1];
        queries[key] = value;
      }
      return queries;
    }
    function appendToURLQuery(url, queryParts) {
      const urlParsed = new URL(url);
      let query = urlParsed.search;
      if (query) {
        query += "&" + queryParts;
      } else {
        query = queryParts;
      }
      urlParsed.search = query;
      return urlParsed.toString();
    }
    function truncatedISO8061Date(date, withMilliseconds = true) {
      const dateString = date.toISOString();
      return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
    }
    function base64encode2(content) {
      return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
    }
    function base64decode2(encodedString) {
      return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
    }
    function generateBlockID(blockIDPrefix, blockIndex) {
      const maxSourceStringLength = 48;
      const maxBlockIndexLength = 6;
      const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
      if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
        blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
      }
      const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
      return base64encode2(res);
    }
    async function delay3(timeInMs, aborter, abortError) {
      return new Promise((resolve, reject) => {
        let timeout;
        const abortHandler = () => {
          if (timeout !== void 0) {
            clearTimeout(timeout);
          }
          reject(abortError);
        };
        const resolveHandler = () => {
          if (aborter !== void 0) {
            aborter.removeEventListener("abort", abortHandler);
          }
          resolve();
        };
        timeout = setTimeout(resolveHandler, timeInMs);
        if (aborter !== void 0) {
          aborter.addEventListener("abort", abortHandler);
        }
      });
    }
    function padStart(currentString, targetLength, padString = " ") {
      if (String.prototype.padStart) {
        return currentString.padStart(targetLength, padString);
      }
      padString = padString || " ";
      if (currentString.length > targetLength) {
        return currentString;
      } else {
        targetLength = targetLength - currentString.length;
        if (targetLength > padString.length) {
          padString += padString.repeat(targetLength / padString.length);
        }
        return padString.slice(0, targetLength) + currentString;
      }
    }
    function sanitizeURL(url) {
      let safeURL = url;
      if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE)) {
        safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
      }
      return safeURL;
    }
    function sanitizeHeaders(originalHeader) {
      const headers = (0, core_rest_pipeline_1.createHttpHeaders)();
      for (const [name, value] of originalHeader) {
        if (name.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase()) {
          headers.set(name, "*****");
        } else if (name.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE) {
          headers.set(name, sanitizeURL(value));
        } else {
          headers.set(name, value);
        }
      }
      return headers;
    }
    function iEqual(str1, str2) {
      return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
    }
    function getAccountNameFromUrl(url) {
      const parsedUrl = new URL(url);
      let accountName;
      try {
        if (parsedUrl.hostname.split(".")[1] === "blob") {
          accountName = parsedUrl.hostname.split(".")[0];
        } else if (isIpEndpointStyle(parsedUrl)) {
          accountName = parsedUrl.pathname.split("/")[1];
        } else {
          accountName = "";
        }
        return accountName;
      } catch (error2) {
        throw new Error("Unable to extract accountName with provided information.");
      }
    }
    function isIpEndpointStyle(parsedUrl) {
      const host = parsedUrl.host;
      return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
    }
    function toBlobTagsString(tags) {
      if (tags === void 0) {
        return void 0;
      }
      const tagPairs = [];
      for (const key in tags) {
        if (Object.prototype.hasOwnProperty.call(tags, key)) {
          const value = tags[key];
          tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
        }
      }
      return tagPairs.join("&");
    }
    function toBlobTags(tags) {
      if (tags === void 0) {
        return void 0;
      }
      const res = {
        blobTagSet: []
      };
      for (const key in tags) {
        if (Object.prototype.hasOwnProperty.call(tags, key)) {
          const value = tags[key];
          res.blobTagSet.push({
            key,
            value
          });
        }
      }
      return res;
    }
    function toTags(tags) {
      if (tags === void 0) {
        return void 0;
      }
      const res = {};
      for (const blobTag of tags.blobTagSet) {
        res[blobTag.key] = blobTag.value;
      }
      return res;
    }
    function toQuerySerialization(textConfiguration) {
      if (textConfiguration === void 0) {
        return void 0;
      }
      switch (textConfiguration.kind) {
        case "csv":
          return {
            format: {
              type: "delimited",
              delimitedTextConfiguration: {
                columnSeparator: textConfiguration.columnSeparator || ",",
                fieldQuote: textConfiguration.fieldQuote || "",
                recordSeparator: textConfiguration.recordSeparator,
                escapeChar: textConfiguration.escapeCharacter || "",
                headersPresent: textConfiguration.hasHeaders || false
              }
            }
          };
        case "json":
          return {
            format: {
              type: "json",
              jsonTextConfiguration: {
                recordSeparator: textConfiguration.recordSeparator
              }
            }
          };
        case "arrow":
          return {
            format: {
              type: "arrow",
              arrowConfiguration: {
                schema: textConfiguration.schema
              }
            }
          };
        case "parquet":
          return {
            format: {
              type: "parquet"
            }
          };
        default:
          throw Error("Invalid BlobQueryTextConfiguration.");
      }
    }
    function parseObjectReplicationRecord(objectReplicationRecord) {
      if (!objectReplicationRecord) {
        return void 0;
      }
      if ("policy-id" in objectReplicationRecord) {
        return void 0;
      }
      const orProperties = [];
      for (const key in objectReplicationRecord) {
        const ids = key.split("_");
        const policyPrefix = "or-";
        if (ids[0].startsWith(policyPrefix)) {
          ids[0] = ids[0].substring(policyPrefix.length);
        }
        const rule = {
          ruleId: ids[1],
          replicationStatus: objectReplicationRecord[key]
        };
        const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);
        if (policyIndex > -1) {
          orProperties[policyIndex].rules.push(rule);
        } else {
          orProperties.push({
            policyId: ids[0],
            rules: [rule]
          });
        }
      }
      return orProperties;
    }
    function attachCredential(thing, credential) {
      thing.credential = credential;
      return thing;
    }
    function httpAuthorizationToString(httpAuthorization) {
      return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : void 0;
    }
    function BlobNameToString(name) {
      if (name.encoded) {
        return decodeURIComponent(name.content);
      } else {
        return name.content;
      }
    }
    function ConvertInternalResponseOfListBlobFlat(internalResponse) {
      return {
        ...internalResponse,
        segment: {
          blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
            const blobItem = {
              ...blobItemInteral,
              name: BlobNameToString(blobItemInteral.name)
            };
            return blobItem;
          })
        }
      };
    }
    function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
      return {
        ...internalResponse,
        segment: {
          blobPrefixes: internalResponse.segment.blobPrefixes?.map((blobPrefixInternal) => {
            const blobPrefix = {
              ...blobPrefixInternal,
              name: BlobNameToString(blobPrefixInternal.name)
            };
            return blobPrefix;
          }),
          blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
            const blobItem = {
              ...blobItemInteral,
              name: BlobNameToString(blobItemInteral.name)
            };
            return blobItem;
          })
        }
      };
    }
    function* ExtractPageRangeInfoItems(getPageRangesSegment) {
      let pageRange = [];
      let clearRange = [];
      if (getPageRangesSegment.pageRange)
        pageRange = getPageRangesSegment.pageRange;
      if (getPageRangesSegment.clearRange)
        clearRange = getPageRangesSegment.clearRange;
      let pageRangeIndex = 0;
      let clearRangeIndex = 0;
      while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {
        if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {
          yield {
            start: pageRange[pageRangeIndex].start,
            end: pageRange[pageRangeIndex].end,
            isClear: false
          };
          ++pageRangeIndex;
        } else {
          yield {
            start: clearRange[clearRangeIndex].start,
            end: clearRange[clearRangeIndex].end,
            isClear: true
          };
          ++clearRangeIndex;
        }
      }
      for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) {
        yield {
          start: pageRange[pageRangeIndex].start,
          end: pageRange[pageRangeIndex].end,
          isClear: false
        };
      }
      for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) {
        yield {
          start: clearRange[clearRangeIndex].start,
          end: clearRange[clearRangeIndex].end,
          isClear: true
        };
      }
    }
    function EscapePath(blobName) {
      const split = blobName.split("/");
      for (let i2 = 0; i2 < split.length; i2++) {
        split[i2] = encodeURIComponent(split[i2]);
      }
      return split.join("/");
    }
    function assertResponse(response) {
      if (`_response` in response) {
        return response;
      }
      throw new TypeError(`Unexpected response object ${response}`);
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageRetryPolicyType.js
var require_StorageRetryPolicyType = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/StorageRetryPolicyType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageRetryPolicyType = void 0;
    var StorageRetryPolicyType;
    (function(StorageRetryPolicyType2) {
      StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
      StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
    })(StorageRetryPolicyType || (exports.StorageRetryPolicyType = StorageRetryPolicyType = {}));
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageRetryPolicy.js
var require_StorageRetryPolicy = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/StorageRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageRetryPolicy = void 0;
    exports.NewRetryPolicyFactory = NewRetryPolicyFactory;
    var abort_controller_1 = require_commonjs11();
    var RequestPolicy_js_1 = require_RequestPolicy();
    var constants_js_1 = require_constants9();
    var utils_common_js_1 = require_utils_common();
    var log_js_1 = require_log5();
    var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType();
    function NewRetryPolicyFactory(retryOptions) {
      return {
        create: (nextPolicy, options) => {
          return new StorageRetryPolicy(nextPolicy, options, retryOptions);
        }
      };
    }
    var DEFAULT_RETRY_OPTIONS = {
      maxRetryDelayInMs: 120 * 1e3,
      maxTries: 4,
      retryDelayInMs: 4 * 1e3,
      retryPolicyType: StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0
      // Use server side default timeout strategy
    };
    var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
    var StorageRetryPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
      /**
       * RetryOptions.
       */
      retryOptions;
      /**
       * Creates an instance of RetryPolicy.
       *
       * @param nextPolicy -
       * @param options -
       * @param retryOptions -
       */
      constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS) {
        super(nextPolicy, options);
        this.retryOptions = {
          retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
          maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
          tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
          retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
          maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
          secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
        };
      }
      /**
       * Sends request.
       *
       * @param request -
       */
      async sendRequest(request) {
        return this.attemptSendRequest(request, false, 1);
      }
      /**
       * Decide and perform next retry. Won't mutate request parameter.
       *
       * @param request -
       * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
       *                                   the resource was not found. This may be due to replication delay. So, in this
       *                                   case, we'll never try the secondary again for this operation.
       * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
       *                                   the attempt will be performed by this method call.
       */
      async attemptSendRequest(request, secondaryHas404, attempt) {
        const newRequest = request.clone();
        const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") || attempt % 2 === 1;
        if (!isPrimaryRetry) {
          newRequest.url = (0, utils_common_js_1.setURLHost)(newRequest.url, this.retryOptions.secondaryHost);
        }
        if (this.retryOptions.tryTimeoutInMs) {
          newRequest.url = (0, utils_common_js_1.setURLParameter)(newRequest.url, constants_js_1.URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString());
        }
        let response;
        try {
          log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
          response = await this._nextPolicy.sendRequest(newRequest);
          if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
            return response;
          }
          secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
        } catch (err) {
          log_js_1.logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
          if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) {
            throw err;
          }
        }
        await this.delay(isPrimaryRetry, attempt, request.abortSignal);
        return this.attemptSendRequest(request, secondaryHas404, ++attempt);
      }
      /**
       * Decide whether to retry according to last HTTP response and retry counters.
       *
       * @param isPrimaryRetry -
       * @param attempt -
       * @param response -
       * @param err -
       */
      shouldRetry(isPrimaryRetry, attempt, response, err) {
        if (attempt >= this.retryOptions.maxTries) {
          log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
          return false;
        }
        const retriableErrors = [
          "ETIMEDOUT",
          "ESOCKETTIMEDOUT",
          "ECONNREFUSED",
          "ECONNRESET",
          "ENOENT",
          "ENOTFOUND",
          "TIMEOUT",
          "EPIPE",
          "REQUEST_SEND_ERROR"
          // For default xhr based http client provided in ms-rest-js
        ];
        if (err) {
          for (const retriableError of retriableErrors) {
            if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
              log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
              return true;
            }
          }
        }
        if (response || err) {
          const statusCode = response ? response.status : err ? err.statusCode : 0;
          if (!isPrimaryRetry && statusCode === 404) {
            log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
            return true;
          }
          if (statusCode === 503 || statusCode === 500) {
            log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
            return true;
          }
        }
        if (response) {
          if (response?.status >= 400) {
            const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
            if (copySourceError !== void 0) {
              switch (copySourceError) {
                case "InternalError":
                case "OperationTimedOut":
                case "ServerBusy":
                  return true;
              }
            }
          }
        }
        if (err?.code === "PARSE_ERROR" && err?.message.startsWith(`Error "Error: Unclosed root tag`)) {
          log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
          return true;
        }
        return false;
      }
      /**
       * Delay a calculated time between retries.
       *
       * @param isPrimaryRetry -
       * @param attempt -
       * @param abortSignal -
       */
      async delay(isPrimaryRetry, attempt, abortSignal2) {
        let delayTimeInMs = 0;
        if (isPrimaryRetry) {
          switch (this.retryOptions.retryPolicyType) {
            case StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL:
              delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
              break;
            case StorageRetryPolicyType_js_1.StorageRetryPolicyType.FIXED:
              delayTimeInMs = this.retryOptions.retryDelayInMs;
              break;
          }
        } else {
          delayTimeInMs = Math.random() * 1e3;
        }
        log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
        return (0, utils_common_js_1.delay)(delayTimeInMs, abortSignal2, RETRY_ABORT_ERROR);
      }
    };
    exports.StorageRetryPolicy = StorageRetryPolicy;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageRetryPolicyFactory.js
var require_StorageRetryPolicyFactory = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/StorageRetryPolicyFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = void 0;
    var StorageRetryPolicy_js_1 = require_StorageRetryPolicy();
    Object.defineProperty(exports, "StorageRetryPolicy", { enumerable: true, get: function() {
      return StorageRetryPolicy_js_1.StorageRetryPolicy;
    } });
    var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType();
    Object.defineProperty(exports, "StorageRetryPolicyType", { enumerable: true, get: function() {
      return StorageRetryPolicyType_js_1.StorageRetryPolicyType;
    } });
    var StorageRetryPolicyFactory = class {
      retryOptions;
      /**
       * Creates an instance of StorageRetryPolicyFactory.
       * @param retryOptions -
       */
      constructor(retryOptions) {
        this.retryOptions = retryOptions;
      }
      /**
       * Creates a StorageRetryPolicy object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options) {
        return new StorageRetryPolicy_js_1.StorageRetryPolicy(nextPolicy, options, this.retryOptions);
      }
    };
    exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/CredentialPolicy.js
var require_CredentialPolicy = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/CredentialPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialPolicy = void 0;
    var RequestPolicy_js_1 = require_RequestPolicy();
    var CredentialPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
      /**
       * Sends out request.
       *
       * @param request -
       */
      sendRequest(request) {
        return this._nextPolicy.sendRequest(this.signRequest(request));
      }
      /**
       * Child classes must implement this method with request signing. This method
       * will be executed in {@link sendRequest}.
       *
       * @param request -
       */
      signRequest(request) {
        return request;
      }
    };
    exports.CredentialPolicy = CredentialPolicy;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/SharedKeyComparator.js
var require_SharedKeyComparator = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/utils/SharedKeyComparator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compareHeader = compareHeader;
    var table_lv0 = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1820,
      0,
      1823,
      1825,
      1827,
      1829,
      0,
      0,
      0,
      1837,
      2051,
      0,
      0,
      1843,
      0,
      3331,
      3354,
      3356,
      3358,
      3360,
      3362,
      3364,
      3366,
      3368,
      3370,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3586,
      3593,
      3594,
      3610,
      3617,
      3619,
      3621,
      3628,
      3634,
      3637,
      3638,
      3656,
      3665,
      3696,
      3708,
      3710,
      3721,
      3722,
      3729,
      3737,
      3743,
      3746,
      3748,
      3750,
      3751,
      3753,
      0,
      0,
      0,
      1859,
      1860,
      1864,
      3586,
      3593,
      3594,
      3610,
      3617,
      3619,
      3621,
      3628,
      3634,
      3637,
      3638,
      3656,
      3665,
      3696,
      3708,
      3710,
      3721,
      3722,
      3729,
      3737,
      3743,
      3746,
      3748,
      3750,
      3751,
      3753,
      0,
      1868,
      0,
      1872,
      0
    ]);
    var table_lv2 = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var table_lv4 = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      32786,
      0,
      0,
      0,
      0,
      0,
      33298,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    function compareHeader(lhs, rhs) {
      if (isLessThan(lhs, rhs))
        return -1;
      return 1;
    }
    function isLessThan(lhs, rhs) {
      const tables = [table_lv0, table_lv2, table_lv4];
      let curr_level = 0;
      let i2 = 0;
      let j = 0;
      while (curr_level < tables.length) {
        if (curr_level === tables.length - 1 && i2 !== j) {
          return i2 > j;
        }
        const weight1 = i2 < lhs.length ? tables[curr_level][lhs[i2].charCodeAt(0)] : 1;
        const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
        if (weight1 === 1 && weight2 === 1) {
          i2 = 0;
          j = 0;
          ++curr_level;
        } else if (weight1 === weight2) {
          ++i2;
          ++j;
        } else if (weight1 === 0) {
          ++i2;
        } else if (weight2 === 0) {
          ++j;
        } else {
          return weight1 < weight2;
        }
      }
      return false;
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageSharedKeyCredentialPolicy.js
var require_StorageSharedKeyCredentialPolicy = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/StorageSharedKeyCredentialPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageSharedKeyCredentialPolicy = void 0;
    var constants_js_1 = require_constants9();
    var utils_common_js_1 = require_utils_common();
    var CredentialPolicy_js_1 = require_CredentialPolicy();
    var SharedKeyComparator_js_1 = require_SharedKeyComparator();
    var StorageSharedKeyCredentialPolicy = class extends CredentialPolicy_js_1.CredentialPolicy {
      /**
       * Reference to StorageSharedKeyCredential which generates StorageSharedKeyCredentialPolicy
       */
      factory;
      /**
       * Creates an instance of StorageSharedKeyCredentialPolicy.
       * @param nextPolicy -
       * @param options -
       * @param factory -
       */
      constructor(nextPolicy, options, factory) {
        super(nextPolicy, options);
        this.factory = factory;
      }
      /**
       * Signs request.
       *
       * @param request -
       */
      signRequest(request) {
        request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
        if (request.body && (typeof request.body === "string" || request.body !== void 0) && request.body.length > 0) {
          request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        const stringToSign = [
          request.method.toUpperCase(),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
        ].join("\n") + "\n" + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request);
        const signature = this.factory.computeHMACSHA256(stringToSign);
        request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
        return request;
      }
      /**
       * Retrieve header value according to shared key sign rules.
       * @see https://learn.microsoft.com/rest/api/storageservices/authenticate-with-shared-key
       *
       * @param request -
       * @param headerName -
       */
      getHeaderValueToSign(request, headerName) {
        const value = request.headers.get(headerName);
        if (!value) {
          return "";
        }
        if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
          return "";
        }
        return value;
      }
      /**
       * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
       * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
       * 2. Convert each HTTP header name to lowercase.
       * 3. Sort the headers lexicographically by header name, in ascending order.
       *    Each header may appear only once in the string.
       * 4. Replace any linear whitespace in the header value with a single space.
       * 5. Trim any whitespace around the colon in the header.
       * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
       *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
       *
       * @param request -
       */
      getCanonicalizedHeadersString(request) {
        let headersArray = request.headers.headersArray().filter((value) => {
          return value.name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE);
        });
        headersArray.sort((a2, b) => {
          return (0, SharedKeyComparator_js_1.compareHeader)(a2.name.toLowerCase(), b.name.toLowerCase());
        });
        headersArray = headersArray.filter((value, index, array) => {
          if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
            return false;
          }
          return true;
        });
        let canonicalizedHeadersStringToSign = "";
        headersArray.forEach((header) => {
          canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
        });
        return canonicalizedHeadersStringToSign;
      }
      /**
       * Retrieves the webResource canonicalized resource string.
       *
       * @param request -
       */
      getCanonicalizedResourceString(request) {
        const path2 = (0, utils_common_js_1.getURLPath)(request.url) || "/";
        let canonicalizedResourceString = "";
        canonicalizedResourceString += `/${this.factory.accountName}${path2}`;
        const queries = (0, utils_common_js_1.getURLQueries)(request.url);
        const lowercaseQueries = {};
        if (queries) {
          const queryKeys = [];
          for (const key in queries) {
            if (Object.prototype.hasOwnProperty.call(queries, key)) {
              const lowercaseKey = key.toLowerCase();
              lowercaseQueries[lowercaseKey] = queries[key];
              queryKeys.push(lowercaseKey);
            }
          }
          queryKeys.sort();
          for (const key of queryKeys) {
            canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
          }
        }
        return canonicalizedResourceString;
      }
    };
    exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/credentials/Credential.js
var require_Credential = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/credentials/Credential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Credential = void 0;
    var Credential = class {
      /**
       * Creates a RequestPolicy object.
       *
       * @param _nextPolicy -
       * @param _options -
       */
      create(_nextPolicy, _options2) {
        throw new Error("Method should be implemented in children classes.");
      }
    };
    exports.Credential = Credential;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/credentials/StorageSharedKeyCredential.js
var require_StorageSharedKeyCredential = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/credentials/StorageSharedKeyCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageSharedKeyCredential = void 0;
    var node_crypto_1 = __require("crypto");
    var StorageSharedKeyCredentialPolicy_js_1 = require_StorageSharedKeyCredentialPolicy();
    var Credential_js_1 = require_Credential();
    var StorageSharedKeyCredential = class extends Credential_js_1.Credential {
      /**
       * Azure Storage account name; readonly.
       */
      accountName;
      /**
       * Azure Storage account key; readonly.
       */
      accountKey;
      /**
       * Creates an instance of StorageSharedKeyCredential.
       * @param accountName -
       * @param accountKey -
       */
      constructor(accountName, accountKey) {
        super();
        this.accountName = accountName;
        this.accountKey = Buffer.from(accountKey, "base64");
      }
      /**
       * Creates a StorageSharedKeyCredentialPolicy object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options) {
        return new StorageSharedKeyCredentialPolicy_js_1.StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
      }
      /**
       * Generates a hash signature for an HTTP request or for a SAS.
       *
       * @param stringToSign -
       */
      computeHMACSHA256(stringToSign) {
        return (0, node_crypto_1.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
      }
    };
    exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/AnonymousCredentialPolicy.js
var require_AnonymousCredentialPolicy = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/AnonymousCredentialPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousCredentialPolicy = void 0;
    var CredentialPolicy_js_1 = require_CredentialPolicy();
    var AnonymousCredentialPolicy = class extends CredentialPolicy_js_1.CredentialPolicy {
      /**
       * Creates an instance of AnonymousCredentialPolicy.
       * @param nextPolicy -
       * @param options -
       */
      // The base class has a protected constructor. Adding a public one to enable constructing of this class.
      /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
      constructor(nextPolicy, options) {
        super(nextPolicy, options);
      }
    };
    exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/credentials/AnonymousCredential.js
var require_AnonymousCredential = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/credentials/AnonymousCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousCredential = void 0;
    var AnonymousCredentialPolicy_js_1 = require_AnonymousCredentialPolicy();
    var Credential_js_1 = require_Credential();
    var AnonymousCredential = class extends Credential_js_1.Credential {
      /**
       * Creates an {@link AnonymousCredentialPolicy} object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options) {
        return new AnonymousCredentialPolicy_js_1.AnonymousCredentialPolicy(nextPolicy, options);
      }
    };
    exports.AnonymousCredential = AnonymousCredential;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/BuffersStream.js
var require_BuffersStream = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/BuffersStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BuffersStream = void 0;
    var node_stream_1 = __require("stream");
    var BuffersStream = class extends node_stream_1.Readable {
      buffers;
      byteLength;
      /**
       * The offset of data to be read in the current buffer.
       */
      byteOffsetInCurrentBuffer;
      /**
       * The index of buffer to be read in the array of buffers.
       */
      bufferIndex;
      /**
       * The total length of data already read.
       */
      pushedBytesLength;
      /**
       * Creates an instance of BuffersStream that will emit the data
       * contained in the array of buffers.
       *
       * @param buffers - Array of buffers containing the data
       * @param byteLength - The total length of data contained in the buffers
       */
      constructor(buffers, byteLength2, options) {
        super(options);
        this.buffers = buffers;
        this.byteLength = byteLength2;
        this.byteOffsetInCurrentBuffer = 0;
        this.bufferIndex = 0;
        this.pushedBytesLength = 0;
        let buffersLength = 0;
        for (const buf of this.buffers) {
          buffersLength += buf.byteLength;
        }
        if (buffersLength < this.byteLength) {
          throw new Error("Data size shouldn't be larger than the total length of buffers.");
        }
      }
      /**
       * Internal _read() that will be called when the stream wants to pull more data in.
       *
       * @param size - Optional. The size of data to be read
       */
      _read(size) {
        if (this.pushedBytesLength >= this.byteLength) {
          this.push(null);
        }
        if (!size) {
          size = this.readableHighWaterMark;
        }
        const outBuffers = [];
        let i2 = 0;
        while (i2 < size && this.pushedBytesLength < this.byteLength) {
          const remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength;
          const remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer;
          const remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
          if (remaining > size - i2) {
            const end = this.byteOffsetInCurrentBuffer + size - i2;
            outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
            this.pushedBytesLength += size - i2;
            this.byteOffsetInCurrentBuffer = end;
            i2 = size;
            break;
          } else {
            const end = this.byteOffsetInCurrentBuffer + remaining;
            outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
            if (remaining === remainingCapacityInThisBuffer) {
              this.byteOffsetInCurrentBuffer = 0;
              this.bufferIndex++;
            } else {
              this.byteOffsetInCurrentBuffer = end;
            }
            this.pushedBytesLength += remaining;
            i2 += remaining;
          }
        }
        if (outBuffers.length > 1) {
          this.push(Buffer.concat(outBuffers));
        } else if (outBuffers.length === 1) {
          this.push(outBuffers[0]);
        }
      }
    };
    exports.BuffersStream = BuffersStream;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/PooledBuffer.js
var require_PooledBuffer = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/PooledBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PooledBuffer = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var BuffersStream_js_1 = require_BuffersStream();
    var node_buffer_1 = tslib_1.__importDefault(__require("buffer"));
    var maxBufferLength = node_buffer_1.default.constants.MAX_LENGTH;
    var PooledBuffer = class {
      /**
       * Internal buffers used to keep the data.
       * Each buffer has a length of the maxBufferLength except last one.
       */
      buffers = [];
      /**
       * The total size of internal buffers.
       */
      capacity;
      /**
       * The total size of data contained in internal buffers.
       */
      _size;
      /**
       * The size of the data contained in the pooled buffers.
       */
      get size() {
        return this._size;
      }
      constructor(capacity, buffers, totalLength) {
        this.capacity = capacity;
        this._size = 0;
        const bufferNum = Math.ceil(capacity / maxBufferLength);
        for (let i2 = 0; i2 < bufferNum; i2++) {
          let len = i2 === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
          if (len === 0) {
            len = maxBufferLength;
          }
          this.buffers.push(Buffer.allocUnsafe(len));
        }
        if (buffers) {
          this.fill(buffers, totalLength);
        }
      }
      /**
       * Fill the internal buffers with data in the input buffers serially
       * with respect to the total length and the total capacity of the internal buffers.
       * Data copied will be shift out of the input buffers.
       *
       * @param buffers - Input buffers containing the data to be filled in the pooled buffer
       * @param totalLength - Total length of the data to be filled in.
       *
       */
      fill(buffers, totalLength) {
        this._size = Math.min(this.capacity, totalLength);
        let i2 = 0, j = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0;
        while (totalCopiedNum < this._size) {
          const source = buffers[i2];
          const target = this.buffers[j];
          const copiedNum = source.copy(target, targetOffset, sourceOffset);
          totalCopiedNum += copiedNum;
          sourceOffset += copiedNum;
          targetOffset += copiedNum;
          if (sourceOffset === source.length) {
            i2++;
            sourceOffset = 0;
          }
          if (targetOffset === target.length) {
            j++;
            targetOffset = 0;
          }
        }
        buffers.splice(0, i2);
        if (buffers.length > 0) {
          buffers[0] = buffers[0].slice(sourceOffset);
        }
      }
      /**
       * Get the readable stream assembled from all the data in the internal buffers.
       *
       */
      getReadableStream() {
        return new BuffersStream_js_1.BuffersStream(this.buffers, this.size);
      }
    };
    exports.PooledBuffer = PooledBuffer;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/BufferScheduler.js
var require_BufferScheduler = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/BufferScheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferScheduler = void 0;
    var events_1 = __require("events");
    var PooledBuffer_js_1 = require_PooledBuffer();
    var BufferScheduler = class {
      /**
       * Size of buffers in incoming and outgoing queues. This class will try to align
       * data read from Readable stream into buffer chunks with bufferSize defined.
       */
      bufferSize;
      /**
       * How many buffers can be created or maintained.
       */
      maxBuffers;
      /**
       * A Node.js Readable stream.
       */
      readable;
      /**
       * OutgoingHandler is an async function triggered by BufferScheduler when there
       * are available buffers in outgoing array.
       */
      outgoingHandler;
      /**
       * An internal event emitter.
       */
      emitter = new events_1.EventEmitter();
      /**
       * Concurrency of executing outgoingHandlers. (0 lesser than concurrency lesser than or equal to maxBuffers)
       */
      concurrency;
      /**
       * An internal offset marker to track data offset in bytes of next outgoingHandler.
       */
      offset = 0;
      /**
       * An internal marker to track whether stream is end.
       */
      isStreamEnd = false;
      /**
       * An internal marker to track whether stream or outgoingHandler returns error.
       */
      isError = false;
      /**
       * How many handlers are executing.
       */
      executingOutgoingHandlers = 0;
      /**
       * Encoding of the input Readable stream which has string data type instead of Buffer.
       */
      encoding;
      /**
       * How many buffers have been allocated.
       */
      numBuffers = 0;
      /**
       * Because this class doesn't know how much data every time stream pops, which
       * is defined by highWaterMarker of the stream. So BufferScheduler will cache
       * data received from the stream, when data in unresolvedDataArray exceeds the
       * blockSize defined, it will try to concat a blockSize of buffer, fill into available
       * buffers from incoming and push to outgoing array.
       */
      unresolvedDataArray = [];
      /**
       * How much data consisted in unresolvedDataArray.
       */
      unresolvedLength = 0;
      /**
       * The array includes all the available buffers can be used to fill data from stream.
       */
      incoming = [];
      /**
       * The array (queue) includes all the buffers filled from stream data.
       */
      outgoing = [];
      /**
       * Creates an instance of BufferScheduler.
       *
       * @param readable - A Node.js Readable stream
       * @param bufferSize - Buffer size of every maintained buffer
       * @param maxBuffers - How many buffers can be allocated
       * @param outgoingHandler - An async function scheduled to be
       *                                          triggered when a buffer fully filled
       *                                          with stream data
       * @param concurrency - Concurrency of executing outgoingHandlers (&gt;0)
       * @param encoding - [Optional] Encoding of Readable stream when it's a string stream
       */
      constructor(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
        if (bufferSize <= 0) {
          throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
        }
        if (maxBuffers <= 0) {
          throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
        }
        if (concurrency <= 0) {
          throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
        }
        this.bufferSize = bufferSize;
        this.maxBuffers = maxBuffers;
        this.readable = readable;
        this.outgoingHandler = outgoingHandler;
        this.concurrency = concurrency;
        this.encoding = encoding;
      }
      /**
       * Start the scheduler, will return error when stream of any of the outgoingHandlers
       * returns error.
       *
       */
      async do() {
        return new Promise((resolve, reject) => {
          this.readable.on("data", (data) => {
            data = typeof data === "string" ? Buffer.from(data, this.encoding) : data;
            this.appendUnresolvedData(data);
            if (!this.resolveData()) {
              this.readable.pause();
            }
          });
          this.readable.on("error", (err) => {
            this.emitter.emit("error", err);
          });
          this.readable.on("end", () => {
            this.isStreamEnd = true;
            this.emitter.emit("checkEnd");
          });
          this.emitter.on("error", (err) => {
            this.isError = true;
            this.readable.pause();
            reject(err);
          });
          this.emitter.on("checkEnd", () => {
            if (this.outgoing.length > 0) {
              this.triggerOutgoingHandlers();
              return;
            }
            if (this.isStreamEnd && this.executingOutgoingHandlers === 0) {
              if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
                const buffer = this.shiftBufferFromUnresolvedDataArray();
                this.outgoingHandler(() => buffer.getReadableStream(), buffer.size, this.offset).then(resolve).catch(reject);
              } else if (this.unresolvedLength >= this.bufferSize) {
                return;
              } else {
                resolve();
              }
            }
          });
        });
      }
      /**
       * Insert a new data into unresolved array.
       *
       * @param data -
       */
      appendUnresolvedData(data) {
        this.unresolvedDataArray.push(data);
        this.unresolvedLength += data.length;
      }
      /**
       * Try to shift a buffer with size in blockSize. The buffer returned may be less
       * than blockSize when data in unresolvedDataArray is less than bufferSize.
       *
       */
      shiftBufferFromUnresolvedDataArray(buffer) {
        if (!buffer) {
          buffer = new PooledBuffer_js_1.PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength);
        } else {
          buffer.fill(this.unresolvedDataArray, this.unresolvedLength);
        }
        this.unresolvedLength -= buffer.size;
        return buffer;
      }
      /**
       * Resolve data in unresolvedDataArray. For every buffer with size in blockSize
       * shifted, it will try to get (or allocate a buffer) from incoming, and fill it,
       * then push it into outgoing to be handled by outgoing handler.
       *
       * Return false when available buffers in incoming are not enough, else true.
       *
       * @returns Return false when buffers in incoming are not enough, else true.
       */
      resolveData() {
        while (this.unresolvedLength >= this.bufferSize) {
          let buffer;
          if (this.incoming.length > 0) {
            buffer = this.incoming.shift();
            this.shiftBufferFromUnresolvedDataArray(buffer);
          } else {
            if (this.numBuffers < this.maxBuffers) {
              buffer = this.shiftBufferFromUnresolvedDataArray();
              this.numBuffers++;
            } else {
              return false;
            }
          }
          this.outgoing.push(buffer);
          this.triggerOutgoingHandlers();
        }
        return true;
      }
      /**
       * Try to trigger a outgoing handler for every buffer in outgoing. Stop when
       * concurrency reaches.
       */
      async triggerOutgoingHandlers() {
        let buffer;
        do {
          if (this.executingOutgoingHandlers >= this.concurrency) {
            return;
          }
          buffer = this.outgoing.shift();
          if (buffer) {
            this.triggerOutgoingHandler(buffer);
          }
        } while (buffer);
      }
      /**
       * Trigger a outgoing handler for a buffer shifted from outgoing.
       *
       * @param buffer -
       */
      async triggerOutgoingHandler(buffer) {
        const bufferLength = buffer.size;
        this.executingOutgoingHandlers++;
        this.offset += bufferLength;
        try {
          await this.outgoingHandler(() => buffer.getReadableStream(), bufferLength, this.offset - bufferLength);
        } catch (err) {
          this.emitter.emit("error", err);
          return;
        }
        this.executingOutgoingHandlers--;
        this.reuseBuffer(buffer);
        this.emitter.emit("checkEnd");
      }
      /**
       * Return buffer used by outgoing handler into incoming.
       *
       * @param buffer -
       */
      reuseBuffer(buffer) {
        this.incoming.push(buffer);
        if (!this.isError && this.resolveData() && !this.isStreamEnd) {
          this.readable.resume();
        }
      }
    };
    exports.BufferScheduler = BufferScheduler;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/cache.js
var require_cache2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
    var core_rest_pipeline_1 = require_commonjs6();
    var _defaultHttpClient;
    function getCachedDefaultHttpClient() {
      if (!_defaultHttpClient) {
        _defaultHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
      }
      return _defaultHttpClient;
    }
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/RequestPolicy.js
var require_RequestPolicy2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/RequestPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseRequestPolicy = void 0;
    var BaseRequestPolicy = class {
      _nextPolicy;
      _options;
      /**
       * The main method to implement that manipulates a request/response.
       */
      constructor(_nextPolicy, _options2) {
        this._nextPolicy = _nextPolicy;
        this._options = _options2;
      }
      /**
       * Get whether or not a log with the provided log level should be logged.
       * @param logLevel - The log level of the log that will be logged.
       * @returns Whether or not a log with the provided log level should be logged.
       */
      shouldLog(logLevel) {
        return this._options.shouldLog(logLevel);
      }
      /**
       * Attempt to log the provided message to the provided logger. If no logger was provided or if
       * the log level does not meat the logger's threshold, then nothing will be logged.
       * @param logLevel - The log level of this log.
       * @param message - The message of this log.
       */
      log(logLevel, message) {
        this._options.log(logLevel, message);
      }
    };
    exports.BaseRequestPolicy = BaseRequestPolicy;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/utils/constants.js
var require_constants10 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/utils/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PathStylePorts = exports.DevelopmentConnectionString = exports.HeaderConstants = exports.URLConstants = exports.SDK_VERSION = void 0;
    exports.SDK_VERSION = "1.0.0";
    exports.URLConstants = {
      Parameters: {
        FORCE_BROWSER_NO_CACHE: "_",
        SIGNATURE: "sig",
        SNAPSHOT: "snapshot",
        VERSIONID: "versionid",
        TIMEOUT: "timeout"
      }
    };
    exports.HeaderConstants = {
      AUTHORIZATION: "Authorization",
      AUTHORIZATION_SCHEME: "Bearer",
      CONTENT_ENCODING: "Content-Encoding",
      CONTENT_ID: "Content-ID",
      CONTENT_LANGUAGE: "Content-Language",
      CONTENT_LENGTH: "Content-Length",
      CONTENT_MD5: "Content-Md5",
      CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
      CONTENT_TYPE: "Content-Type",
      COOKIE: "Cookie",
      DATE: "date",
      IF_MATCH: "if-match",
      IF_MODIFIED_SINCE: "if-modified-since",
      IF_NONE_MATCH: "if-none-match",
      IF_UNMODIFIED_SINCE: "if-unmodified-since",
      PREFIX_FOR_STORAGE: "x-ms-",
      RANGE: "Range",
      USER_AGENT: "User-Agent",
      X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
      X_MS_COPY_SOURCE: "x-ms-copy-source",
      X_MS_DATE: "x-ms-date",
      X_MS_ERROR_CODE: "x-ms-error-code",
      X_MS_VERSION: "x-ms-version",
      X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
    };
    exports.DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
    exports.PathStylePorts = [
      "10000",
      "10001",
      "10002",
      "10003",
      "10004",
      "10100",
      "10101",
      "10102",
      "10103",
      "10104",
      "11000",
      "11001",
      "11002",
      "11003",
      "11004",
      "11100",
      "11101",
      "11102",
      "11103",
      "11104"
    ];
  }
});

// node_modules/@azure/storage-common/dist/commonjs/utils/utils.common.js
var require_utils_common2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/utils/utils.common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeURLPath = escapeURLPath;
    exports.getValueInConnString = getValueInConnString;
    exports.extractConnectionStringParts = extractConnectionStringParts;
    exports.appendToURLPath = appendToURLPath;
    exports.setURLParameter = setURLParameter;
    exports.getURLParameter = getURLParameter;
    exports.setURLHost = setURLHost;
    exports.getURLPath = getURLPath;
    exports.getURLScheme = getURLScheme;
    exports.getURLPathAndQuery = getURLPathAndQuery;
    exports.getURLQueries = getURLQueries;
    exports.appendToURLQuery = appendToURLQuery;
    exports.truncatedISO8061Date = truncatedISO8061Date;
    exports.base64encode = base64encode2;
    exports.base64decode = base64decode2;
    exports.generateBlockID = generateBlockID;
    exports.delay = delay3;
    exports.padStart = padStart;
    exports.sanitizeURL = sanitizeURL;
    exports.sanitizeHeaders = sanitizeHeaders;
    exports.iEqual = iEqual;
    exports.getAccountNameFromUrl = getAccountNameFromUrl;
    exports.isIpEndpointStyle = isIpEndpointStyle;
    exports.attachCredential = attachCredential;
    exports.httpAuthorizationToString = httpAuthorizationToString;
    exports.EscapePath = EscapePath;
    exports.assertResponse = assertResponse;
    var core_rest_pipeline_1 = require_commonjs6();
    var core_util_1 = require_commonjs4();
    var constants_js_1 = require_constants10();
    function escapeURLPath(url) {
      const urlParsed = new URL(url);
      let path2 = urlParsed.pathname;
      path2 = path2 || "/";
      path2 = escape(path2);
      urlParsed.pathname = path2;
      return urlParsed.toString();
    }
    function getProxyUriFromDevConnString(connectionString) {
      let proxyUri = "";
      if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
        const matchCredentials = connectionString.split(";");
        for (const element of matchCredentials) {
          if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
            proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
          }
        }
      }
      return proxyUri;
    }
    function getValueInConnString(connectionString, argument) {
      const elements = connectionString.split(";");
      for (const element of elements) {
        if (element.trim().startsWith(argument)) {
          return element.trim().match(argument + "=(.*)")[1];
        }
      }
      return "";
    }
    function extractConnectionStringParts(connectionString) {
      let proxyUri = "";
      if (connectionString.startsWith("UseDevelopmentStorage=true")) {
        proxyUri = getProxyUriFromDevConnString(connectionString);
        connectionString = constants_js_1.DevelopmentConnectionString;
      }
      let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
      blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
      if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
        let defaultEndpointsProtocol = "";
        let accountName = "";
        let accountKey = Buffer.from("accountKey", "base64");
        let endpointSuffix = "";
        accountName = getValueInConnString(connectionString, "AccountName");
        accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
        if (!blobEndpoint) {
          defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
          const protocol = defaultEndpointsProtocol.toLowerCase();
          if (protocol !== "https" && protocol !== "http") {
            throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
          }
          endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
          if (!endpointSuffix) {
            throw new Error("Invalid EndpointSuffix in the provided Connection String");
          }
          blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
        }
        if (!accountName) {
          throw new Error("Invalid AccountName in the provided Connection String");
        } else if (accountKey.length === 0) {
          throw new Error("Invalid AccountKey in the provided Connection String");
        }
        return {
          kind: "AccountConnString",
          url: blobEndpoint,
          accountName,
          accountKey,
          proxyUri
        };
      } else {
        let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
        let accountName = getValueInConnString(connectionString, "AccountName");
        if (!accountName) {
          accountName = getAccountNameFromUrl(blobEndpoint);
        }
        if (!blobEndpoint) {
          throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
        } else if (!accountSas) {
          throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
        }
        if (accountSas.startsWith("?")) {
          accountSas = accountSas.substring(1);
        }
        return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
      }
    }
    function escape(text) {
      return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
    }
    function appendToURLPath(url, name) {
      const urlParsed = new URL(url);
      let path2 = urlParsed.pathname;
      path2 = path2 ? path2.endsWith("/") ? `${path2}${name}` : `${path2}/${name}` : name;
      urlParsed.pathname = path2;
      return urlParsed.toString();
    }
    function setURLParameter(url, name, value) {
      const urlParsed = new URL(url);
      const encodedName = encodeURIComponent(name);
      const encodedValue = value ? encodeURIComponent(value) : void 0;
      const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
      const searchPieces = [];
      for (const pair of searchString.slice(1).split("&")) {
        if (pair) {
          const [key] = pair.split("=", 2);
          if (key !== encodedName) {
            searchPieces.push(pair);
          }
        }
      }
      if (encodedValue) {
        searchPieces.push(`${encodedName}=${encodedValue}`);
      }
      urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
      return urlParsed.toString();
    }
    function getURLParameter(url, name) {
      const urlParsed = new URL(url);
      return urlParsed.searchParams.get(name) ?? void 0;
    }
    function setURLHost(url, host) {
      const urlParsed = new URL(url);
      urlParsed.hostname = host;
      return urlParsed.toString();
    }
    function getURLPath(url) {
      try {
        const urlParsed = new URL(url);
        return urlParsed.pathname;
      } catch (e) {
        return void 0;
      }
    }
    function getURLScheme(url) {
      try {
        const urlParsed = new URL(url);
        return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
      } catch (e) {
        return void 0;
      }
    }
    function getURLPathAndQuery(url) {
      const urlParsed = new URL(url);
      const pathString = urlParsed.pathname;
      if (!pathString) {
        throw new RangeError("Invalid url without valid path.");
      }
      let queryString = urlParsed.search || "";
      queryString = queryString.trim();
      if (queryString !== "") {
        queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
      }
      return `${pathString}${queryString}`;
    }
    function getURLQueries(url) {
      let queryString = new URL(url).search;
      if (!queryString) {
        return {};
      }
      queryString = queryString.trim();
      queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
      let querySubStrings = queryString.split("&");
      querySubStrings = querySubStrings.filter((value) => {
        const indexOfEqual = value.indexOf("=");
        const lastIndexOfEqual = value.lastIndexOf("=");
        return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
      });
      const queries = {};
      for (const querySubString of querySubStrings) {
        const splitResults = querySubString.split("=");
        const key = splitResults[0];
        const value = splitResults[1];
        queries[key] = value;
      }
      return queries;
    }
    function appendToURLQuery(url, queryParts) {
      const urlParsed = new URL(url);
      let query = urlParsed.search;
      if (query) {
        query += "&" + queryParts;
      } else {
        query = queryParts;
      }
      urlParsed.search = query;
      return urlParsed.toString();
    }
    function truncatedISO8061Date(date, withMilliseconds = true) {
      const dateString = date.toISOString();
      return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
    }
    function base64encode2(content) {
      return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
    }
    function base64decode2(encodedString) {
      return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
    }
    function generateBlockID(blockIDPrefix, blockIndex) {
      const maxSourceStringLength = 48;
      const maxBlockIndexLength = 6;
      const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
      if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
        blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
      }
      const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
      return base64encode2(res);
    }
    async function delay3(timeInMs, aborter, abortError) {
      return new Promise((resolve, reject) => {
        let timeout;
        const abortHandler = () => {
          if (timeout !== void 0) {
            clearTimeout(timeout);
          }
          reject(abortError);
        };
        const resolveHandler = () => {
          if (aborter !== void 0) {
            aborter.removeEventListener("abort", abortHandler);
          }
          resolve();
        };
        timeout = setTimeout(resolveHandler, timeInMs);
        if (aborter !== void 0) {
          aborter.addEventListener("abort", abortHandler);
        }
      });
    }
    function padStart(currentString, targetLength, padString = " ") {
      if (String.prototype.padStart) {
        return currentString.padStart(targetLength, padString);
      }
      padString = padString || " ";
      if (currentString.length > targetLength) {
        return currentString;
      } else {
        targetLength = targetLength - currentString.length;
        if (targetLength > padString.length) {
          padString += padString.repeat(targetLength / padString.length);
        }
        return padString.slice(0, targetLength) + currentString;
      }
    }
    function sanitizeURL(url) {
      let safeURL = url;
      if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE)) {
        safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
      }
      return safeURL;
    }
    function sanitizeHeaders(originalHeader) {
      const headers = (0, core_rest_pipeline_1.createHttpHeaders)();
      for (const [name, value] of originalHeader) {
        if (name.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase()) {
          headers.set(name, "*****");
        } else if (name.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE) {
          headers.set(name, sanitizeURL(value));
        } else {
          headers.set(name, value);
        }
      }
      return headers;
    }
    function iEqual(str1, str2) {
      return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
    }
    function getAccountNameFromUrl(url) {
      const parsedUrl = new URL(url);
      let accountName;
      try {
        if (parsedUrl.hostname.split(".")[1] === "blob") {
          accountName = parsedUrl.hostname.split(".")[0];
        } else if (isIpEndpointStyle(parsedUrl)) {
          accountName = parsedUrl.pathname.split("/")[1];
        } else {
          accountName = "";
        }
        return accountName;
      } catch (error2) {
        throw new Error("Unable to extract accountName with provided information.");
      }
    }
    function isIpEndpointStyle(parsedUrl) {
      const host = parsedUrl.host;
      return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
    }
    function attachCredential(thing, credential) {
      thing.credential = credential;
      return thing;
    }
    function httpAuthorizationToString(httpAuthorization) {
      return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : void 0;
    }
    function EscapePath(blobName) {
      const split = blobName.split("/");
      for (let i2 = 0; i2 < split.length; i2++) {
        split[i2] = encodeURIComponent(split[i2]);
      }
      return split.join("/");
    }
    function assertResponse(response) {
      if (`_response` in response) {
        return response;
      }
      throw new TypeError(`Unexpected response object ${response}`);
    }
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageBrowserPolicy.js
var require_StorageBrowserPolicy = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/StorageBrowserPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageBrowserPolicy = void 0;
    var RequestPolicy_js_1 = require_RequestPolicy2();
    var core_util_1 = require_commonjs4();
    var constants_js_1 = require_constants10();
    var utils_common_js_1 = require_utils_common2();
    var StorageBrowserPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
      /**
       * Creates an instance of StorageBrowserPolicy.
       * @param nextPolicy -
       * @param options -
       */
      // The base class has a protected constructor. Adding a public one to enable constructing of this class.
      /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
      constructor(nextPolicy, options) {
        super(nextPolicy, options);
      }
      /**
       * Sends out request.
       *
       * @param request -
       */
      async sendRequest(request) {
        if (core_util_1.isNodeLike) {
          return this._nextPolicy.sendRequest(request);
        }
        if (request.method.toUpperCase() === "GET" || request.method.toUpperCase() === "HEAD") {
          request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
        }
        request.headers.remove(constants_js_1.HeaderConstants.COOKIE);
        request.headers.remove(constants_js_1.HeaderConstants.CONTENT_LENGTH);
        return this._nextPolicy.sendRequest(request);
      }
    };
    exports.StorageBrowserPolicy = StorageBrowserPolicy;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/StorageBrowserPolicyFactory.js
var require_StorageBrowserPolicyFactory = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/StorageBrowserPolicyFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = void 0;
    var StorageBrowserPolicy_js_1 = require_StorageBrowserPolicy();
    Object.defineProperty(exports, "StorageBrowserPolicy", { enumerable: true, get: function() {
      return StorageBrowserPolicy_js_1.StorageBrowserPolicy;
    } });
    var StorageBrowserPolicyFactory = class {
      /**
       * Creates a StorageBrowserPolicyFactory object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options) {
        return new StorageBrowserPolicy_js_1.StorageBrowserPolicy(nextPolicy, options);
      }
    };
    exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/CredentialPolicy.js
var require_CredentialPolicy2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/CredentialPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialPolicy = void 0;
    var RequestPolicy_js_1 = require_RequestPolicy2();
    var CredentialPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
      /**
       * Sends out request.
       *
       * @param request -
       */
      sendRequest(request) {
        return this._nextPolicy.sendRequest(this.signRequest(request));
      }
      /**
       * Child classes must implement this method with request signing. This method
       * will be executed in {@link sendRequest}.
       *
       * @param request -
       */
      signRequest(request) {
        return request;
      }
    };
    exports.CredentialPolicy = CredentialPolicy;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/AnonymousCredentialPolicy.js
var require_AnonymousCredentialPolicy2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/AnonymousCredentialPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousCredentialPolicy = void 0;
    var CredentialPolicy_js_1 = require_CredentialPolicy2();
    var AnonymousCredentialPolicy = class extends CredentialPolicy_js_1.CredentialPolicy {
      /**
       * Creates an instance of AnonymousCredentialPolicy.
       * @param nextPolicy -
       * @param options -
       */
      // The base class has a protected constructor. Adding a public one to enable constructing of this class.
      /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
      constructor(nextPolicy, options) {
        super(nextPolicy, options);
      }
    };
    exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/Credential.js
var require_Credential2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/credentials/Credential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Credential = void 0;
    var Credential = class {
      /**
       * Creates a RequestPolicy object.
       *
       * @param _nextPolicy -
       * @param _options -
       */
      create(_nextPolicy, _options2) {
        throw new Error("Method should be implemented in children classes.");
      }
    };
    exports.Credential = Credential;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/AnonymousCredential.js
var require_AnonymousCredential2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/credentials/AnonymousCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousCredential = void 0;
    var AnonymousCredentialPolicy_js_1 = require_AnonymousCredentialPolicy2();
    var Credential_js_1 = require_Credential2();
    var AnonymousCredential = class extends Credential_js_1.Credential {
      /**
       * Creates an {@link AnonymousCredentialPolicy} object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options) {
        return new AnonymousCredentialPolicy_js_1.AnonymousCredentialPolicy(nextPolicy, options);
      }
    };
    exports.AnonymousCredential = AnonymousCredential;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/utils/SharedKeyComparator.js
var require_SharedKeyComparator2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/utils/SharedKeyComparator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compareHeader = compareHeader;
    var table_lv0 = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1820,
      0,
      1823,
      1825,
      1827,
      1829,
      0,
      0,
      0,
      1837,
      2051,
      0,
      0,
      1843,
      0,
      3331,
      3354,
      3356,
      3358,
      3360,
      3362,
      3364,
      3366,
      3368,
      3370,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3586,
      3593,
      3594,
      3610,
      3617,
      3619,
      3621,
      3628,
      3634,
      3637,
      3638,
      3656,
      3665,
      3696,
      3708,
      3710,
      3721,
      3722,
      3729,
      3737,
      3743,
      3746,
      3748,
      3750,
      3751,
      3753,
      0,
      0,
      0,
      1859,
      1860,
      1864,
      3586,
      3593,
      3594,
      3610,
      3617,
      3619,
      3621,
      3628,
      3634,
      3637,
      3638,
      3656,
      3665,
      3696,
      3708,
      3710,
      3721,
      3722,
      3729,
      3737,
      3743,
      3746,
      3748,
      3750,
      3751,
      3753,
      0,
      1868,
      0,
      1872,
      0
    ]);
    var table_lv2 = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var table_lv4 = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      32786,
      0,
      0,
      0,
      0,
      0,
      33298,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    function compareHeader(lhs, rhs) {
      if (isLessThan(lhs, rhs))
        return -1;
      return 1;
    }
    function isLessThan(lhs, rhs) {
      const tables = [table_lv0, table_lv2, table_lv4];
      let curr_level = 0;
      let i2 = 0;
      let j = 0;
      while (curr_level < tables.length) {
        if (curr_level === tables.length - 1 && i2 !== j) {
          return i2 > j;
        }
        const weight1 = i2 < lhs.length ? tables[curr_level][lhs[i2].charCodeAt(0)] : 1;
        const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
        if (weight1 === 1 && weight2 === 1) {
          i2 = 0;
          j = 0;
          ++curr_level;
        } else if (weight1 === weight2) {
          ++i2;
          ++j;
        } else if (weight1 === 0) {
          ++i2;
        } else if (weight2 === 0) {
          ++j;
        } else {
          return weight1 < weight2;
        }
      }
      return false;
    }
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageSharedKeyCredentialPolicy.js
var require_StorageSharedKeyCredentialPolicy2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/StorageSharedKeyCredentialPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageSharedKeyCredentialPolicy = void 0;
    var constants_js_1 = require_constants10();
    var utils_common_js_1 = require_utils_common2();
    var CredentialPolicy_js_1 = require_CredentialPolicy2();
    var SharedKeyComparator_js_1 = require_SharedKeyComparator2();
    var StorageSharedKeyCredentialPolicy = class extends CredentialPolicy_js_1.CredentialPolicy {
      /**
       * Reference to StorageSharedKeyCredential which generates StorageSharedKeyCredentialPolicy
       */
      factory;
      /**
       * Creates an instance of StorageSharedKeyCredentialPolicy.
       * @param nextPolicy -
       * @param options -
       * @param factory -
       */
      constructor(nextPolicy, options, factory) {
        super(nextPolicy, options);
        this.factory = factory;
      }
      /**
       * Signs request.
       *
       * @param request -
       */
      signRequest(request) {
        request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
        if (request.body && (typeof request.body === "string" || request.body !== void 0) && request.body.length > 0) {
          request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        const stringToSign = [
          request.method.toUpperCase(),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
          this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
        ].join("\n") + "\n" + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request);
        const signature = this.factory.computeHMACSHA256(stringToSign);
        request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
        return request;
      }
      /**
       * Retrieve header value according to shared key sign rules.
       * @see https://learn.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
       *
       * @param request -
       * @param headerName -
       */
      getHeaderValueToSign(request, headerName) {
        const value = request.headers.get(headerName);
        if (!value) {
          return "";
        }
        if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
          return "";
        }
        return value;
      }
      /**
       * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
       * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
       * 2. Convert each HTTP header name to lowercase.
       * 3. Sort the headers lexicographically by header name, in ascending order.
       *    Each header may appear only once in the string.
       * 4. Replace any linear whitespace in the header value with a single space.
       * 5. Trim any whitespace around the colon in the header.
       * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
       *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
       *
       * @param request -
       */
      getCanonicalizedHeadersString(request) {
        let headersArray = request.headers.headersArray().filter((value) => {
          return value.name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE);
        });
        headersArray.sort((a2, b) => {
          return (0, SharedKeyComparator_js_1.compareHeader)(a2.name.toLowerCase(), b.name.toLowerCase());
        });
        headersArray = headersArray.filter((value, index, array) => {
          if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
            return false;
          }
          return true;
        });
        let canonicalizedHeadersStringToSign = "";
        headersArray.forEach((header) => {
          canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
        });
        return canonicalizedHeadersStringToSign;
      }
      /**
       * Retrieves the webResource canonicalized resource string.
       *
       * @param request -
       */
      getCanonicalizedResourceString(request) {
        const path2 = (0, utils_common_js_1.getURLPath)(request.url) || "/";
        let canonicalizedResourceString = "";
        canonicalizedResourceString += `/${this.factory.accountName}${path2}`;
        const queries = (0, utils_common_js_1.getURLQueries)(request.url);
        const lowercaseQueries = {};
        if (queries) {
          const queryKeys = [];
          for (const key in queries) {
            if (Object.prototype.hasOwnProperty.call(queries, key)) {
              const lowercaseKey = key.toLowerCase();
              lowercaseQueries[lowercaseKey] = queries[key];
              queryKeys.push(lowercaseKey);
            }
          }
          queryKeys.sort();
          for (const key of queryKeys) {
            canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
          }
        }
        return canonicalizedResourceString;
      }
    };
    exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/StorageSharedKeyCredential.js
var require_StorageSharedKeyCredential2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/credentials/StorageSharedKeyCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageSharedKeyCredential = void 0;
    var node_crypto_1 = __require("crypto");
    var StorageSharedKeyCredentialPolicy_js_1 = require_StorageSharedKeyCredentialPolicy2();
    var Credential_js_1 = require_Credential2();
    var StorageSharedKeyCredential = class extends Credential_js_1.Credential {
      /**
       * Azure Storage account name; readonly.
       */
      accountName;
      /**
       * Azure Storage account key; readonly.
       */
      accountKey;
      /**
       * Creates an instance of StorageSharedKeyCredential.
       * @param accountName -
       * @param accountKey -
       */
      constructor(accountName, accountKey) {
        super();
        this.accountName = accountName;
        this.accountKey = Buffer.from(accountKey, "base64");
      }
      /**
       * Creates a StorageSharedKeyCredentialPolicy object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options) {
        return new StorageSharedKeyCredentialPolicy_js_1.StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
      }
      /**
       * Generates a hash signature for an HTTP request or for a SAS.
       *
       * @param stringToSign -
       */
      computeHMACSHA256(stringToSign) {
        return (0, node_crypto_1.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
      }
    };
    exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
  }
});

// node_modules/@azure/storage-common/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError4 = __commonJS({
  "node_modules/@azure/storage-common/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbortError = void 0;
    var AbortError3 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    exports.AbortError = AbortError3;
  }
});

// node_modules/@azure/storage-common/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs12 = __commonJS({
  "node_modules/@azure/storage-common/node_modules/@azure/abort-controller/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbortError = void 0;
    var AbortError_js_1 = require_AbortError4();
    Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
      return AbortError_js_1.AbortError;
    } });
  }
});

// node_modules/@azure/storage-common/dist/commonjs/log.js
var require_log6 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = void 0;
    var logger_1 = require_commonjs2();
    exports.logger = (0, logger_1.createClientLogger)("storage-common");
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicyType.js
var require_StorageRetryPolicyType2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicyType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageRetryPolicyType = void 0;
    var StorageRetryPolicyType;
    (function(StorageRetryPolicyType2) {
      StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
      StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
    })(StorageRetryPolicyType || (exports.StorageRetryPolicyType = StorageRetryPolicyType = {}));
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicy.js
var require_StorageRetryPolicy2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageRetryPolicy = void 0;
    exports.NewRetryPolicyFactory = NewRetryPolicyFactory;
    var abort_controller_1 = require_commonjs12();
    var RequestPolicy_js_1 = require_RequestPolicy2();
    var constants_js_1 = require_constants10();
    var utils_common_js_1 = require_utils_common2();
    var log_js_1 = require_log6();
    var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType2();
    function NewRetryPolicyFactory(retryOptions) {
      return {
        create: (nextPolicy, options) => {
          return new StorageRetryPolicy(nextPolicy, options, retryOptions);
        }
      };
    }
    var DEFAULT_RETRY_OPTIONS = {
      maxRetryDelayInMs: 120 * 1e3,
      maxTries: 4,
      retryDelayInMs: 4 * 1e3,
      retryPolicyType: StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0
      // Use server side default timeout strategy
    };
    var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
    var StorageRetryPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
      /**
       * RetryOptions.
       */
      retryOptions;
      /**
       * Creates an instance of RetryPolicy.
       *
       * @param nextPolicy -
       * @param options -
       * @param retryOptions -
       */
      constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS) {
        super(nextPolicy, options);
        this.retryOptions = {
          retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
          maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
          tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
          retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
          maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
          secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
        };
      }
      /**
       * Sends request.
       *
       * @param request -
       */
      async sendRequest(request) {
        return this.attemptSendRequest(request, false, 1);
      }
      /**
       * Decide and perform next retry. Won't mutate request parameter.
       *
       * @param request -
       * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
       *                                   the resource was not found. This may be due to replication delay. So, in this
       *                                   case, we'll never try the secondary again for this operation.
       * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
       *                                   the attempt will be performed by this method call.
       */
      async attemptSendRequest(request, secondaryHas404, attempt) {
        const newRequest = request.clone();
        const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") || attempt % 2 === 1;
        if (!isPrimaryRetry) {
          newRequest.url = (0, utils_common_js_1.setURLHost)(newRequest.url, this.retryOptions.secondaryHost);
        }
        if (this.retryOptions.tryTimeoutInMs) {
          newRequest.url = (0, utils_common_js_1.setURLParameter)(newRequest.url, constants_js_1.URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString());
        }
        let response;
        try {
          log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
          response = await this._nextPolicy.sendRequest(newRequest);
          if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
            return response;
          }
          secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
        } catch (err) {
          log_js_1.logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
          if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) {
            throw err;
          }
        }
        await this.delay(isPrimaryRetry, attempt, request.abortSignal);
        return this.attemptSendRequest(request, secondaryHas404, ++attempt);
      }
      /**
       * Decide whether to retry according to last HTTP response and retry counters.
       *
       * @param isPrimaryRetry -
       * @param attempt -
       * @param response -
       * @param err -
       */
      shouldRetry(isPrimaryRetry, attempt, response, err) {
        if (attempt >= this.retryOptions.maxTries) {
          log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
          return false;
        }
        const retriableErrors = [
          "ETIMEDOUT",
          "ESOCKETTIMEDOUT",
          "ECONNREFUSED",
          "ECONNRESET",
          "ENOENT",
          "ENOTFOUND",
          "TIMEOUT",
          "EPIPE",
          "REQUEST_SEND_ERROR"
          // For default xhr based http client provided in ms-rest-js
        ];
        if (err) {
          for (const retriableError of retriableErrors) {
            if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
              log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
              return true;
            }
          }
        }
        if (response || err) {
          const statusCode = response ? response.status : err ? err.statusCode : 0;
          if (!isPrimaryRetry && statusCode === 404) {
            log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
            return true;
          }
          if (statusCode === 503 || statusCode === 500) {
            log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
            return true;
          }
        }
        if (response) {
          if (response?.status >= 400) {
            const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
            if (copySourceError !== void 0) {
              switch (copySourceError) {
                case "InternalError":
                case "OperationTimedOut":
                case "ServerBusy":
                  return true;
              }
            }
          }
        }
        if (err?.code === "PARSE_ERROR" && err?.message.startsWith(`Error "Error: Unclosed root tag`)) {
          log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
          return true;
        }
        return false;
      }
      /**
       * Delay a calculated time between retries.
       *
       * @param isPrimaryRetry -
       * @param attempt -
       * @param abortSignal -
       */
      async delay(isPrimaryRetry, attempt, abortSignal2) {
        let delayTimeInMs = 0;
        if (isPrimaryRetry) {
          switch (this.retryOptions.retryPolicyType) {
            case StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL:
              delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
              break;
            case StorageRetryPolicyType_js_1.StorageRetryPolicyType.FIXED:
              delayTimeInMs = this.retryOptions.retryDelayInMs;
              break;
          }
        } else {
          delayTimeInMs = Math.random() * 1e3;
        }
        log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
        return (0, utils_common_js_1.delay)(delayTimeInMs, abortSignal2, RETRY_ABORT_ERROR);
      }
    };
    exports.StorageRetryPolicy = StorageRetryPolicy;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/StorageRetryPolicyFactory.js
var require_StorageRetryPolicyFactory2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/StorageRetryPolicyFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = void 0;
    var StorageRetryPolicy_js_1 = require_StorageRetryPolicy2();
    Object.defineProperty(exports, "StorageRetryPolicy", { enumerable: true, get: function() {
      return StorageRetryPolicy_js_1.StorageRetryPolicy;
    } });
    var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType2();
    Object.defineProperty(exports, "StorageRetryPolicyType", { enumerable: true, get: function() {
      return StorageRetryPolicyType_js_1.StorageRetryPolicyType;
    } });
    var StorageRetryPolicyFactory = class {
      retryOptions;
      /**
       * Creates an instance of StorageRetryPolicyFactory.
       * @param retryOptions -
       */
      constructor(retryOptions) {
        this.retryOptions = retryOptions;
      }
      /**
       * Creates a StorageRetryPolicy object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options) {
        return new StorageRetryPolicy_js_1.StorageRetryPolicy(nextPolicy, options, this.retryOptions);
      }
    };
    exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageBrowserPolicyV2.js
var require_StorageBrowserPolicyV2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/StorageBrowserPolicyV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageBrowserPolicyName = void 0;
    exports.storageBrowserPolicy = storageBrowserPolicy;
    var core_util_1 = require_commonjs4();
    var constants_js_1 = require_constants10();
    var utils_common_js_1 = require_utils_common2();
    exports.storageBrowserPolicyName = "storageBrowserPolicy";
    function storageBrowserPolicy() {
      return {
        name: exports.storageBrowserPolicyName,
        async sendRequest(request, next) {
          if (core_util_1.isNodeLike) {
            return next(request);
          }
          if (request.method === "GET" || request.method === "HEAD") {
            request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
          }
          request.headers.delete(constants_js_1.HeaderConstants.COOKIE);
          request.headers.delete(constants_js_1.HeaderConstants.CONTENT_LENGTH);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageCorrectContentLengthPolicy.js
var require_StorageCorrectContentLengthPolicy = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/StorageCorrectContentLengthPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageCorrectContentLengthPolicyName = void 0;
    exports.storageCorrectContentLengthPolicy = storageCorrectContentLengthPolicy;
    var constants_js_1 = require_constants10();
    exports.storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
    function storageCorrectContentLengthPolicy() {
      function correctContentLength(request) {
        if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
          request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
      }
      return {
        name: exports.storageCorrectContentLengthPolicyName,
        async sendRequest(request, next) {
          correctContentLength(request);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicyV2.js
var require_StorageRetryPolicyV2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicyV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageRetryPolicyName = void 0;
    exports.storageRetryPolicy = storageRetryPolicy;
    var abort_controller_1 = require_commonjs12();
    var core_rest_pipeline_1 = require_commonjs6();
    var core_util_1 = require_commonjs4();
    var StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory2();
    var constants_js_1 = require_constants10();
    var utils_common_js_1 = require_utils_common2();
    var log_js_1 = require_log6();
    exports.storageRetryPolicyName = "storageRetryPolicy";
    var DEFAULT_RETRY_OPTIONS = {
      maxRetryDelayInMs: 120 * 1e3,
      maxTries: 4,
      retryDelayInMs: 4 * 1e3,
      retryPolicyType: StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0
      // Use server side default timeout strategy
    };
    var retriableErrors = [
      "ETIMEDOUT",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "ECONNRESET",
      "ENOENT",
      "ENOTFOUND",
      "TIMEOUT",
      "EPIPE",
      "REQUEST_SEND_ERROR"
    ];
    var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
    function storageRetryPolicy(options = {}) {
      const retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;
      const maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;
      const retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;
      const maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
      const secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;
      const tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
      function shouldRetry({ isPrimaryRetry, attempt, response, error: error2 }) {
        if (attempt >= maxTries) {
          log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
          return false;
        }
        if (error2) {
          for (const retriableError of retriableErrors) {
            if (error2.name.toUpperCase().includes(retriableError) || error2.message.toUpperCase().includes(retriableError) || error2.code && error2.code.toString().toUpperCase() === retriableError) {
              log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
              return true;
            }
          }
          if (error2?.code === "PARSE_ERROR" && error2?.message.startsWith(`Error "Error: Unclosed root tag`)) {
            log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
            return true;
          }
        }
        if (response || error2) {
          const statusCode = response?.status ?? error2?.statusCode ?? 0;
          if (!isPrimaryRetry && statusCode === 404) {
            log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
            return true;
          }
          if (statusCode === 503 || statusCode === 500) {
            log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
            return true;
          }
        }
        if (response) {
          if (response?.status >= 400) {
            const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
            if (copySourceError !== void 0) {
              switch (copySourceError) {
                case "InternalError":
                case "OperationTimedOut":
                case "ServerBusy":
                  return true;
              }
            }
          }
        }
        return false;
      }
      function calculateDelay(isPrimaryRetry, attempt) {
        let delayTimeInMs = 0;
        if (isPrimaryRetry) {
          switch (retryPolicyType) {
            case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL:
              delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
              break;
            case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.FIXED:
              delayTimeInMs = retryDelayInMs;
              break;
          }
        } else {
          delayTimeInMs = Math.random() * 1e3;
        }
        log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
        return delayTimeInMs;
      }
      return {
        name: exports.storageRetryPolicyName,
        async sendRequest(request, next) {
          if (tryTimeoutInMs) {
            request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1e3)));
          }
          const primaryUrl = request.url;
          const secondaryUrl = secondaryHost ? (0, utils_common_js_1.setURLHost)(request.url, secondaryHost) : void 0;
          let secondaryHas404 = false;
          let attempt = 1;
          let retryAgain = true;
          let response;
          let error2;
          while (retryAgain) {
            const isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request.method) || attempt % 2 === 1;
            request.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
            response = void 0;
            error2 = void 0;
            try {
              log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
              response = await next(request);
              secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
            } catch (e) {
              if ((0, core_rest_pipeline_1.isRestError)(e)) {
                log_js_1.logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);
                error2 = e;
              } else {
                log_js_1.logger.error(`RetryPolicy: Caught error, message: ${(0, core_util_1.getErrorMessage)(e)}`);
                throw e;
              }
            }
            retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error: error2 });
            if (retryAgain) {
              await (0, utils_common_js_1.delay)(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);
            }
            attempt++;
          }
          if (response) {
            return response;
          }
          throw error2 ?? new core_rest_pipeline_1.RestError("RetryPolicy failed without known error.");
        }
      };
    }
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageSharedKeyCredentialPolicyV2.js
var require_StorageSharedKeyCredentialPolicyV2 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/StorageSharedKeyCredentialPolicyV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageSharedKeyCredentialPolicyName = void 0;
    exports.storageSharedKeyCredentialPolicy = storageSharedKeyCredentialPolicy;
    var node_crypto_1 = __require("crypto");
    var constants_js_1 = require_constants10();
    var utils_common_js_1 = require_utils_common2();
    var SharedKeyComparator_js_1 = require_SharedKeyComparator2();
    exports.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
    function storageSharedKeyCredentialPolicy(options) {
      function signRequest(request) {
        request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
        if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
          request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        const stringToSign = [
          request.method.toUpperCase(),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
        ].join("\n") + "\n" + getCanonicalizedHeadersString(request) + getCanonicalizedResourceString(request);
        const signature = (0, node_crypto_1.createHmac)("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
        request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
      }
      function getHeaderValueToSign(request, headerName) {
        const value = request.headers.get(headerName);
        if (!value) {
          return "";
        }
        if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
          return "";
        }
        return value;
      }
      function getCanonicalizedHeadersString(request) {
        let headersArray = [];
        for (const [name, value] of request.headers) {
          if (name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE)) {
            headersArray.push({ name, value });
          }
        }
        headersArray.sort((a2, b) => {
          return (0, SharedKeyComparator_js_1.compareHeader)(a2.name.toLowerCase(), b.name.toLowerCase());
        });
        headersArray = headersArray.filter((value, index, array) => {
          if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
            return false;
          }
          return true;
        });
        let canonicalizedHeadersStringToSign = "";
        headersArray.forEach((header) => {
          canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
        });
        return canonicalizedHeadersStringToSign;
      }
      function getCanonicalizedResourceString(request) {
        const path2 = (0, utils_common_js_1.getURLPath)(request.url) || "/";
        let canonicalizedResourceString = "";
        canonicalizedResourceString += `/${options.accountName}${path2}`;
        const queries = (0, utils_common_js_1.getURLQueries)(request.url);
        const lowercaseQueries = {};
        if (queries) {
          const queryKeys = [];
          for (const key in queries) {
            if (Object.prototype.hasOwnProperty.call(queries, key)) {
              const lowercaseKey = key.toLowerCase();
              lowercaseQueries[lowercaseKey] = queries[key];
              queryKeys.push(lowercaseKey);
            }
          }
          queryKeys.sort();
          for (const key of queryKeys) {
            canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
          }
        }
        return canonicalizedResourceString;
      }
      return {
        name: exports.storageSharedKeyCredentialPolicyName,
        async sendRequest(request, next) {
          signRequest(request);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRequestFailureDetailsParserPolicy.js
var require_StorageRequestFailureDetailsParserPolicy = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/policies/StorageRequestFailureDetailsParserPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageRequestFailureDetailsParserPolicyName = void 0;
    exports.storageRequestFailureDetailsParserPolicy = storageRequestFailureDetailsParserPolicy;
    exports.storageRequestFailureDetailsParserPolicyName = "storageRequestFailureDetailsParserPolicy";
    function storageRequestFailureDetailsParserPolicy() {
      return {
        name: exports.storageRequestFailureDetailsParserPolicyName,
        async sendRequest(request, next) {
          try {
            const response = await next(request);
            return response;
          } catch (err) {
            if (typeof err === "object" && err !== null && err.response && err.response.parsedBody) {
              if (err.response.parsedBody.code === "InvalidHeaderValue" && err.response.parsedBody.HeaderName === "x-ms-version") {
                err.message = "The provided service version is not enabled on this storage account. Please see https://learn.microsoft.com/rest/api/storageservices/versioning-for-the-azure-storage-services for additional information.\n";
              }
            }
            throw err;
          }
        }
      };
    }
  }
});

// node_modules/@azure/storage-common/dist/commonjs/index.js
var require_commonjs13 = __commonJS({
  "node_modules/@azure/storage-common/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseRequestPolicy = exports.getCachedDefaultHttpClient = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_BufferScheduler(), exports);
    var cache_js_1 = require_cache2();
    Object.defineProperty(exports, "getCachedDefaultHttpClient", { enumerable: true, get: function() {
      return cache_js_1.getCachedDefaultHttpClient;
    } });
    tslib_1.__exportStar(require_StorageBrowserPolicyFactory(), exports);
    tslib_1.__exportStar(require_AnonymousCredential2(), exports);
    tslib_1.__exportStar(require_Credential2(), exports);
    tslib_1.__exportStar(require_StorageSharedKeyCredential2(), exports);
    tslib_1.__exportStar(require_StorageRetryPolicyFactory2(), exports);
    var RequestPolicy_js_1 = require_RequestPolicy2();
    Object.defineProperty(exports, "BaseRequestPolicy", { enumerable: true, get: function() {
      return RequestPolicy_js_1.BaseRequestPolicy;
    } });
    tslib_1.__exportStar(require_AnonymousCredentialPolicy2(), exports);
    tslib_1.__exportStar(require_CredentialPolicy2(), exports);
    tslib_1.__exportStar(require_StorageBrowserPolicy(), exports);
    tslib_1.__exportStar(require_StorageBrowserPolicyV2(), exports);
    tslib_1.__exportStar(require_StorageCorrectContentLengthPolicy(), exports);
    tslib_1.__exportStar(require_StorageRetryPolicyType2(), exports);
    tslib_1.__exportStar(require_StorageRetryPolicy2(), exports);
    tslib_1.__exportStar(require_StorageRetryPolicyV2(), exports);
    tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicy2(), exports);
    tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicyV2(), exports);
    tslib_1.__exportStar(require_StorageRetryPolicyFactory2(), exports);
    tslib_1.__exportStar(require_StorageRequestFailureDetailsParserPolicy(), exports);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageBrowserPolicyV2.js
var require_StorageBrowserPolicyV22 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/StorageBrowserPolicyV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageBrowserPolicyName = void 0;
    exports.storageBrowserPolicy = storageBrowserPolicy;
    var core_util_1 = require_commonjs4();
    var constants_js_1 = require_constants9();
    var utils_common_js_1 = require_utils_common();
    exports.storageBrowserPolicyName = "storageBrowserPolicy";
    function storageBrowserPolicy() {
      return {
        name: exports.storageBrowserPolicyName,
        async sendRequest(request, next) {
          if (core_util_1.isNodeLike) {
            return next(request);
          }
          if (request.method === "GET" || request.method === "HEAD") {
            request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
          }
          request.headers.delete(constants_js_1.HeaderConstants.COOKIE);
          request.headers.delete(constants_js_1.HeaderConstants.CONTENT_LENGTH);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageRetryPolicyV2.js
var require_StorageRetryPolicyV22 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/StorageRetryPolicyV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageRetryPolicyName = void 0;
    exports.storageRetryPolicy = storageRetryPolicy;
    var abort_controller_1 = require_commonjs11();
    var core_rest_pipeline_1 = require_commonjs6();
    var core_util_1 = require_commonjs4();
    var StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory();
    var constants_js_1 = require_constants9();
    var utils_common_js_1 = require_utils_common();
    var log_js_1 = require_log5();
    exports.storageRetryPolicyName = "storageRetryPolicy";
    var DEFAULT_RETRY_OPTIONS = {
      maxRetryDelayInMs: 120 * 1e3,
      maxTries: 4,
      retryDelayInMs: 4 * 1e3,
      retryPolicyType: StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0
      // Use server side default timeout strategy
    };
    var retriableErrors = [
      "ETIMEDOUT",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "ECONNRESET",
      "ENOENT",
      "ENOTFOUND",
      "TIMEOUT",
      "EPIPE",
      "REQUEST_SEND_ERROR"
    ];
    var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
    function storageRetryPolicy(options = {}) {
      const retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;
      const maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;
      const retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;
      const maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
      const secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;
      const tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
      function shouldRetry({ isPrimaryRetry, attempt, response, error: error2 }) {
        if (attempt >= maxTries) {
          log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
          return false;
        }
        if (error2) {
          for (const retriableError of retriableErrors) {
            if (error2.name.toUpperCase().includes(retriableError) || error2.message.toUpperCase().includes(retriableError) || error2.code && error2.code.toString().toUpperCase() === retriableError) {
              log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
              return true;
            }
          }
          if (error2?.code === "PARSE_ERROR" && error2?.message.startsWith(`Error "Error: Unclosed root tag`)) {
            log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
            return true;
          }
        }
        if (response || error2) {
          const statusCode = response?.status ?? error2?.statusCode ?? 0;
          if (!isPrimaryRetry && statusCode === 404) {
            log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
            return true;
          }
          if (statusCode === 503 || statusCode === 500) {
            log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
            return true;
          }
        }
        if (response) {
          if (response?.status >= 400) {
            const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
            if (copySourceError !== void 0) {
              switch (copySourceError) {
                case "InternalError":
                case "OperationTimedOut":
                case "ServerBusy":
                  return true;
              }
            }
          }
        }
        return false;
      }
      function calculateDelay(isPrimaryRetry, attempt) {
        let delayTimeInMs = 0;
        if (isPrimaryRetry) {
          switch (retryPolicyType) {
            case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL:
              delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
              break;
            case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.FIXED:
              delayTimeInMs = retryDelayInMs;
              break;
          }
        } else {
          delayTimeInMs = Math.random() * 1e3;
        }
        log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
        return delayTimeInMs;
      }
      return {
        name: exports.storageRetryPolicyName,
        async sendRequest(request, next) {
          if (tryTimeoutInMs) {
            request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1e3)));
          }
          const primaryUrl = request.url;
          const secondaryUrl = secondaryHost ? (0, utils_common_js_1.setURLHost)(request.url, secondaryHost) : void 0;
          let secondaryHas404 = false;
          let attempt = 1;
          let retryAgain = true;
          let response;
          let error2;
          while (retryAgain) {
            const isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request.method) || attempt % 2 === 1;
            request.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
            response = void 0;
            error2 = void 0;
            try {
              log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
              response = await next(request);
              secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
            } catch (e) {
              if ((0, core_rest_pipeline_1.isRestError)(e)) {
                log_js_1.logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);
                error2 = e;
              } else {
                log_js_1.logger.error(`RetryPolicy: Caught error, message: ${(0, core_util_1.getErrorMessage)(e)}`);
                throw e;
              }
            }
            retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error: error2 });
            if (retryAgain) {
              await (0, utils_common_js_1.delay)(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);
            }
            attempt++;
          }
          if (response) {
            return response;
          }
          throw error2 ?? new core_rest_pipeline_1.RestError("RetryPolicy failed without known error.");
        }
      };
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageSharedKeyCredentialPolicyV2.js
var require_StorageSharedKeyCredentialPolicyV22 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/StorageSharedKeyCredentialPolicyV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageSharedKeyCredentialPolicyName = void 0;
    exports.storageSharedKeyCredentialPolicy = storageSharedKeyCredentialPolicy;
    var node_crypto_1 = __require("crypto");
    var constants_js_1 = require_constants9();
    var utils_common_js_1 = require_utils_common();
    var SharedKeyComparator_js_1 = require_SharedKeyComparator();
    exports.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
    function storageSharedKeyCredentialPolicy(options) {
      function signRequest(request) {
        request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
        if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
          request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        const stringToSign = [
          request.method.toUpperCase(),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
          getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
        ].join("\n") + "\n" + getCanonicalizedHeadersString(request) + getCanonicalizedResourceString(request);
        const signature = (0, node_crypto_1.createHmac)("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
        request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
      }
      function getHeaderValueToSign(request, headerName) {
        const value = request.headers.get(headerName);
        if (!value) {
          return "";
        }
        if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
          return "";
        }
        return value;
      }
      function getCanonicalizedHeadersString(request) {
        let headersArray = [];
        for (const [name, value] of request.headers) {
          if (name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE)) {
            headersArray.push({ name, value });
          }
        }
        headersArray.sort((a2, b) => {
          return (0, SharedKeyComparator_js_1.compareHeader)(a2.name.toLowerCase(), b.name.toLowerCase());
        });
        headersArray = headersArray.filter((value, index, array) => {
          if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
            return false;
          }
          return true;
        });
        let canonicalizedHeadersStringToSign = "";
        headersArray.forEach((header) => {
          canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
        });
        return canonicalizedHeadersStringToSign;
      }
      function getCanonicalizedResourceString(request) {
        const path2 = (0, utils_common_js_1.getURLPath)(request.url) || "/";
        let canonicalizedResourceString = "";
        canonicalizedResourceString += `/${options.accountName}${path2}`;
        const queries = (0, utils_common_js_1.getURLQueries)(request.url);
        const lowercaseQueries = {};
        if (queries) {
          const queryKeys = [];
          for (const key in queries) {
            if (Object.prototype.hasOwnProperty.call(queries, key)) {
              const lowercaseKey = key.toLowerCase();
              lowercaseQueries[lowercaseKey] = queries[key];
              queryKeys.push(lowercaseKey);
            }
          }
          queryKeys.sort();
          for (const key of queryKeys) {
            canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
          }
        }
        return canonicalizedResourceString;
      }
      return {
        name: exports.storageSharedKeyCredentialPolicyName,
        async sendRequest(request, next) {
          signRequest(request);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageBrowserPolicy.js
var require_StorageBrowserPolicy2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/StorageBrowserPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageBrowserPolicy = void 0;
    var RequestPolicy_js_1 = require_RequestPolicy();
    var core_util_1 = require_commonjs4();
    var constants_js_1 = require_constants9();
    var utils_common_js_1 = require_utils_common();
    var StorageBrowserPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
      /**
       * Creates an instance of StorageBrowserPolicy.
       * @param nextPolicy -
       * @param options -
       */
      // The base class has a protected constructor. Adding a public one to enable constructing of this class.
      /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
      constructor(nextPolicy, options) {
        super(nextPolicy, options);
      }
      /**
       * Sends out request.
       *
       * @param request -
       */
      async sendRequest(request) {
        if (core_util_1.isNodeLike) {
          return this._nextPolicy.sendRequest(request);
        }
        if (request.method.toUpperCase() === "GET" || request.method.toUpperCase() === "HEAD") {
          request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
        }
        request.headers.remove(constants_js_1.HeaderConstants.COOKIE);
        request.headers.remove(constants_js_1.HeaderConstants.CONTENT_LENGTH);
        return this._nextPolicy.sendRequest(request);
      }
    };
    exports.StorageBrowserPolicy = StorageBrowserPolicy;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageBrowserPolicyFactory.js
var require_StorageBrowserPolicyFactory2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/StorageBrowserPolicyFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = void 0;
    var StorageBrowserPolicy_js_1 = require_StorageBrowserPolicy2();
    Object.defineProperty(exports, "StorageBrowserPolicy", { enumerable: true, get: function() {
      return StorageBrowserPolicy_js_1.StorageBrowserPolicy;
    } });
    var StorageBrowserPolicyFactory = class {
      /**
       * Creates a StorageBrowserPolicyFactory object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options) {
        return new StorageBrowserPolicy_js_1.StorageBrowserPolicy(nextPolicy, options);
      }
    };
    exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageCorrectContentLengthPolicy.js
var require_StorageCorrectContentLengthPolicy2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/policies/StorageCorrectContentLengthPolicy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageCorrectContentLengthPolicyName = void 0;
    exports.storageCorrectContentLengthPolicy = storageCorrectContentLengthPolicy;
    var constants_js_1 = require_constants9();
    exports.storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
    function storageCorrectContentLengthPolicy() {
      function correctContentLength(request) {
        if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
          request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
      }
      return {
        name: exports.storageCorrectContentLengthPolicyName,
        async sendRequest(request, next) {
          correctContentLength(request);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/Pipeline.js
var require_Pipeline = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/Pipeline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pipeline = exports.StorageOAuthScopes = void 0;
    exports.isPipelineLike = isPipelineLike;
    exports.newPipeline = newPipeline;
    exports.getCoreClientOptions = getCoreClientOptions;
    exports.getCredentialFromPipeline = getCredentialFromPipeline;
    var core_http_compat_1 = require_commonjs9();
    var core_rest_pipeline_1 = require_commonjs6();
    var core_client_1 = require_commonjs8();
    var core_xml_1 = require_commonjs10();
    var core_auth_1 = require_commonjs7();
    var log_js_1 = require_log5();
    var StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory();
    var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential();
    var AnonymousCredential_js_1 = require_AnonymousCredential();
    var constants_js_1 = require_constants9();
    Object.defineProperty(exports, "StorageOAuthScopes", { enumerable: true, get: function() {
      return constants_js_1.StorageOAuthScopes;
    } });
    var storage_common_1 = require_commonjs13();
    var StorageBrowserPolicyV2_js_1 = require_StorageBrowserPolicyV22();
    var StorageRetryPolicyV2_js_1 = require_StorageRetryPolicyV22();
    var StorageSharedKeyCredentialPolicyV2_js_1 = require_StorageSharedKeyCredentialPolicyV22();
    var StorageBrowserPolicyFactory_js_1 = require_StorageBrowserPolicyFactory2();
    var StorageCorrectContentLengthPolicy_js_1 = require_StorageCorrectContentLengthPolicy2();
    function isPipelineLike(pipeline) {
      if (!pipeline || typeof pipeline !== "object") {
        return false;
      }
      const castPipeline = pipeline;
      return Array.isArray(castPipeline.factories) && typeof castPipeline.options === "object" && typeof castPipeline.toServiceClientOptions === "function";
    }
    var Pipeline = class {
      /**
       * A list of chained request policy factories.
       */
      factories;
      /**
       * Configures pipeline logger and HTTP client.
       */
      options;
      /**
       * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
       *
       * @param factories -
       * @param options -
       */
      constructor(factories, options = {}) {
        this.factories = factories;
        this.options = options;
      }
      /**
       * Transfer Pipeline object to ServiceClientOptions object which is required by
       * ServiceClient constructor.
       *
       * @returns The ServiceClientOptions object from this Pipeline.
       */
      toServiceClientOptions() {
        return {
          httpClient: this.options.httpClient,
          requestPolicyFactories: this.factories
        };
      }
    };
    exports.Pipeline = Pipeline;
    function newPipeline(credential, pipelineOptions = {}) {
      if (!credential) {
        credential = new AnonymousCredential_js_1.AnonymousCredential();
      }
      const pipeline = new Pipeline([], pipelineOptions);
      pipeline._credential = credential;
      return pipeline;
    }
    function processDownlevelPipeline(pipeline) {
      const knownFactoryFunctions = [
        isAnonymousCredential,
        isStorageSharedKeyCredential,
        isCoreHttpBearerTokenFactory,
        isStorageBrowserPolicyFactory,
        isStorageRetryPolicyFactory,
        isStorageTelemetryPolicyFactory,
        isCoreHttpPolicyFactory
      ];
      if (pipeline.factories.length) {
        const novelFactories = pipeline.factories.filter((factory) => {
          return !knownFactoryFunctions.some((knownFactory) => knownFactory(factory));
        });
        if (novelFactories.length) {
          const hasInjector = novelFactories.some((factory) => isInjectorPolicyFactory(factory));
          return {
            wrappedPolicies: (0, core_http_compat_1.createRequestPolicyFactoryPolicy)(novelFactories),
            afterRetry: hasInjector
          };
        }
      }
      return void 0;
    }
    function getCoreClientOptions(pipeline) {
      const { httpClient: v1Client, ...restOptions } = pipeline.options;
      let httpClient = pipeline._coreHttpClient;
      if (!httpClient) {
        httpClient = v1Client ? (0, core_http_compat_1.convertHttpClient)(v1Client) : (0, storage_common_1.getCachedDefaultHttpClient)();
        pipeline._coreHttpClient = httpClient;
      }
      let corePipeline = pipeline._corePipeline;
      if (!corePipeline) {
        const packageDetails = `azsdk-js-azure-storage-blob/${constants_js_1.SDK_VERSION}`;
        const userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        corePipeline = (0, core_client_1.createClientPipeline)({
          ...restOptions,
          loggingOptions: {
            additionalAllowedHeaderNames: constants_js_1.StorageBlobLoggingAllowedHeaderNames,
            additionalAllowedQueryParameters: constants_js_1.StorageBlobLoggingAllowedQueryParameters,
            logger: log_js_1.logger.info
          },
          userAgentOptions: {
            userAgentPrefix
          },
          serializationOptions: {
            stringifyXML: core_xml_1.stringifyXML,
            serializerOptions: {
              xml: {
                // Use customized XML char key of "#" so we can deserialize metadata
                // with "_" key
                xmlCharKey: "#"
              }
            }
          },
          deserializationOptions: {
            parseXML: core_xml_1.parseXML,
            serializerOptions: {
              xml: {
                // Use customized XML char key of "#" so we can deserialize metadata
                // with "_" key
                xmlCharKey: "#"
              }
            }
          }
        });
        corePipeline.removePolicy({ phase: "Retry" });
        corePipeline.removePolicy({ name: core_rest_pipeline_1.decompressResponsePolicyName });
        corePipeline.addPolicy((0, StorageCorrectContentLengthPolicy_js_1.storageCorrectContentLengthPolicy)());
        corePipeline.addPolicy((0, StorageRetryPolicyV2_js_1.storageRetryPolicy)(restOptions.retryOptions), { phase: "Retry" });
        corePipeline.addPolicy((0, storage_common_1.storageRequestFailureDetailsParserPolicy)());
        corePipeline.addPolicy((0, StorageBrowserPolicyV2_js_1.storageBrowserPolicy)());
        const downlevelResults = processDownlevelPipeline(pipeline);
        if (downlevelResults) {
          corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? { afterPhase: "Retry" } : void 0);
        }
        const credential = getCredentialFromPipeline(pipeline);
        if ((0, core_auth_1.isTokenCredential)(credential)) {
          corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
            credential,
            scopes: restOptions.audience ?? constants_js_1.StorageOAuthScopes,
            challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
          }), { phase: "Sign" });
        } else if (credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential) {
          corePipeline.addPolicy((0, StorageSharedKeyCredentialPolicyV2_js_1.storageSharedKeyCredentialPolicy)({
            accountName: credential.accountName,
            accountKey: credential.accountKey
          }), { phase: "Sign" });
        }
        pipeline._corePipeline = corePipeline;
      }
      return {
        ...restOptions,
        allowInsecureConnection: true,
        httpClient,
        pipeline: corePipeline
      };
    }
    function getCredentialFromPipeline(pipeline) {
      if (pipeline._credential) {
        return pipeline._credential;
      }
      let credential = new AnonymousCredential_js_1.AnonymousCredential();
      for (const factory of pipeline.factories) {
        if ((0, core_auth_1.isTokenCredential)(factory.credential)) {
          credential = factory.credential;
        } else if (isStorageSharedKeyCredential(factory)) {
          return factory;
        }
      }
      return credential;
    }
    function isStorageSharedKeyCredential(factory) {
      if (factory instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential) {
        return true;
      }
      return factory.constructor.name === "StorageSharedKeyCredential";
    }
    function isAnonymousCredential(factory) {
      if (factory instanceof AnonymousCredential_js_1.AnonymousCredential) {
        return true;
      }
      return factory.constructor.name === "AnonymousCredential";
    }
    function isCoreHttpBearerTokenFactory(factory) {
      return (0, core_auth_1.isTokenCredential)(factory.credential);
    }
    function isStorageBrowserPolicyFactory(factory) {
      if (factory instanceof StorageBrowserPolicyFactory_js_1.StorageBrowserPolicyFactory) {
        return true;
      }
      return factory.constructor.name === "StorageBrowserPolicyFactory";
    }
    function isStorageRetryPolicyFactory(factory) {
      if (factory instanceof StorageRetryPolicyFactory_js_1.StorageRetryPolicyFactory) {
        return true;
      }
      return factory.constructor.name === "StorageRetryPolicyFactory";
    }
    function isStorageTelemetryPolicyFactory(factory) {
      return factory.constructor.name === "TelemetryPolicyFactory";
    }
    function isInjectorPolicyFactory(factory) {
      return factory.constructor.name === "InjectorPolicyFactory";
    }
    function isCoreHttpPolicyFactory(factory) {
      const knownPolicies = [
        "GenerateClientRequestIdPolicy",
        "TracingPolicy",
        "LogPolicy",
        "ProxyPolicy",
        "DisableResponseDecompressionPolicy",
        "KeepAlivePolicy",
        "DeserializationPolicy"
      ];
      const mockHttpClient = {
        sendRequest: async (request) => {
          return {
            request,
            headers: request.headers.clone(),
            status: 500
          };
        }
      };
      const mockRequestPolicyOptions = {
        log(_logLevel, _message) {
        },
        shouldLog(_logLevel) {
          return false;
        }
      };
      const policyInstance = factory.create(mockHttpClient, mockRequestPolicyOptions);
      const policyName = policyInstance.constructor.name;
      return knownPolicies.some((knownPolicyName) => {
        return policyName.startsWith(knownPolicyName);
      });
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/index.js
var require_models = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KnownStorageErrorCode = exports.KnownBlobExpiryOptions = exports.KnownFileShareTokenIntent = exports.KnownEncryptionAlgorithmType = void 0;
    var KnownEncryptionAlgorithmType;
    (function(KnownEncryptionAlgorithmType2) {
      KnownEncryptionAlgorithmType2["AES256"] = "AES256";
    })(KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
    var KnownFileShareTokenIntent;
    (function(KnownFileShareTokenIntent2) {
      KnownFileShareTokenIntent2["Backup"] = "backup";
    })(KnownFileShareTokenIntent || (exports.KnownFileShareTokenIntent = KnownFileShareTokenIntent = {}));
    var KnownBlobExpiryOptions;
    (function(KnownBlobExpiryOptions2) {
      KnownBlobExpiryOptions2["NeverExpire"] = "NeverExpire";
      KnownBlobExpiryOptions2["RelativeToCreation"] = "RelativeToCreation";
      KnownBlobExpiryOptions2["RelativeToNow"] = "RelativeToNow";
      KnownBlobExpiryOptions2["Absolute"] = "Absolute";
    })(KnownBlobExpiryOptions || (exports.KnownBlobExpiryOptions = KnownBlobExpiryOptions = {}));
    var KnownStorageErrorCode;
    (function(KnownStorageErrorCode2) {
      KnownStorageErrorCode2["AccountAlreadyExists"] = "AccountAlreadyExists";
      KnownStorageErrorCode2["AccountBeingCreated"] = "AccountBeingCreated";
      KnownStorageErrorCode2["AccountIsDisabled"] = "AccountIsDisabled";
      KnownStorageErrorCode2["AuthenticationFailed"] = "AuthenticationFailed";
      KnownStorageErrorCode2["AuthorizationFailure"] = "AuthorizationFailure";
      KnownStorageErrorCode2["ConditionHeadersNotSupported"] = "ConditionHeadersNotSupported";
      KnownStorageErrorCode2["ConditionNotMet"] = "ConditionNotMet";
      KnownStorageErrorCode2["EmptyMetadataKey"] = "EmptyMetadataKey";
      KnownStorageErrorCode2["InsufficientAccountPermissions"] = "InsufficientAccountPermissions";
      KnownStorageErrorCode2["InternalError"] = "InternalError";
      KnownStorageErrorCode2["InvalidAuthenticationInfo"] = "InvalidAuthenticationInfo";
      KnownStorageErrorCode2["InvalidHeaderValue"] = "InvalidHeaderValue";
      KnownStorageErrorCode2["InvalidHttpVerb"] = "InvalidHttpVerb";
      KnownStorageErrorCode2["InvalidInput"] = "InvalidInput";
      KnownStorageErrorCode2["InvalidMd5"] = "InvalidMd5";
      KnownStorageErrorCode2["InvalidMetadata"] = "InvalidMetadata";
      KnownStorageErrorCode2["InvalidQueryParameterValue"] = "InvalidQueryParameterValue";
      KnownStorageErrorCode2["InvalidRange"] = "InvalidRange";
      KnownStorageErrorCode2["InvalidResourceName"] = "InvalidResourceName";
      KnownStorageErrorCode2["InvalidUri"] = "InvalidUri";
      KnownStorageErrorCode2["InvalidXmlDocument"] = "InvalidXmlDocument";
      KnownStorageErrorCode2["InvalidXmlNodeValue"] = "InvalidXmlNodeValue";
      KnownStorageErrorCode2["Md5Mismatch"] = "Md5Mismatch";
      KnownStorageErrorCode2["MetadataTooLarge"] = "MetadataTooLarge";
      KnownStorageErrorCode2["MissingContentLengthHeader"] = "MissingContentLengthHeader";
      KnownStorageErrorCode2["MissingRequiredQueryParameter"] = "MissingRequiredQueryParameter";
      KnownStorageErrorCode2["MissingRequiredHeader"] = "MissingRequiredHeader";
      KnownStorageErrorCode2["MissingRequiredXmlNode"] = "MissingRequiredXmlNode";
      KnownStorageErrorCode2["MultipleConditionHeadersNotSupported"] = "MultipleConditionHeadersNotSupported";
      KnownStorageErrorCode2["OperationTimedOut"] = "OperationTimedOut";
      KnownStorageErrorCode2["OutOfRangeInput"] = "OutOfRangeInput";
      KnownStorageErrorCode2["OutOfRangeQueryParameterValue"] = "OutOfRangeQueryParameterValue";
      KnownStorageErrorCode2["RequestBodyTooLarge"] = "RequestBodyTooLarge";
      KnownStorageErrorCode2["ResourceTypeMismatch"] = "ResourceTypeMismatch";
      KnownStorageErrorCode2["RequestUrlFailedToParse"] = "RequestUrlFailedToParse";
      KnownStorageErrorCode2["ResourceAlreadyExists"] = "ResourceAlreadyExists";
      KnownStorageErrorCode2["ResourceNotFound"] = "ResourceNotFound";
      KnownStorageErrorCode2["ServerBusy"] = "ServerBusy";
      KnownStorageErrorCode2["UnsupportedHeader"] = "UnsupportedHeader";
      KnownStorageErrorCode2["UnsupportedXmlNode"] = "UnsupportedXmlNode";
      KnownStorageErrorCode2["UnsupportedQueryParameter"] = "UnsupportedQueryParameter";
      KnownStorageErrorCode2["UnsupportedHttpVerb"] = "UnsupportedHttpVerb";
      KnownStorageErrorCode2["AppendPositionConditionNotMet"] = "AppendPositionConditionNotMet";
      KnownStorageErrorCode2["BlobAlreadyExists"] = "BlobAlreadyExists";
      KnownStorageErrorCode2["BlobImmutableDueToPolicy"] = "BlobImmutableDueToPolicy";
      KnownStorageErrorCode2["BlobNotFound"] = "BlobNotFound";
      KnownStorageErrorCode2["BlobOverwritten"] = "BlobOverwritten";
      KnownStorageErrorCode2["BlobTierInadequateForContentLength"] = "BlobTierInadequateForContentLength";
      KnownStorageErrorCode2["BlobUsesCustomerSpecifiedEncryption"] = "BlobUsesCustomerSpecifiedEncryption";
      KnownStorageErrorCode2["BlockCountExceedsLimit"] = "BlockCountExceedsLimit";
      KnownStorageErrorCode2["BlockListTooLong"] = "BlockListTooLong";
      KnownStorageErrorCode2["CannotChangeToLowerTier"] = "CannotChangeToLowerTier";
      KnownStorageErrorCode2["CannotVerifyCopySource"] = "CannotVerifyCopySource";
      KnownStorageErrorCode2["ContainerAlreadyExists"] = "ContainerAlreadyExists";
      KnownStorageErrorCode2["ContainerBeingDeleted"] = "ContainerBeingDeleted";
      KnownStorageErrorCode2["ContainerDisabled"] = "ContainerDisabled";
      KnownStorageErrorCode2["ContainerNotFound"] = "ContainerNotFound";
      KnownStorageErrorCode2["ContentLengthLargerThanTierLimit"] = "ContentLengthLargerThanTierLimit";
      KnownStorageErrorCode2["CopyAcrossAccountsNotSupported"] = "CopyAcrossAccountsNotSupported";
      KnownStorageErrorCode2["CopyIdMismatch"] = "CopyIdMismatch";
      KnownStorageErrorCode2["FeatureVersionMismatch"] = "FeatureVersionMismatch";
      KnownStorageErrorCode2["IncrementalCopyBlobMismatch"] = "IncrementalCopyBlobMismatch";
      KnownStorageErrorCode2["IncrementalCopyOfEarlierVersionSnapshotNotAllowed"] = "IncrementalCopyOfEarlierVersionSnapshotNotAllowed";
      KnownStorageErrorCode2["IncrementalCopySourceMustBeSnapshot"] = "IncrementalCopySourceMustBeSnapshot";
      KnownStorageErrorCode2["InfiniteLeaseDurationRequired"] = "InfiniteLeaseDurationRequired";
      KnownStorageErrorCode2["InvalidBlobOrBlock"] = "InvalidBlobOrBlock";
      KnownStorageErrorCode2["InvalidBlobTier"] = "InvalidBlobTier";
      KnownStorageErrorCode2["InvalidBlobType"] = "InvalidBlobType";
      KnownStorageErrorCode2["InvalidBlockId"] = "InvalidBlockId";
      KnownStorageErrorCode2["InvalidBlockList"] = "InvalidBlockList";
      KnownStorageErrorCode2["InvalidOperation"] = "InvalidOperation";
      KnownStorageErrorCode2["InvalidPageRange"] = "InvalidPageRange";
      KnownStorageErrorCode2["InvalidSourceBlobType"] = "InvalidSourceBlobType";
      KnownStorageErrorCode2["InvalidSourceBlobUrl"] = "InvalidSourceBlobUrl";
      KnownStorageErrorCode2["InvalidVersionForPageBlobOperation"] = "InvalidVersionForPageBlobOperation";
      KnownStorageErrorCode2["LeaseAlreadyPresent"] = "LeaseAlreadyPresent";
      KnownStorageErrorCode2["LeaseAlreadyBroken"] = "LeaseAlreadyBroken";
      KnownStorageErrorCode2["LeaseIdMismatchWithBlobOperation"] = "LeaseIdMismatchWithBlobOperation";
      KnownStorageErrorCode2["LeaseIdMismatchWithContainerOperation"] = "LeaseIdMismatchWithContainerOperation";
      KnownStorageErrorCode2["LeaseIdMismatchWithLeaseOperation"] = "LeaseIdMismatchWithLeaseOperation";
      KnownStorageErrorCode2["LeaseIdMissing"] = "LeaseIdMissing";
      KnownStorageErrorCode2["LeaseIsBreakingAndCannotBeAcquired"] = "LeaseIsBreakingAndCannotBeAcquired";
      KnownStorageErrorCode2["LeaseIsBreakingAndCannotBeChanged"] = "LeaseIsBreakingAndCannotBeChanged";
      KnownStorageErrorCode2["LeaseIsBrokenAndCannotBeRenewed"] = "LeaseIsBrokenAndCannotBeRenewed";
      KnownStorageErrorCode2["LeaseLost"] = "LeaseLost";
      KnownStorageErrorCode2["LeaseNotPresentWithBlobOperation"] = "LeaseNotPresentWithBlobOperation";
      KnownStorageErrorCode2["LeaseNotPresentWithContainerOperation"] = "LeaseNotPresentWithContainerOperation";
      KnownStorageErrorCode2["LeaseNotPresentWithLeaseOperation"] = "LeaseNotPresentWithLeaseOperation";
      KnownStorageErrorCode2["MaxBlobSizeConditionNotMet"] = "MaxBlobSizeConditionNotMet";
      KnownStorageErrorCode2["NoAuthenticationInformation"] = "NoAuthenticationInformation";
      KnownStorageErrorCode2["NoPendingCopyOperation"] = "NoPendingCopyOperation";
      KnownStorageErrorCode2["OperationNotAllowedOnIncrementalCopyBlob"] = "OperationNotAllowedOnIncrementalCopyBlob";
      KnownStorageErrorCode2["PendingCopyOperation"] = "PendingCopyOperation";
      KnownStorageErrorCode2["PreviousSnapshotCannotBeNewer"] = "PreviousSnapshotCannotBeNewer";
      KnownStorageErrorCode2["PreviousSnapshotNotFound"] = "PreviousSnapshotNotFound";
      KnownStorageErrorCode2["PreviousSnapshotOperationNotSupported"] = "PreviousSnapshotOperationNotSupported";
      KnownStorageErrorCode2["SequenceNumberConditionNotMet"] = "SequenceNumberConditionNotMet";
      KnownStorageErrorCode2["SequenceNumberIncrementTooLarge"] = "SequenceNumberIncrementTooLarge";
      KnownStorageErrorCode2["SnapshotCountExceeded"] = "SnapshotCountExceeded";
      KnownStorageErrorCode2["SnapshotOperationRateExceeded"] = "SnapshotOperationRateExceeded";
      KnownStorageErrorCode2["SnapshotsPresent"] = "SnapshotsPresent";
      KnownStorageErrorCode2["SourceConditionNotMet"] = "SourceConditionNotMet";
      KnownStorageErrorCode2["SystemInUse"] = "SystemInUse";
      KnownStorageErrorCode2["TargetConditionNotMet"] = "TargetConditionNotMet";
      KnownStorageErrorCode2["UnauthorizedBlobOverwrite"] = "UnauthorizedBlobOverwrite";
      KnownStorageErrorCode2["BlobBeingRehydrated"] = "BlobBeingRehydrated";
      KnownStorageErrorCode2["BlobArchived"] = "BlobArchived";
      KnownStorageErrorCode2["BlobNotArchived"] = "BlobNotArchived";
      KnownStorageErrorCode2["AuthorizationSourceIPMismatch"] = "AuthorizationSourceIPMismatch";
      KnownStorageErrorCode2["AuthorizationProtocolMismatch"] = "AuthorizationProtocolMismatch";
      KnownStorageErrorCode2["AuthorizationPermissionMismatch"] = "AuthorizationPermissionMismatch";
      KnownStorageErrorCode2["AuthorizationServiceMismatch"] = "AuthorizationServiceMismatch";
      KnownStorageErrorCode2["AuthorizationResourceTypeMismatch"] = "AuthorizationResourceTypeMismatch";
      KnownStorageErrorCode2["BlobAccessTierNotSupportedForAccountType"] = "BlobAccessTierNotSupportedForAccountType";
    })(KnownStorageErrorCode || (exports.KnownStorageErrorCode = KnownStorageErrorCode = {}));
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/mappers.js
var require_mappers = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/mappers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServiceGetUserDelegationKeyHeaders = exports.ServiceListContainersSegmentExceptionHeaders = exports.ServiceListContainersSegmentHeaders = exports.ServiceGetStatisticsExceptionHeaders = exports.ServiceGetStatisticsHeaders = exports.ServiceGetPropertiesExceptionHeaders = exports.ServiceGetPropertiesHeaders = exports.ServiceSetPropertiesExceptionHeaders = exports.ServiceSetPropertiesHeaders = exports.ArrowField = exports.ArrowConfiguration = exports.JsonTextConfiguration = exports.DelimitedTextConfiguration = exports.QueryFormat = exports.QuerySerialization = exports.QueryRequest = exports.ClearRange = exports.PageRange = exports.PageList = exports.Block = exports.BlockList = exports.BlockLookupList = exports.BlobPrefix = exports.BlobHierarchyListSegment = exports.ListBlobsHierarchySegmentResponse = exports.BlobPropertiesInternal = exports.BlobName = exports.BlobItemInternal = exports.BlobFlatListSegment = exports.ListBlobsFlatSegmentResponse = exports.AccessPolicy = exports.SignedIdentifier = exports.BlobTag = exports.BlobTags = exports.FilterBlobItem = exports.FilterBlobSegment = exports.UserDelegationKey = exports.KeyInfo = exports.ContainerProperties = exports.ContainerItem = exports.ListContainersSegmentResponse = exports.GeoReplication = exports.BlobServiceStatistics = exports.StorageError = exports.StaticWebsite = exports.CorsRule = exports.Metrics = exports.RetentionPolicy = exports.Logging = exports.BlobServiceProperties = void 0;
    exports.BlobUndeleteHeaders = exports.BlobDeleteExceptionHeaders = exports.BlobDeleteHeaders = exports.BlobGetPropertiesExceptionHeaders = exports.BlobGetPropertiesHeaders = exports.BlobDownloadExceptionHeaders = exports.BlobDownloadHeaders = exports.ContainerGetAccountInfoExceptionHeaders = exports.ContainerGetAccountInfoHeaders = exports.ContainerListBlobHierarchySegmentExceptionHeaders = exports.ContainerListBlobHierarchySegmentHeaders = exports.ContainerListBlobFlatSegmentExceptionHeaders = exports.ContainerListBlobFlatSegmentHeaders = exports.ContainerChangeLeaseExceptionHeaders = exports.ContainerChangeLeaseHeaders = exports.ContainerBreakLeaseExceptionHeaders = exports.ContainerBreakLeaseHeaders = exports.ContainerRenewLeaseExceptionHeaders = exports.ContainerRenewLeaseHeaders = exports.ContainerReleaseLeaseExceptionHeaders = exports.ContainerReleaseLeaseHeaders = exports.ContainerAcquireLeaseExceptionHeaders = exports.ContainerAcquireLeaseHeaders = exports.ContainerFilterBlobsExceptionHeaders = exports.ContainerFilterBlobsHeaders = exports.ContainerSubmitBatchExceptionHeaders = exports.ContainerSubmitBatchHeaders = exports.ContainerRenameExceptionHeaders = exports.ContainerRenameHeaders = exports.ContainerRestoreExceptionHeaders = exports.ContainerRestoreHeaders = exports.ContainerSetAccessPolicyExceptionHeaders = exports.ContainerSetAccessPolicyHeaders = exports.ContainerGetAccessPolicyExceptionHeaders = exports.ContainerGetAccessPolicyHeaders = exports.ContainerSetMetadataExceptionHeaders = exports.ContainerSetMetadataHeaders = exports.ContainerDeleteExceptionHeaders = exports.ContainerDeleteHeaders = exports.ContainerGetPropertiesExceptionHeaders = exports.ContainerGetPropertiesHeaders = exports.ContainerCreateExceptionHeaders = exports.ContainerCreateHeaders = exports.ServiceFilterBlobsExceptionHeaders = exports.ServiceFilterBlobsHeaders = exports.ServiceSubmitBatchExceptionHeaders = exports.ServiceSubmitBatchHeaders = exports.ServiceGetAccountInfoExceptionHeaders = exports.ServiceGetAccountInfoHeaders = exports.ServiceGetUserDelegationKeyExceptionHeaders = void 0;
    exports.PageBlobGetPageRangesHeaders = exports.PageBlobUploadPagesFromURLExceptionHeaders = exports.PageBlobUploadPagesFromURLHeaders = exports.PageBlobClearPagesExceptionHeaders = exports.PageBlobClearPagesHeaders = exports.PageBlobUploadPagesExceptionHeaders = exports.PageBlobUploadPagesHeaders = exports.PageBlobCreateExceptionHeaders = exports.PageBlobCreateHeaders = exports.BlobSetTagsExceptionHeaders = exports.BlobSetTagsHeaders = exports.BlobGetTagsExceptionHeaders = exports.BlobGetTagsHeaders = exports.BlobQueryExceptionHeaders = exports.BlobQueryHeaders = exports.BlobGetAccountInfoExceptionHeaders = exports.BlobGetAccountInfoHeaders = exports.BlobSetTierExceptionHeaders = exports.BlobSetTierHeaders = exports.BlobAbortCopyFromURLExceptionHeaders = exports.BlobAbortCopyFromURLHeaders = exports.BlobCopyFromURLExceptionHeaders = exports.BlobCopyFromURLHeaders = exports.BlobStartCopyFromURLExceptionHeaders = exports.BlobStartCopyFromURLHeaders = exports.BlobCreateSnapshotExceptionHeaders = exports.BlobCreateSnapshotHeaders = exports.BlobBreakLeaseExceptionHeaders = exports.BlobBreakLeaseHeaders = exports.BlobChangeLeaseExceptionHeaders = exports.BlobChangeLeaseHeaders = exports.BlobRenewLeaseExceptionHeaders = exports.BlobRenewLeaseHeaders = exports.BlobReleaseLeaseExceptionHeaders = exports.BlobReleaseLeaseHeaders = exports.BlobAcquireLeaseExceptionHeaders = exports.BlobAcquireLeaseHeaders = exports.BlobSetMetadataExceptionHeaders = exports.BlobSetMetadataHeaders = exports.BlobSetLegalHoldExceptionHeaders = exports.BlobSetLegalHoldHeaders = exports.BlobDeleteImmutabilityPolicyExceptionHeaders = exports.BlobDeleteImmutabilityPolicyHeaders = exports.BlobSetImmutabilityPolicyExceptionHeaders = exports.BlobSetImmutabilityPolicyHeaders = exports.BlobSetHttpHeadersExceptionHeaders = exports.BlobSetHttpHeadersHeaders = exports.BlobSetExpiryExceptionHeaders = exports.BlobSetExpiryHeaders = exports.BlobUndeleteExceptionHeaders = void 0;
    exports.BlockBlobGetBlockListExceptionHeaders = exports.BlockBlobGetBlockListHeaders = exports.BlockBlobCommitBlockListExceptionHeaders = exports.BlockBlobCommitBlockListHeaders = exports.BlockBlobStageBlockFromURLExceptionHeaders = exports.BlockBlobStageBlockFromURLHeaders = exports.BlockBlobStageBlockExceptionHeaders = exports.BlockBlobStageBlockHeaders = exports.BlockBlobPutBlobFromUrlExceptionHeaders = exports.BlockBlobPutBlobFromUrlHeaders = exports.BlockBlobUploadExceptionHeaders = exports.BlockBlobUploadHeaders = exports.AppendBlobSealExceptionHeaders = exports.AppendBlobSealHeaders = exports.AppendBlobAppendBlockFromUrlExceptionHeaders = exports.AppendBlobAppendBlockFromUrlHeaders = exports.AppendBlobAppendBlockExceptionHeaders = exports.AppendBlobAppendBlockHeaders = exports.AppendBlobCreateExceptionHeaders = exports.AppendBlobCreateHeaders = exports.PageBlobCopyIncrementalExceptionHeaders = exports.PageBlobCopyIncrementalHeaders = exports.PageBlobUpdateSequenceNumberExceptionHeaders = exports.PageBlobUpdateSequenceNumberHeaders = exports.PageBlobResizeExceptionHeaders = exports.PageBlobResizeHeaders = exports.PageBlobGetPageRangesDiffExceptionHeaders = exports.PageBlobGetPageRangesDiffHeaders = exports.PageBlobGetPageRangesExceptionHeaders = void 0;
    exports.BlobServiceProperties = {
      serializedName: "BlobServiceProperties",
      xmlName: "StorageServiceProperties",
      type: {
        name: "Composite",
        className: "BlobServiceProperties",
        modelProperties: {
          blobAnalyticsLogging: {
            serializedName: "Logging",
            xmlName: "Logging",
            type: {
              name: "Composite",
              className: "Logging"
            }
          },
          hourMetrics: {
            serializedName: "HourMetrics",
            xmlName: "HourMetrics",
            type: {
              name: "Composite",
              className: "Metrics"
            }
          },
          minuteMetrics: {
            serializedName: "MinuteMetrics",
            xmlName: "MinuteMetrics",
            type: {
              name: "Composite",
              className: "Metrics"
            }
          },
          cors: {
            serializedName: "Cors",
            xmlName: "Cors",
            xmlIsWrapped: true,
            xmlElementName: "CorsRule",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "CorsRule"
                }
              }
            }
          },
          defaultServiceVersion: {
            serializedName: "DefaultServiceVersion",
            xmlName: "DefaultServiceVersion",
            type: {
              name: "String"
            }
          },
          deleteRetentionPolicy: {
            serializedName: "DeleteRetentionPolicy",
            xmlName: "DeleteRetentionPolicy",
            type: {
              name: "Composite",
              className: "RetentionPolicy"
            }
          },
          staticWebsite: {
            serializedName: "StaticWebsite",
            xmlName: "StaticWebsite",
            type: {
              name: "Composite",
              className: "StaticWebsite"
            }
          }
        }
      }
    };
    exports.Logging = {
      serializedName: "Logging",
      type: {
        name: "Composite",
        className: "Logging",
        modelProperties: {
          version: {
            serializedName: "Version",
            required: true,
            xmlName: "Version",
            type: {
              name: "String"
            }
          },
          deleteProperty: {
            serializedName: "Delete",
            required: true,
            xmlName: "Delete",
            type: {
              name: "Boolean"
            }
          },
          read: {
            serializedName: "Read",
            required: true,
            xmlName: "Read",
            type: {
              name: "Boolean"
            }
          },
          write: {
            serializedName: "Write",
            required: true,
            xmlName: "Write",
            type: {
              name: "Boolean"
            }
          },
          retentionPolicy: {
            serializedName: "RetentionPolicy",
            xmlName: "RetentionPolicy",
            type: {
              name: "Composite",
              className: "RetentionPolicy"
            }
          }
        }
      }
    };
    exports.RetentionPolicy = {
      serializedName: "RetentionPolicy",
      type: {
        name: "Composite",
        className: "RetentionPolicy",
        modelProperties: {
          enabled: {
            serializedName: "Enabled",
            required: true,
            xmlName: "Enabled",
            type: {
              name: "Boolean"
            }
          },
          days: {
            constraints: {
              InclusiveMinimum: 1
            },
            serializedName: "Days",
            xmlName: "Days",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.Metrics = {
      serializedName: "Metrics",
      type: {
        name: "Composite",
        className: "Metrics",
        modelProperties: {
          version: {
            serializedName: "Version",
            xmlName: "Version",
            type: {
              name: "String"
            }
          },
          enabled: {
            serializedName: "Enabled",
            required: true,
            xmlName: "Enabled",
            type: {
              name: "Boolean"
            }
          },
          includeAPIs: {
            serializedName: "IncludeAPIs",
            xmlName: "IncludeAPIs",
            type: {
              name: "Boolean"
            }
          },
          retentionPolicy: {
            serializedName: "RetentionPolicy",
            xmlName: "RetentionPolicy",
            type: {
              name: "Composite",
              className: "RetentionPolicy"
            }
          }
        }
      }
    };
    exports.CorsRule = {
      serializedName: "CorsRule",
      type: {
        name: "Composite",
        className: "CorsRule",
        modelProperties: {
          allowedOrigins: {
            serializedName: "AllowedOrigins",
            required: true,
            xmlName: "AllowedOrigins",
            type: {
              name: "String"
            }
          },
          allowedMethods: {
            serializedName: "AllowedMethods",
            required: true,
            xmlName: "AllowedMethods",
            type: {
              name: "String"
            }
          },
          allowedHeaders: {
            serializedName: "AllowedHeaders",
            required: true,
            xmlName: "AllowedHeaders",
            type: {
              name: "String"
            }
          },
          exposedHeaders: {
            serializedName: "ExposedHeaders",
            required: true,
            xmlName: "ExposedHeaders",
            type: {
              name: "String"
            }
          },
          maxAgeInSeconds: {
            constraints: {
              InclusiveMinimum: 0
            },
            serializedName: "MaxAgeInSeconds",
            required: true,
            xmlName: "MaxAgeInSeconds",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.StaticWebsite = {
      serializedName: "StaticWebsite",
      type: {
        name: "Composite",
        className: "StaticWebsite",
        modelProperties: {
          enabled: {
            serializedName: "Enabled",
            required: true,
            xmlName: "Enabled",
            type: {
              name: "Boolean"
            }
          },
          indexDocument: {
            serializedName: "IndexDocument",
            xmlName: "IndexDocument",
            type: {
              name: "String"
            }
          },
          errorDocument404Path: {
            serializedName: "ErrorDocument404Path",
            xmlName: "ErrorDocument404Path",
            type: {
              name: "String"
            }
          },
          defaultIndexDocumentPath: {
            serializedName: "DefaultIndexDocumentPath",
            xmlName: "DefaultIndexDocumentPath",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.StorageError = {
      serializedName: "StorageError",
      type: {
        name: "Composite",
        className: "StorageError",
        modelProperties: {
          message: {
            serializedName: "Message",
            xmlName: "Message",
            type: {
              name: "String"
            }
          },
          copySourceStatusCode: {
            serializedName: "CopySourceStatusCode",
            xmlName: "CopySourceStatusCode",
            type: {
              name: "Number"
            }
          },
          copySourceErrorCode: {
            serializedName: "CopySourceErrorCode",
            xmlName: "CopySourceErrorCode",
            type: {
              name: "String"
            }
          },
          copySourceErrorMessage: {
            serializedName: "CopySourceErrorMessage",
            xmlName: "CopySourceErrorMessage",
            type: {
              name: "String"
            }
          },
          code: {
            serializedName: "Code",
            xmlName: "Code",
            type: {
              name: "String"
            }
          },
          authenticationErrorDetail: {
            serializedName: "AuthenticationErrorDetail",
            xmlName: "AuthenticationErrorDetail",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobServiceStatistics = {
      serializedName: "BlobServiceStatistics",
      xmlName: "StorageServiceStats",
      type: {
        name: "Composite",
        className: "BlobServiceStatistics",
        modelProperties: {
          geoReplication: {
            serializedName: "GeoReplication",
            xmlName: "GeoReplication",
            type: {
              name: "Composite",
              className: "GeoReplication"
            }
          }
        }
      }
    };
    exports.GeoReplication = {
      serializedName: "GeoReplication",
      type: {
        name: "Composite",
        className: "GeoReplication",
        modelProperties: {
          status: {
            serializedName: "Status",
            required: true,
            xmlName: "Status",
            type: {
              name: "Enum",
              allowedValues: ["live", "bootstrap", "unavailable"]
            }
          },
          lastSyncOn: {
            serializedName: "LastSyncTime",
            required: true,
            xmlName: "LastSyncTime",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.ListContainersSegmentResponse = {
      serializedName: "ListContainersSegmentResponse",
      xmlName: "EnumerationResults",
      type: {
        name: "Composite",
        className: "ListContainersSegmentResponse",
        modelProperties: {
          serviceEndpoint: {
            serializedName: "ServiceEndpoint",
            required: true,
            xmlName: "ServiceEndpoint",
            xmlIsAttribute: true,
            type: {
              name: "String"
            }
          },
          prefix: {
            serializedName: "Prefix",
            xmlName: "Prefix",
            type: {
              name: "String"
            }
          },
          marker: {
            serializedName: "Marker",
            xmlName: "Marker",
            type: {
              name: "String"
            }
          },
          maxPageSize: {
            serializedName: "MaxResults",
            xmlName: "MaxResults",
            type: {
              name: "Number"
            }
          },
          containerItems: {
            serializedName: "ContainerItems",
            required: true,
            xmlName: "Containers",
            xmlIsWrapped: true,
            xmlElementName: "Container",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ContainerItem"
                }
              }
            }
          },
          continuationToken: {
            serializedName: "NextMarker",
            xmlName: "NextMarker",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerItem = {
      serializedName: "ContainerItem",
      xmlName: "Container",
      type: {
        name: "Composite",
        className: "ContainerItem",
        modelProperties: {
          name: {
            serializedName: "Name",
            required: true,
            xmlName: "Name",
            type: {
              name: "String"
            }
          },
          deleted: {
            serializedName: "Deleted",
            xmlName: "Deleted",
            type: {
              name: "Boolean"
            }
          },
          version: {
            serializedName: "Version",
            xmlName: "Version",
            type: {
              name: "String"
            }
          },
          properties: {
            serializedName: "Properties",
            xmlName: "Properties",
            type: {
              name: "Composite",
              className: "ContainerProperties"
            }
          },
          metadata: {
            serializedName: "Metadata",
            xmlName: "Metadata",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          }
        }
      }
    };
    exports.ContainerProperties = {
      serializedName: "ContainerProperties",
      type: {
        name: "Composite",
        className: "ContainerProperties",
        modelProperties: {
          lastModified: {
            serializedName: "Last-Modified",
            required: true,
            xmlName: "Last-Modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          etag: {
            serializedName: "Etag",
            required: true,
            xmlName: "Etag",
            type: {
              name: "String"
            }
          },
          leaseStatus: {
            serializedName: "LeaseStatus",
            xmlName: "LeaseStatus",
            type: {
              name: "Enum",
              allowedValues: ["locked", "unlocked"]
            }
          },
          leaseState: {
            serializedName: "LeaseState",
            xmlName: "LeaseState",
            type: {
              name: "Enum",
              allowedValues: [
                "available",
                "leased",
                "expired",
                "breaking",
                "broken"
              ]
            }
          },
          leaseDuration: {
            serializedName: "LeaseDuration",
            xmlName: "LeaseDuration",
            type: {
              name: "Enum",
              allowedValues: ["infinite", "fixed"]
            }
          },
          publicAccess: {
            serializedName: "PublicAccess",
            xmlName: "PublicAccess",
            type: {
              name: "Enum",
              allowedValues: ["container", "blob"]
            }
          },
          hasImmutabilityPolicy: {
            serializedName: "HasImmutabilityPolicy",
            xmlName: "HasImmutabilityPolicy",
            type: {
              name: "Boolean"
            }
          },
          hasLegalHold: {
            serializedName: "HasLegalHold",
            xmlName: "HasLegalHold",
            type: {
              name: "Boolean"
            }
          },
          defaultEncryptionScope: {
            serializedName: "DefaultEncryptionScope",
            xmlName: "DefaultEncryptionScope",
            type: {
              name: "String"
            }
          },
          preventEncryptionScopeOverride: {
            serializedName: "DenyEncryptionScopeOverride",
            xmlName: "DenyEncryptionScopeOverride",
            type: {
              name: "Boolean"
            }
          },
          deletedOn: {
            serializedName: "DeletedTime",
            xmlName: "DeletedTime",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          remainingRetentionDays: {
            serializedName: "RemainingRetentionDays",
            xmlName: "RemainingRetentionDays",
            type: {
              name: "Number"
            }
          },
          isImmutableStorageWithVersioningEnabled: {
            serializedName: "ImmutableStorageWithVersioningEnabled",
            xmlName: "ImmutableStorageWithVersioningEnabled",
            type: {
              name: "Boolean"
            }
          }
        }
      }
    };
    exports.KeyInfo = {
      serializedName: "KeyInfo",
      type: {
        name: "Composite",
        className: "KeyInfo",
        modelProperties: {
          startsOn: {
            serializedName: "Start",
            required: true,
            xmlName: "Start",
            type: {
              name: "String"
            }
          },
          expiresOn: {
            serializedName: "Expiry",
            required: true,
            xmlName: "Expiry",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.UserDelegationKey = {
      serializedName: "UserDelegationKey",
      type: {
        name: "Composite",
        className: "UserDelegationKey",
        modelProperties: {
          signedObjectId: {
            serializedName: "SignedOid",
            required: true,
            xmlName: "SignedOid",
            type: {
              name: "String"
            }
          },
          signedTenantId: {
            serializedName: "SignedTid",
            required: true,
            xmlName: "SignedTid",
            type: {
              name: "String"
            }
          },
          signedStartsOn: {
            serializedName: "SignedStart",
            required: true,
            xmlName: "SignedStart",
            type: {
              name: "String"
            }
          },
          signedExpiresOn: {
            serializedName: "SignedExpiry",
            required: true,
            xmlName: "SignedExpiry",
            type: {
              name: "String"
            }
          },
          signedService: {
            serializedName: "SignedService",
            required: true,
            xmlName: "SignedService",
            type: {
              name: "String"
            }
          },
          signedVersion: {
            serializedName: "SignedVersion",
            required: true,
            xmlName: "SignedVersion",
            type: {
              name: "String"
            }
          },
          value: {
            serializedName: "Value",
            required: true,
            xmlName: "Value",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.FilterBlobSegment = {
      serializedName: "FilterBlobSegment",
      xmlName: "EnumerationResults",
      type: {
        name: "Composite",
        className: "FilterBlobSegment",
        modelProperties: {
          serviceEndpoint: {
            serializedName: "ServiceEndpoint",
            required: true,
            xmlName: "ServiceEndpoint",
            xmlIsAttribute: true,
            type: {
              name: "String"
            }
          },
          where: {
            serializedName: "Where",
            required: true,
            xmlName: "Where",
            type: {
              name: "String"
            }
          },
          blobs: {
            serializedName: "Blobs",
            required: true,
            xmlName: "Blobs",
            xmlIsWrapped: true,
            xmlElementName: "Blob",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "FilterBlobItem"
                }
              }
            }
          },
          continuationToken: {
            serializedName: "NextMarker",
            xmlName: "NextMarker",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.FilterBlobItem = {
      serializedName: "FilterBlobItem",
      xmlName: "Blob",
      type: {
        name: "Composite",
        className: "FilterBlobItem",
        modelProperties: {
          name: {
            serializedName: "Name",
            required: true,
            xmlName: "Name",
            type: {
              name: "String"
            }
          },
          containerName: {
            serializedName: "ContainerName",
            required: true,
            xmlName: "ContainerName",
            type: {
              name: "String"
            }
          },
          tags: {
            serializedName: "Tags",
            xmlName: "Tags",
            type: {
              name: "Composite",
              className: "BlobTags"
            }
          }
        }
      }
    };
    exports.BlobTags = {
      serializedName: "BlobTags",
      xmlName: "Tags",
      type: {
        name: "Composite",
        className: "BlobTags",
        modelProperties: {
          blobTagSet: {
            serializedName: "BlobTagSet",
            required: true,
            xmlName: "TagSet",
            xmlIsWrapped: true,
            xmlElementName: "Tag",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "BlobTag"
                }
              }
            }
          }
        }
      }
    };
    exports.BlobTag = {
      serializedName: "BlobTag",
      xmlName: "Tag",
      type: {
        name: "Composite",
        className: "BlobTag",
        modelProperties: {
          key: {
            serializedName: "Key",
            required: true,
            xmlName: "Key",
            type: {
              name: "String"
            }
          },
          value: {
            serializedName: "Value",
            required: true,
            xmlName: "Value",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.SignedIdentifier = {
      serializedName: "SignedIdentifier",
      xmlName: "SignedIdentifier",
      type: {
        name: "Composite",
        className: "SignedIdentifier",
        modelProperties: {
          id: {
            serializedName: "Id",
            required: true,
            xmlName: "Id",
            type: {
              name: "String"
            }
          },
          accessPolicy: {
            serializedName: "AccessPolicy",
            xmlName: "AccessPolicy",
            type: {
              name: "Composite",
              className: "AccessPolicy"
            }
          }
        }
      }
    };
    exports.AccessPolicy = {
      serializedName: "AccessPolicy",
      type: {
        name: "Composite",
        className: "AccessPolicy",
        modelProperties: {
          startsOn: {
            serializedName: "Start",
            xmlName: "Start",
            type: {
              name: "String"
            }
          },
          expiresOn: {
            serializedName: "Expiry",
            xmlName: "Expiry",
            type: {
              name: "String"
            }
          },
          permissions: {
            serializedName: "Permission",
            xmlName: "Permission",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ListBlobsFlatSegmentResponse = {
      serializedName: "ListBlobsFlatSegmentResponse",
      xmlName: "EnumerationResults",
      type: {
        name: "Composite",
        className: "ListBlobsFlatSegmentResponse",
        modelProperties: {
          serviceEndpoint: {
            serializedName: "ServiceEndpoint",
            required: true,
            xmlName: "ServiceEndpoint",
            xmlIsAttribute: true,
            type: {
              name: "String"
            }
          },
          containerName: {
            serializedName: "ContainerName",
            required: true,
            xmlName: "ContainerName",
            xmlIsAttribute: true,
            type: {
              name: "String"
            }
          },
          prefix: {
            serializedName: "Prefix",
            xmlName: "Prefix",
            type: {
              name: "String"
            }
          },
          marker: {
            serializedName: "Marker",
            xmlName: "Marker",
            type: {
              name: "String"
            }
          },
          maxPageSize: {
            serializedName: "MaxResults",
            xmlName: "MaxResults",
            type: {
              name: "Number"
            }
          },
          segment: {
            serializedName: "Segment",
            xmlName: "Blobs",
            type: {
              name: "Composite",
              className: "BlobFlatListSegment"
            }
          },
          continuationToken: {
            serializedName: "NextMarker",
            xmlName: "NextMarker",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobFlatListSegment = {
      serializedName: "BlobFlatListSegment",
      xmlName: "Blobs",
      type: {
        name: "Composite",
        className: "BlobFlatListSegment",
        modelProperties: {
          blobItems: {
            serializedName: "BlobItems",
            required: true,
            xmlName: "BlobItems",
            xmlElementName: "Blob",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "BlobItemInternal"
                }
              }
            }
          }
        }
      }
    };
    exports.BlobItemInternal = {
      serializedName: "BlobItemInternal",
      xmlName: "Blob",
      type: {
        name: "Composite",
        className: "BlobItemInternal",
        modelProperties: {
          name: {
            serializedName: "Name",
            xmlName: "Name",
            type: {
              name: "Composite",
              className: "BlobName"
            }
          },
          deleted: {
            serializedName: "Deleted",
            required: true,
            xmlName: "Deleted",
            type: {
              name: "Boolean"
            }
          },
          snapshot: {
            serializedName: "Snapshot",
            required: true,
            xmlName: "Snapshot",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "VersionId",
            xmlName: "VersionId",
            type: {
              name: "String"
            }
          },
          isCurrentVersion: {
            serializedName: "IsCurrentVersion",
            xmlName: "IsCurrentVersion",
            type: {
              name: "Boolean"
            }
          },
          properties: {
            serializedName: "Properties",
            xmlName: "Properties",
            type: {
              name: "Composite",
              className: "BlobPropertiesInternal"
            }
          },
          metadata: {
            serializedName: "Metadata",
            xmlName: "Metadata",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          },
          blobTags: {
            serializedName: "BlobTags",
            xmlName: "Tags",
            type: {
              name: "Composite",
              className: "BlobTags"
            }
          },
          objectReplicationMetadata: {
            serializedName: "ObjectReplicationMetadata",
            xmlName: "OrMetadata",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          },
          hasVersionsOnly: {
            serializedName: "HasVersionsOnly",
            xmlName: "HasVersionsOnly",
            type: {
              name: "Boolean"
            }
          }
        }
      }
    };
    exports.BlobName = {
      serializedName: "BlobName",
      type: {
        name: "Composite",
        className: "BlobName",
        modelProperties: {
          encoded: {
            serializedName: "Encoded",
            xmlName: "Encoded",
            xmlIsAttribute: true,
            type: {
              name: "Boolean"
            }
          },
          content: {
            serializedName: "content",
            xmlName: "content",
            xmlIsMsText: true,
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobPropertiesInternal = {
      serializedName: "BlobPropertiesInternal",
      xmlName: "Properties",
      type: {
        name: "Composite",
        className: "BlobPropertiesInternal",
        modelProperties: {
          createdOn: {
            serializedName: "Creation-Time",
            xmlName: "Creation-Time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          lastModified: {
            serializedName: "Last-Modified",
            required: true,
            xmlName: "Last-Modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          etag: {
            serializedName: "Etag",
            required: true,
            xmlName: "Etag",
            type: {
              name: "String"
            }
          },
          contentLength: {
            serializedName: "Content-Length",
            xmlName: "Content-Length",
            type: {
              name: "Number"
            }
          },
          contentType: {
            serializedName: "Content-Type",
            xmlName: "Content-Type",
            type: {
              name: "String"
            }
          },
          contentEncoding: {
            serializedName: "Content-Encoding",
            xmlName: "Content-Encoding",
            type: {
              name: "String"
            }
          },
          contentLanguage: {
            serializedName: "Content-Language",
            xmlName: "Content-Language",
            type: {
              name: "String"
            }
          },
          contentMD5: {
            serializedName: "Content-MD5",
            xmlName: "Content-MD5",
            type: {
              name: "ByteArray"
            }
          },
          contentDisposition: {
            serializedName: "Content-Disposition",
            xmlName: "Content-Disposition",
            type: {
              name: "String"
            }
          },
          cacheControl: {
            serializedName: "Cache-Control",
            xmlName: "Cache-Control",
            type: {
              name: "String"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          blobType: {
            serializedName: "BlobType",
            xmlName: "BlobType",
            type: {
              name: "Enum",
              allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
            }
          },
          leaseStatus: {
            serializedName: "LeaseStatus",
            xmlName: "LeaseStatus",
            type: {
              name: "Enum",
              allowedValues: ["locked", "unlocked"]
            }
          },
          leaseState: {
            serializedName: "LeaseState",
            xmlName: "LeaseState",
            type: {
              name: "Enum",
              allowedValues: [
                "available",
                "leased",
                "expired",
                "breaking",
                "broken"
              ]
            }
          },
          leaseDuration: {
            serializedName: "LeaseDuration",
            xmlName: "LeaseDuration",
            type: {
              name: "Enum",
              allowedValues: ["infinite", "fixed"]
            }
          },
          copyId: {
            serializedName: "CopyId",
            xmlName: "CopyId",
            type: {
              name: "String"
            }
          },
          copyStatus: {
            serializedName: "CopyStatus",
            xmlName: "CopyStatus",
            type: {
              name: "Enum",
              allowedValues: ["pending", "success", "aborted", "failed"]
            }
          },
          copySource: {
            serializedName: "CopySource",
            xmlName: "CopySource",
            type: {
              name: "String"
            }
          },
          copyProgress: {
            serializedName: "CopyProgress",
            xmlName: "CopyProgress",
            type: {
              name: "String"
            }
          },
          copyCompletedOn: {
            serializedName: "CopyCompletionTime",
            xmlName: "CopyCompletionTime",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          copyStatusDescription: {
            serializedName: "CopyStatusDescription",
            xmlName: "CopyStatusDescription",
            type: {
              name: "String"
            }
          },
          serverEncrypted: {
            serializedName: "ServerEncrypted",
            xmlName: "ServerEncrypted",
            type: {
              name: "Boolean"
            }
          },
          incrementalCopy: {
            serializedName: "IncrementalCopy",
            xmlName: "IncrementalCopy",
            type: {
              name: "Boolean"
            }
          },
          destinationSnapshot: {
            serializedName: "DestinationSnapshot",
            xmlName: "DestinationSnapshot",
            type: {
              name: "String"
            }
          },
          deletedOn: {
            serializedName: "DeletedTime",
            xmlName: "DeletedTime",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          remainingRetentionDays: {
            serializedName: "RemainingRetentionDays",
            xmlName: "RemainingRetentionDays",
            type: {
              name: "Number"
            }
          },
          accessTier: {
            serializedName: "AccessTier",
            xmlName: "AccessTier",
            type: {
              name: "Enum",
              allowedValues: [
                "P4",
                "P6",
                "P10",
                "P15",
                "P20",
                "P30",
                "P40",
                "P50",
                "P60",
                "P70",
                "P80",
                "Hot",
                "Cool",
                "Archive",
                "Cold"
              ]
            }
          },
          accessTierInferred: {
            serializedName: "AccessTierInferred",
            xmlName: "AccessTierInferred",
            type: {
              name: "Boolean"
            }
          },
          archiveStatus: {
            serializedName: "ArchiveStatus",
            xmlName: "ArchiveStatus",
            type: {
              name: "Enum",
              allowedValues: [
                "rehydrate-pending-to-hot",
                "rehydrate-pending-to-cool",
                "rehydrate-pending-to-cold"
              ]
            }
          },
          customerProvidedKeySha256: {
            serializedName: "CustomerProvidedKeySha256",
            xmlName: "CustomerProvidedKeySha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "EncryptionScope",
            xmlName: "EncryptionScope",
            type: {
              name: "String"
            }
          },
          accessTierChangedOn: {
            serializedName: "AccessTierChangeTime",
            xmlName: "AccessTierChangeTime",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          tagCount: {
            serializedName: "TagCount",
            xmlName: "TagCount",
            type: {
              name: "Number"
            }
          },
          expiresOn: {
            serializedName: "Expiry-Time",
            xmlName: "Expiry-Time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isSealed: {
            serializedName: "Sealed",
            xmlName: "Sealed",
            type: {
              name: "Boolean"
            }
          },
          rehydratePriority: {
            serializedName: "RehydratePriority",
            xmlName: "RehydratePriority",
            type: {
              name: "Enum",
              allowedValues: ["High", "Standard"]
            }
          },
          lastAccessedOn: {
            serializedName: "LastAccessTime",
            xmlName: "LastAccessTime",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          immutabilityPolicyExpiresOn: {
            serializedName: "ImmutabilityPolicyUntilDate",
            xmlName: "ImmutabilityPolicyUntilDate",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          immutabilityPolicyMode: {
            serializedName: "ImmutabilityPolicyMode",
            xmlName: "ImmutabilityPolicyMode",
            type: {
              name: "Enum",
              allowedValues: ["Mutable", "Unlocked", "Locked"]
            }
          },
          legalHold: {
            serializedName: "LegalHold",
            xmlName: "LegalHold",
            type: {
              name: "Boolean"
            }
          }
        }
      }
    };
    exports.ListBlobsHierarchySegmentResponse = {
      serializedName: "ListBlobsHierarchySegmentResponse",
      xmlName: "EnumerationResults",
      type: {
        name: "Composite",
        className: "ListBlobsHierarchySegmentResponse",
        modelProperties: {
          serviceEndpoint: {
            serializedName: "ServiceEndpoint",
            required: true,
            xmlName: "ServiceEndpoint",
            xmlIsAttribute: true,
            type: {
              name: "String"
            }
          },
          containerName: {
            serializedName: "ContainerName",
            required: true,
            xmlName: "ContainerName",
            xmlIsAttribute: true,
            type: {
              name: "String"
            }
          },
          prefix: {
            serializedName: "Prefix",
            xmlName: "Prefix",
            type: {
              name: "String"
            }
          },
          marker: {
            serializedName: "Marker",
            xmlName: "Marker",
            type: {
              name: "String"
            }
          },
          maxPageSize: {
            serializedName: "MaxResults",
            xmlName: "MaxResults",
            type: {
              name: "Number"
            }
          },
          delimiter: {
            serializedName: "Delimiter",
            xmlName: "Delimiter",
            type: {
              name: "String"
            }
          },
          segment: {
            serializedName: "Segment",
            xmlName: "Blobs",
            type: {
              name: "Composite",
              className: "BlobHierarchyListSegment"
            }
          },
          continuationToken: {
            serializedName: "NextMarker",
            xmlName: "NextMarker",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobHierarchyListSegment = {
      serializedName: "BlobHierarchyListSegment",
      xmlName: "Blobs",
      type: {
        name: "Composite",
        className: "BlobHierarchyListSegment",
        modelProperties: {
          blobPrefixes: {
            serializedName: "BlobPrefixes",
            xmlName: "BlobPrefixes",
            xmlElementName: "BlobPrefix",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "BlobPrefix"
                }
              }
            }
          },
          blobItems: {
            serializedName: "BlobItems",
            required: true,
            xmlName: "BlobItems",
            xmlElementName: "Blob",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "BlobItemInternal"
                }
              }
            }
          }
        }
      }
    };
    exports.BlobPrefix = {
      serializedName: "BlobPrefix",
      type: {
        name: "Composite",
        className: "BlobPrefix",
        modelProperties: {
          name: {
            serializedName: "Name",
            xmlName: "Name",
            type: {
              name: "Composite",
              className: "BlobName"
            }
          }
        }
      }
    };
    exports.BlockLookupList = {
      serializedName: "BlockLookupList",
      xmlName: "BlockList",
      type: {
        name: "Composite",
        className: "BlockLookupList",
        modelProperties: {
          committed: {
            serializedName: "Committed",
            xmlName: "Committed",
            xmlElementName: "Committed",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "String"
                }
              }
            }
          },
          uncommitted: {
            serializedName: "Uncommitted",
            xmlName: "Uncommitted",
            xmlElementName: "Uncommitted",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "String"
                }
              }
            }
          },
          latest: {
            serializedName: "Latest",
            xmlName: "Latest",
            xmlElementName: "Latest",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "String"
                }
              }
            }
          }
        }
      }
    };
    exports.BlockList = {
      serializedName: "BlockList",
      type: {
        name: "Composite",
        className: "BlockList",
        modelProperties: {
          committedBlocks: {
            serializedName: "CommittedBlocks",
            xmlName: "CommittedBlocks",
            xmlIsWrapped: true,
            xmlElementName: "Block",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "Block"
                }
              }
            }
          },
          uncommittedBlocks: {
            serializedName: "UncommittedBlocks",
            xmlName: "UncommittedBlocks",
            xmlIsWrapped: true,
            xmlElementName: "Block",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "Block"
                }
              }
            }
          }
        }
      }
    };
    exports.Block = {
      serializedName: "Block",
      type: {
        name: "Composite",
        className: "Block",
        modelProperties: {
          name: {
            serializedName: "Name",
            required: true,
            xmlName: "Name",
            type: {
              name: "String"
            }
          },
          size: {
            serializedName: "Size",
            required: true,
            xmlName: "Size",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.PageList = {
      serializedName: "PageList",
      type: {
        name: "Composite",
        className: "PageList",
        modelProperties: {
          pageRange: {
            serializedName: "PageRange",
            xmlName: "PageRange",
            xmlElementName: "PageRange",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "PageRange"
                }
              }
            }
          },
          clearRange: {
            serializedName: "ClearRange",
            xmlName: "ClearRange",
            xmlElementName: "ClearRange",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ClearRange"
                }
              }
            }
          },
          continuationToken: {
            serializedName: "NextMarker",
            xmlName: "NextMarker",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageRange = {
      serializedName: "PageRange",
      xmlName: "PageRange",
      type: {
        name: "Composite",
        className: "PageRange",
        modelProperties: {
          start: {
            serializedName: "Start",
            required: true,
            xmlName: "Start",
            type: {
              name: "Number"
            }
          },
          end: {
            serializedName: "End",
            required: true,
            xmlName: "End",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.ClearRange = {
      serializedName: "ClearRange",
      xmlName: "ClearRange",
      type: {
        name: "Composite",
        className: "ClearRange",
        modelProperties: {
          start: {
            serializedName: "Start",
            required: true,
            xmlName: "Start",
            type: {
              name: "Number"
            }
          },
          end: {
            serializedName: "End",
            required: true,
            xmlName: "End",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.QueryRequest = {
      serializedName: "QueryRequest",
      xmlName: "QueryRequest",
      type: {
        name: "Composite",
        className: "QueryRequest",
        modelProperties: {
          queryType: {
            serializedName: "QueryType",
            required: true,
            xmlName: "QueryType",
            type: {
              name: "String"
            }
          },
          expression: {
            serializedName: "Expression",
            required: true,
            xmlName: "Expression",
            type: {
              name: "String"
            }
          },
          inputSerialization: {
            serializedName: "InputSerialization",
            xmlName: "InputSerialization",
            type: {
              name: "Composite",
              className: "QuerySerialization"
            }
          },
          outputSerialization: {
            serializedName: "OutputSerialization",
            xmlName: "OutputSerialization",
            type: {
              name: "Composite",
              className: "QuerySerialization"
            }
          }
        }
      }
    };
    exports.QuerySerialization = {
      serializedName: "QuerySerialization",
      type: {
        name: "Composite",
        className: "QuerySerialization",
        modelProperties: {
          format: {
            serializedName: "Format",
            xmlName: "Format",
            type: {
              name: "Composite",
              className: "QueryFormat"
            }
          }
        }
      }
    };
    exports.QueryFormat = {
      serializedName: "QueryFormat",
      type: {
        name: "Composite",
        className: "QueryFormat",
        modelProperties: {
          type: {
            serializedName: "Type",
            required: true,
            xmlName: "Type",
            type: {
              name: "Enum",
              allowedValues: ["delimited", "json", "arrow", "parquet"]
            }
          },
          delimitedTextConfiguration: {
            serializedName: "DelimitedTextConfiguration",
            xmlName: "DelimitedTextConfiguration",
            type: {
              name: "Composite",
              className: "DelimitedTextConfiguration"
            }
          },
          jsonTextConfiguration: {
            serializedName: "JsonTextConfiguration",
            xmlName: "JsonTextConfiguration",
            type: {
              name: "Composite",
              className: "JsonTextConfiguration"
            }
          },
          arrowConfiguration: {
            serializedName: "ArrowConfiguration",
            xmlName: "ArrowConfiguration",
            type: {
              name: "Composite",
              className: "ArrowConfiguration"
            }
          },
          parquetTextConfiguration: {
            serializedName: "ParquetTextConfiguration",
            xmlName: "ParquetTextConfiguration",
            type: {
              name: "Dictionary",
              value: { type: { name: "any" } }
            }
          }
        }
      }
    };
    exports.DelimitedTextConfiguration = {
      serializedName: "DelimitedTextConfiguration",
      xmlName: "DelimitedTextConfiguration",
      type: {
        name: "Composite",
        className: "DelimitedTextConfiguration",
        modelProperties: {
          columnSeparator: {
            serializedName: "ColumnSeparator",
            xmlName: "ColumnSeparator",
            type: {
              name: "String"
            }
          },
          fieldQuote: {
            serializedName: "FieldQuote",
            xmlName: "FieldQuote",
            type: {
              name: "String"
            }
          },
          recordSeparator: {
            serializedName: "RecordSeparator",
            xmlName: "RecordSeparator",
            type: {
              name: "String"
            }
          },
          escapeChar: {
            serializedName: "EscapeChar",
            xmlName: "EscapeChar",
            type: {
              name: "String"
            }
          },
          headersPresent: {
            serializedName: "HeadersPresent",
            xmlName: "HasHeaders",
            type: {
              name: "Boolean"
            }
          }
        }
      }
    };
    exports.JsonTextConfiguration = {
      serializedName: "JsonTextConfiguration",
      xmlName: "JsonTextConfiguration",
      type: {
        name: "Composite",
        className: "JsonTextConfiguration",
        modelProperties: {
          recordSeparator: {
            serializedName: "RecordSeparator",
            xmlName: "RecordSeparator",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ArrowConfiguration = {
      serializedName: "ArrowConfiguration",
      xmlName: "ArrowConfiguration",
      type: {
        name: "Composite",
        className: "ArrowConfiguration",
        modelProperties: {
          schema: {
            serializedName: "Schema",
            required: true,
            xmlName: "Schema",
            xmlIsWrapped: true,
            xmlElementName: "Field",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ArrowField"
                }
              }
            }
          }
        }
      }
    };
    exports.ArrowField = {
      serializedName: "ArrowField",
      xmlName: "Field",
      type: {
        name: "Composite",
        className: "ArrowField",
        modelProperties: {
          type: {
            serializedName: "Type",
            required: true,
            xmlName: "Type",
            type: {
              name: "String"
            }
          },
          name: {
            serializedName: "Name",
            xmlName: "Name",
            type: {
              name: "String"
            }
          },
          precision: {
            serializedName: "Precision",
            xmlName: "Precision",
            type: {
              name: "Number"
            }
          },
          scale: {
            serializedName: "Scale",
            xmlName: "Scale",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.ServiceSetPropertiesHeaders = {
      serializedName: "Service_setPropertiesHeaders",
      type: {
        name: "Composite",
        className: "ServiceSetPropertiesHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceSetPropertiesExceptionHeaders = {
      serializedName: "Service_setPropertiesExceptionHeaders",
      type: {
        name: "Composite",
        className: "ServiceSetPropertiesExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceGetPropertiesHeaders = {
      serializedName: "Service_getPropertiesHeaders",
      type: {
        name: "Composite",
        className: "ServiceGetPropertiesHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceGetPropertiesExceptionHeaders = {
      serializedName: "Service_getPropertiesExceptionHeaders",
      type: {
        name: "Composite",
        className: "ServiceGetPropertiesExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceGetStatisticsHeaders = {
      serializedName: "Service_getStatisticsHeaders",
      type: {
        name: "Composite",
        className: "ServiceGetStatisticsHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceGetStatisticsExceptionHeaders = {
      serializedName: "Service_getStatisticsExceptionHeaders",
      type: {
        name: "Composite",
        className: "ServiceGetStatisticsExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceListContainersSegmentHeaders = {
      serializedName: "Service_listContainersSegmentHeaders",
      type: {
        name: "Composite",
        className: "ServiceListContainersSegmentHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceListContainersSegmentExceptionHeaders = {
      serializedName: "Service_listContainersSegmentExceptionHeaders",
      type: {
        name: "Composite",
        className: "ServiceListContainersSegmentExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceGetUserDelegationKeyHeaders = {
      serializedName: "Service_getUserDelegationKeyHeaders",
      type: {
        name: "Composite",
        className: "ServiceGetUserDelegationKeyHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceGetUserDelegationKeyExceptionHeaders = {
      serializedName: "Service_getUserDelegationKeyExceptionHeaders",
      type: {
        name: "Composite",
        className: "ServiceGetUserDelegationKeyExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceGetAccountInfoHeaders = {
      serializedName: "Service_getAccountInfoHeaders",
      type: {
        name: "Composite",
        className: "ServiceGetAccountInfoHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          skuName: {
            serializedName: "x-ms-sku-name",
            xmlName: "x-ms-sku-name",
            type: {
              name: "Enum",
              allowedValues: [
                "Standard_LRS",
                "Standard_GRS",
                "Standard_RAGRS",
                "Standard_ZRS",
                "Premium_LRS"
              ]
            }
          },
          accountKind: {
            serializedName: "x-ms-account-kind",
            xmlName: "x-ms-account-kind",
            type: {
              name: "Enum",
              allowedValues: [
                "Storage",
                "BlobStorage",
                "StorageV2",
                "FileStorage",
                "BlockBlobStorage"
              ]
            }
          },
          isHierarchicalNamespaceEnabled: {
            serializedName: "x-ms-is-hns-enabled",
            xmlName: "x-ms-is-hns-enabled",
            type: {
              name: "Boolean"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceGetAccountInfoExceptionHeaders = {
      serializedName: "Service_getAccountInfoExceptionHeaders",
      type: {
        name: "Composite",
        className: "ServiceGetAccountInfoExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceSubmitBatchHeaders = {
      serializedName: "Service_submitBatchHeaders",
      type: {
        name: "Composite",
        className: "ServiceSubmitBatchHeaders",
        modelProperties: {
          contentType: {
            serializedName: "content-type",
            xmlName: "content-type",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceSubmitBatchExceptionHeaders = {
      serializedName: "Service_submitBatchExceptionHeaders",
      type: {
        name: "Composite",
        className: "ServiceSubmitBatchExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceFilterBlobsHeaders = {
      serializedName: "Service_filterBlobsHeaders",
      type: {
        name: "Composite",
        className: "ServiceFilterBlobsHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ServiceFilterBlobsExceptionHeaders = {
      serializedName: "Service_filterBlobsExceptionHeaders",
      type: {
        name: "Composite",
        className: "ServiceFilterBlobsExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerCreateHeaders = {
      serializedName: "Container_createHeaders",
      type: {
        name: "Composite",
        className: "ContainerCreateHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerCreateExceptionHeaders = {
      serializedName: "Container_createExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerCreateExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerGetPropertiesHeaders = {
      serializedName: "Container_getPropertiesHeaders",
      type: {
        name: "Composite",
        className: "ContainerGetPropertiesHeaders",
        modelProperties: {
          metadata: {
            serializedName: "x-ms-meta",
            headerCollectionPrefix: "x-ms-meta-",
            xmlName: "x-ms-meta",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          },
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          leaseDuration: {
            serializedName: "x-ms-lease-duration",
            xmlName: "x-ms-lease-duration",
            type: {
              name: "Enum",
              allowedValues: ["infinite", "fixed"]
            }
          },
          leaseState: {
            serializedName: "x-ms-lease-state",
            xmlName: "x-ms-lease-state",
            type: {
              name: "Enum",
              allowedValues: [
                "available",
                "leased",
                "expired",
                "breaking",
                "broken"
              ]
            }
          },
          leaseStatus: {
            serializedName: "x-ms-lease-status",
            xmlName: "x-ms-lease-status",
            type: {
              name: "Enum",
              allowedValues: ["locked", "unlocked"]
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          blobPublicAccess: {
            serializedName: "x-ms-blob-public-access",
            xmlName: "x-ms-blob-public-access",
            type: {
              name: "Enum",
              allowedValues: ["container", "blob"]
            }
          },
          hasImmutabilityPolicy: {
            serializedName: "x-ms-has-immutability-policy",
            xmlName: "x-ms-has-immutability-policy",
            type: {
              name: "Boolean"
            }
          },
          hasLegalHold: {
            serializedName: "x-ms-has-legal-hold",
            xmlName: "x-ms-has-legal-hold",
            type: {
              name: "Boolean"
            }
          },
          defaultEncryptionScope: {
            serializedName: "x-ms-default-encryption-scope",
            xmlName: "x-ms-default-encryption-scope",
            type: {
              name: "String"
            }
          },
          denyEncryptionScopeOverride: {
            serializedName: "x-ms-deny-encryption-scope-override",
            xmlName: "x-ms-deny-encryption-scope-override",
            type: {
              name: "Boolean"
            }
          },
          isImmutableStorageWithVersioningEnabled: {
            serializedName: "x-ms-immutable-storage-with-versioning-enabled",
            xmlName: "x-ms-immutable-storage-with-versioning-enabled",
            type: {
              name: "Boolean"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerGetPropertiesExceptionHeaders = {
      serializedName: "Container_getPropertiesExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerGetPropertiesExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerDeleteHeaders = {
      serializedName: "Container_deleteHeaders",
      type: {
        name: "Composite",
        className: "ContainerDeleteHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerDeleteExceptionHeaders = {
      serializedName: "Container_deleteExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerDeleteExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerSetMetadataHeaders = {
      serializedName: "Container_setMetadataHeaders",
      type: {
        name: "Composite",
        className: "ContainerSetMetadataHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerSetMetadataExceptionHeaders = {
      serializedName: "Container_setMetadataExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerSetMetadataExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerGetAccessPolicyHeaders = {
      serializedName: "Container_getAccessPolicyHeaders",
      type: {
        name: "Composite",
        className: "ContainerGetAccessPolicyHeaders",
        modelProperties: {
          blobPublicAccess: {
            serializedName: "x-ms-blob-public-access",
            xmlName: "x-ms-blob-public-access",
            type: {
              name: "Enum",
              allowedValues: ["container", "blob"]
            }
          },
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerGetAccessPolicyExceptionHeaders = {
      serializedName: "Container_getAccessPolicyExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerGetAccessPolicyExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerSetAccessPolicyHeaders = {
      serializedName: "Container_setAccessPolicyHeaders",
      type: {
        name: "Composite",
        className: "ContainerSetAccessPolicyHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerSetAccessPolicyExceptionHeaders = {
      serializedName: "Container_setAccessPolicyExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerSetAccessPolicyExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerRestoreHeaders = {
      serializedName: "Container_restoreHeaders",
      type: {
        name: "Composite",
        className: "ContainerRestoreHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerRestoreExceptionHeaders = {
      serializedName: "Container_restoreExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerRestoreExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerRenameHeaders = {
      serializedName: "Container_renameHeaders",
      type: {
        name: "Composite",
        className: "ContainerRenameHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerRenameExceptionHeaders = {
      serializedName: "Container_renameExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerRenameExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerSubmitBatchHeaders = {
      serializedName: "Container_submitBatchHeaders",
      type: {
        name: "Composite",
        className: "ContainerSubmitBatchHeaders",
        modelProperties: {
          contentType: {
            serializedName: "content-type",
            xmlName: "content-type",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerSubmitBatchExceptionHeaders = {
      serializedName: "Container_submitBatchExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerSubmitBatchExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerFilterBlobsHeaders = {
      serializedName: "Container_filterBlobsHeaders",
      type: {
        name: "Composite",
        className: "ContainerFilterBlobsHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.ContainerFilterBlobsExceptionHeaders = {
      serializedName: "Container_filterBlobsExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerFilterBlobsExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerAcquireLeaseHeaders = {
      serializedName: "Container_acquireLeaseHeaders",
      type: {
        name: "Composite",
        className: "ContainerAcquireLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          leaseId: {
            serializedName: "x-ms-lease-id",
            xmlName: "x-ms-lease-id",
            type: {
              name: "String"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.ContainerAcquireLeaseExceptionHeaders = {
      serializedName: "Container_acquireLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerAcquireLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerReleaseLeaseHeaders = {
      serializedName: "Container_releaseLeaseHeaders",
      type: {
        name: "Composite",
        className: "ContainerReleaseLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.ContainerReleaseLeaseExceptionHeaders = {
      serializedName: "Container_releaseLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerReleaseLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerRenewLeaseHeaders = {
      serializedName: "Container_renewLeaseHeaders",
      type: {
        name: "Composite",
        className: "ContainerRenewLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          leaseId: {
            serializedName: "x-ms-lease-id",
            xmlName: "x-ms-lease-id",
            type: {
              name: "String"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.ContainerRenewLeaseExceptionHeaders = {
      serializedName: "Container_renewLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerRenewLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerBreakLeaseHeaders = {
      serializedName: "Container_breakLeaseHeaders",
      type: {
        name: "Composite",
        className: "ContainerBreakLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          leaseTime: {
            serializedName: "x-ms-lease-time",
            xmlName: "x-ms-lease-time",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.ContainerBreakLeaseExceptionHeaders = {
      serializedName: "Container_breakLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerBreakLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerChangeLeaseHeaders = {
      serializedName: "Container_changeLeaseHeaders",
      type: {
        name: "Composite",
        className: "ContainerChangeLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          leaseId: {
            serializedName: "x-ms-lease-id",
            xmlName: "x-ms-lease-id",
            type: {
              name: "String"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.ContainerChangeLeaseExceptionHeaders = {
      serializedName: "Container_changeLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerChangeLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerListBlobFlatSegmentHeaders = {
      serializedName: "Container_listBlobFlatSegmentHeaders",
      type: {
        name: "Composite",
        className: "ContainerListBlobFlatSegmentHeaders",
        modelProperties: {
          contentType: {
            serializedName: "content-type",
            xmlName: "content-type",
            type: {
              name: "String"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerListBlobFlatSegmentExceptionHeaders = {
      serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerListBlobFlatSegmentExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerListBlobHierarchySegmentHeaders = {
      serializedName: "Container_listBlobHierarchySegmentHeaders",
      type: {
        name: "Composite",
        className: "ContainerListBlobHierarchySegmentHeaders",
        modelProperties: {
          contentType: {
            serializedName: "content-type",
            xmlName: "content-type",
            type: {
              name: "String"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerListBlobHierarchySegmentExceptionHeaders = {
      serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerListBlobHierarchySegmentExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.ContainerGetAccountInfoHeaders = {
      serializedName: "Container_getAccountInfoHeaders",
      type: {
        name: "Composite",
        className: "ContainerGetAccountInfoHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          skuName: {
            serializedName: "x-ms-sku-name",
            xmlName: "x-ms-sku-name",
            type: {
              name: "Enum",
              allowedValues: [
                "Standard_LRS",
                "Standard_GRS",
                "Standard_RAGRS",
                "Standard_ZRS",
                "Premium_LRS"
              ]
            }
          },
          accountKind: {
            serializedName: "x-ms-account-kind",
            xmlName: "x-ms-account-kind",
            type: {
              name: "Enum",
              allowedValues: [
                "Storage",
                "BlobStorage",
                "StorageV2",
                "FileStorage",
                "BlockBlobStorage"
              ]
            }
          },
          isHierarchicalNamespaceEnabled: {
            serializedName: "x-ms-is-hns-enabled",
            xmlName: "x-ms-is-hns-enabled",
            type: {
              name: "Boolean"
            }
          }
        }
      }
    };
    exports.ContainerGetAccountInfoExceptionHeaders = {
      serializedName: "Container_getAccountInfoExceptionHeaders",
      type: {
        name: "Composite",
        className: "ContainerGetAccountInfoExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobDownloadHeaders = {
      serializedName: "Blob_downloadHeaders",
      type: {
        name: "Composite",
        className: "BlobDownloadHeaders",
        modelProperties: {
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          createdOn: {
            serializedName: "x-ms-creation-time",
            xmlName: "x-ms-creation-time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          metadata: {
            serializedName: "x-ms-meta",
            headerCollectionPrefix: "x-ms-meta-",
            xmlName: "x-ms-meta",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          },
          objectReplicationPolicyId: {
            serializedName: "x-ms-or-policy-id",
            xmlName: "x-ms-or-policy-id",
            type: {
              name: "String"
            }
          },
          objectReplicationRules: {
            serializedName: "x-ms-or",
            headerCollectionPrefix: "x-ms-or-",
            xmlName: "x-ms-or",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          },
          contentLength: {
            serializedName: "content-length",
            xmlName: "content-length",
            type: {
              name: "Number"
            }
          },
          contentType: {
            serializedName: "content-type",
            xmlName: "content-type",
            type: {
              name: "String"
            }
          },
          contentRange: {
            serializedName: "content-range",
            xmlName: "content-range",
            type: {
              name: "String"
            }
          },
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          contentEncoding: {
            serializedName: "content-encoding",
            xmlName: "content-encoding",
            type: {
              name: "String"
            }
          },
          cacheControl: {
            serializedName: "cache-control",
            xmlName: "cache-control",
            type: {
              name: "String"
            }
          },
          contentDisposition: {
            serializedName: "content-disposition",
            xmlName: "content-disposition",
            type: {
              name: "String"
            }
          },
          contentLanguage: {
            serializedName: "content-language",
            xmlName: "content-language",
            type: {
              name: "String"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          blobType: {
            serializedName: "x-ms-blob-type",
            xmlName: "x-ms-blob-type",
            type: {
              name: "Enum",
              allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
            }
          },
          copyCompletedOn: {
            serializedName: "x-ms-copy-completion-time",
            xmlName: "x-ms-copy-completion-time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          copyStatusDescription: {
            serializedName: "x-ms-copy-status-description",
            xmlName: "x-ms-copy-status-description",
            type: {
              name: "String"
            }
          },
          copyId: {
            serializedName: "x-ms-copy-id",
            xmlName: "x-ms-copy-id",
            type: {
              name: "String"
            }
          },
          copyProgress: {
            serializedName: "x-ms-copy-progress",
            xmlName: "x-ms-copy-progress",
            type: {
              name: "String"
            }
          },
          copySource: {
            serializedName: "x-ms-copy-source",
            xmlName: "x-ms-copy-source",
            type: {
              name: "String"
            }
          },
          copyStatus: {
            serializedName: "x-ms-copy-status",
            xmlName: "x-ms-copy-status",
            type: {
              name: "Enum",
              allowedValues: ["pending", "success", "aborted", "failed"]
            }
          },
          leaseDuration: {
            serializedName: "x-ms-lease-duration",
            xmlName: "x-ms-lease-duration",
            type: {
              name: "Enum",
              allowedValues: ["infinite", "fixed"]
            }
          },
          leaseState: {
            serializedName: "x-ms-lease-state",
            xmlName: "x-ms-lease-state",
            type: {
              name: "Enum",
              allowedValues: [
                "available",
                "leased",
                "expired",
                "breaking",
                "broken"
              ]
            }
          },
          leaseStatus: {
            serializedName: "x-ms-lease-status",
            xmlName: "x-ms-lease-status",
            type: {
              name: "Enum",
              allowedValues: ["locked", "unlocked"]
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          isCurrentVersion: {
            serializedName: "x-ms-is-current-version",
            xmlName: "x-ms-is-current-version",
            type: {
              name: "Boolean"
            }
          },
          acceptRanges: {
            serializedName: "accept-ranges",
            xmlName: "accept-ranges",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          blobCommittedBlockCount: {
            serializedName: "x-ms-blob-committed-block-count",
            xmlName: "x-ms-blob-committed-block-count",
            type: {
              name: "Number"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-server-encrypted",
            xmlName: "x-ms-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          blobContentMD5: {
            serializedName: "x-ms-blob-content-md5",
            xmlName: "x-ms-blob-content-md5",
            type: {
              name: "ByteArray"
            }
          },
          tagCount: {
            serializedName: "x-ms-tag-count",
            xmlName: "x-ms-tag-count",
            type: {
              name: "Number"
            }
          },
          isSealed: {
            serializedName: "x-ms-blob-sealed",
            xmlName: "x-ms-blob-sealed",
            type: {
              name: "Boolean"
            }
          },
          lastAccessed: {
            serializedName: "x-ms-last-access-time",
            xmlName: "x-ms-last-access-time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          immutabilityPolicyExpiresOn: {
            serializedName: "x-ms-immutability-policy-until-date",
            xmlName: "x-ms-immutability-policy-until-date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          immutabilityPolicyMode: {
            serializedName: "x-ms-immutability-policy-mode",
            xmlName: "x-ms-immutability-policy-mode",
            type: {
              name: "Enum",
              allowedValues: ["Mutable", "Unlocked", "Locked"]
            }
          },
          legalHold: {
            serializedName: "x-ms-legal-hold",
            xmlName: "x-ms-legal-hold",
            type: {
              name: "Boolean"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          },
          contentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          }
        }
      }
    };
    exports.BlobDownloadExceptionHeaders = {
      serializedName: "Blob_downloadExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobDownloadExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobGetPropertiesHeaders = {
      serializedName: "Blob_getPropertiesHeaders",
      type: {
        name: "Composite",
        className: "BlobGetPropertiesHeaders",
        modelProperties: {
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          createdOn: {
            serializedName: "x-ms-creation-time",
            xmlName: "x-ms-creation-time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          metadata: {
            serializedName: "x-ms-meta",
            headerCollectionPrefix: "x-ms-meta-",
            xmlName: "x-ms-meta",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          },
          objectReplicationPolicyId: {
            serializedName: "x-ms-or-policy-id",
            xmlName: "x-ms-or-policy-id",
            type: {
              name: "String"
            }
          },
          objectReplicationRules: {
            serializedName: "x-ms-or",
            headerCollectionPrefix: "x-ms-or-",
            xmlName: "x-ms-or",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          },
          blobType: {
            serializedName: "x-ms-blob-type",
            xmlName: "x-ms-blob-type",
            type: {
              name: "Enum",
              allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
            }
          },
          copyCompletedOn: {
            serializedName: "x-ms-copy-completion-time",
            xmlName: "x-ms-copy-completion-time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          copyStatusDescription: {
            serializedName: "x-ms-copy-status-description",
            xmlName: "x-ms-copy-status-description",
            type: {
              name: "String"
            }
          },
          copyId: {
            serializedName: "x-ms-copy-id",
            xmlName: "x-ms-copy-id",
            type: {
              name: "String"
            }
          },
          copyProgress: {
            serializedName: "x-ms-copy-progress",
            xmlName: "x-ms-copy-progress",
            type: {
              name: "String"
            }
          },
          copySource: {
            serializedName: "x-ms-copy-source",
            xmlName: "x-ms-copy-source",
            type: {
              name: "String"
            }
          },
          copyStatus: {
            serializedName: "x-ms-copy-status",
            xmlName: "x-ms-copy-status",
            type: {
              name: "Enum",
              allowedValues: ["pending", "success", "aborted", "failed"]
            }
          },
          isIncrementalCopy: {
            serializedName: "x-ms-incremental-copy",
            xmlName: "x-ms-incremental-copy",
            type: {
              name: "Boolean"
            }
          },
          destinationSnapshot: {
            serializedName: "x-ms-copy-destination-snapshot",
            xmlName: "x-ms-copy-destination-snapshot",
            type: {
              name: "String"
            }
          },
          leaseDuration: {
            serializedName: "x-ms-lease-duration",
            xmlName: "x-ms-lease-duration",
            type: {
              name: "Enum",
              allowedValues: ["infinite", "fixed"]
            }
          },
          leaseState: {
            serializedName: "x-ms-lease-state",
            xmlName: "x-ms-lease-state",
            type: {
              name: "Enum",
              allowedValues: [
                "available",
                "leased",
                "expired",
                "breaking",
                "broken"
              ]
            }
          },
          leaseStatus: {
            serializedName: "x-ms-lease-status",
            xmlName: "x-ms-lease-status",
            type: {
              name: "Enum",
              allowedValues: ["locked", "unlocked"]
            }
          },
          contentLength: {
            serializedName: "content-length",
            xmlName: "content-length",
            type: {
              name: "Number"
            }
          },
          contentType: {
            serializedName: "content-type",
            xmlName: "content-type",
            type: {
              name: "String"
            }
          },
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          contentEncoding: {
            serializedName: "content-encoding",
            xmlName: "content-encoding",
            type: {
              name: "String"
            }
          },
          contentDisposition: {
            serializedName: "content-disposition",
            xmlName: "content-disposition",
            type: {
              name: "String"
            }
          },
          contentLanguage: {
            serializedName: "content-language",
            xmlName: "content-language",
            type: {
              name: "String"
            }
          },
          cacheControl: {
            serializedName: "cache-control",
            xmlName: "cache-control",
            type: {
              name: "String"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          acceptRanges: {
            serializedName: "accept-ranges",
            xmlName: "accept-ranges",
            type: {
              name: "String"
            }
          },
          blobCommittedBlockCount: {
            serializedName: "x-ms-blob-committed-block-count",
            xmlName: "x-ms-blob-committed-block-count",
            type: {
              name: "Number"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-server-encrypted",
            xmlName: "x-ms-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          accessTier: {
            serializedName: "x-ms-access-tier",
            xmlName: "x-ms-access-tier",
            type: {
              name: "String"
            }
          },
          accessTierInferred: {
            serializedName: "x-ms-access-tier-inferred",
            xmlName: "x-ms-access-tier-inferred",
            type: {
              name: "Boolean"
            }
          },
          archiveStatus: {
            serializedName: "x-ms-archive-status",
            xmlName: "x-ms-archive-status",
            type: {
              name: "String"
            }
          },
          accessTierChangedOn: {
            serializedName: "x-ms-access-tier-change-time",
            xmlName: "x-ms-access-tier-change-time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          isCurrentVersion: {
            serializedName: "x-ms-is-current-version",
            xmlName: "x-ms-is-current-version",
            type: {
              name: "Boolean"
            }
          },
          tagCount: {
            serializedName: "x-ms-tag-count",
            xmlName: "x-ms-tag-count",
            type: {
              name: "Number"
            }
          },
          expiresOn: {
            serializedName: "x-ms-expiry-time",
            xmlName: "x-ms-expiry-time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isSealed: {
            serializedName: "x-ms-blob-sealed",
            xmlName: "x-ms-blob-sealed",
            type: {
              name: "Boolean"
            }
          },
          rehydratePriority: {
            serializedName: "x-ms-rehydrate-priority",
            xmlName: "x-ms-rehydrate-priority",
            type: {
              name: "Enum",
              allowedValues: ["High", "Standard"]
            }
          },
          lastAccessed: {
            serializedName: "x-ms-last-access-time",
            xmlName: "x-ms-last-access-time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          immutabilityPolicyExpiresOn: {
            serializedName: "x-ms-immutability-policy-until-date",
            xmlName: "x-ms-immutability-policy-until-date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          immutabilityPolicyMode: {
            serializedName: "x-ms-immutability-policy-mode",
            xmlName: "x-ms-immutability-policy-mode",
            type: {
              name: "Enum",
              allowedValues: ["Mutable", "Unlocked", "Locked"]
            }
          },
          legalHold: {
            serializedName: "x-ms-legal-hold",
            xmlName: "x-ms-legal-hold",
            type: {
              name: "Boolean"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobGetPropertiesExceptionHeaders = {
      serializedName: "Blob_getPropertiesExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobGetPropertiesExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobDeleteHeaders = {
      serializedName: "Blob_deleteHeaders",
      type: {
        name: "Composite",
        className: "BlobDeleteHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobDeleteExceptionHeaders = {
      serializedName: "Blob_deleteExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobDeleteExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobUndeleteHeaders = {
      serializedName: "Blob_undeleteHeaders",
      type: {
        name: "Composite",
        className: "BlobUndeleteHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobUndeleteExceptionHeaders = {
      serializedName: "Blob_undeleteExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobUndeleteExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetExpiryHeaders = {
      serializedName: "Blob_setExpiryHeaders",
      type: {
        name: "Composite",
        className: "BlobSetExpiryHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.BlobSetExpiryExceptionHeaders = {
      serializedName: "Blob_setExpiryExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobSetExpiryExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetHttpHeadersHeaders = {
      serializedName: "Blob_setHttpHeadersHeaders",
      type: {
        name: "Composite",
        className: "BlobSetHttpHeadersHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetHttpHeadersExceptionHeaders = {
      serializedName: "Blob_setHttpHeadersExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobSetHttpHeadersExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetImmutabilityPolicyHeaders = {
      serializedName: "Blob_setImmutabilityPolicyHeaders",
      type: {
        name: "Composite",
        className: "BlobSetImmutabilityPolicyHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          immutabilityPolicyExpiry: {
            serializedName: "x-ms-immutability-policy-until-date",
            xmlName: "x-ms-immutability-policy-until-date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          immutabilityPolicyMode: {
            serializedName: "x-ms-immutability-policy-mode",
            xmlName: "x-ms-immutability-policy-mode",
            type: {
              name: "Enum",
              allowedValues: ["Mutable", "Unlocked", "Locked"]
            }
          }
        }
      }
    };
    exports.BlobSetImmutabilityPolicyExceptionHeaders = {
      serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobSetImmutabilityPolicyExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobDeleteImmutabilityPolicyHeaders = {
      serializedName: "Blob_deleteImmutabilityPolicyHeaders",
      type: {
        name: "Composite",
        className: "BlobDeleteImmutabilityPolicyHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.BlobDeleteImmutabilityPolicyExceptionHeaders = {
      serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetLegalHoldHeaders = {
      serializedName: "Blob_setLegalHoldHeaders",
      type: {
        name: "Composite",
        className: "BlobSetLegalHoldHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          legalHold: {
            serializedName: "x-ms-legal-hold",
            xmlName: "x-ms-legal-hold",
            type: {
              name: "Boolean"
            }
          }
        }
      }
    };
    exports.BlobSetLegalHoldExceptionHeaders = {
      serializedName: "Blob_setLegalHoldExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobSetLegalHoldExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetMetadataHeaders = {
      serializedName: "Blob_setMetadataHeaders",
      type: {
        name: "Composite",
        className: "BlobSetMetadataHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetMetadataExceptionHeaders = {
      serializedName: "Blob_setMetadataExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobSetMetadataExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobAcquireLeaseHeaders = {
      serializedName: "Blob_acquireLeaseHeaders",
      type: {
        name: "Composite",
        className: "BlobAcquireLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          leaseId: {
            serializedName: "x-ms-lease-id",
            xmlName: "x-ms-lease-id",
            type: {
              name: "String"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.BlobAcquireLeaseExceptionHeaders = {
      serializedName: "Blob_acquireLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobAcquireLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobReleaseLeaseHeaders = {
      serializedName: "Blob_releaseLeaseHeaders",
      type: {
        name: "Composite",
        className: "BlobReleaseLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.BlobReleaseLeaseExceptionHeaders = {
      serializedName: "Blob_releaseLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobReleaseLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobRenewLeaseHeaders = {
      serializedName: "Blob_renewLeaseHeaders",
      type: {
        name: "Composite",
        className: "BlobRenewLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          leaseId: {
            serializedName: "x-ms-lease-id",
            xmlName: "x-ms-lease-id",
            type: {
              name: "String"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.BlobRenewLeaseExceptionHeaders = {
      serializedName: "Blob_renewLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobRenewLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobChangeLeaseHeaders = {
      serializedName: "Blob_changeLeaseHeaders",
      type: {
        name: "Composite",
        className: "BlobChangeLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          leaseId: {
            serializedName: "x-ms-lease-id",
            xmlName: "x-ms-lease-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.BlobChangeLeaseExceptionHeaders = {
      serializedName: "Blob_changeLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobChangeLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobBreakLeaseHeaders = {
      serializedName: "Blob_breakLeaseHeaders",
      type: {
        name: "Composite",
        className: "BlobBreakLeaseHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          leaseTime: {
            serializedName: "x-ms-lease-time",
            xmlName: "x-ms-lease-time",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          }
        }
      }
    };
    exports.BlobBreakLeaseExceptionHeaders = {
      serializedName: "Blob_breakLeaseExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobBreakLeaseExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobCreateSnapshotHeaders = {
      serializedName: "Blob_createSnapshotHeaders",
      type: {
        name: "Composite",
        className: "BlobCreateSnapshotHeaders",
        modelProperties: {
          snapshot: {
            serializedName: "x-ms-snapshot",
            xmlName: "x-ms-snapshot",
            type: {
              name: "String"
            }
          },
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobCreateSnapshotExceptionHeaders = {
      serializedName: "Blob_createSnapshotExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobCreateSnapshotExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobStartCopyFromURLHeaders = {
      serializedName: "Blob_startCopyFromURLHeaders",
      type: {
        name: "Composite",
        className: "BlobStartCopyFromURLHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          copyId: {
            serializedName: "x-ms-copy-id",
            xmlName: "x-ms-copy-id",
            type: {
              name: "String"
            }
          },
          copyStatus: {
            serializedName: "x-ms-copy-status",
            xmlName: "x-ms-copy-status",
            type: {
              name: "Enum",
              allowedValues: ["pending", "success", "aborted", "failed"]
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobStartCopyFromURLExceptionHeaders = {
      serializedName: "Blob_startCopyFromURLExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobStartCopyFromURLExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          },
          copySourceErrorCode: {
            serializedName: "x-ms-copy-source-error-code",
            xmlName: "x-ms-copy-source-error-code",
            type: {
              name: "String"
            }
          },
          copySourceStatusCode: {
            serializedName: "x-ms-copy-source-status-code",
            xmlName: "x-ms-copy-source-status-code",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.BlobCopyFromURLHeaders = {
      serializedName: "Blob_copyFromURLHeaders",
      type: {
        name: "Composite",
        className: "BlobCopyFromURLHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          copyId: {
            serializedName: "x-ms-copy-id",
            xmlName: "x-ms-copy-id",
            type: {
              name: "String"
            }
          },
          copyStatus: {
            defaultValue: "success",
            isConstant: true,
            serializedName: "x-ms-copy-status",
            type: {
              name: "String"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          xMsContentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobCopyFromURLExceptionHeaders = {
      serializedName: "Blob_copyFromURLExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobCopyFromURLExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          },
          copySourceErrorCode: {
            serializedName: "x-ms-copy-source-error-code",
            xmlName: "x-ms-copy-source-error-code",
            type: {
              name: "String"
            }
          },
          copySourceStatusCode: {
            serializedName: "x-ms-copy-source-status-code",
            xmlName: "x-ms-copy-source-status-code",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.BlobAbortCopyFromURLHeaders = {
      serializedName: "Blob_abortCopyFromURLHeaders",
      type: {
        name: "Composite",
        className: "BlobAbortCopyFromURLHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobAbortCopyFromURLExceptionHeaders = {
      serializedName: "Blob_abortCopyFromURLExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobAbortCopyFromURLExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetTierHeaders = {
      serializedName: "Blob_setTierHeaders",
      type: {
        name: "Composite",
        className: "BlobSetTierHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetTierExceptionHeaders = {
      serializedName: "Blob_setTierExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobSetTierExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobGetAccountInfoHeaders = {
      serializedName: "Blob_getAccountInfoHeaders",
      type: {
        name: "Composite",
        className: "BlobGetAccountInfoHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          skuName: {
            serializedName: "x-ms-sku-name",
            xmlName: "x-ms-sku-name",
            type: {
              name: "Enum",
              allowedValues: [
                "Standard_LRS",
                "Standard_GRS",
                "Standard_RAGRS",
                "Standard_ZRS",
                "Premium_LRS"
              ]
            }
          },
          accountKind: {
            serializedName: "x-ms-account-kind",
            xmlName: "x-ms-account-kind",
            type: {
              name: "Enum",
              allowedValues: [
                "Storage",
                "BlobStorage",
                "StorageV2",
                "FileStorage",
                "BlockBlobStorage"
              ]
            }
          },
          isHierarchicalNamespaceEnabled: {
            serializedName: "x-ms-is-hns-enabled",
            xmlName: "x-ms-is-hns-enabled",
            type: {
              name: "Boolean"
            }
          }
        }
      }
    };
    exports.BlobGetAccountInfoExceptionHeaders = {
      serializedName: "Blob_getAccountInfoExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobGetAccountInfoExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobQueryHeaders = {
      serializedName: "Blob_queryHeaders",
      type: {
        name: "Composite",
        className: "BlobQueryHeaders",
        modelProperties: {
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          metadata: {
            serializedName: "x-ms-meta",
            headerCollectionPrefix: "x-ms-meta-",
            xmlName: "x-ms-meta",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          },
          contentLength: {
            serializedName: "content-length",
            xmlName: "content-length",
            type: {
              name: "Number"
            }
          },
          contentType: {
            serializedName: "content-type",
            xmlName: "content-type",
            type: {
              name: "String"
            }
          },
          contentRange: {
            serializedName: "content-range",
            xmlName: "content-range",
            type: {
              name: "String"
            }
          },
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          contentEncoding: {
            serializedName: "content-encoding",
            xmlName: "content-encoding",
            type: {
              name: "String"
            }
          },
          cacheControl: {
            serializedName: "cache-control",
            xmlName: "cache-control",
            type: {
              name: "String"
            }
          },
          contentDisposition: {
            serializedName: "content-disposition",
            xmlName: "content-disposition",
            type: {
              name: "String"
            }
          },
          contentLanguage: {
            serializedName: "content-language",
            xmlName: "content-language",
            type: {
              name: "String"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          blobType: {
            serializedName: "x-ms-blob-type",
            xmlName: "x-ms-blob-type",
            type: {
              name: "Enum",
              allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
            }
          },
          copyCompletionTime: {
            serializedName: "x-ms-copy-completion-time",
            xmlName: "x-ms-copy-completion-time",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          copyStatusDescription: {
            serializedName: "x-ms-copy-status-description",
            xmlName: "x-ms-copy-status-description",
            type: {
              name: "String"
            }
          },
          copyId: {
            serializedName: "x-ms-copy-id",
            xmlName: "x-ms-copy-id",
            type: {
              name: "String"
            }
          },
          copyProgress: {
            serializedName: "x-ms-copy-progress",
            xmlName: "x-ms-copy-progress",
            type: {
              name: "String"
            }
          },
          copySource: {
            serializedName: "x-ms-copy-source",
            xmlName: "x-ms-copy-source",
            type: {
              name: "String"
            }
          },
          copyStatus: {
            serializedName: "x-ms-copy-status",
            xmlName: "x-ms-copy-status",
            type: {
              name: "Enum",
              allowedValues: ["pending", "success", "aborted", "failed"]
            }
          },
          leaseDuration: {
            serializedName: "x-ms-lease-duration",
            xmlName: "x-ms-lease-duration",
            type: {
              name: "Enum",
              allowedValues: ["infinite", "fixed"]
            }
          },
          leaseState: {
            serializedName: "x-ms-lease-state",
            xmlName: "x-ms-lease-state",
            type: {
              name: "Enum",
              allowedValues: [
                "available",
                "leased",
                "expired",
                "breaking",
                "broken"
              ]
            }
          },
          leaseStatus: {
            serializedName: "x-ms-lease-status",
            xmlName: "x-ms-lease-status",
            type: {
              name: "Enum",
              allowedValues: ["locked", "unlocked"]
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          acceptRanges: {
            serializedName: "accept-ranges",
            xmlName: "accept-ranges",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          blobCommittedBlockCount: {
            serializedName: "x-ms-blob-committed-block-count",
            xmlName: "x-ms-blob-committed-block-count",
            type: {
              name: "Number"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-server-encrypted",
            xmlName: "x-ms-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          blobContentMD5: {
            serializedName: "x-ms-blob-content-md5",
            xmlName: "x-ms-blob-content-md5",
            type: {
              name: "ByteArray"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          },
          contentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          }
        }
      }
    };
    exports.BlobQueryExceptionHeaders = {
      serializedName: "Blob_queryExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobQueryExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobGetTagsHeaders = {
      serializedName: "Blob_getTagsHeaders",
      type: {
        name: "Composite",
        className: "BlobGetTagsHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobGetTagsExceptionHeaders = {
      serializedName: "Blob_getTagsExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobGetTagsExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetTagsHeaders = {
      serializedName: "Blob_setTagsHeaders",
      type: {
        name: "Composite",
        className: "BlobSetTagsHeaders",
        modelProperties: {
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlobSetTagsExceptionHeaders = {
      serializedName: "Blob_setTagsExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlobSetTagsExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobCreateHeaders = {
      serializedName: "PageBlob_createHeaders",
      type: {
        name: "Composite",
        className: "PageBlobCreateHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobCreateExceptionHeaders = {
      serializedName: "PageBlob_createExceptionHeaders",
      type: {
        name: "Composite",
        className: "PageBlobCreateExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobUploadPagesHeaders = {
      serializedName: "PageBlob_uploadPagesHeaders",
      type: {
        name: "Composite",
        className: "PageBlobUploadPagesHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          xMsContentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobUploadPagesExceptionHeaders = {
      serializedName: "PageBlob_uploadPagesExceptionHeaders",
      type: {
        name: "Composite",
        className: "PageBlobUploadPagesExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobClearPagesHeaders = {
      serializedName: "PageBlob_clearPagesHeaders",
      type: {
        name: "Composite",
        className: "PageBlobClearPagesHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          xMsContentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobClearPagesExceptionHeaders = {
      serializedName: "PageBlob_clearPagesExceptionHeaders",
      type: {
        name: "Composite",
        className: "PageBlobClearPagesExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobUploadPagesFromURLHeaders = {
      serializedName: "PageBlob_uploadPagesFromURLHeaders",
      type: {
        name: "Composite",
        className: "PageBlobUploadPagesFromURLHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          xMsContentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobUploadPagesFromURLExceptionHeaders = {
      serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
      type: {
        name: "Composite",
        className: "PageBlobUploadPagesFromURLExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          },
          copySourceErrorCode: {
            serializedName: "x-ms-copy-source-error-code",
            xmlName: "x-ms-copy-source-error-code",
            type: {
              name: "String"
            }
          },
          copySourceStatusCode: {
            serializedName: "x-ms-copy-source-status-code",
            xmlName: "x-ms-copy-source-status-code",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.PageBlobGetPageRangesHeaders = {
      serializedName: "PageBlob_getPageRangesHeaders",
      type: {
        name: "Composite",
        className: "PageBlobGetPageRangesHeaders",
        modelProperties: {
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          blobContentLength: {
            serializedName: "x-ms-blob-content-length",
            xmlName: "x-ms-blob-content-length",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobGetPageRangesExceptionHeaders = {
      serializedName: "PageBlob_getPageRangesExceptionHeaders",
      type: {
        name: "Composite",
        className: "PageBlobGetPageRangesExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobGetPageRangesDiffHeaders = {
      serializedName: "PageBlob_getPageRangesDiffHeaders",
      type: {
        name: "Composite",
        className: "PageBlobGetPageRangesDiffHeaders",
        modelProperties: {
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          blobContentLength: {
            serializedName: "x-ms-blob-content-length",
            xmlName: "x-ms-blob-content-length",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobGetPageRangesDiffExceptionHeaders = {
      serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
      type: {
        name: "Composite",
        className: "PageBlobGetPageRangesDiffExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobResizeHeaders = {
      serializedName: "PageBlob_resizeHeaders",
      type: {
        name: "Composite",
        className: "PageBlobResizeHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobResizeExceptionHeaders = {
      serializedName: "PageBlob_resizeExceptionHeaders",
      type: {
        name: "Composite",
        className: "PageBlobResizeExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobUpdateSequenceNumberHeaders = {
      serializedName: "PageBlob_updateSequenceNumberHeaders",
      type: {
        name: "Composite",
        className: "PageBlobUpdateSequenceNumberHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          blobSequenceNumber: {
            serializedName: "x-ms-blob-sequence-number",
            xmlName: "x-ms-blob-sequence-number",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobUpdateSequenceNumberExceptionHeaders = {
      serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
      type: {
        name: "Composite",
        className: "PageBlobUpdateSequenceNumberExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobCopyIncrementalHeaders = {
      serializedName: "PageBlob_copyIncrementalHeaders",
      type: {
        name: "Composite",
        className: "PageBlobCopyIncrementalHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          copyId: {
            serializedName: "x-ms-copy-id",
            xmlName: "x-ms-copy-id",
            type: {
              name: "String"
            }
          },
          copyStatus: {
            serializedName: "x-ms-copy-status",
            xmlName: "x-ms-copy-status",
            type: {
              name: "Enum",
              allowedValues: ["pending", "success", "aborted", "failed"]
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.PageBlobCopyIncrementalExceptionHeaders = {
      serializedName: "PageBlob_copyIncrementalExceptionHeaders",
      type: {
        name: "Composite",
        className: "PageBlobCopyIncrementalExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.AppendBlobCreateHeaders = {
      serializedName: "AppendBlob_createHeaders",
      type: {
        name: "Composite",
        className: "AppendBlobCreateHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.AppendBlobCreateExceptionHeaders = {
      serializedName: "AppendBlob_createExceptionHeaders",
      type: {
        name: "Composite",
        className: "AppendBlobCreateExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.AppendBlobAppendBlockHeaders = {
      serializedName: "AppendBlob_appendBlockHeaders",
      type: {
        name: "Composite",
        className: "AppendBlobAppendBlockHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          xMsContentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          blobAppendOffset: {
            serializedName: "x-ms-blob-append-offset",
            xmlName: "x-ms-blob-append-offset",
            type: {
              name: "String"
            }
          },
          blobCommittedBlockCount: {
            serializedName: "x-ms-blob-committed-block-count",
            xmlName: "x-ms-blob-committed-block-count",
            type: {
              name: "Number"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.AppendBlobAppendBlockExceptionHeaders = {
      serializedName: "AppendBlob_appendBlockExceptionHeaders",
      type: {
        name: "Composite",
        className: "AppendBlobAppendBlockExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.AppendBlobAppendBlockFromUrlHeaders = {
      serializedName: "AppendBlob_appendBlockFromUrlHeaders",
      type: {
        name: "Composite",
        className: "AppendBlobAppendBlockFromUrlHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          xMsContentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          blobAppendOffset: {
            serializedName: "x-ms-blob-append-offset",
            xmlName: "x-ms-blob-append-offset",
            type: {
              name: "String"
            }
          },
          blobCommittedBlockCount: {
            serializedName: "x-ms-blob-committed-block-count",
            xmlName: "x-ms-blob-committed-block-count",
            type: {
              name: "Number"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.AppendBlobAppendBlockFromUrlExceptionHeaders = {
      serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
      type: {
        name: "Composite",
        className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          },
          copySourceErrorCode: {
            serializedName: "x-ms-copy-source-error-code",
            xmlName: "x-ms-copy-source-error-code",
            type: {
              name: "String"
            }
          },
          copySourceStatusCode: {
            serializedName: "x-ms-copy-source-status-code",
            xmlName: "x-ms-copy-source-status-code",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.AppendBlobSealHeaders = {
      serializedName: "AppendBlob_sealHeaders",
      type: {
        name: "Composite",
        className: "AppendBlobSealHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isSealed: {
            serializedName: "x-ms-blob-sealed",
            xmlName: "x-ms-blob-sealed",
            type: {
              name: "Boolean"
            }
          }
        }
      }
    };
    exports.AppendBlobSealExceptionHeaders = {
      serializedName: "AppendBlob_sealExceptionHeaders",
      type: {
        name: "Composite",
        className: "AppendBlobSealExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobUploadHeaders = {
      serializedName: "BlockBlob_uploadHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobUploadHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobUploadExceptionHeaders = {
      serializedName: "BlockBlob_uploadExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobUploadExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobPutBlobFromUrlHeaders = {
      serializedName: "BlockBlob_putBlobFromUrlHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobPutBlobFromUrlHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobPutBlobFromUrlExceptionHeaders = {
      serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobPutBlobFromUrlExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          },
          copySourceErrorCode: {
            serializedName: "x-ms-copy-source-error-code",
            xmlName: "x-ms-copy-source-error-code",
            type: {
              name: "String"
            }
          },
          copySourceStatusCode: {
            serializedName: "x-ms-copy-source-status-code",
            xmlName: "x-ms-copy-source-status-code",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.BlockBlobStageBlockHeaders = {
      serializedName: "BlockBlob_stageBlockHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobStageBlockHeaders",
        modelProperties: {
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          xMsContentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobStageBlockExceptionHeaders = {
      serializedName: "BlockBlob_stageBlockExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobStageBlockExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobStageBlockFromURLHeaders = {
      serializedName: "BlockBlob_stageBlockFromURLHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobStageBlockFromURLHeaders",
        modelProperties: {
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          xMsContentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobStageBlockFromURLExceptionHeaders = {
      serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobStageBlockFromURLExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          },
          copySourceErrorCode: {
            serializedName: "x-ms-copy-source-error-code",
            xmlName: "x-ms-copy-source-error-code",
            type: {
              name: "String"
            }
          },
          copySourceStatusCode: {
            serializedName: "x-ms-copy-source-status-code",
            xmlName: "x-ms-copy-source-status-code",
            type: {
              name: "Number"
            }
          }
        }
      }
    };
    exports.BlockBlobCommitBlockListHeaders = {
      serializedName: "BlockBlob_commitBlockListHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobCommitBlockListHeaders",
        modelProperties: {
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          contentMD5: {
            serializedName: "content-md5",
            xmlName: "content-md5",
            type: {
              name: "ByteArray"
            }
          },
          xMsContentCrc64: {
            serializedName: "x-ms-content-crc64",
            xmlName: "x-ms-content-crc64",
            type: {
              name: "ByteArray"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          versionId: {
            serializedName: "x-ms-version-id",
            xmlName: "x-ms-version-id",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          isServerEncrypted: {
            serializedName: "x-ms-request-server-encrypted",
            xmlName: "x-ms-request-server-encrypted",
            type: {
              name: "Boolean"
            }
          },
          encryptionKeySha256: {
            serializedName: "x-ms-encryption-key-sha256",
            xmlName: "x-ms-encryption-key-sha256",
            type: {
              name: "String"
            }
          },
          encryptionScope: {
            serializedName: "x-ms-encryption-scope",
            xmlName: "x-ms-encryption-scope",
            type: {
              name: "String"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobCommitBlockListExceptionHeaders = {
      serializedName: "BlockBlob_commitBlockListExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobCommitBlockListExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobGetBlockListHeaders = {
      serializedName: "BlockBlob_getBlockListHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobGetBlockListHeaders",
        modelProperties: {
          lastModified: {
            serializedName: "last-modified",
            xmlName: "last-modified",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          etag: {
            serializedName: "etag",
            xmlName: "etag",
            type: {
              name: "String"
            }
          },
          contentType: {
            serializedName: "content-type",
            xmlName: "content-type",
            type: {
              name: "String"
            }
          },
          blobContentLength: {
            serializedName: "x-ms-blob-content-length",
            xmlName: "x-ms-blob-content-length",
            type: {
              name: "Number"
            }
          },
          clientRequestId: {
            serializedName: "x-ms-client-request-id",
            xmlName: "x-ms-client-request-id",
            type: {
              name: "String"
            }
          },
          requestId: {
            serializedName: "x-ms-request-id",
            xmlName: "x-ms-request-id",
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "x-ms-version",
            xmlName: "x-ms-version",
            type: {
              name: "String"
            }
          },
          date: {
            serializedName: "date",
            xmlName: "date",
            type: {
              name: "DateTimeRfc1123"
            }
          },
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    exports.BlockBlobGetBlockListExceptionHeaders = {
      serializedName: "BlockBlob_getBlockListExceptionHeaders",
      type: {
        name: "Composite",
        className: "BlockBlobGetBlockListExceptionHeaders",
        modelProperties: {
          errorCode: {
            serializedName: "x-ms-error-code",
            xmlName: "x-ms-error-code",
            type: {
              name: "String"
            }
          }
        }
      }
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/parameters.js
var require_parameters = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/parameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.action3 = exports.action2 = exports.leaseId1 = exports.action1 = exports.proposedLeaseId = exports.duration = exports.action = exports.comp10 = exports.sourceLeaseId = exports.sourceContainerName = exports.comp9 = exports.deletedContainerVersion = exports.deletedContainerName = exports.comp8 = exports.containerAcl = exports.comp7 = exports.comp6 = exports.ifUnmodifiedSince = exports.ifModifiedSince = exports.leaseId = exports.preventEncryptionScopeOverride = exports.defaultEncryptionScope = exports.access = exports.metadata = exports.restype2 = exports.where = exports.comp5 = exports.multipartContentType = exports.contentLength = exports.comp4 = exports.body = exports.restype1 = exports.comp3 = exports.keyInfo = exports.include = exports.maxPageSize = exports.marker = exports.prefix = exports.comp2 = exports.comp1 = exports.accept1 = exports.requestId = exports.version = exports.timeoutInSeconds = exports.comp = exports.restype = exports.url = exports.accept = exports.blobServiceProperties = exports.contentType = void 0;
    exports.fileRequestIntent = exports.copySourceTags = exports.copySourceAuthorization = exports.sourceContentMD5 = exports.xMsRequiresSync = exports.legalHold1 = exports.sealBlob = exports.blobTagsString = exports.copySource = exports.sourceIfTags = exports.sourceIfNoneMatch = exports.sourceIfMatch = exports.sourceIfUnmodifiedSince = exports.sourceIfModifiedSince = exports.rehydratePriority = exports.tier = exports.comp14 = exports.encryptionScope = exports.legalHold = exports.comp13 = exports.immutabilityPolicyMode = exports.immutabilityPolicyExpiry = exports.comp12 = exports.blobContentDisposition = exports.blobContentLanguage = exports.blobContentEncoding = exports.blobContentMD5 = exports.blobContentType = exports.blobCacheControl = exports.expiresOn = exports.expiryOptions = exports.comp11 = exports.blobDeleteType = exports.deleteSnapshots = exports.ifTags = exports.ifNoneMatch = exports.ifMatch = exports.encryptionAlgorithm = exports.encryptionKeySha256 = exports.encryptionKey = exports.rangeGetContentCRC64 = exports.rangeGetContentMD5 = exports.range = exports.versionId = exports.snapshot = exports.delimiter = exports.include1 = exports.proposedLeaseId1 = exports.action4 = exports.breakPeriod = void 0;
    exports.listType = exports.comp25 = exports.blocks = exports.blockId = exports.comp24 = exports.copySourceBlobProperties = exports.blobType2 = exports.comp23 = exports.sourceRange1 = exports.appendPosition = exports.maxSize = exports.comp22 = exports.blobType1 = exports.comp21 = exports.sequenceNumberAction = exports.prevSnapshotUrl = exports.prevsnapshot = exports.comp20 = exports.range1 = exports.sourceContentCrc64 = exports.sourceRange = exports.sourceUrl = exports.pageWrite1 = exports.ifSequenceNumberEqualTo = exports.ifSequenceNumberLessThan = exports.ifSequenceNumberLessThanOrEqualTo = exports.pageWrite = exports.comp19 = exports.accept2 = exports.body1 = exports.contentType1 = exports.blobSequenceNumber = exports.blobContentLength = exports.blobType = exports.transactionalContentCrc64 = exports.transactionalContentMD5 = exports.tags = exports.comp18 = exports.comp17 = exports.queryRequest = exports.tier1 = exports.comp16 = exports.copyId = exports.copyActionAbortConstant = exports.comp15 = void 0;
    var mappers_js_1 = require_mappers();
    exports.contentType = {
      parameterPath: ["options", "contentType"],
      mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
          name: "String"
        }
      }
    };
    exports.blobServiceProperties = {
      parameterPath: "blobServiceProperties",
      mapper: mappers_js_1.BlobServiceProperties
    };
    exports.accept = {
      parameterPath: "accept",
      mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
          name: "String"
        }
      }
    };
    exports.url = {
      parameterPath: "url",
      mapper: {
        serializedName: "url",
        required: true,
        xmlName: "url",
        type: {
          name: "String"
        }
      },
      skipEncoding: true
    };
    exports.restype = {
      parameterPath: "restype",
      mapper: {
        defaultValue: "service",
        isConstant: true,
        serializedName: "restype",
        type: {
          name: "String"
        }
      }
    };
    exports.comp = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "properties",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.timeoutInSeconds = {
      parameterPath: ["options", "timeoutInSeconds"],
      mapper: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "timeout",
        xmlName: "timeout",
        type: {
          name: "Number"
        }
      }
    };
    exports.version = {
      parameterPath: "version",
      mapper: {
        defaultValue: "2025-11-05",
        isConstant: true,
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      }
    };
    exports.requestId = {
      parameterPath: ["options", "requestId"],
      mapper: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      }
    };
    exports.accept1 = {
      parameterPath: "accept",
      mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
          name: "String"
        }
      }
    };
    exports.comp1 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "stats",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.comp2 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "list",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.prefix = {
      parameterPath: ["options", "prefix"],
      mapper: {
        serializedName: "prefix",
        xmlName: "prefix",
        type: {
          name: "String"
        }
      }
    };
    exports.marker = {
      parameterPath: ["options", "marker"],
      mapper: {
        serializedName: "marker",
        xmlName: "marker",
        type: {
          name: "String"
        }
      }
    };
    exports.maxPageSize = {
      parameterPath: ["options", "maxPageSize"],
      mapper: {
        constraints: {
          InclusiveMinimum: 1
        },
        serializedName: "maxresults",
        xmlName: "maxresults",
        type: {
          name: "Number"
        }
      }
    };
    exports.include = {
      parameterPath: ["options", "include"],
      mapper: {
        serializedName: "include",
        xmlName: "include",
        xmlElementName: "ListContainersIncludeType",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Enum",
              allowedValues: ["metadata", "deleted", "system"]
            }
          }
        }
      },
      collectionFormat: "CSV"
    };
    exports.keyInfo = {
      parameterPath: "keyInfo",
      mapper: mappers_js_1.KeyInfo
    };
    exports.comp3 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "userdelegationkey",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.restype1 = {
      parameterPath: "restype",
      mapper: {
        defaultValue: "account",
        isConstant: true,
        serializedName: "restype",
        type: {
          name: "String"
        }
      }
    };
    exports.body = {
      parameterPath: "body",
      mapper: {
        serializedName: "body",
        required: true,
        xmlName: "body",
        type: {
          name: "Stream"
        }
      }
    };
    exports.comp4 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "batch",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.contentLength = {
      parameterPath: "contentLength",
      mapper: {
        serializedName: "Content-Length",
        required: true,
        xmlName: "Content-Length",
        type: {
          name: "Number"
        }
      }
    };
    exports.multipartContentType = {
      parameterPath: "multipartContentType",
      mapper: {
        serializedName: "Content-Type",
        required: true,
        xmlName: "Content-Type",
        type: {
          name: "String"
        }
      }
    };
    exports.comp5 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "blobs",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.where = {
      parameterPath: ["options", "where"],
      mapper: {
        serializedName: "where",
        xmlName: "where",
        type: {
          name: "String"
        }
      }
    };
    exports.restype2 = {
      parameterPath: "restype",
      mapper: {
        defaultValue: "container",
        isConstant: true,
        serializedName: "restype",
        type: {
          name: "String"
        }
      }
    };
    exports.metadata = {
      parameterPath: ["options", "metadata"],
      mapper: {
        serializedName: "x-ms-meta",
        xmlName: "x-ms-meta",
        headerCollectionPrefix: "x-ms-meta-",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      }
    };
    exports.access = {
      parameterPath: ["options", "access"],
      mapper: {
        serializedName: "x-ms-blob-public-access",
        xmlName: "x-ms-blob-public-access",
        type: {
          name: "Enum",
          allowedValues: ["container", "blob"]
        }
      }
    };
    exports.defaultEncryptionScope = {
      parameterPath: [
        "options",
        "containerEncryptionScope",
        "defaultEncryptionScope"
      ],
      mapper: {
        serializedName: "x-ms-default-encryption-scope",
        xmlName: "x-ms-default-encryption-scope",
        type: {
          name: "String"
        }
      }
    };
    exports.preventEncryptionScopeOverride = {
      parameterPath: [
        "options",
        "containerEncryptionScope",
        "preventEncryptionScopeOverride"
      ],
      mapper: {
        serializedName: "x-ms-deny-encryption-scope-override",
        xmlName: "x-ms-deny-encryption-scope-override",
        type: {
          name: "Boolean"
        }
      }
    };
    exports.leaseId = {
      parameterPath: ["options", "leaseAccessConditions", "leaseId"],
      mapper: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      }
    };
    exports.ifModifiedSince = {
      parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
      mapper: {
        serializedName: "If-Modified-Since",
        xmlName: "If-Modified-Since",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    };
    exports.ifUnmodifiedSince = {
      parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
      mapper: {
        serializedName: "If-Unmodified-Since",
        xmlName: "If-Unmodified-Since",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    };
    exports.comp6 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "metadata",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.comp7 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "acl",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.containerAcl = {
      parameterPath: ["options", "containerAcl"],
      mapper: {
        serializedName: "containerAcl",
        xmlName: "SignedIdentifiers",
        xmlIsWrapped: true,
        xmlElementName: "SignedIdentifier",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SignedIdentifier"
            }
          }
        }
      }
    };
    exports.comp8 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "undelete",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.deletedContainerName = {
      parameterPath: ["options", "deletedContainerName"],
      mapper: {
        serializedName: "x-ms-deleted-container-name",
        xmlName: "x-ms-deleted-container-name",
        type: {
          name: "String"
        }
      }
    };
    exports.deletedContainerVersion = {
      parameterPath: ["options", "deletedContainerVersion"],
      mapper: {
        serializedName: "x-ms-deleted-container-version",
        xmlName: "x-ms-deleted-container-version",
        type: {
          name: "String"
        }
      }
    };
    exports.comp9 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "rename",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.sourceContainerName = {
      parameterPath: "sourceContainerName",
      mapper: {
        serializedName: "x-ms-source-container-name",
        required: true,
        xmlName: "x-ms-source-container-name",
        type: {
          name: "String"
        }
      }
    };
    exports.sourceLeaseId = {
      parameterPath: ["options", "sourceLeaseId"],
      mapper: {
        serializedName: "x-ms-source-lease-id",
        xmlName: "x-ms-source-lease-id",
        type: {
          name: "String"
        }
      }
    };
    exports.comp10 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "lease",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.action = {
      parameterPath: "action",
      mapper: {
        defaultValue: "acquire",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
          name: "String"
        }
      }
    };
    exports.duration = {
      parameterPath: ["options", "duration"],
      mapper: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
          name: "Number"
        }
      }
    };
    exports.proposedLeaseId = {
      parameterPath: ["options", "proposedLeaseId"],
      mapper: {
        serializedName: "x-ms-proposed-lease-id",
        xmlName: "x-ms-proposed-lease-id",
        type: {
          name: "String"
        }
      }
    };
    exports.action1 = {
      parameterPath: "action",
      mapper: {
        defaultValue: "release",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
          name: "String"
        }
      }
    };
    exports.leaseId1 = {
      parameterPath: "leaseId",
      mapper: {
        serializedName: "x-ms-lease-id",
        required: true,
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      }
    };
    exports.action2 = {
      parameterPath: "action",
      mapper: {
        defaultValue: "renew",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
          name: "String"
        }
      }
    };
    exports.action3 = {
      parameterPath: "action",
      mapper: {
        defaultValue: "break",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
          name: "String"
        }
      }
    };
    exports.breakPeriod = {
      parameterPath: ["options", "breakPeriod"],
      mapper: {
        serializedName: "x-ms-lease-break-period",
        xmlName: "x-ms-lease-break-period",
        type: {
          name: "Number"
        }
      }
    };
    exports.action4 = {
      parameterPath: "action",
      mapper: {
        defaultValue: "change",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
          name: "String"
        }
      }
    };
    exports.proposedLeaseId1 = {
      parameterPath: "proposedLeaseId",
      mapper: {
        serializedName: "x-ms-proposed-lease-id",
        required: true,
        xmlName: "x-ms-proposed-lease-id",
        type: {
          name: "String"
        }
      }
    };
    exports.include1 = {
      parameterPath: ["options", "include"],
      mapper: {
        serializedName: "include",
        xmlName: "include",
        xmlElementName: "ListBlobsIncludeItem",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Enum",
              allowedValues: [
                "copy",
                "deleted",
                "metadata",
                "snapshots",
                "uncommittedblobs",
                "versions",
                "tags",
                "immutabilitypolicy",
                "legalhold",
                "deletedwithversions"
              ]
            }
          }
        }
      },
      collectionFormat: "CSV"
    };
    exports.delimiter = {
      parameterPath: "delimiter",
      mapper: {
        serializedName: "delimiter",
        required: true,
        xmlName: "delimiter",
        type: {
          name: "String"
        }
      }
    };
    exports.snapshot = {
      parameterPath: ["options", "snapshot"],
      mapper: {
        serializedName: "snapshot",
        xmlName: "snapshot",
        type: {
          name: "String"
        }
      }
    };
    exports.versionId = {
      parameterPath: ["options", "versionId"],
      mapper: {
        serializedName: "versionid",
        xmlName: "versionid",
        type: {
          name: "String"
        }
      }
    };
    exports.range = {
      parameterPath: ["options", "range"],
      mapper: {
        serializedName: "x-ms-range",
        xmlName: "x-ms-range",
        type: {
          name: "String"
        }
      }
    };
    exports.rangeGetContentMD5 = {
      parameterPath: ["options", "rangeGetContentMD5"],
      mapper: {
        serializedName: "x-ms-range-get-content-md5",
        xmlName: "x-ms-range-get-content-md5",
        type: {
          name: "Boolean"
        }
      }
    };
    exports.rangeGetContentCRC64 = {
      parameterPath: ["options", "rangeGetContentCRC64"],
      mapper: {
        serializedName: "x-ms-range-get-content-crc64",
        xmlName: "x-ms-range-get-content-crc64",
        type: {
          name: "Boolean"
        }
      }
    };
    exports.encryptionKey = {
      parameterPath: ["options", "cpkInfo", "encryptionKey"],
      mapper: {
        serializedName: "x-ms-encryption-key",
        xmlName: "x-ms-encryption-key",
        type: {
          name: "String"
        }
      }
    };
    exports.encryptionKeySha256 = {
      parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
      mapper: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      }
    };
    exports.encryptionAlgorithm = {
      parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
      mapper: {
        serializedName: "x-ms-encryption-algorithm",
        xmlName: "x-ms-encryption-algorithm",
        type: {
          name: "String"
        }
      }
    };
    exports.ifMatch = {
      parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
      mapper: {
        serializedName: "If-Match",
        xmlName: "If-Match",
        type: {
          name: "String"
        }
      }
    };
    exports.ifNoneMatch = {
      parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
      mapper: {
        serializedName: "If-None-Match",
        xmlName: "If-None-Match",
        type: {
          name: "String"
        }
      }
    };
    exports.ifTags = {
      parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
      mapper: {
        serializedName: "x-ms-if-tags",
        xmlName: "x-ms-if-tags",
        type: {
          name: "String"
        }
      }
    };
    exports.deleteSnapshots = {
      parameterPath: ["options", "deleteSnapshots"],
      mapper: {
        serializedName: "x-ms-delete-snapshots",
        xmlName: "x-ms-delete-snapshots",
        type: {
          name: "Enum",
          allowedValues: ["include", "only"]
        }
      }
    };
    exports.blobDeleteType = {
      parameterPath: ["options", "blobDeleteType"],
      mapper: {
        serializedName: "deletetype",
        xmlName: "deletetype",
        type: {
          name: "String"
        }
      }
    };
    exports.comp11 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "expiry",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.expiryOptions = {
      parameterPath: "expiryOptions",
      mapper: {
        serializedName: "x-ms-expiry-option",
        required: true,
        xmlName: "x-ms-expiry-option",
        type: {
          name: "String"
        }
      }
    };
    exports.expiresOn = {
      parameterPath: ["options", "expiresOn"],
      mapper: {
        serializedName: "x-ms-expiry-time",
        xmlName: "x-ms-expiry-time",
        type: {
          name: "String"
        }
      }
    };
    exports.blobCacheControl = {
      parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
      mapper: {
        serializedName: "x-ms-blob-cache-control",
        xmlName: "x-ms-blob-cache-control",
        type: {
          name: "String"
        }
      }
    };
    exports.blobContentType = {
      parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
      mapper: {
        serializedName: "x-ms-blob-content-type",
        xmlName: "x-ms-blob-content-type",
        type: {
          name: "String"
        }
      }
    };
    exports.blobContentMD5 = {
      parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
      mapper: {
        serializedName: "x-ms-blob-content-md5",
        xmlName: "x-ms-blob-content-md5",
        type: {
          name: "ByteArray"
        }
      }
    };
    exports.blobContentEncoding = {
      parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
      mapper: {
        serializedName: "x-ms-blob-content-encoding",
        xmlName: "x-ms-blob-content-encoding",
        type: {
          name: "String"
        }
      }
    };
    exports.blobContentLanguage = {
      parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
      mapper: {
        serializedName: "x-ms-blob-content-language",
        xmlName: "x-ms-blob-content-language",
        type: {
          name: "String"
        }
      }
    };
    exports.blobContentDisposition = {
      parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
      mapper: {
        serializedName: "x-ms-blob-content-disposition",
        xmlName: "x-ms-blob-content-disposition",
        type: {
          name: "String"
        }
      }
    };
    exports.comp12 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "immutabilityPolicies",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.immutabilityPolicyExpiry = {
      parameterPath: ["options", "immutabilityPolicyExpiry"],
      mapper: {
        serializedName: "x-ms-immutability-policy-until-date",
        xmlName: "x-ms-immutability-policy-until-date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    };
    exports.immutabilityPolicyMode = {
      parameterPath: ["options", "immutabilityPolicyMode"],
      mapper: {
        serializedName: "x-ms-immutability-policy-mode",
        xmlName: "x-ms-immutability-policy-mode",
        type: {
          name: "Enum",
          allowedValues: ["Mutable", "Unlocked", "Locked"]
        }
      }
    };
    exports.comp13 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "legalhold",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.legalHold = {
      parameterPath: "legalHold",
      mapper: {
        serializedName: "x-ms-legal-hold",
        required: true,
        xmlName: "x-ms-legal-hold",
        type: {
          name: "Boolean"
        }
      }
    };
    exports.encryptionScope = {
      parameterPath: ["options", "encryptionScope"],
      mapper: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      }
    };
    exports.comp14 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "snapshot",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.tier = {
      parameterPath: ["options", "tier"],
      mapper: {
        serializedName: "x-ms-access-tier",
        xmlName: "x-ms-access-tier",
        type: {
          name: "Enum",
          allowedValues: [
            "P4",
            "P6",
            "P10",
            "P15",
            "P20",
            "P30",
            "P40",
            "P50",
            "P60",
            "P70",
            "P80",
            "Hot",
            "Cool",
            "Archive",
            "Cold"
          ]
        }
      }
    };
    exports.rehydratePriority = {
      parameterPath: ["options", "rehydratePriority"],
      mapper: {
        serializedName: "x-ms-rehydrate-priority",
        xmlName: "x-ms-rehydrate-priority",
        type: {
          name: "Enum",
          allowedValues: ["High", "Standard"]
        }
      }
    };
    exports.sourceIfModifiedSince = {
      parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfModifiedSince"
      ],
      mapper: {
        serializedName: "x-ms-source-if-modified-since",
        xmlName: "x-ms-source-if-modified-since",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    };
    exports.sourceIfUnmodifiedSince = {
      parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfUnmodifiedSince"
      ],
      mapper: {
        serializedName: "x-ms-source-if-unmodified-since",
        xmlName: "x-ms-source-if-unmodified-since",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    };
    exports.sourceIfMatch = {
      parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
      mapper: {
        serializedName: "x-ms-source-if-match",
        xmlName: "x-ms-source-if-match",
        type: {
          name: "String"
        }
      }
    };
    exports.sourceIfNoneMatch = {
      parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfNoneMatch"
      ],
      mapper: {
        serializedName: "x-ms-source-if-none-match",
        xmlName: "x-ms-source-if-none-match",
        type: {
          name: "String"
        }
      }
    };
    exports.sourceIfTags = {
      parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
      mapper: {
        serializedName: "x-ms-source-if-tags",
        xmlName: "x-ms-source-if-tags",
        type: {
          name: "String"
        }
      }
    };
    exports.copySource = {
      parameterPath: "copySource",
      mapper: {
        serializedName: "x-ms-copy-source",
        required: true,
        xmlName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      }
    };
    exports.blobTagsString = {
      parameterPath: ["options", "blobTagsString"],
      mapper: {
        serializedName: "x-ms-tags",
        xmlName: "x-ms-tags",
        type: {
          name: "String"
        }
      }
    };
    exports.sealBlob = {
      parameterPath: ["options", "sealBlob"],
      mapper: {
        serializedName: "x-ms-seal-blob",
        xmlName: "x-ms-seal-blob",
        type: {
          name: "Boolean"
        }
      }
    };
    exports.legalHold1 = {
      parameterPath: ["options", "legalHold"],
      mapper: {
        serializedName: "x-ms-legal-hold",
        xmlName: "x-ms-legal-hold",
        type: {
          name: "Boolean"
        }
      }
    };
    exports.xMsRequiresSync = {
      parameterPath: "xMsRequiresSync",
      mapper: {
        defaultValue: "true",
        isConstant: true,
        serializedName: "x-ms-requires-sync",
        type: {
          name: "String"
        }
      }
    };
    exports.sourceContentMD5 = {
      parameterPath: ["options", "sourceContentMD5"],
      mapper: {
        serializedName: "x-ms-source-content-md5",
        xmlName: "x-ms-source-content-md5",
        type: {
          name: "ByteArray"
        }
      }
    };
    exports.copySourceAuthorization = {
      parameterPath: ["options", "copySourceAuthorization"],
      mapper: {
        serializedName: "x-ms-copy-source-authorization",
        xmlName: "x-ms-copy-source-authorization",
        type: {
          name: "String"
        }
      }
    };
    exports.copySourceTags = {
      parameterPath: ["options", "copySourceTags"],
      mapper: {
        serializedName: "x-ms-copy-source-tag-option",
        xmlName: "x-ms-copy-source-tag-option",
        type: {
          name: "Enum",
          allowedValues: ["REPLACE", "COPY"]
        }
      }
    };
    exports.fileRequestIntent = {
      parameterPath: ["options", "fileRequestIntent"],
      mapper: {
        serializedName: "x-ms-file-request-intent",
        xmlName: "x-ms-file-request-intent",
        type: {
          name: "String"
        }
      }
    };
    exports.comp15 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "copy",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.copyActionAbortConstant = {
      parameterPath: "copyActionAbortConstant",
      mapper: {
        defaultValue: "abort",
        isConstant: true,
        serializedName: "x-ms-copy-action",
        type: {
          name: "String"
        }
      }
    };
    exports.copyId = {
      parameterPath: "copyId",
      mapper: {
        serializedName: "copyid",
        required: true,
        xmlName: "copyid",
        type: {
          name: "String"
        }
      }
    };
    exports.comp16 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "tier",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.tier1 = {
      parameterPath: "tier",
      mapper: {
        serializedName: "x-ms-access-tier",
        required: true,
        xmlName: "x-ms-access-tier",
        type: {
          name: "Enum",
          allowedValues: [
            "P4",
            "P6",
            "P10",
            "P15",
            "P20",
            "P30",
            "P40",
            "P50",
            "P60",
            "P70",
            "P80",
            "Hot",
            "Cool",
            "Archive",
            "Cold"
          ]
        }
      }
    };
    exports.queryRequest = {
      parameterPath: ["options", "queryRequest"],
      mapper: mappers_js_1.QueryRequest
    };
    exports.comp17 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "query",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.comp18 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "tags",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.tags = {
      parameterPath: ["options", "tags"],
      mapper: mappers_js_1.BlobTags
    };
    exports.transactionalContentMD5 = {
      parameterPath: ["options", "transactionalContentMD5"],
      mapper: {
        serializedName: "Content-MD5",
        xmlName: "Content-MD5",
        type: {
          name: "ByteArray"
        }
      }
    };
    exports.transactionalContentCrc64 = {
      parameterPath: ["options", "transactionalContentCrc64"],
      mapper: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      }
    };
    exports.blobType = {
      parameterPath: "blobType",
      mapper: {
        defaultValue: "PageBlob",
        isConstant: true,
        serializedName: "x-ms-blob-type",
        type: {
          name: "String"
        }
      }
    };
    exports.blobContentLength = {
      parameterPath: "blobContentLength",
      mapper: {
        serializedName: "x-ms-blob-content-length",
        required: true,
        xmlName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      }
    };
    exports.blobSequenceNumber = {
      parameterPath: ["options", "blobSequenceNumber"],
      mapper: {
        defaultValue: 0,
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      }
    };
    exports.contentType1 = {
      parameterPath: ["options", "contentType"],
      mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
          name: "String"
        }
      }
    };
    exports.body1 = {
      parameterPath: "body",
      mapper: {
        serializedName: "body",
        required: true,
        xmlName: "body",
        type: {
          name: "Stream"
        }
      }
    };
    exports.accept2 = {
      parameterPath: "accept",
      mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
          name: "String"
        }
      }
    };
    exports.comp19 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "page",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.pageWrite = {
      parameterPath: "pageWrite",
      mapper: {
        defaultValue: "update",
        isConstant: true,
        serializedName: "x-ms-page-write",
        type: {
          name: "String"
        }
      }
    };
    exports.ifSequenceNumberLessThanOrEqualTo = {
      parameterPath: [
        "options",
        "sequenceNumberAccessConditions",
        "ifSequenceNumberLessThanOrEqualTo"
      ],
      mapper: {
        serializedName: "x-ms-if-sequence-number-le",
        xmlName: "x-ms-if-sequence-number-le",
        type: {
          name: "Number"
        }
      }
    };
    exports.ifSequenceNumberLessThan = {
      parameterPath: [
        "options",
        "sequenceNumberAccessConditions",
        "ifSequenceNumberLessThan"
      ],
      mapper: {
        serializedName: "x-ms-if-sequence-number-lt",
        xmlName: "x-ms-if-sequence-number-lt",
        type: {
          name: "Number"
        }
      }
    };
    exports.ifSequenceNumberEqualTo = {
      parameterPath: [
        "options",
        "sequenceNumberAccessConditions",
        "ifSequenceNumberEqualTo"
      ],
      mapper: {
        serializedName: "x-ms-if-sequence-number-eq",
        xmlName: "x-ms-if-sequence-number-eq",
        type: {
          name: "Number"
        }
      }
    };
    exports.pageWrite1 = {
      parameterPath: "pageWrite",
      mapper: {
        defaultValue: "clear",
        isConstant: true,
        serializedName: "x-ms-page-write",
        type: {
          name: "String"
        }
      }
    };
    exports.sourceUrl = {
      parameterPath: "sourceUrl",
      mapper: {
        serializedName: "x-ms-copy-source",
        required: true,
        xmlName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      }
    };
    exports.sourceRange = {
      parameterPath: "sourceRange",
      mapper: {
        serializedName: "x-ms-source-range",
        required: true,
        xmlName: "x-ms-source-range",
        type: {
          name: "String"
        }
      }
    };
    exports.sourceContentCrc64 = {
      parameterPath: ["options", "sourceContentCrc64"],
      mapper: {
        serializedName: "x-ms-source-content-crc64",
        xmlName: "x-ms-source-content-crc64",
        type: {
          name: "ByteArray"
        }
      }
    };
    exports.range1 = {
      parameterPath: "range",
      mapper: {
        serializedName: "x-ms-range",
        required: true,
        xmlName: "x-ms-range",
        type: {
          name: "String"
        }
      }
    };
    exports.comp20 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "pagelist",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.prevsnapshot = {
      parameterPath: ["options", "prevsnapshot"],
      mapper: {
        serializedName: "prevsnapshot",
        xmlName: "prevsnapshot",
        type: {
          name: "String"
        }
      }
    };
    exports.prevSnapshotUrl = {
      parameterPath: ["options", "prevSnapshotUrl"],
      mapper: {
        serializedName: "x-ms-previous-snapshot-url",
        xmlName: "x-ms-previous-snapshot-url",
        type: {
          name: "String"
        }
      }
    };
    exports.sequenceNumberAction = {
      parameterPath: "sequenceNumberAction",
      mapper: {
        serializedName: "x-ms-sequence-number-action",
        required: true,
        xmlName: "x-ms-sequence-number-action",
        type: {
          name: "Enum",
          allowedValues: ["max", "update", "increment"]
        }
      }
    };
    exports.comp21 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "incrementalcopy",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.blobType1 = {
      parameterPath: "blobType",
      mapper: {
        defaultValue: "AppendBlob",
        isConstant: true,
        serializedName: "x-ms-blob-type",
        type: {
          name: "String"
        }
      }
    };
    exports.comp22 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "appendblock",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.maxSize = {
      parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
      mapper: {
        serializedName: "x-ms-blob-condition-maxsize",
        xmlName: "x-ms-blob-condition-maxsize",
        type: {
          name: "Number"
        }
      }
    };
    exports.appendPosition = {
      parameterPath: [
        "options",
        "appendPositionAccessConditions",
        "appendPosition"
      ],
      mapper: {
        serializedName: "x-ms-blob-condition-appendpos",
        xmlName: "x-ms-blob-condition-appendpos",
        type: {
          name: "Number"
        }
      }
    };
    exports.sourceRange1 = {
      parameterPath: ["options", "sourceRange"],
      mapper: {
        serializedName: "x-ms-source-range",
        xmlName: "x-ms-source-range",
        type: {
          name: "String"
        }
      }
    };
    exports.comp23 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "seal",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.blobType2 = {
      parameterPath: "blobType",
      mapper: {
        defaultValue: "BlockBlob",
        isConstant: true,
        serializedName: "x-ms-blob-type",
        type: {
          name: "String"
        }
      }
    };
    exports.copySourceBlobProperties = {
      parameterPath: ["options", "copySourceBlobProperties"],
      mapper: {
        serializedName: "x-ms-copy-source-blob-properties",
        xmlName: "x-ms-copy-source-blob-properties",
        type: {
          name: "Boolean"
        }
      }
    };
    exports.comp24 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "block",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.blockId = {
      parameterPath: "blockId",
      mapper: {
        serializedName: "blockid",
        required: true,
        xmlName: "blockid",
        type: {
          name: "String"
        }
      }
    };
    exports.blocks = {
      parameterPath: "blocks",
      mapper: mappers_js_1.BlockLookupList
    };
    exports.comp25 = {
      parameterPath: "comp",
      mapper: {
        defaultValue: "blocklist",
        isConstant: true,
        serializedName: "comp",
        type: {
          name: "String"
        }
      }
    };
    exports.listType = {
      parameterPath: "listType",
      mapper: {
        defaultValue: "committed",
        serializedName: "blocklisttype",
        required: true,
        xmlName: "blocklisttype",
        type: {
          name: "Enum",
          allowedValues: ["committed", "uncommitted", "all"]
        }
      }
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/service.js
var require_service = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServiceImpl = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var coreClient = tslib_1.__importStar(require_commonjs8());
    var Mappers = tslib_1.__importStar(require_mappers());
    var Parameters = tslib_1.__importStar(require_parameters());
    var ServiceImpl = class {
      client;
      /**
       * Initialize a new instance of the class Service class.
       * @param client Reference to the service client
       */
      constructor(client) {
        this.client = client;
      }
      /**
       * Sets properties for a storage account's Blob service endpoint, including properties for Storage
       * Analytics and CORS (Cross-Origin Resource Sharing) rules
       * @param blobServiceProperties The StorageService properties.
       * @param options The options parameters.
       */
      setProperties(blobServiceProperties, options) {
        return this.client.sendOperationRequest({ blobServiceProperties, options }, setPropertiesOperationSpec);
      }
      /**
       * gets the properties of a storage account's Blob service, including properties for Storage Analytics
       * and CORS (Cross-Origin Resource Sharing) rules.
       * @param options The options parameters.
       */
      getProperties(options) {
        return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
      }
      /**
       * Retrieves statistics related to replication for the Blob service. It is only available on the
       * secondary location endpoint when read-access geo-redundant replication is enabled for the storage
       * account.
       * @param options The options parameters.
       */
      getStatistics(options) {
        return this.client.sendOperationRequest({ options }, getStatisticsOperationSpec);
      }
      /**
       * The List Containers Segment operation returns a list of the containers under the specified account
       * @param options The options parameters.
       */
      listContainersSegment(options) {
        return this.client.sendOperationRequest({ options }, listContainersSegmentOperationSpec);
      }
      /**
       * Retrieves a user delegation key for the Blob service. This is only a valid operation when using
       * bearer token authentication.
       * @param keyInfo Key information
       * @param options The options parameters.
       */
      getUserDelegationKey(keyInfo, options) {
        return this.client.sendOperationRequest({ keyInfo, options }, getUserDelegationKeyOperationSpec);
      }
      /**
       * Returns the sku name and account kind
       * @param options The options parameters.
       */
      getAccountInfo(options) {
        return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
      }
      /**
       * The Batch operation allows multiple API calls to be embedded into a single HTTP request.
       * @param contentLength The length of the request.
       * @param multipartContentType Required. The value of this header must be multipart/mixed with a batch
       *                             boundary. Example header value: multipart/mixed; boundary=batch_<GUID>
       * @param body Initial data
       * @param options The options parameters.
       */
      submitBatch(contentLength, multipartContentType, body, options) {
        return this.client.sendOperationRequest({ contentLength, multipartContentType, body, options }, submitBatchOperationSpec);
      }
      /**
       * The Filter Blobs operation enables callers to list blobs across all containers whose tags match a
       * given search expression.  Filter blobs searches across all containers within a storage account but
       * can be scoped within the expression to a single container.
       * @param options The options parameters.
       */
      filterBlobs(options) {
        return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
      }
    };
    exports.ServiceImpl = ServiceImpl;
    var xmlSerializer = coreClient.createSerializer(
      Mappers,
      /* isXml */
      true
    );
    var setPropertiesOperationSpec = {
      path: "/",
      httpMethod: "PUT",
      responses: {
        202: {
          headersMapper: Mappers.ServiceSetPropertiesHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ServiceSetPropertiesExceptionHeaders
        }
      },
      requestBody: Parameters.blobServiceProperties,
      queryParameters: [
        Parameters.restype,
        Parameters.comp,
        Parameters.timeoutInSeconds
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.contentType,
        Parameters.accept,
        Parameters.version,
        Parameters.requestId
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: xmlSerializer
    };
    var getPropertiesOperationSpec = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.BlobServiceProperties,
          headersMapper: Mappers.ServiceGetPropertiesHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ServiceGetPropertiesExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.restype,
        Parameters.comp,
        Parameters.timeoutInSeconds
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var getStatisticsOperationSpec = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.BlobServiceStatistics,
          headersMapper: Mappers.ServiceGetStatisticsHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ServiceGetStatisticsExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.restype,
        Parameters.timeoutInSeconds,
        Parameters.comp1
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var listContainersSegmentOperationSpec = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.ListContainersSegmentResponse,
          headersMapper: Mappers.ServiceListContainersSegmentHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ServiceListContainersSegmentExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.comp2,
        Parameters.prefix,
        Parameters.marker,
        Parameters.maxPageSize,
        Parameters.include
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var getUserDelegationKeyOperationSpec = {
      path: "/",
      httpMethod: "POST",
      responses: {
        200: {
          bodyMapper: Mappers.UserDelegationKey,
          headersMapper: Mappers.ServiceGetUserDelegationKeyHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ServiceGetUserDelegationKeyExceptionHeaders
        }
      },
      requestBody: Parameters.keyInfo,
      queryParameters: [
        Parameters.restype,
        Parameters.timeoutInSeconds,
        Parameters.comp3
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.contentType,
        Parameters.accept,
        Parameters.version,
        Parameters.requestId
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: xmlSerializer
    };
    var getAccountInfoOperationSpec = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: {
          headersMapper: Mappers.ServiceGetAccountInfoHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ServiceGetAccountInfoExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.comp,
        Parameters.timeoutInSeconds,
        Parameters.restype1
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var submitBatchOperationSpec = {
      path: "/",
      httpMethod: "POST",
      responses: {
        202: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse"
          },
          headersMapper: Mappers.ServiceSubmitBatchHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ServiceSubmitBatchExceptionHeaders
        }
      },
      requestBody: Parameters.body,
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp4],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.accept,
        Parameters.version,
        Parameters.requestId,
        Parameters.contentLength,
        Parameters.multipartContentType
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: xmlSerializer
    };
    var filterBlobsOperationSpec = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.FilterBlobSegment,
          headersMapper: Mappers.ServiceFilterBlobsHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ServiceFilterBlobsExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.marker,
        Parameters.maxPageSize,
        Parameters.comp5,
        Parameters.where
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/container.js
var require_container = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/container.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerImpl = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var coreClient = tslib_1.__importStar(require_commonjs8());
    var Mappers = tslib_1.__importStar(require_mappers());
    var Parameters = tslib_1.__importStar(require_parameters());
    var ContainerImpl = class {
      client;
      /**
       * Initialize a new instance of the class Container class.
       * @param client Reference to the service client
       */
      constructor(client) {
        this.client = client;
      }
      /**
       * creates a new container under the specified account. If the container with the same name already
       * exists, the operation fails
       * @param options The options parameters.
       */
      create(options) {
        return this.client.sendOperationRequest({ options }, createOperationSpec);
      }
      /**
       * returns all user-defined metadata and system properties for the specified container. The data
       * returned does not include the container's list of blobs
       * @param options The options parameters.
       */
      getProperties(options) {
        return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
      }
      /**
       * operation marks the specified container for deletion. The container and any blobs contained within
       * it are later deleted during garbage collection
       * @param options The options parameters.
       */
      delete(options) {
        return this.client.sendOperationRequest({ options }, deleteOperationSpec);
      }
      /**
       * operation sets one or more user-defined name-value pairs for the specified container.
       * @param options The options parameters.
       */
      setMetadata(options) {
        return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
      }
      /**
       * gets the permissions for the specified container. The permissions indicate whether container data
       * may be accessed publicly.
       * @param options The options parameters.
       */
      getAccessPolicy(options) {
        return this.client.sendOperationRequest({ options }, getAccessPolicyOperationSpec);
      }
      /**
       * sets the permissions for the specified container. The permissions indicate whether blobs in a
       * container may be accessed publicly.
       * @param options The options parameters.
       */
      setAccessPolicy(options) {
        return this.client.sendOperationRequest({ options }, setAccessPolicyOperationSpec);
      }
      /**
       * Restores a previously-deleted container.
       * @param options The options parameters.
       */
      restore(options) {
        return this.client.sendOperationRequest({ options }, restoreOperationSpec);
      }
      /**
       * Renames an existing container.
       * @param sourceContainerName Required.  Specifies the name of the container to rename.
       * @param options The options parameters.
       */
      rename(sourceContainerName, options) {
        return this.client.sendOperationRequest({ sourceContainerName, options }, renameOperationSpec);
      }
      /**
       * The Batch operation allows multiple API calls to be embedded into a single HTTP request.
       * @param contentLength The length of the request.
       * @param multipartContentType Required. The value of this header must be multipart/mixed with a batch
       *                             boundary. Example header value: multipart/mixed; boundary=batch_<GUID>
       * @param body Initial data
       * @param options The options parameters.
       */
      submitBatch(contentLength, multipartContentType, body, options) {
        return this.client.sendOperationRequest({ contentLength, multipartContentType, body, options }, submitBatchOperationSpec);
      }
      /**
       * The Filter Blobs operation enables callers to list blobs in a container whose tags match a given
       * search expression.  Filter blobs searches within the given container.
       * @param options The options parameters.
       */
      filterBlobs(options) {
        return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
      }
      /**
       * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
       * be 15 to 60 seconds, or can be infinite
       * @param options The options parameters.
       */
      acquireLease(options) {
        return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
      }
      /**
       * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
       * be 15 to 60 seconds, or can be infinite
       * @param leaseId Specifies the current lease ID on the resource.
       * @param options The options parameters.
       */
      releaseLease(leaseId, options) {
        return this.client.sendOperationRequest({ leaseId, options }, releaseLeaseOperationSpec);
      }
      /**
       * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
       * be 15 to 60 seconds, or can be infinite
       * @param leaseId Specifies the current lease ID on the resource.
       * @param options The options parameters.
       */
      renewLease(leaseId, options) {
        return this.client.sendOperationRequest({ leaseId, options }, renewLeaseOperationSpec);
      }
      /**
       * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
       * be 15 to 60 seconds, or can be infinite
       * @param options The options parameters.
       */
      breakLease(options) {
        return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
      }
      /**
       * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
       * be 15 to 60 seconds, or can be infinite
       * @param leaseId Specifies the current lease ID on the resource.
       * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400
       *                        (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor
       *                        (String) for a list of valid GUID string formats.
       * @param options The options parameters.
       */
      changeLease(leaseId, proposedLeaseId, options) {
        return this.client.sendOperationRequest({ leaseId, proposedLeaseId, options }, changeLeaseOperationSpec);
      }
      /**
       * [Update] The List Blobs operation returns a list of the blobs under the specified container
       * @param options The options parameters.
       */
      listBlobFlatSegment(options) {
        return this.client.sendOperationRequest({ options }, listBlobFlatSegmentOperationSpec);
      }
      /**
       * [Update] The List Blobs operation returns a list of the blobs under the specified container
       * @param delimiter When the request includes this parameter, the operation returns a BlobPrefix
       *                  element in the response body that acts as a placeholder for all blobs whose names begin with the
       *                  same substring up to the appearance of the delimiter character. The delimiter may be a single
       *                  character or a string.
       * @param options The options parameters.
       */
      listBlobHierarchySegment(delimiter, options) {
        return this.client.sendOperationRequest({ delimiter, options }, listBlobHierarchySegmentOperationSpec);
      }
      /**
       * Returns the sku name and account kind
       * @param options The options parameters.
       */
      getAccountInfo(options) {
        return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
      }
    };
    exports.ContainerImpl = ContainerImpl;
    var xmlSerializer = coreClient.createSerializer(
      Mappers,
      /* isXml */
      true
    );
    var createOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.ContainerCreateHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerCreateExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.metadata,
        Parameters.access,
        Parameters.defaultEncryptionScope,
        Parameters.preventEncryptionScopeOverride
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var getPropertiesOperationSpec = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          headersMapper: Mappers.ContainerGetPropertiesHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerGetPropertiesExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var deleteOperationSpec = {
      path: "/{containerName}",
      httpMethod: "DELETE",
      responses: {
        202: {
          headersMapper: Mappers.ContainerDeleteHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerDeleteExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var setMetadataOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.ContainerSetMetadataHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerSetMetadataExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp6
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var getAccessPolicyOperationSpec = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: {
            type: {
              name: "Sequence",
              element: {
                type: { name: "Composite", className: "SignedIdentifier" }
              }
            },
            serializedName: "SignedIdentifiers",
            xmlName: "SignedIdentifiers",
            xmlIsWrapped: true,
            xmlElementName: "SignedIdentifier"
          },
          headersMapper: Mappers.ContainerGetAccessPolicyHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerGetAccessPolicyExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp7
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var setAccessPolicyOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.ContainerSetAccessPolicyHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerSetAccessPolicyExceptionHeaders
        }
      },
      requestBody: Parameters.containerAcl,
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp7
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.contentType,
        Parameters.accept,
        Parameters.version,
        Parameters.requestId,
        Parameters.access,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: xmlSerializer
    };
    var restoreOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.ContainerRestoreHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerRestoreExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp8
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.deletedContainerName,
        Parameters.deletedContainerVersion
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var renameOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.ContainerRenameHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerRenameExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp9
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.sourceContainerName,
        Parameters.sourceLeaseId
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var submitBatchOperationSpec = {
      path: "/{containerName}",
      httpMethod: "POST",
      responses: {
        202: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse"
          },
          headersMapper: Mappers.ContainerSubmitBatchHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerSubmitBatchExceptionHeaders
        }
      },
      requestBody: Parameters.body,
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.comp4,
        Parameters.restype2
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.accept,
        Parameters.version,
        Parameters.requestId,
        Parameters.contentLength,
        Parameters.multipartContentType
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: xmlSerializer
    };
    var filterBlobsOperationSpec = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.FilterBlobSegment,
          headersMapper: Mappers.ContainerFilterBlobsHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerFilterBlobsExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.marker,
        Parameters.maxPageSize,
        Parameters.comp5,
        Parameters.where,
        Parameters.restype2
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var acquireLeaseOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.ContainerAcquireLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerAcquireLeaseExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp10
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.action,
        Parameters.duration,
        Parameters.proposedLeaseId
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var releaseLeaseOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.ContainerReleaseLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerReleaseLeaseExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp10
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.action1,
        Parameters.leaseId1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var renewLeaseOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.ContainerRenewLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerRenewLeaseExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp10
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.leaseId1,
        Parameters.action2
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var breakLeaseOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        202: {
          headersMapper: Mappers.ContainerBreakLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerBreakLeaseExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp10
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.action3,
        Parameters.breakPeriod
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var changeLeaseOperationSpec = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.ContainerChangeLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerChangeLeaseExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.restype2,
        Parameters.comp10
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.leaseId1,
        Parameters.action4,
        Parameters.proposedLeaseId1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var listBlobFlatSegmentOperationSpec = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.ListBlobsFlatSegmentResponse,
          headersMapper: Mappers.ContainerListBlobFlatSegmentHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerListBlobFlatSegmentExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.comp2,
        Parameters.prefix,
        Parameters.marker,
        Parameters.maxPageSize,
        Parameters.restype2,
        Parameters.include1
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var listBlobHierarchySegmentOperationSpec = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.ListBlobsHierarchySegmentResponse,
          headersMapper: Mappers.ContainerListBlobHierarchySegmentHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerListBlobHierarchySegmentExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.comp2,
        Parameters.prefix,
        Parameters.marker,
        Parameters.maxPageSize,
        Parameters.restype2,
        Parameters.include1,
        Parameters.delimiter
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var getAccountInfoOperationSpec = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          headersMapper: Mappers.ContainerGetAccountInfoHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.ContainerGetAccountInfoExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.comp,
        Parameters.timeoutInSeconds,
        Parameters.restype1
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/blob.js
var require_blob = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/blob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobImpl = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var coreClient = tslib_1.__importStar(require_commonjs8());
    var Mappers = tslib_1.__importStar(require_mappers());
    var Parameters = tslib_1.__importStar(require_parameters());
    var BlobImpl = class {
      client;
      /**
       * Initialize a new instance of the class Blob class.
       * @param client Reference to the service client
       */
      constructor(client) {
        this.client = client;
      }
      /**
       * The Download operation reads or downloads a blob from the system, including its metadata and
       * properties. You can also call Download to read a snapshot.
       * @param options The options parameters.
       */
      download(options) {
        return this.client.sendOperationRequest({ options }, downloadOperationSpec);
      }
      /**
       * The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system
       * properties for the blob. It does not return the content of the blob.
       * @param options The options parameters.
       */
      getProperties(options) {
        return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
      }
      /**
       * If the storage account's soft delete feature is disabled then, when a blob is deleted, it is
       * permanently removed from the storage account. If the storage account's soft delete feature is
       * enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible
       * immediately. However, the blob service retains the blob or snapshot for the number of days specified
       * by the DeleteRetentionPolicy section of [Storage service properties]
       * (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data is
       * permanently removed from the storage account. Note that you continue to be charged for the
       * soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify the
       * "include=deleted" query parameter to discover which blobs and snapshots have been soft deleted. You
       * can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a
       * soft-deleted blob or snapshot causes the service to return an HTTP status code of 404
       * (ResourceNotFound).
       * @param options The options parameters.
       */
      delete(options) {
        return this.client.sendOperationRequest({ options }, deleteOperationSpec);
      }
      /**
       * Undelete a blob that was previously soft deleted
       * @param options The options parameters.
       */
      undelete(options) {
        return this.client.sendOperationRequest({ options }, undeleteOperationSpec);
      }
      /**
       * Sets the time a blob will expire and be deleted.
       * @param expiryOptions Required. Indicates mode of the expiry time
       * @param options The options parameters.
       */
      setExpiry(expiryOptions, options) {
        return this.client.sendOperationRequest({ expiryOptions, options }, setExpiryOperationSpec);
      }
      /**
       * The Set HTTP Headers operation sets system properties on the blob
       * @param options The options parameters.
       */
      setHttpHeaders(options) {
        return this.client.sendOperationRequest({ options }, setHttpHeadersOperationSpec);
      }
      /**
       * The Set Immutability Policy operation sets the immutability policy on the blob
       * @param options The options parameters.
       */
      setImmutabilityPolicy(options) {
        return this.client.sendOperationRequest({ options }, setImmutabilityPolicyOperationSpec);
      }
      /**
       * The Delete Immutability Policy operation deletes the immutability policy on the blob
       * @param options The options parameters.
       */
      deleteImmutabilityPolicy(options) {
        return this.client.sendOperationRequest({ options }, deleteImmutabilityPolicyOperationSpec);
      }
      /**
       * The Set Legal Hold operation sets a legal hold on the blob.
       * @param legalHold Specified if a legal hold should be set on the blob.
       * @param options The options parameters.
       */
      setLegalHold(legalHold, options) {
        return this.client.sendOperationRequest({ legalHold, options }, setLegalHoldOperationSpec);
      }
      /**
       * The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more
       * name-value pairs
       * @param options The options parameters.
       */
      setMetadata(options) {
        return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
      }
      /**
       * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
       * operations
       * @param options The options parameters.
       */
      acquireLease(options) {
        return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
      }
      /**
       * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
       * operations
       * @param leaseId Specifies the current lease ID on the resource.
       * @param options The options parameters.
       */
      releaseLease(leaseId, options) {
        return this.client.sendOperationRequest({ leaseId, options }, releaseLeaseOperationSpec);
      }
      /**
       * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
       * operations
       * @param leaseId Specifies the current lease ID on the resource.
       * @param options The options parameters.
       */
      renewLease(leaseId, options) {
        return this.client.sendOperationRequest({ leaseId, options }, renewLeaseOperationSpec);
      }
      /**
       * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
       * operations
       * @param leaseId Specifies the current lease ID on the resource.
       * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400
       *                        (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor
       *                        (String) for a list of valid GUID string formats.
       * @param options The options parameters.
       */
      changeLease(leaseId, proposedLeaseId, options) {
        return this.client.sendOperationRequest({ leaseId, proposedLeaseId, options }, changeLeaseOperationSpec);
      }
      /**
       * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
       * operations
       * @param options The options parameters.
       */
      breakLease(options) {
        return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
      }
      /**
       * The Create Snapshot operation creates a read-only snapshot of a blob
       * @param options The options parameters.
       */
      createSnapshot(options) {
        return this.client.sendOperationRequest({ options }, createSnapshotOperationSpec);
      }
      /**
       * The Start Copy From URL operation copies a blob or an internet resource to a new blob.
       * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
       *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
       *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
       *                   access signature.
       * @param options The options parameters.
       */
      startCopyFromURL(copySource, options) {
        return this.client.sendOperationRequest({ copySource, options }, startCopyFromURLOperationSpec);
      }
      /**
       * The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return
       * a response until the copy is complete.
       * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
       *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
       *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
       *                   access signature.
       * @param options The options parameters.
       */
      copyFromURL(copySource, options) {
        return this.client.sendOperationRequest({ copySource, options }, copyFromURLOperationSpec);
      }
      /**
       * The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination
       * blob with zero length and full metadata.
       * @param copyId The copy identifier provided in the x-ms-copy-id header of the original Copy Blob
       *               operation.
       * @param options The options parameters.
       */
      abortCopyFromURL(copyId, options) {
        return this.client.sendOperationRequest({ copyId, options }, abortCopyFromURLOperationSpec);
      }
      /**
       * The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium
       * storage account and on a block blob in a blob storage account (locally redundant storage only). A
       * premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block
       * blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's
       * ETag.
       * @param tier Indicates the tier to be set on the blob.
       * @param options The options parameters.
       */
      setTier(tier, options) {
        return this.client.sendOperationRequest({ tier, options }, setTierOperationSpec);
      }
      /**
       * Returns the sku name and account kind
       * @param options The options parameters.
       */
      getAccountInfo(options) {
        return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
      }
      /**
       * The Query operation enables users to select/project on blob data by providing simple query
       * expressions.
       * @param options The options parameters.
       */
      query(options) {
        return this.client.sendOperationRequest({ options }, queryOperationSpec);
      }
      /**
       * The Get Tags operation enables users to get the tags associated with a blob.
       * @param options The options parameters.
       */
      getTags(options) {
        return this.client.sendOperationRequest({ options }, getTagsOperationSpec);
      }
      /**
       * The Set Tags operation enables users to set tags on a blob.
       * @param options The options parameters.
       */
      setTags(options) {
        return this.client.sendOperationRequest({ options }, setTagsOperationSpec);
      }
    };
    exports.BlobImpl = BlobImpl;
    var xmlSerializer = coreClient.createSerializer(
      Mappers,
      /* isXml */
      true
    );
    var downloadOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse"
          },
          headersMapper: Mappers.BlobDownloadHeaders
        },
        206: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse"
          },
          headersMapper: Mappers.BlobDownloadHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobDownloadExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.versionId
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.range,
        Parameters.rangeGetContentMD5,
        Parameters.rangeGetContentCRC64,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var getPropertiesOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "HEAD",
      responses: {
        200: {
          headersMapper: Mappers.BlobGetPropertiesHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobGetPropertiesExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.versionId
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var deleteOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "DELETE",
      responses: {
        202: {
          headersMapper: Mappers.BlobDeleteHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobDeleteExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.blobDeleteType
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.deleteSnapshots
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var undeleteOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobUndeleteHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobUndeleteExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp8],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var setExpiryOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobSetExpiryHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobSetExpiryExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp11],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.expiryOptions,
        Parameters.expiresOn
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var setHttpHeadersOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobSetHttpHeadersHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobSetHttpHeadersExceptionHeaders
        }
      },
      queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.blobCacheControl,
        Parameters.blobContentType,
        Parameters.blobContentMD5,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentDisposition
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var setImmutabilityPolicyOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobSetImmutabilityPolicyHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobSetImmutabilityPolicyExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.comp12
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifUnmodifiedSince,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var deleteImmutabilityPolicyOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "DELETE",
      responses: {
        200: {
          headersMapper: Mappers.BlobDeleteImmutabilityPolicyHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobDeleteImmutabilityPolicyExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.comp12
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var setLegalHoldOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobSetLegalHoldHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobSetLegalHoldExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.comp13
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.legalHold
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var setMetadataOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobSetMetadataHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobSetMetadataExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp6],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.encryptionScope
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var acquireLeaseOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.BlobAcquireLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobAcquireLeaseExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.action,
        Parameters.duration,
        Parameters.proposedLeaseId,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var releaseLeaseOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobReleaseLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobReleaseLeaseExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.action1,
        Parameters.leaseId1,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var renewLeaseOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobRenewLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobRenewLeaseExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.leaseId1,
        Parameters.action2,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var changeLeaseOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobChangeLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobChangeLeaseExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.leaseId1,
        Parameters.action4,
        Parameters.proposedLeaseId1,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var breakLeaseOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        202: {
          headersMapper: Mappers.BlobBreakLeaseHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobBreakLeaseExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.action3,
        Parameters.breakPeriod,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var createSnapshotOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.BlobCreateSnapshotHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobCreateSnapshotExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp14],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.encryptionScope
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var startCopyFromURLOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        202: {
          headersMapper: Mappers.BlobStartCopyFromURLHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobStartCopyFromURLExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.tier,
        Parameters.rehydratePriority,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch,
        Parameters.sourceIfTags,
        Parameters.copySource,
        Parameters.blobTagsString,
        Parameters.sealBlob,
        Parameters.legalHold1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var copyFromURLOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        202: {
          headersMapper: Mappers.BlobCopyFromURLHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobCopyFromURLExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.encryptionScope,
        Parameters.tier,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch,
        Parameters.copySource,
        Parameters.blobTagsString,
        Parameters.legalHold1,
        Parameters.xMsRequiresSync,
        Parameters.sourceContentMD5,
        Parameters.copySourceAuthorization,
        Parameters.copySourceTags,
        Parameters.fileRequestIntent
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var abortCopyFromURLOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        204: {
          headersMapper: Mappers.BlobAbortCopyFromURLHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobAbortCopyFromURLExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.comp15,
        Parameters.copyId
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.copyActionAbortConstant
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var setTierOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.BlobSetTierHeaders
        },
        202: {
          headersMapper: Mappers.BlobSetTierHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobSetTierExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.comp16
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifTags,
        Parameters.rehydratePriority,
        Parameters.tier1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var getAccountInfoOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          headersMapper: Mappers.BlobGetAccountInfoHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobGetAccountInfoExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.comp,
        Parameters.timeoutInSeconds,
        Parameters.restype1
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var queryOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "POST",
      responses: {
        200: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse"
          },
          headersMapper: Mappers.BlobQueryHeaders
        },
        206: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse"
          },
          headersMapper: Mappers.BlobQueryHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobQueryExceptionHeaders
        }
      },
      requestBody: Parameters.queryRequest,
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.comp17
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.contentType,
        Parameters.accept,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: xmlSerializer
    };
    var getTagsOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.BlobTags,
          headersMapper: Mappers.BlobGetTagsHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobGetTagsExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.comp18
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var setTagsOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        204: {
          headersMapper: Mappers.BlobSetTagsHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlobSetTagsExceptionHeaders
        }
      },
      requestBody: Parameters.tags,
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.versionId,
        Parameters.comp18
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.contentType,
        Parameters.accept,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId,
        Parameters.ifTags,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: xmlSerializer
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/pageBlob.js
var require_pageBlob = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/pageBlob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageBlobImpl = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var coreClient = tslib_1.__importStar(require_commonjs8());
    var Mappers = tslib_1.__importStar(require_mappers());
    var Parameters = tslib_1.__importStar(require_parameters());
    var PageBlobImpl = class {
      client;
      /**
       * Initialize a new instance of the class PageBlob class.
       * @param client Reference to the service client
       */
      constructor(client) {
        this.client = client;
      }
      /**
       * The Create operation creates a new page blob.
       * @param contentLength The length of the request.
       * @param blobContentLength This header specifies the maximum size for the page blob, up to 1 TB. The
       *                          page blob size must be aligned to a 512-byte boundary.
       * @param options The options parameters.
       */
      create(contentLength, blobContentLength, options) {
        return this.client.sendOperationRequest({ contentLength, blobContentLength, options }, createOperationSpec);
      }
      /**
       * The Upload Pages operation writes a range of pages to a page blob
       * @param contentLength The length of the request.
       * @param body Initial data
       * @param options The options parameters.
       */
      uploadPages(contentLength, body, options) {
        return this.client.sendOperationRequest({ contentLength, body, options }, uploadPagesOperationSpec);
      }
      /**
       * The Clear Pages operation clears a set of pages from a page blob
       * @param contentLength The length of the request.
       * @param options The options parameters.
       */
      clearPages(contentLength, options) {
        return this.client.sendOperationRequest({ contentLength, options }, clearPagesOperationSpec);
      }
      /**
       * The Upload Pages operation writes a range of pages to a page blob where the contents are read from a
       * URL
       * @param sourceUrl Specify a URL to the copy source.
       * @param sourceRange Bytes of source data in the specified range. The length of this range should
       *                    match the ContentLength header and x-ms-range/Range destination range header.
       * @param contentLength The length of the request.
       * @param range The range of bytes to which the source range would be written. The range should be 512
       *              aligned and range-end is required.
       * @param options The options parameters.
       */
      uploadPagesFromURL(sourceUrl, sourceRange, contentLength, range, options) {
        return this.client.sendOperationRequest({ sourceUrl, sourceRange, contentLength, range, options }, uploadPagesFromURLOperationSpec);
      }
      /**
       * The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot of a
       * page blob
       * @param options The options parameters.
       */
      getPageRanges(options) {
        return this.client.sendOperationRequest({ options }, getPageRangesOperationSpec);
      }
      /**
       * The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob that were
       * changed between target blob and previous snapshot.
       * @param options The options parameters.
       */
      getPageRangesDiff(options) {
        return this.client.sendOperationRequest({ options }, getPageRangesDiffOperationSpec);
      }
      /**
       * Resize the Blob
       * @param blobContentLength This header specifies the maximum size for the page blob, up to 1 TB. The
       *                          page blob size must be aligned to a 512-byte boundary.
       * @param options The options parameters.
       */
      resize(blobContentLength, options) {
        return this.client.sendOperationRequest({ blobContentLength, options }, resizeOperationSpec);
      }
      /**
       * Update the sequence number of the blob
       * @param sequenceNumberAction Required if the x-ms-blob-sequence-number header is set for the request.
       *                             This property applies to page blobs only. This property indicates how the service should modify the
       *                             blob's sequence number
       * @param options The options parameters.
       */
      updateSequenceNumber(sequenceNumberAction, options) {
        return this.client.sendOperationRequest({ sequenceNumberAction, options }, updateSequenceNumberOperationSpec);
      }
      /**
       * The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob.
       * The snapshot is copied such that only the differential changes between the previously copied
       * snapshot are transferred to the destination. The copied snapshots are complete copies of the
       * original snapshot and can be read or copied from as usual. This API is supported since REST version
       * 2016-05-31.
       * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
       *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
       *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
       *                   access signature.
       * @param options The options parameters.
       */
      copyIncremental(copySource, options) {
        return this.client.sendOperationRequest({ copySource, options }, copyIncrementalOperationSpec);
      }
    };
    exports.PageBlobImpl = PageBlobImpl;
    var xmlSerializer = coreClient.createSerializer(
      Mappers,
      /* isXml */
      true
    );
    var createOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.PageBlobCreateHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.PageBlobCreateExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.contentLength,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.blobCacheControl,
        Parameters.blobContentType,
        Parameters.blobContentMD5,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentDisposition,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.encryptionScope,
        Parameters.tier,
        Parameters.blobTagsString,
        Parameters.legalHold1,
        Parameters.blobType,
        Parameters.blobContentLength,
        Parameters.blobSequenceNumber
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var uploadPagesOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.PageBlobUploadPagesHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.PageBlobUploadPagesExceptionHeaders
        }
      },
      requestBody: Parameters.body1,
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.contentLength,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.range,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.encryptionScope,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64,
        Parameters.contentType1,
        Parameters.accept2,
        Parameters.pageWrite,
        Parameters.ifSequenceNumberLessThanOrEqualTo,
        Parameters.ifSequenceNumberLessThan,
        Parameters.ifSequenceNumberEqualTo
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "binary",
      serializer: xmlSerializer
    };
    var clearPagesOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.PageBlobClearPagesHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.PageBlobClearPagesExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.contentLength,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.range,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.encryptionScope,
        Parameters.ifSequenceNumberLessThanOrEqualTo,
        Parameters.ifSequenceNumberLessThan,
        Parameters.ifSequenceNumberEqualTo,
        Parameters.pageWrite1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var uploadPagesFromURLOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.PageBlobUploadPagesFromURLHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.PageBlobUploadPagesFromURLExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.contentLength,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.encryptionScope,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch,
        Parameters.sourceContentMD5,
        Parameters.copySourceAuthorization,
        Parameters.fileRequestIntent,
        Parameters.pageWrite,
        Parameters.ifSequenceNumberLessThanOrEqualTo,
        Parameters.ifSequenceNumberLessThan,
        Parameters.ifSequenceNumberEqualTo,
        Parameters.sourceUrl,
        Parameters.sourceRange,
        Parameters.sourceContentCrc64,
        Parameters.range1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var getPageRangesOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.PageList,
          headersMapper: Mappers.PageBlobGetPageRangesHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.PageBlobGetPageRangesExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.marker,
        Parameters.maxPageSize,
        Parameters.snapshot,
        Parameters.comp20
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.range,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var getPageRangesDiffOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.PageList,
          headersMapper: Mappers.PageBlobGetPageRangesDiffHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.PageBlobGetPageRangesDiffExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.marker,
        Parameters.maxPageSize,
        Parameters.snapshot,
        Parameters.comp20,
        Parameters.prevsnapshot
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.range,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.prevSnapshotUrl
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var resizeOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.PageBlobResizeHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.PageBlobResizeExceptionHeaders
        }
      },
      queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.encryptionScope,
        Parameters.blobContentLength
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var updateSequenceNumberOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.PageBlobUpdateSequenceNumberHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.PageBlobUpdateSequenceNumberExceptionHeaders
        }
      },
      queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.blobSequenceNumber,
        Parameters.sequenceNumberAction
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var copyIncrementalOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        202: {
          headersMapper: Mappers.PageBlobCopyIncrementalHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.PageBlobCopyIncrementalExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp21],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.copySource
      ],
      isXML: true,
      serializer: xmlSerializer
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/appendBlob.js
var require_appendBlob = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/appendBlob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AppendBlobImpl = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var coreClient = tslib_1.__importStar(require_commonjs8());
    var Mappers = tslib_1.__importStar(require_mappers());
    var Parameters = tslib_1.__importStar(require_parameters());
    var AppendBlobImpl = class {
      client;
      /**
       * Initialize a new instance of the class AppendBlob class.
       * @param client Reference to the service client
       */
      constructor(client) {
        this.client = client;
      }
      /**
       * The Create Append Blob operation creates a new append blob.
       * @param contentLength The length of the request.
       * @param options The options parameters.
       */
      create(contentLength, options) {
        return this.client.sendOperationRequest({ contentLength, options }, createOperationSpec);
      }
      /**
       * The Append Block operation commits a new block of data to the end of an existing append blob. The
       * Append Block operation is permitted only if the blob was created with x-ms-blob-type set to
       * AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
       * @param contentLength The length of the request.
       * @param body Initial data
       * @param options The options parameters.
       */
      appendBlock(contentLength, body, options) {
        return this.client.sendOperationRequest({ contentLength, body, options }, appendBlockOperationSpec);
      }
      /**
       * The Append Block operation commits a new block of data to the end of an existing append blob where
       * the contents are read from a source url. The Append Block operation is permitted only if the blob
       * was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version
       * 2015-02-21 version or later.
       * @param sourceUrl Specify a URL to the copy source.
       * @param contentLength The length of the request.
       * @param options The options parameters.
       */
      appendBlockFromUrl(sourceUrl, contentLength, options) {
        return this.client.sendOperationRequest({ sourceUrl, contentLength, options }, appendBlockFromUrlOperationSpec);
      }
      /**
       * The Seal operation seals the Append Blob to make it read-only. Seal is supported only on version
       * 2019-12-12 version or later.
       * @param options The options parameters.
       */
      seal(options) {
        return this.client.sendOperationRequest({ options }, sealOperationSpec);
      }
    };
    exports.AppendBlobImpl = AppendBlobImpl;
    var xmlSerializer = coreClient.createSerializer(
      Mappers,
      /* isXml */
      true
    );
    var createOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.AppendBlobCreateHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.AppendBlobCreateExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.contentLength,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.blobCacheControl,
        Parameters.blobContentType,
        Parameters.blobContentMD5,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentDisposition,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.encryptionScope,
        Parameters.blobTagsString,
        Parameters.legalHold1,
        Parameters.blobType1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var appendBlockOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.AppendBlobAppendBlockHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.AppendBlobAppendBlockExceptionHeaders
        }
      },
      requestBody: Parameters.body1,
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.contentLength,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.encryptionScope,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64,
        Parameters.contentType1,
        Parameters.accept2,
        Parameters.maxSize,
        Parameters.appendPosition
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "binary",
      serializer: xmlSerializer
    };
    var appendBlockFromUrlOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.AppendBlobAppendBlockFromUrlHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.AppendBlobAppendBlockFromUrlExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.contentLength,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.encryptionScope,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch,
        Parameters.sourceContentMD5,
        Parameters.copySourceAuthorization,
        Parameters.fileRequestIntent,
        Parameters.transactionalContentMD5,
        Parameters.sourceUrl,
        Parameters.sourceContentCrc64,
        Parameters.maxSize,
        Parameters.appendPosition,
        Parameters.sourceRange1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var sealOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: {
          headersMapper: Mappers.AppendBlobSealHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.AppendBlobSealExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp23],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.appendPosition
      ],
      isXML: true,
      serializer: xmlSerializer
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/blockBlob.js
var require_blockBlob = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/blockBlob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockBlobImpl = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var coreClient = tslib_1.__importStar(require_commonjs8());
    var Mappers = tslib_1.__importStar(require_mappers());
    var Parameters = tslib_1.__importStar(require_parameters());
    var BlockBlobImpl = class {
      client;
      /**
       * Initialize a new instance of the class BlockBlob class.
       * @param client Reference to the service client
       */
      constructor(client) {
        this.client = client;
      }
      /**
       * The Upload Block Blob operation updates the content of an existing block blob. Updating an existing
       * block blob overwrites any existing metadata on the blob. Partial updates are not supported with Put
       * Blob; the content of the existing blob is overwritten with the content of the new blob. To perform a
       * partial update of the content of a block blob, use the Put Block List operation.
       * @param contentLength The length of the request.
       * @param body Initial data
       * @param options The options parameters.
       */
      upload(contentLength, body, options) {
        return this.client.sendOperationRequest({ contentLength, body, options }, uploadOperationSpec);
      }
      /**
       * The Put Blob from URL operation creates a new Block Blob where the contents of the blob are read
       * from a given URL.  This API is supported beginning with the 2020-04-08 version. Partial updates are
       * not supported with Put Blob from URL; the content of an existing blob is overwritten with the
       * content of the new blob.  To perform partial updates to a block blobs contents using a source URL,
       * use the Put Block from URL API in conjunction with Put Block List.
       * @param contentLength The length of the request.
       * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
       *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
       *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
       *                   access signature.
       * @param options The options parameters.
       */
      putBlobFromUrl(contentLength, copySource, options) {
        return this.client.sendOperationRequest({ contentLength, copySource, options }, putBlobFromUrlOperationSpec);
      }
      /**
       * The Stage Block operation creates a new block to be committed as part of a blob
       * @param blockId A valid Base64 string value that identifies the block. Prior to encoding, the string
       *                must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified
       *                for the blockid parameter must be the same size for each block.
       * @param contentLength The length of the request.
       * @param body Initial data
       * @param options The options parameters.
       */
      stageBlock(blockId, contentLength, body, options) {
        return this.client.sendOperationRequest({ blockId, contentLength, body, options }, stageBlockOperationSpec);
      }
      /**
       * The Stage Block operation creates a new block to be committed as part of a blob where the contents
       * are read from a URL.
       * @param blockId A valid Base64 string value that identifies the block. Prior to encoding, the string
       *                must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified
       *                for the blockid parameter must be the same size for each block.
       * @param contentLength The length of the request.
       * @param sourceUrl Specify a URL to the copy source.
       * @param options The options parameters.
       */
      stageBlockFromURL(blockId, contentLength, sourceUrl, options) {
        return this.client.sendOperationRequest({ blockId, contentLength, sourceUrl, options }, stageBlockFromURLOperationSpec);
      }
      /**
       * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the
       * blob. In order to be written as part of a blob, a block must have been successfully written to the
       * server in a prior Put Block operation. You can call Put Block List to update a blob by uploading
       * only those blocks that have changed, then committing the new and existing blocks together. You can
       * do this by specifying whether to commit a block from the committed block list or from the
       * uncommitted block list, or to commit the most recently uploaded version of the block, whichever list
       * it may belong to.
       * @param blocks Blob Blocks.
       * @param options The options parameters.
       */
      commitBlockList(blocks, options) {
        return this.client.sendOperationRequest({ blocks, options }, commitBlockListOperationSpec);
      }
      /**
       * The Get Block List operation retrieves the list of blocks that have been uploaded as part of a block
       * blob
       * @param listType Specifies whether to return the list of committed blocks, the list of uncommitted
       *                 blocks, or both lists together.
       * @param options The options parameters.
       */
      getBlockList(listType, options) {
        return this.client.sendOperationRequest({ listType, options }, getBlockListOperationSpec);
      }
    };
    exports.BlockBlobImpl = BlockBlobImpl;
    var xmlSerializer = coreClient.createSerializer(
      Mappers,
      /* isXml */
      true
    );
    var uploadOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.BlockBlobUploadHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlockBlobUploadExceptionHeaders
        }
      },
      requestBody: Parameters.body1,
      queryParameters: [Parameters.timeoutInSeconds],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.contentLength,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.blobCacheControl,
        Parameters.blobContentType,
        Parameters.blobContentMD5,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentDisposition,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.encryptionScope,
        Parameters.tier,
        Parameters.blobTagsString,
        Parameters.legalHold1,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64,
        Parameters.contentType1,
        Parameters.accept2,
        Parameters.blobType2
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "binary",
      serializer: xmlSerializer
    };
    var putBlobFromUrlOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.BlockBlobPutBlobFromUrlHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlockBlobPutBlobFromUrlExceptionHeaders
        }
      },
      queryParameters: [Parameters.timeoutInSeconds],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.contentLength,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.blobCacheControl,
        Parameters.blobContentType,
        Parameters.blobContentMD5,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentDisposition,
        Parameters.encryptionScope,
        Parameters.tier,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch,
        Parameters.sourceIfTags,
        Parameters.copySource,
        Parameters.blobTagsString,
        Parameters.sourceContentMD5,
        Parameters.copySourceAuthorization,
        Parameters.copySourceTags,
        Parameters.fileRequestIntent,
        Parameters.transactionalContentMD5,
        Parameters.blobType2,
        Parameters.copySourceBlobProperties
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var stageBlockOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.BlockBlobStageBlockHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlockBlobStageBlockExceptionHeaders
        }
      },
      requestBody: Parameters.body1,
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.comp24,
        Parameters.blockId
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.contentLength,
        Parameters.leaseId,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64,
        Parameters.contentType1,
        Parameters.accept2
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "binary",
      serializer: xmlSerializer
    };
    var stageBlockFromURLOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.BlockBlobStageBlockFromURLHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlockBlobStageBlockFromURLExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.comp24,
        Parameters.blockId
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.contentLength,
        Parameters.leaseId,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch,
        Parameters.sourceContentMD5,
        Parameters.copySourceAuthorization,
        Parameters.fileRequestIntent,
        Parameters.sourceUrl,
        Parameters.sourceContentCrc64,
        Parameters.sourceRange1
      ],
      isXML: true,
      serializer: xmlSerializer
    };
    var commitBlockListOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: {
          headersMapper: Mappers.BlockBlobCommitBlockListHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlockBlobCommitBlockListExceptionHeaders
        }
      },
      requestBody: Parameters.blocks,
      queryParameters: [Parameters.timeoutInSeconds, Parameters.comp25],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.contentType,
        Parameters.accept,
        Parameters.version,
        Parameters.requestId,
        Parameters.metadata,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.blobCacheControl,
        Parameters.blobContentType,
        Parameters.blobContentMD5,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentDisposition,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.encryptionScope,
        Parameters.tier,
        Parameters.blobTagsString,
        Parameters.legalHold1,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64
      ],
      isXML: true,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: xmlSerializer
    };
    var getBlockListOperationSpec = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.BlockList,
          headersMapper: Mappers.BlockBlobGetBlockListHeaders
        },
        default: {
          bodyMapper: Mappers.StorageError,
          headersMapper: Mappers.BlockBlobGetBlockListExceptionHeaders
        }
      },
      queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.snapshot,
        Parameters.comp25,
        Parameters.listType
      ],
      urlParameters: [Parameters.url],
      headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifTags
      ],
      isXML: true,
      serializer: xmlSerializer
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/index.js
var require_operations = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_service(), exports);
    tslib_1.__exportStar(require_container(), exports);
    tslib_1.__exportStar(require_blob(), exports);
    tslib_1.__exportStar(require_pageBlob(), exports);
    tslib_1.__exportStar(require_appendBlob(), exports);
    tslib_1.__exportStar(require_blockBlob(), exports);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/storageClient.js
var require_storageClient = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/storageClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageClient = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var coreHttpCompat = tslib_1.__importStar(require_commonjs9());
    var index_js_1 = require_operations();
    var StorageClient = class extends coreHttpCompat.ExtendedServiceClient {
      url;
      version;
      /**
       * Initializes a new instance of the StorageClient class.
       * @param url The URL of the service account, container, or blob that is the target of the desired
       *            operation.
       * @param options The parameter options
       */
      constructor(url, options) {
        if (url === void 0) {
          throw new Error("'url' cannot be null");
        }
        if (!options) {
          options = {};
        }
        const defaults2 = {
          requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-azure-storage-blob/12.29.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        const optionsWithDefaults = {
          ...defaults2,
          ...options,
          userAgentOptions: {
            userAgentPrefix
          },
          endpoint: options.endpoint ?? options.baseUri ?? "{url}"
        };
        super(optionsWithDefaults);
        this.url = url;
        this.version = options.version || "2025-11-05";
        this.service = new index_js_1.ServiceImpl(this);
        this.container = new index_js_1.ContainerImpl(this);
        this.blob = new index_js_1.BlobImpl(this);
        this.pageBlob = new index_js_1.PageBlobImpl(this);
        this.appendBlob = new index_js_1.AppendBlobImpl(this);
        this.blockBlob = new index_js_1.BlockBlobImpl(this);
      }
      service;
      container;
      blob;
      pageBlob;
      appendBlob;
      blockBlob;
    };
    exports.StorageClient = StorageClient;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/service.js
var require_service2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/container.js
var require_container2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/container.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/blob.js
var require_blob2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/blob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/pageBlob.js
var require_pageBlob2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/pageBlob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/appendBlob.js
var require_appendBlob2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/appendBlob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/blockBlob.js
var require_blockBlob2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/blockBlob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/index.js
var require_operationsInterfaces = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_service2(), exports);
    tslib_1.__exportStar(require_container2(), exports);
    tslib_1.__exportStar(require_blob2(), exports);
    tslib_1.__exportStar(require_pageBlob2(), exports);
    tslib_1.__exportStar(require_appendBlob2(), exports);
    tslib_1.__exportStar(require_blockBlob2(), exports);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/index.js
var require_src2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generated/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageClient = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_models(), exports);
    var storageClient_js_1 = require_storageClient();
    Object.defineProperty(exports, "StorageClient", { enumerable: true, get: function() {
      return storageClient_js_1.StorageClient;
    } });
    tslib_1.__exportStar(require_operationsInterfaces(), exports);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageContextClient.js
var require_StorageContextClient = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/StorageContextClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageContextClient = void 0;
    var index_js_1 = require_src2();
    var StorageContextClient = class extends index_js_1.StorageClient {
      async sendOperationRequest(operationArguments, operationSpec) {
        const operationSpecToSend = { ...operationSpec };
        if (operationSpecToSend.path === "/{containerName}" || operationSpecToSend.path === "/{containerName}/{blob}") {
          operationSpecToSend.path = "";
        }
        return super.sendOperationRequest(operationArguments, operationSpecToSend);
      }
    };
    exports.StorageContextClient = StorageContextClient;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageClient.js
var require_StorageClient = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/StorageClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageClient = void 0;
    var StorageContextClient_js_1 = require_StorageContextClient();
    var Pipeline_js_1 = require_Pipeline();
    var utils_common_js_1 = require_utils_common();
    var StorageClient = class {
      /**
       * Encoded URL string value.
       */
      url;
      accountName;
      /**
       * Request policy pipeline.
       *
       * @internal
       */
      pipeline;
      /**
       * Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
       */
      credential;
      /**
       * StorageClient is a reference to protocol layer operations entry, which is
       * generated by AutoRest generator.
       */
      storageClientContext;
      /**
       */
      isHttps;
      /**
       * Creates an instance of StorageClient.
       * @param url - url to resource
       * @param pipeline - request policy pipeline.
       */
      constructor(url, pipeline) {
        this.url = (0, utils_common_js_1.escapeURLPath)(url);
        this.accountName = (0, utils_common_js_1.getAccountNameFromUrl)(url);
        this.pipeline = pipeline;
        this.storageClientContext = new StorageContextClient_js_1.StorageContextClient(this.url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline));
        this.isHttps = (0, utils_common_js_1.iEqual)((0, utils_common_js_1.getURLScheme)(this.url) || "", "https");
        this.credential = (0, Pipeline_js_1.getCredentialFromPipeline)(pipeline);
        const storageClientContext = this.storageClientContext;
        storageClientContext.requestContentType = void 0;
      }
    };
    exports.StorageClient = StorageClient;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/tracing.js
var require_tracing = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/utils/tracing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tracingClient = void 0;
    var core_tracing_1 = require_commonjs5();
    var constants_js_1 = require_constants9();
    exports.tracingClient = (0, core_tracing_1.createTracingClient)({
      packageName: "@azure/storage-blob",
      packageVersion: constants_js_1.SDK_VERSION,
      namespace: "Microsoft.Storage"
    });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/BlobSASPermissions.js
var require_BlobSASPermissions = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/sas/BlobSASPermissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobSASPermissions = void 0;
    var BlobSASPermissions = class _BlobSASPermissions {
      /**
       * Creates a {@link BlobSASPermissions} from the specified permissions string. This method will throw an
       * Error if it encounters a character that does not correspond to a valid permission.
       *
       * @param permissions -
       */
      static parse(permissions) {
        const blobSASPermissions = new _BlobSASPermissions();
        for (const char of permissions) {
          switch (char) {
            case "r":
              blobSASPermissions.read = true;
              break;
            case "a":
              blobSASPermissions.add = true;
              break;
            case "c":
              blobSASPermissions.create = true;
              break;
            case "w":
              blobSASPermissions.write = true;
              break;
            case "d":
              blobSASPermissions.delete = true;
              break;
            case "x":
              blobSASPermissions.deleteVersion = true;
              break;
            case "t":
              blobSASPermissions.tag = true;
              break;
            case "m":
              blobSASPermissions.move = true;
              break;
            case "e":
              blobSASPermissions.execute = true;
              break;
            case "i":
              blobSASPermissions.setImmutabilityPolicy = true;
              break;
            case "y":
              blobSASPermissions.permanentDelete = true;
              break;
            default:
              throw new RangeError(`Invalid permission: ${char}`);
          }
        }
        return blobSASPermissions;
      }
      /**
       * Creates a {@link BlobSASPermissions} from a raw object which contains same keys as it
       * and boolean values for them.
       *
       * @param permissionLike -
       */
      static from(permissionLike) {
        const blobSASPermissions = new _BlobSASPermissions();
        if (permissionLike.read) {
          blobSASPermissions.read = true;
        }
        if (permissionLike.add) {
          blobSASPermissions.add = true;
        }
        if (permissionLike.create) {
          blobSASPermissions.create = true;
        }
        if (permissionLike.write) {
          blobSASPermissions.write = true;
        }
        if (permissionLike.delete) {
          blobSASPermissions.delete = true;
        }
        if (permissionLike.deleteVersion) {
          blobSASPermissions.deleteVersion = true;
        }
        if (permissionLike.tag) {
          blobSASPermissions.tag = true;
        }
        if (permissionLike.move) {
          blobSASPermissions.move = true;
        }
        if (permissionLike.execute) {
          blobSASPermissions.execute = true;
        }
        if (permissionLike.setImmutabilityPolicy) {
          blobSASPermissions.setImmutabilityPolicy = true;
        }
        if (permissionLike.permanentDelete) {
          blobSASPermissions.permanentDelete = true;
        }
        return blobSASPermissions;
      }
      /**
       * Specifies Read access granted.
       */
      read = false;
      /**
       * Specifies Add access granted.
       */
      add = false;
      /**
       * Specifies Create access granted.
       */
      create = false;
      /**
       * Specifies Write access granted.
       */
      write = false;
      /**
       * Specifies Delete access granted.
       */
      delete = false;
      /**
       * Specifies Delete version access granted.
       */
      deleteVersion = false;
      /**
       * Specfies Tag access granted.
       */
      tag = false;
      /**
       * Specifies Move access granted.
       */
      move = false;
      /**
       * Specifies Execute access granted.
       */
      execute = false;
      /**
       * Specifies SetImmutabilityPolicy access granted.
       */
      setImmutabilityPolicy = false;
      /**
       * Specifies that Permanent Delete is permitted.
       */
      permanentDelete = false;
      /**
       * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
       * order accepted by the service.
       *
       * @returns A string which represents the BlobSASPermissions
       */
      toString() {
        const permissions = [];
        if (this.read) {
          permissions.push("r");
        }
        if (this.add) {
          permissions.push("a");
        }
        if (this.create) {
          permissions.push("c");
        }
        if (this.write) {
          permissions.push("w");
        }
        if (this.delete) {
          permissions.push("d");
        }
        if (this.deleteVersion) {
          permissions.push("x");
        }
        if (this.tag) {
          permissions.push("t");
        }
        if (this.move) {
          permissions.push("m");
        }
        if (this.execute) {
          permissions.push("e");
        }
        if (this.setImmutabilityPolicy) {
          permissions.push("i");
        }
        if (this.permanentDelete) {
          permissions.push("y");
        }
        return permissions.join("");
      }
    };
    exports.BlobSASPermissions = BlobSASPermissions;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/ContainerSASPermissions.js
var require_ContainerSASPermissions = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/sas/ContainerSASPermissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerSASPermissions = void 0;
    var ContainerSASPermissions = class _ContainerSASPermissions {
      /**
       * Creates an {@link ContainerSASPermissions} from the specified permissions string. This method will throw an
       * Error if it encounters a character that does not correspond to a valid permission.
       *
       * @param permissions -
       */
      static parse(permissions) {
        const containerSASPermissions = new _ContainerSASPermissions();
        for (const char of permissions) {
          switch (char) {
            case "r":
              containerSASPermissions.read = true;
              break;
            case "a":
              containerSASPermissions.add = true;
              break;
            case "c":
              containerSASPermissions.create = true;
              break;
            case "w":
              containerSASPermissions.write = true;
              break;
            case "d":
              containerSASPermissions.delete = true;
              break;
            case "l":
              containerSASPermissions.list = true;
              break;
            case "t":
              containerSASPermissions.tag = true;
              break;
            case "x":
              containerSASPermissions.deleteVersion = true;
              break;
            case "m":
              containerSASPermissions.move = true;
              break;
            case "e":
              containerSASPermissions.execute = true;
              break;
            case "i":
              containerSASPermissions.setImmutabilityPolicy = true;
              break;
            case "y":
              containerSASPermissions.permanentDelete = true;
              break;
            case "f":
              containerSASPermissions.filterByTags = true;
              break;
            default:
              throw new RangeError(`Invalid permission ${char}`);
          }
        }
        return containerSASPermissions;
      }
      /**
       * Creates a {@link ContainerSASPermissions} from a raw object which contains same keys as it
       * and boolean values for them.
       *
       * @param permissionLike -
       */
      static from(permissionLike) {
        const containerSASPermissions = new _ContainerSASPermissions();
        if (permissionLike.read) {
          containerSASPermissions.read = true;
        }
        if (permissionLike.add) {
          containerSASPermissions.add = true;
        }
        if (permissionLike.create) {
          containerSASPermissions.create = true;
        }
        if (permissionLike.write) {
          containerSASPermissions.write = true;
        }
        if (permissionLike.delete) {
          containerSASPermissions.delete = true;
        }
        if (permissionLike.list) {
          containerSASPermissions.list = true;
        }
        if (permissionLike.deleteVersion) {
          containerSASPermissions.deleteVersion = true;
        }
        if (permissionLike.tag) {
          containerSASPermissions.tag = true;
        }
        if (permissionLike.move) {
          containerSASPermissions.move = true;
        }
        if (permissionLike.execute) {
          containerSASPermissions.execute = true;
        }
        if (permissionLike.setImmutabilityPolicy) {
          containerSASPermissions.setImmutabilityPolicy = true;
        }
        if (permissionLike.permanentDelete) {
          containerSASPermissions.permanentDelete = true;
        }
        if (permissionLike.filterByTags) {
          containerSASPermissions.filterByTags = true;
        }
        return containerSASPermissions;
      }
      /**
       * Specifies Read access granted.
       */
      read = false;
      /**
       * Specifies Add access granted.
       */
      add = false;
      /**
       * Specifies Create access granted.
       */
      create = false;
      /**
       * Specifies Write access granted.
       */
      write = false;
      /**
       * Specifies Delete access granted.
       */
      delete = false;
      /**
       * Specifies Delete version access granted.
       */
      deleteVersion = false;
      /**
       * Specifies List access granted.
       */
      list = false;
      /**
       * Specfies Tag access granted.
       */
      tag = false;
      /**
       * Specifies Move access granted.
       */
      move = false;
      /**
       * Specifies Execute access granted.
       */
      execute = false;
      /**
       * Specifies SetImmutabilityPolicy access granted.
       */
      setImmutabilityPolicy = false;
      /**
       * Specifies that Permanent Delete is permitted.
       */
      permanentDelete = false;
      /**
       * Specifies that Filter Blobs by Tags is permitted.
       */
      filterByTags = false;
      /**
       * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
       * order accepted by the service.
       *
       * The order of the characters should be as specified here to ensure correctness.
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
       *
       */
      toString() {
        const permissions = [];
        if (this.read) {
          permissions.push("r");
        }
        if (this.add) {
          permissions.push("a");
        }
        if (this.create) {
          permissions.push("c");
        }
        if (this.write) {
          permissions.push("w");
        }
        if (this.delete) {
          permissions.push("d");
        }
        if (this.deleteVersion) {
          permissions.push("x");
        }
        if (this.list) {
          permissions.push("l");
        }
        if (this.tag) {
          permissions.push("t");
        }
        if (this.move) {
          permissions.push("m");
        }
        if (this.execute) {
          permissions.push("e");
        }
        if (this.setImmutabilityPolicy) {
          permissions.push("i");
        }
        if (this.permanentDelete) {
          permissions.push("y");
        }
        if (this.filterByTags) {
          permissions.push("f");
        }
        return permissions.join("");
      }
    };
    exports.ContainerSASPermissions = ContainerSASPermissions;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/credentials/UserDelegationKeyCredential.js
var require_UserDelegationKeyCredential = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/credentials/UserDelegationKeyCredential.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserDelegationKeyCredential = void 0;
    var node_crypto_1 = __require("crypto");
    var UserDelegationKeyCredential = class {
      /**
       * Azure Storage account name; readonly.
       */
      accountName;
      /**
       * Azure Storage user delegation key; readonly.
       */
      userDelegationKey;
      /**
       * Key value in Buffer type.
       */
      key;
      /**
       * Creates an instance of UserDelegationKeyCredential.
       * @param accountName -
       * @param userDelegationKey -
       */
      constructor(accountName, userDelegationKey) {
        this.accountName = accountName;
        this.userDelegationKey = userDelegationKey;
        this.key = Buffer.from(userDelegationKey.value, "base64");
      }
      /**
       * Generates a hash signature for an HTTP request or for a SAS.
       *
       * @param stringToSign -
       */
      computeHMACSHA256(stringToSign) {
        return (0, node_crypto_1.createHmac)("sha256", this.key).update(stringToSign, "utf8").digest("base64");
      }
    };
    exports.UserDelegationKeyCredential = UserDelegationKeyCredential;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/SasIPRange.js
var require_SasIPRange = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/sas/SasIPRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ipRangeToString = ipRangeToString;
    function ipRangeToString(ipRange) {
      return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/SASQueryParameters.js
var require_SASQueryParameters = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/sas/SASQueryParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SASQueryParameters = exports.SASProtocol = void 0;
    var SasIPRange_js_1 = require_SasIPRange();
    var utils_common_js_1 = require_utils_common();
    var SASProtocol;
    (function(SASProtocol2) {
      SASProtocol2["Https"] = "https";
      SASProtocol2["HttpsAndHttp"] = "https,http";
    })(SASProtocol || (exports.SASProtocol = SASProtocol = {}));
    var SASQueryParameters = class {
      /**
       * The storage API version.
       */
      version;
      /**
       * Optional. The allowed HTTP protocol(s).
       */
      protocol;
      /**
       * Optional. The start time for this SAS token.
       */
      startsOn;
      /**
       * Optional only when identifier is provided. The expiry time for this SAS token.
       */
      expiresOn;
      /**
       * Optional only when identifier is provided.
       * Please refer to {@link AccountSASPermissions}, {@link BlobSASPermissions}, or {@link ContainerSASPermissions} for
       * more details.
       */
      permissions;
      /**
       * Optional. The storage services being accessed (only for Account SAS). Please refer to {@link AccountSASServices}
       * for more details.
       */
      services;
      /**
       * Optional. The storage resource types being accessed (only for Account SAS). Please refer to
       * {@link AccountSASResourceTypes} for more details.
       */
      resourceTypes;
      /**
       * Optional. The signed identifier (only for {@link BlobSASSignatureValues}).
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/establishing-a-stored-access-policy
       */
      identifier;
      /**
       * Optional. Encryption scope to use when sending requests authorized with this SAS URI.
       */
      encryptionScope;
      /**
       * Optional. Specifies which resources are accessible via the SAS (only for {@link BlobSASSignatureValues}).
       * @see https://learn.microsoft.com/rest/api/storageservices/create-service-sas#specifying-the-signed-resource-blob-service-only
       */
      resource;
      /**
       * The signature for the SAS token.
       */
      signature;
      /**
       * Value for cache-control header in Blob/File Service SAS.
       */
      cacheControl;
      /**
       * Value for content-disposition header in Blob/File Service SAS.
       */
      contentDisposition;
      /**
       * Value for content-encoding header in Blob/File Service SAS.
       */
      contentEncoding;
      /**
       * Value for content-length header in Blob/File Service SAS.
       */
      contentLanguage;
      /**
       * Value for content-type header in Blob/File Service SAS.
       */
      contentType;
      /**
       * Inner value of getter ipRange.
       */
      ipRangeInner;
      /**
       * The Azure Active Directory object ID in GUID format.
       * Property of user delegation key.
       */
      signedOid;
      /**
       * The Azure Active Directory tenant ID in GUID format.
       * Property of user delegation key.
       */
      signedTenantId;
      /**
       * The date-time the key is active.
       * Property of user delegation key.
       */
      signedStartsOn;
      /**
       * The date-time the key expires.
       * Property of user delegation key.
       */
      signedExpiresOn;
      /**
       * Abbreviation of the Azure Storage service that accepts the user delegation key.
       * Property of user delegation key.
       */
      signedService;
      /**
       * The service version that created the user delegation key.
       * Property of user delegation key.
       */
      signedVersion;
      /**
       * Authorized AAD Object ID in GUID format. The AAD Object ID of a user authorized by the owner of the User Delegation Key
       * to perform the action granted by the SAS. The Azure Storage service will ensure that the owner of the user delegation key
       * has the required permissions before granting access but no additional permission check for the user specified in
       * this value will be performed. This is only used for User Delegation SAS.
       */
      preauthorizedAgentObjectId;
      /**
       * A GUID value that will be logged in the storage diagnostic logs and can be used to correlate SAS generation with storage resource access.
       * This is only used for User Delegation SAS.
       */
      correlationId;
      /**
       * Optional. IP range allowed for this SAS.
       *
       * @readonly
       */
      get ipRange() {
        if (this.ipRangeInner) {
          return {
            end: this.ipRangeInner.end,
            start: this.ipRangeInner.start
          };
        }
        return void 0;
      }
      constructor(version, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope) {
        this.version = version;
        this.signature = signature;
        if (permissionsOrOptions !== void 0 && typeof permissionsOrOptions !== "string") {
          this.permissions = permissionsOrOptions.permissions;
          this.services = permissionsOrOptions.services;
          this.resourceTypes = permissionsOrOptions.resourceTypes;
          this.protocol = permissionsOrOptions.protocol;
          this.startsOn = permissionsOrOptions.startsOn;
          this.expiresOn = permissionsOrOptions.expiresOn;
          this.ipRangeInner = permissionsOrOptions.ipRange;
          this.identifier = permissionsOrOptions.identifier;
          this.encryptionScope = permissionsOrOptions.encryptionScope;
          this.resource = permissionsOrOptions.resource;
          this.cacheControl = permissionsOrOptions.cacheControl;
          this.contentDisposition = permissionsOrOptions.contentDisposition;
          this.contentEncoding = permissionsOrOptions.contentEncoding;
          this.contentLanguage = permissionsOrOptions.contentLanguage;
          this.contentType = permissionsOrOptions.contentType;
          if (permissionsOrOptions.userDelegationKey) {
            this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId;
            this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId;
            this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn;
            this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn;
            this.signedService = permissionsOrOptions.userDelegationKey.signedService;
            this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion;
            this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId;
            this.correlationId = permissionsOrOptions.correlationId;
          }
        } else {
          this.services = services;
          this.resourceTypes = resourceTypes;
          this.expiresOn = expiresOn;
          this.permissions = permissionsOrOptions;
          this.protocol = protocol;
          this.startsOn = startsOn;
          this.ipRangeInner = ipRange;
          this.encryptionScope = encryptionScope;
          this.identifier = identifier;
          this.resource = resource;
          this.cacheControl = cacheControl;
          this.contentDisposition = contentDisposition;
          this.contentEncoding = contentEncoding;
          this.contentLanguage = contentLanguage;
          this.contentType = contentType;
          if (userDelegationKey) {
            this.signedOid = userDelegationKey.signedObjectId;
            this.signedTenantId = userDelegationKey.signedTenantId;
            this.signedStartsOn = userDelegationKey.signedStartsOn;
            this.signedExpiresOn = userDelegationKey.signedExpiresOn;
            this.signedService = userDelegationKey.signedService;
            this.signedVersion = userDelegationKey.signedVersion;
            this.preauthorizedAgentObjectId = preauthorizedAgentObjectId;
            this.correlationId = correlationId;
          }
        }
      }
      /**
       * Encodes all SAS query parameters into a string that can be appended to a URL.
       *
       */
      toString() {
        const params = [
          "sv",
          "ss",
          "srt",
          "spr",
          "st",
          "se",
          "sip",
          "si",
          "ses",
          "skoid",
          // Signed object ID
          "sktid",
          // Signed tenant ID
          "skt",
          // Signed key start time
          "ske",
          // Signed key expiry time
          "sks",
          // Signed key service
          "skv",
          // Signed key version
          "sr",
          "sp",
          "sig",
          "rscc",
          "rscd",
          "rsce",
          "rscl",
          "rsct",
          "saoid",
          "scid"
        ];
        const queries = [];
        for (const param of params) {
          switch (param) {
            case "sv":
              this.tryAppendQueryParameter(queries, param, this.version);
              break;
            case "ss":
              this.tryAppendQueryParameter(queries, param, this.services);
              break;
            case "srt":
              this.tryAppendQueryParameter(queries, param, this.resourceTypes);
              break;
            case "spr":
              this.tryAppendQueryParameter(queries, param, this.protocol);
              break;
            case "st":
              this.tryAppendQueryParameter(queries, param, this.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.startsOn, false) : void 0);
              break;
            case "se":
              this.tryAppendQueryParameter(queries, param, this.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.expiresOn, false) : void 0);
              break;
            case "sip":
              this.tryAppendQueryParameter(queries, param, this.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(this.ipRange) : void 0);
              break;
            case "si":
              this.tryAppendQueryParameter(queries, param, this.identifier);
              break;
            case "ses":
              this.tryAppendQueryParameter(queries, param, this.encryptionScope);
              break;
            case "skoid":
              this.tryAppendQueryParameter(queries, param, this.signedOid);
              break;
            case "sktid":
              this.tryAppendQueryParameter(queries, param, this.signedTenantId);
              break;
            case "skt":
              this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedStartsOn, false) : void 0);
              break;
            case "ske":
              this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedExpiresOn, false) : void 0);
              break;
            case "sks":
              this.tryAppendQueryParameter(queries, param, this.signedService);
              break;
            case "skv":
              this.tryAppendQueryParameter(queries, param, this.signedVersion);
              break;
            case "sr":
              this.tryAppendQueryParameter(queries, param, this.resource);
              break;
            case "sp":
              this.tryAppendQueryParameter(queries, param, this.permissions);
              break;
            case "sig":
              this.tryAppendQueryParameter(queries, param, this.signature);
              break;
            case "rscc":
              this.tryAppendQueryParameter(queries, param, this.cacheControl);
              break;
            case "rscd":
              this.tryAppendQueryParameter(queries, param, this.contentDisposition);
              break;
            case "rsce":
              this.tryAppendQueryParameter(queries, param, this.contentEncoding);
              break;
            case "rscl":
              this.tryAppendQueryParameter(queries, param, this.contentLanguage);
              break;
            case "rsct":
              this.tryAppendQueryParameter(queries, param, this.contentType);
              break;
            case "saoid":
              this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
              break;
            case "scid":
              this.tryAppendQueryParameter(queries, param, this.correlationId);
              break;
          }
        }
        return queries.join("&");
      }
      /**
       * A private helper method used to filter and append query key/value pairs into an array.
       *
       * @param queries -
       * @param key -
       * @param value -
       */
      tryAppendQueryParameter(queries, key, value) {
        if (!value) {
          return;
        }
        key = encodeURIComponent(key);
        value = encodeURIComponent(value);
        if (key.length > 0 && value.length > 0) {
          queries.push(`${key}=${value}`);
        }
      }
    };
    exports.SASQueryParameters = SASQueryParameters;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/BlobSASSignatureValues.js
var require_BlobSASSignatureValues = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/sas/BlobSASSignatureValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateBlobSASQueryParameters = generateBlobSASQueryParameters;
    exports.generateBlobSASQueryParametersInternal = generateBlobSASQueryParametersInternal;
    var BlobSASPermissions_js_1 = require_BlobSASPermissions();
    var ContainerSASPermissions_js_1 = require_ContainerSASPermissions();
    var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential();
    var UserDelegationKeyCredential_js_1 = require_UserDelegationKeyCredential();
    var SasIPRange_js_1 = require_SasIPRange();
    var SASQueryParameters_js_1 = require_SASQueryParameters();
    var constants_js_1 = require_constants9();
    var utils_common_js_1 = require_utils_common();
    function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
      return generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName).sasQueryParameters;
    }
    function generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
      const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
      const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : void 0;
      let userDelegationKeyCredential;
      if (sharedKeyCredential === void 0 && accountName !== void 0) {
        userDelegationKeyCredential = new UserDelegationKeyCredential_js_1.UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
      }
      if (sharedKeyCredential === void 0 && userDelegationKeyCredential === void 0) {
        throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
      }
      if (version >= "2020-12-06") {
        if (sharedKeyCredential !== void 0) {
          return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
        } else {
          if (version >= "2025-07-05") {
            return generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential);
          } else {
            return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
          }
        }
      }
      if (version >= "2018-11-09") {
        if (sharedKeyCredential !== void 0) {
          return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
        } else {
          if (version >= "2020-02-10") {
            return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
          } else {
            return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
          }
        }
      }
      if (version >= "2015-04-05") {
        if (sharedKeyCredential !== void 0) {
          return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
        } else {
          throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
        }
      }
      throw new RangeError("'version' must be >= '2015-04-05'.");
    }
    function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
      blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
      if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
      }
      let resource = "c";
      if (blobSASSignatureValues.blobName) {
        resource = "b";
      }
      let verifiedPermissions;
      if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
          verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
          verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        }
      }
      const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        blobSASSignatureValues.identifier,
        blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
        blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
        blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
        blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
        blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
      ].join("\n");
      const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
      return {
        sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
        stringToSign
      };
    }
    function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
      blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
      if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
      }
      let resource = "c";
      let timestamp = blobSASSignatureValues.snapshotTime;
      if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
          resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
          resource = "bv";
          timestamp = blobSASSignatureValues.versionId;
        }
      }
      let verifiedPermissions;
      if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
          verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
          verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        }
      }
      const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        blobSASSignatureValues.identifier,
        blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
        blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
        blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
        blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
        blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
      ].join("\n");
      const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
      return {
        sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
        stringToSign
      };
    }
    function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
      blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
      if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
      }
      let resource = "c";
      let timestamp = blobSASSignatureValues.snapshotTime;
      if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
          resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
          resource = "bv";
          timestamp = blobSASSignatureValues.versionId;
        }
      }
      let verifiedPermissions;
      if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
          verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
          verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        }
      }
      const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        blobSASSignatureValues.identifier,
        blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.encryptionScope,
        blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
        blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
        blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
        blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
        blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
      ].join("\n");
      const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
      return {
        sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, void 0, void 0, void 0, blobSASSignatureValues.encryptionScope),
        stringToSign
      };
    }
    function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
      blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
      if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
      }
      let resource = "c";
      let timestamp = blobSASSignatureValues.snapshotTime;
      if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
          resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
          resource = "bv";
          timestamp = blobSASSignatureValues.versionId;
        }
      }
      let verifiedPermissions;
      if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
          verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
          verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        }
      }
      const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.cacheControl,
        blobSASSignatureValues.contentDisposition,
        blobSASSignatureValues.contentEncoding,
        blobSASSignatureValues.contentLanguage,
        blobSASSignatureValues.contentType
      ].join("\n");
      const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
      return {
        sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey),
        stringToSign
      };
    }
    function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
      blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
      if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
      }
      let resource = "c";
      let timestamp = blobSASSignatureValues.snapshotTime;
      if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
          resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
          resource = "bv";
          timestamp = blobSASSignatureValues.versionId;
        }
      }
      let verifiedPermissions;
      if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
          verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
          verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        }
      }
      const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        blobSASSignatureValues.preauthorizedAgentObjectId,
        void 0,
        // agentObjectId
        blobSASSignatureValues.correlationId,
        blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.cacheControl,
        blobSASSignatureValues.contentDisposition,
        blobSASSignatureValues.contentEncoding,
        blobSASSignatureValues.contentLanguage,
        blobSASSignatureValues.contentType
      ].join("\n");
      const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
      return {
        sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId),
        stringToSign
      };
    }
    function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
      blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
      if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
      }
      let resource = "c";
      let timestamp = blobSASSignatureValues.snapshotTime;
      if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
          resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
          resource = "bv";
          timestamp = blobSASSignatureValues.versionId;
        }
      }
      let verifiedPermissions;
      if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
          verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
          verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        }
      }
      const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        blobSASSignatureValues.preauthorizedAgentObjectId,
        void 0,
        // agentObjectId
        blobSASSignatureValues.correlationId,
        blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.encryptionScope,
        blobSASSignatureValues.cacheControl,
        blobSASSignatureValues.contentDisposition,
        blobSASSignatureValues.contentEncoding,
        blobSASSignatureValues.contentLanguage,
        blobSASSignatureValues.contentType
      ].join("\n");
      const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
      return {
        sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
        stringToSign
      };
    }
    function generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential) {
      blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
      if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
      }
      let resource = "c";
      let timestamp = blobSASSignatureValues.snapshotTime;
      if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
          resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
          resource = "bv";
          timestamp = blobSASSignatureValues.versionId;
        }
      }
      let verifiedPermissions;
      if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
          verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
          verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
        }
      }
      const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        blobSASSignatureValues.preauthorizedAgentObjectId,
        void 0,
        // agentObjectId
        blobSASSignatureValues.correlationId,
        void 0,
        // SignedKeyDelegatedUserTenantId, will be added in a future release.
        void 0,
        // SignedDelegatedUserObjectId, will be added in future release.
        blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.encryptionScope,
        blobSASSignatureValues.cacheControl,
        blobSASSignatureValues.contentDisposition,
        blobSASSignatureValues.contentEncoding,
        blobSASSignatureValues.contentLanguage,
        blobSASSignatureValues.contentType
      ].join("\n");
      const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
      return {
        sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
        stringToSign
      };
    }
    function getCanonicalName(accountName, containerName, blobName) {
      const elements = [`/blob/${accountName}/${containerName}`];
      if (blobName) {
        elements.push(`/${blobName}`);
      }
      return elements.join("");
    }
    function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
      const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
      if (blobSASSignatureValues.snapshotTime && version < "2018-11-09") {
        throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
      }
      if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.snapshotTime) {
        throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
      }
      if (blobSASSignatureValues.versionId && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
      }
      if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.versionId) {
        throw RangeError("Must provide 'blobName' when providing 'versionId'.");
      }
      if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04") {
        throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
      }
      if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
      }
      if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
      }
      if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version < "2019-12-12") {
        throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
      }
      if (version < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) {
        throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
      }
      if (version < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) {
        throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
      }
      if (version < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) {
        throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
      }
      if (blobSASSignatureValues.encryptionScope && version < "2020-12-06") {
        throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
      }
      blobSASSignatureValues.version = version;
      return blobSASSignatureValues;
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobLeaseClient.js
var require_BlobLeaseClient = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/BlobLeaseClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobLeaseClient = void 0;
    var core_util_1 = require_commonjs4();
    var constants_js_1 = require_constants9();
    var tracing_js_1 = require_tracing();
    var utils_common_js_1 = require_utils_common();
    var BlobLeaseClient = class {
      _leaseId;
      _url;
      _containerOrBlobOperation;
      _isContainer;
      /**
       * Gets the lease Id.
       *
       * @readonly
       */
      get leaseId() {
        return this._leaseId;
      }
      /**
       * Gets the url.
       *
       * @readonly
       */
      get url() {
        return this._url;
      }
      /**
       * Creates an instance of BlobLeaseClient.
       * @param client - The client to make the lease operation requests.
       * @param leaseId - Initial proposed lease id.
       */
      constructor(client, leaseId) {
        const clientContext = client.storageClientContext;
        this._url = client.url;
        if (client.name === void 0) {
          this._isContainer = true;
          this._containerOrBlobOperation = clientContext.container;
        } else {
          this._isContainer = false;
          this._containerOrBlobOperation = clientContext.blob;
        }
        if (!leaseId) {
          leaseId = (0, core_util_1.randomUUID)();
        }
        this._leaseId = leaseId;
      }
      /**
       * Establishes and manages a lock on a container for delete operations, or on a blob
       * for write and delete operations.
       * The lock duration can be 15 to 60 seconds, or can be infinite.
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
       * and
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
       *
       * @param duration - Must be between 15 to 60 seconds, or infinite (-1)
       * @param options - option to configure lease management operations.
       * @returns Response data for acquire lease operation.
       */
      async acquireLease(duration, options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
          throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-acquireLease", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.acquireLease({
            abortSignal: options.abortSignal,
            duration,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            proposedLeaseId: this._leaseId,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * To change the ID of the lease.
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
       * and
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
       *
       * @param proposedLeaseId - the proposed new lease Id.
       * @param options - option to configure lease management operations.
       * @returns Response data for change lease operation.
       */
      async changeLease(proposedLeaseId, options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
          throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-changeLease", options, async (updatedOptions) => {
          const response = (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId, {
            abortSignal: options.abortSignal,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          }));
          this._leaseId = proposedLeaseId;
          return response;
        });
      }
      /**
       * To free the lease if it is no longer needed so that another client may
       * immediately acquire a lease against the container or the blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
       * and
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
       *
       * @param options - option to configure lease management operations.
       * @returns Response data for release lease operation.
       */
      async releaseLease(options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
          throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-releaseLease", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
            abortSignal: options.abortSignal,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * To renew the lease.
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
       * and
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
       *
       * @param options - Optional option to configure lease management operations.
       * @returns Response data for renew lease operation.
       */
      async renewLease(options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
          throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-renewLease", options, async (updatedOptions) => {
          return this._containerOrBlobOperation.renewLease(this._leaseId, {
            abortSignal: options.abortSignal,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          });
        });
      }
      /**
       * To end the lease but ensure that another client cannot acquire a new lease
       * until the current lease period has expired.
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
       * and
       * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
       *
       * @param breakPeriod - Break period
       * @param options - Optional options to configure lease management operations.
       * @returns Response data for break lease operation.
       */
      async breakLease(breakPeriod, options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
          throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-breakLease", options, async (updatedOptions) => {
          const operationOptions = {
            abortSignal: options.abortSignal,
            breakPeriod,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          };
          return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.breakLease(operationOptions));
        });
      }
    };
    exports.BlobLeaseClient = BlobLeaseClient;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/RetriableReadableStream.js
var require_RetriableReadableStream = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/utils/RetriableReadableStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RetriableReadableStream = void 0;
    var abort_controller_1 = require_commonjs11();
    var node_stream_1 = __require("stream");
    var RetriableReadableStream = class extends node_stream_1.Readable {
      start;
      offset;
      end;
      getter;
      source;
      retries = 0;
      maxRetryRequests;
      onProgress;
      options;
      /**
       * Creates an instance of RetriableReadableStream.
       *
       * @param source - The current ReadableStream returned from getter
       * @param getter - A method calling downloading request returning
       *                                      a new ReadableStream from specified offset
       * @param offset - Offset position in original data source to read
       * @param count - How much data in original data source to read
       * @param options -
       */
      constructor(source, getter, offset, count, options = {}) {
        super({ highWaterMark: options.highWaterMark });
        this.getter = getter;
        this.source = source;
        this.start = offset;
        this.offset = offset;
        this.end = offset + count - 1;
        this.maxRetryRequests = options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
        this.onProgress = options.onProgress;
        this.options = options;
        this.setSourceEventHandlers();
      }
      _read() {
        this.source.resume();
      }
      setSourceEventHandlers() {
        this.source.on("data", this.sourceDataHandler);
        this.source.on("end", this.sourceErrorOrEndHandler);
        this.source.on("error", this.sourceErrorOrEndHandler);
        this.source.on("aborted", this.sourceAbortedHandler);
      }
      removeSourceEventHandlers() {
        this.source.removeListener("data", this.sourceDataHandler);
        this.source.removeListener("end", this.sourceErrorOrEndHandler);
        this.source.removeListener("error", this.sourceErrorOrEndHandler);
        this.source.removeListener("aborted", this.sourceAbortedHandler);
      }
      sourceDataHandler = (data) => {
        if (this.options.doInjectErrorOnce) {
          this.options.doInjectErrorOnce = void 0;
          this.source.pause();
          this.sourceErrorOrEndHandler();
          this.source.destroy();
          return;
        }
        this.offset += data.length;
        if (this.onProgress) {
          this.onProgress({ loadedBytes: this.offset - this.start });
        }
        if (!this.push(data)) {
          this.source.pause();
        }
      };
      sourceAbortedHandler = () => {
        const abortError = new abort_controller_1.AbortError("The operation was aborted.");
        this.destroy(abortError);
      };
      sourceErrorOrEndHandler = (err) => {
        if (err && err.name === "AbortError") {
          this.destroy(err);
          return;
        }
        this.removeSourceEventHandlers();
        if (this.offset - 1 === this.end) {
          this.push(null);
        } else if (this.offset <= this.end) {
          if (this.retries < this.maxRetryRequests) {
            this.retries += 1;
            this.getter(this.offset).then((newSource) => {
              this.source = newSource;
              this.setSourceEventHandlers();
              return;
            }).catch((error2) => {
              this.destroy(error2);
            });
          } else {
            this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
          }
        } else {
          this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
        }
      };
      _destroy(error2, callback) {
        this.removeSourceEventHandlers();
        this.source.destroy();
        callback(error2 === null ? void 0 : error2);
      }
    };
    exports.RetriableReadableStream = RetriableReadableStream;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobDownloadResponse.js
var require_BlobDownloadResponse = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/BlobDownloadResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobDownloadResponse = void 0;
    var core_util_1 = require_commonjs4();
    var RetriableReadableStream_js_1 = require_RetriableReadableStream();
    var BlobDownloadResponse = class {
      /**
       * Indicates that the service supports
       * requests for partial file content.
       *
       * @readonly
       */
      get acceptRanges() {
        return this.originalResponse.acceptRanges;
      }
      /**
       * Returns if it was previously specified
       * for the file.
       *
       * @readonly
       */
      get cacheControl() {
        return this.originalResponse.cacheControl;
      }
      /**
       * Returns the value that was specified
       * for the 'x-ms-content-disposition' header and specifies how to process the
       * response.
       *
       * @readonly
       */
      get contentDisposition() {
        return this.originalResponse.contentDisposition;
      }
      /**
       * Returns the value that was specified
       * for the Content-Encoding request header.
       *
       * @readonly
       */
      get contentEncoding() {
        return this.originalResponse.contentEncoding;
      }
      /**
       * Returns the value that was specified
       * for the Content-Language request header.
       *
       * @readonly
       */
      get contentLanguage() {
        return this.originalResponse.contentLanguage;
      }
      /**
       * The current sequence number for a
       * page blob. This header is not returned for block blobs or append blobs.
       *
       * @readonly
       */
      get blobSequenceNumber() {
        return this.originalResponse.blobSequenceNumber;
      }
      /**
       * The blob's type. Possible values include:
       * 'BlockBlob', 'PageBlob', 'AppendBlob'.
       *
       * @readonly
       */
      get blobType() {
        return this.originalResponse.blobType;
      }
      /**
       * The number of bytes present in the
       * response body.
       *
       * @readonly
       */
      get contentLength() {
        return this.originalResponse.contentLength;
      }
      /**
       * If the file has an MD5 hash and the
       * request is to read the full file, this response header is returned so that
       * the client can check for message content integrity. If the request is to
       * read a specified range and the 'x-ms-range-get-content-md5' is set to
       * true, then the request returns an MD5 hash for the range, as long as the
       * range size is less than or equal to 4 MB. If neither of these sets of
       * conditions is true, then no value is returned for the 'Content-MD5'
       * header.
       *
       * @readonly
       */
      get contentMD5() {
        return this.originalResponse.contentMD5;
      }
      /**
       * Indicates the range of bytes returned if
       * the client requested a subset of the file by setting the Range request
       * header.
       *
       * @readonly
       */
      get contentRange() {
        return this.originalResponse.contentRange;
      }
      /**
       * The content type specified for the file.
       * The default content type is 'application/octet-stream'
       *
       * @readonly
       */
      get contentType() {
        return this.originalResponse.contentType;
      }
      /**
       * Conclusion time of the last attempted
       * Copy File operation where this file was the destination file. This value
       * can specify the time of a completed, aborted, or failed copy attempt.
       *
       * @readonly
       */
      get copyCompletedOn() {
        return this.originalResponse.copyCompletedOn;
      }
      /**
       * String identifier for the last attempted Copy
       * File operation where this file was the destination file.
       *
       * @readonly
       */
      get copyId() {
        return this.originalResponse.copyId;
      }
      /**
       * Contains the number of bytes copied and
       * the total bytes in the source in the last attempted Copy File operation
       * where this file was the destination file. Can show between 0 and
       * Content-Length bytes copied.
       *
       * @readonly
       */
      get copyProgress() {
        return this.originalResponse.copyProgress;
      }
      /**
       * URL up to 2KB in length that specifies the
       * source file used in the last attempted Copy File operation where this file
       * was the destination file.
       *
       * @readonly
       */
      get copySource() {
        return this.originalResponse.copySource;
      }
      /**
       * State of the copy operation
       * identified by 'x-ms-copy-id'. Possible values include: 'pending',
       * 'success', 'aborted', 'failed'
       *
       * @readonly
       */
      get copyStatus() {
        return this.originalResponse.copyStatus;
      }
      /**
       * Only appears when
       * x-ms-copy-status is failed or pending. Describes cause of fatal or
       * non-fatal copy operation failure.
       *
       * @readonly
       */
      get copyStatusDescription() {
        return this.originalResponse.copyStatusDescription;
      }
      /**
       * When a blob is leased,
       * specifies whether the lease is of infinite or fixed duration. Possible
       * values include: 'infinite', 'fixed'.
       *
       * @readonly
       */
      get leaseDuration() {
        return this.originalResponse.leaseDuration;
      }
      /**
       * Lease state of the blob. Possible
       * values include: 'available', 'leased', 'expired', 'breaking', 'broken'.
       *
       * @readonly
       */
      get leaseState() {
        return this.originalResponse.leaseState;
      }
      /**
       * The current lease status of the
       * blob. Possible values include: 'locked', 'unlocked'.
       *
       * @readonly
       */
      get leaseStatus() {
        return this.originalResponse.leaseStatus;
      }
      /**
       * A UTC date/time value generated by the service that
       * indicates the time at which the response was initiated.
       *
       * @readonly
       */
      get date() {
        return this.originalResponse.date;
      }
      /**
       * The number of committed blocks
       * present in the blob. This header is returned only for append blobs.
       *
       * @readonly
       */
      get blobCommittedBlockCount() {
        return this.originalResponse.blobCommittedBlockCount;
      }
      /**
       * The ETag contains a value that you can use to
       * perform operations conditionally, in quotes.
       *
       * @readonly
       */
      get etag() {
        return this.originalResponse.etag;
      }
      /**
       * The number of tags associated with the blob
       *
       * @readonly
       */
      get tagCount() {
        return this.originalResponse.tagCount;
      }
      /**
       * The error code.
       *
       * @readonly
       */
      get errorCode() {
        return this.originalResponse.errorCode;
      }
      /**
       * The value of this header is set to
       * true if the file data and application metadata are completely encrypted
       * using the specified algorithm. Otherwise, the value is set to false (when
       * the file is unencrypted, or if only parts of the file/application metadata
       * are encrypted).
       *
       * @readonly
       */
      get isServerEncrypted() {
        return this.originalResponse.isServerEncrypted;
      }
      /**
       * If the blob has a MD5 hash, and if
       * request contains range header (Range or x-ms-range), this response header
       * is returned with the value of the whole blob's MD5 value. This value may
       * or may not be equal to the value returned in Content-MD5 header, with the
       * latter calculated from the requested range.
       *
       * @readonly
       */
      get blobContentMD5() {
        return this.originalResponse.blobContentMD5;
      }
      /**
       * Returns the date and time the file was last
       * modified. Any operation that modifies the file or its properties updates
       * the last modified time.
       *
       * @readonly
       */
      get lastModified() {
        return this.originalResponse.lastModified;
      }
      /**
       * Returns the UTC date and time generated by the service that indicates the time at which the blob was
       * last read or written to.
       *
       * @readonly
       */
      get lastAccessed() {
        return this.originalResponse.lastAccessed;
      }
      /**
       * Returns the date and time the blob was created.
       *
       * @readonly
       */
      get createdOn() {
        return this.originalResponse.createdOn;
      }
      /**
       * A name-value pair
       * to associate with a file storage object.
       *
       * @readonly
       */
      get metadata() {
        return this.originalResponse.metadata;
      }
      /**
       * This header uniquely identifies the request
       * that was made and can be used for troubleshooting the request.
       *
       * @readonly
       */
      get requestId() {
        return this.originalResponse.requestId;
      }
      /**
       * If a client request id header is sent in the request, this header will be present in the
       * response with the same value.
       *
       * @readonly
       */
      get clientRequestId() {
        return this.originalResponse.clientRequestId;
      }
      /**
       * Indicates the version of the Blob service used
       * to execute the request.
       *
       * @readonly
       */
      get version() {
        return this.originalResponse.version;
      }
      /**
       * Indicates the versionId of the downloaded blob version.
       *
       * @readonly
       */
      get versionId() {
        return this.originalResponse.versionId;
      }
      /**
       * Indicates whether version of this blob is a current version.
       *
       * @readonly
       */
      get isCurrentVersion() {
        return this.originalResponse.isCurrentVersion;
      }
      /**
       * The SHA-256 hash of the encryption key used to encrypt the blob. This value is only returned
       * when the blob was encrypted with a customer-provided key.
       *
       * @readonly
       */
      get encryptionKeySha256() {
        return this.originalResponse.encryptionKeySha256;
      }
      /**
       * If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to
       * true, then the request returns a crc64 for the range, as long as the range size is less than
       * or equal to 4 MB. If both x-ms-range-get-content-crc64 & x-ms-range-get-content-md5 is
       * specified in the same request, it will fail with 400(Bad Request)
       */
      get contentCrc64() {
        return this.originalResponse.contentCrc64;
      }
      /**
       * Object Replication Policy Id of the destination blob.
       *
       * @readonly
       */
      get objectReplicationDestinationPolicyId() {
        return this.originalResponse.objectReplicationDestinationPolicyId;
      }
      /**
       * Parsed Object Replication Policy Id, Rule Id(s) and status of the source blob.
       *
       * @readonly
       */
      get objectReplicationSourceProperties() {
        return this.originalResponse.objectReplicationSourceProperties;
      }
      /**
       * If this blob has been sealed.
       *
       * @readonly
       */
      get isSealed() {
        return this.originalResponse.isSealed;
      }
      /**
       * UTC date/time value generated by the service that indicates the time at which the blob immutability policy will expire.
       *
       * @readonly
       */
      get immutabilityPolicyExpiresOn() {
        return this.originalResponse.immutabilityPolicyExpiresOn;
      }
      /**
       * Indicates immutability policy mode.
       *
       * @readonly
       */
      get immutabilityPolicyMode() {
        return this.originalResponse.immutabilityPolicyMode;
      }
      /**
       * Indicates if a legal hold is present on the blob.
       *
       * @readonly
       */
      get legalHold() {
        return this.originalResponse.legalHold;
      }
      /**
       * The response body as a browser Blob.
       * Always undefined in node.js.
       *
       * @readonly
       */
      get contentAsBlob() {
        return this.originalResponse.blobBody;
      }
      /**
       * The response body as a node.js Readable stream.
       * Always undefined in the browser.
       *
       * It will automatically retry when internal read stream unexpected ends.
       *
       * @readonly
       */
      get readableStreamBody() {
        return core_util_1.isNodeLike ? this.blobDownloadStream : void 0;
      }
      /**
       * The HTTP response.
       */
      get _response() {
        return this.originalResponse._response;
      }
      originalResponse;
      blobDownloadStream;
      /**
       * Creates an instance of BlobDownloadResponse.
       *
       * @param originalResponse -
       * @param getter -
       * @param offset -
       * @param count -
       * @param options -
       */
      constructor(originalResponse, getter, offset, count, options = {}) {
        this.originalResponse = originalResponse;
        this.blobDownloadStream = new RetriableReadableStream_js_1.RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
      }
    };
    exports.BlobDownloadResponse = BlobDownloadResponse;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroConstants.js
var require_AvroConstants = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroConstants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AVRO_SCHEMA_KEY = exports.AVRO_CODEC_KEY = exports.AVRO_INIT_BYTES = exports.AVRO_SYNC_MARKER_SIZE = void 0;
    exports.AVRO_SYNC_MARKER_SIZE = 16;
    exports.AVRO_INIT_BYTES = new Uint8Array([79, 98, 106, 1]);
    exports.AVRO_CODEC_KEY = "avro.codec";
    exports.AVRO_SCHEMA_KEY = "avro.schema";
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroParser.js
var require_AvroParser = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AvroType = exports.AvroParser = void 0;
    var AvroParser = class _AvroParser {
      /**
       * Reads a fixed number of bytes from the stream.
       *
       * @param stream -
       * @param length -
       * @param options -
       */
      static async readFixedBytes(stream2, length, options = {}) {
        const bytes = await stream2.read(length, { abortSignal: options.abortSignal });
        if (bytes.length !== length) {
          throw new Error("Hit stream end.");
        }
        return bytes;
      }
      /**
       * Reads a single byte from the stream.
       *
       * @param stream -
       * @param options -
       */
      static async readByte(stream2, options = {}) {
        const buf = await _AvroParser.readFixedBytes(stream2, 1, options);
        return buf[0];
      }
      // int and long are stored in variable-length zig-zag coding.
      // variable-length: https://lucene.apache.org/core/3_5_0/fileformats.html#VInt
      // zig-zag: https://developers.google.com/protocol-buffers/docs/encoding?csw=1#types
      static async readZigZagLong(stream2, options = {}) {
        let zigZagEncoded = 0;
        let significanceInBit = 0;
        let byte, haveMoreByte, significanceInFloat;
        do {
          byte = await _AvroParser.readByte(stream2, options);
          haveMoreByte = byte & 128;
          zigZagEncoded |= (byte & 127) << significanceInBit;
          significanceInBit += 7;
        } while (haveMoreByte && significanceInBit < 28);
        if (haveMoreByte) {
          zigZagEncoded = zigZagEncoded;
          significanceInFloat = 268435456;
          do {
            byte = await _AvroParser.readByte(stream2, options);
            zigZagEncoded += (byte & 127) * significanceInFloat;
            significanceInFloat *= 128;
          } while (byte & 128);
          const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
          if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) {
            throw new Error("Integer overflow.");
          }
          return res;
        }
        return zigZagEncoded >> 1 ^ -(zigZagEncoded & 1);
      }
      static async readLong(stream2, options = {}) {
        return _AvroParser.readZigZagLong(stream2, options);
      }
      static async readInt(stream2, options = {}) {
        return _AvroParser.readZigZagLong(stream2, options);
      }
      static async readNull() {
        return null;
      }
      static async readBoolean(stream2, options = {}) {
        const b = await _AvroParser.readByte(stream2, options);
        if (b === 1) {
          return true;
        } else if (b === 0) {
          return false;
        } else {
          throw new Error("Byte was not a boolean.");
        }
      }
      static async readFloat(stream2, options = {}) {
        const u8arr = await _AvroParser.readFixedBytes(stream2, 4, options);
        const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
        return view.getFloat32(0, true);
      }
      static async readDouble(stream2, options = {}) {
        const u8arr = await _AvroParser.readFixedBytes(stream2, 8, options);
        const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
        return view.getFloat64(0, true);
      }
      static async readBytes(stream2, options = {}) {
        const size = await _AvroParser.readLong(stream2, options);
        if (size < 0) {
          throw new Error("Bytes size was negative.");
        }
        return stream2.read(size, { abortSignal: options.abortSignal });
      }
      static async readString(stream2, options = {}) {
        const u8arr = await _AvroParser.readBytes(stream2, options);
        const utf8decoder = new TextDecoder();
        return utf8decoder.decode(u8arr);
      }
      static async readMapPair(stream2, readItemMethod, options = {}) {
        const key = await _AvroParser.readString(stream2, options);
        const value = await readItemMethod(stream2, options);
        return { key, value };
      }
      static async readMap(stream2, readItemMethod, options = {}) {
        const readPairMethod = (s, opts = {}) => {
          return _AvroParser.readMapPair(s, readItemMethod, opts);
        };
        const pairs = await _AvroParser.readArray(stream2, readPairMethod, options);
        const dict = {};
        for (const pair of pairs) {
          dict[pair.key] = pair.value;
        }
        return dict;
      }
      static async readArray(stream2, readItemMethod, options = {}) {
        const items = [];
        for (let count = await _AvroParser.readLong(stream2, options); count !== 0; count = await _AvroParser.readLong(stream2, options)) {
          if (count < 0) {
            await _AvroParser.readLong(stream2, options);
            count = -count;
          }
          while (count--) {
            const item = await readItemMethod(stream2, options);
            items.push(item);
          }
        }
        return items;
      }
    };
    exports.AvroParser = AvroParser;
    var AvroComplex;
    (function(AvroComplex2) {
      AvroComplex2["RECORD"] = "record";
      AvroComplex2["ENUM"] = "enum";
      AvroComplex2["ARRAY"] = "array";
      AvroComplex2["MAP"] = "map";
      AvroComplex2["UNION"] = "union";
      AvroComplex2["FIXED"] = "fixed";
    })(AvroComplex || (AvroComplex = {}));
    var AvroPrimitive;
    (function(AvroPrimitive2) {
      AvroPrimitive2["NULL"] = "null";
      AvroPrimitive2["BOOLEAN"] = "boolean";
      AvroPrimitive2["INT"] = "int";
      AvroPrimitive2["LONG"] = "long";
      AvroPrimitive2["FLOAT"] = "float";
      AvroPrimitive2["DOUBLE"] = "double";
      AvroPrimitive2["BYTES"] = "bytes";
      AvroPrimitive2["STRING"] = "string";
    })(AvroPrimitive || (AvroPrimitive = {}));
    var AvroType = class _AvroType {
      /**
       * Determines the AvroType from the Avro Schema.
       */
      // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
      static fromSchema(schema) {
        if (typeof schema === "string") {
          return _AvroType.fromStringSchema(schema);
        } else if (Array.isArray(schema)) {
          return _AvroType.fromArraySchema(schema);
        } else {
          return _AvroType.fromObjectSchema(schema);
        }
      }
      static fromStringSchema(schema) {
        switch (schema) {
          case AvroPrimitive.NULL:
          case AvroPrimitive.BOOLEAN:
          case AvroPrimitive.INT:
          case AvroPrimitive.LONG:
          case AvroPrimitive.FLOAT:
          case AvroPrimitive.DOUBLE:
          case AvroPrimitive.BYTES:
          case AvroPrimitive.STRING:
            return new AvroPrimitiveType(schema);
          default:
            throw new Error(`Unexpected Avro type ${schema}`);
        }
      }
      static fromArraySchema(schema) {
        return new AvroUnionType(schema.map(_AvroType.fromSchema));
      }
      static fromObjectSchema(schema) {
        const type2 = schema.type;
        try {
          return _AvroType.fromStringSchema(type2);
        } catch {
        }
        switch (type2) {
          case AvroComplex.RECORD:
            if (schema.aliases) {
              throw new Error(`aliases currently is not supported, schema: ${schema}`);
            }
            if (!schema.name) {
              throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
            }
            const fields = {};
            if (!schema.fields) {
              throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
            }
            for (const field of schema.fields) {
              fields[field.name] = _AvroType.fromSchema(field.type);
            }
            return new AvroRecordType(fields, schema.name);
          case AvroComplex.ENUM:
            if (schema.aliases) {
              throw new Error(`aliases currently is not supported, schema: ${schema}`);
            }
            if (!schema.symbols) {
              throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
            }
            return new AvroEnumType(schema.symbols);
          case AvroComplex.MAP:
            if (!schema.values) {
              throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
            }
            return new AvroMapType(_AvroType.fromSchema(schema.values));
          case AvroComplex.ARRAY:
          // Unused today
          case AvroComplex.FIXED:
          // Unused today
          default:
            throw new Error(`Unexpected Avro type ${type2} in ${schema}`);
        }
      }
    };
    exports.AvroType = AvroType;
    var AvroPrimitiveType = class extends AvroType {
      _primitive;
      constructor(primitive) {
        super();
        this._primitive = primitive;
      }
      // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
      read(stream2, options = {}) {
        switch (this._primitive) {
          case AvroPrimitive.NULL:
            return AvroParser.readNull();
          case AvroPrimitive.BOOLEAN:
            return AvroParser.readBoolean(stream2, options);
          case AvroPrimitive.INT:
            return AvroParser.readInt(stream2, options);
          case AvroPrimitive.LONG:
            return AvroParser.readLong(stream2, options);
          case AvroPrimitive.FLOAT:
            return AvroParser.readFloat(stream2, options);
          case AvroPrimitive.DOUBLE:
            return AvroParser.readDouble(stream2, options);
          case AvroPrimitive.BYTES:
            return AvroParser.readBytes(stream2, options);
          case AvroPrimitive.STRING:
            return AvroParser.readString(stream2, options);
          default:
            throw new Error("Unknown Avro Primitive");
        }
      }
    };
    var AvroEnumType = class extends AvroType {
      _symbols;
      constructor(symbols) {
        super();
        this._symbols = symbols;
      }
      // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
      async read(stream2, options = {}) {
        const value = await AvroParser.readInt(stream2, options);
        return this._symbols[value];
      }
    };
    var AvroUnionType = class extends AvroType {
      _types;
      constructor(types2) {
        super();
        this._types = types2;
      }
      async read(stream2, options = {}) {
        const typeIndex = await AvroParser.readInt(stream2, options);
        return this._types[typeIndex].read(stream2, options);
      }
    };
    var AvroMapType = class extends AvroType {
      _itemType;
      constructor(itemType) {
        super();
        this._itemType = itemType;
      }
      // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
      read(stream2, options = {}) {
        const readItemMethod = (s, opts) => {
          return this._itemType.read(s, opts);
        };
        return AvroParser.readMap(stream2, readItemMethod, options);
      }
    };
    var AvroRecordType = class extends AvroType {
      _name;
      _fields;
      constructor(fields, name) {
        super();
        this._fields = fields;
        this._name = name;
      }
      // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
      async read(stream2, options = {}) {
        const record = {};
        record["$schema"] = this._name;
        for (const key in this._fields) {
          if (Object.prototype.hasOwnProperty.call(this._fields, key)) {
            record[key] = await this._fields[key].read(stream2, options);
          }
        }
        return record;
      }
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/utils/utils.common.js
var require_utils_common3 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/internal-avro/utils/utils.common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arraysEqual = arraysEqual;
    function arraysEqual(a2, b) {
      if (a2 === b)
        return true;
      if (a2 == null || b == null)
        return false;
      if (a2.length !== b.length)
        return false;
      for (let i2 = 0; i2 < a2.length; ++i2) {
        if (a2[i2] !== b[i2])
          return false;
      }
      return true;
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReader.js
var require_AvroReader = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AvroReader = void 0;
    var AvroConstants_js_1 = require_AvroConstants();
    var AvroParser_js_1 = require_AvroParser();
    var utils_common_js_1 = require_utils_common3();
    var AvroReader = class {
      _dataStream;
      _headerStream;
      _syncMarker;
      _metadata;
      _itemType;
      _itemsRemainingInBlock;
      // Remembers where we started if partial data stream was provided.
      _initialBlockOffset;
      /// The byte offset within the Avro file (both header and data)
      /// of the start of the current block.
      _blockOffset;
      get blockOffset() {
        return this._blockOffset;
      }
      _objectIndex;
      get objectIndex() {
        return this._objectIndex;
      }
      _initialized;
      constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock) {
        this._dataStream = dataStream;
        this._headerStream = headerStream || dataStream;
        this._initialized = false;
        this._blockOffset = currentBlockOffset || 0;
        this._objectIndex = indexWithinCurrentBlock || 0;
        this._initialBlockOffset = currentBlockOffset || 0;
      }
      async initialize(options = {}) {
        const header = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_INIT_BYTES.length, {
          abortSignal: options.abortSignal
        });
        if (!(0, utils_common_js_1.arraysEqual)(header, AvroConstants_js_1.AVRO_INIT_BYTES)) {
          throw new Error("Stream is not an Avro file.");
        }
        this._metadata = await AvroParser_js_1.AvroParser.readMap(this._headerStream, AvroParser_js_1.AvroParser.readString, {
          abortSignal: options.abortSignal
        });
        const codec = this._metadata[AvroConstants_js_1.AVRO_CODEC_KEY];
        if (!(codec === void 0 || codec === null || codec === "null")) {
          throw new Error("Codecs are not supported");
        }
        this._syncMarker = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, {
          abortSignal: options.abortSignal
        });
        const schema = JSON.parse(this._metadata[AvroConstants_js_1.AVRO_SCHEMA_KEY]);
        this._itemType = AvroParser_js_1.AvroType.fromSchema(schema);
        if (this._blockOffset === 0) {
          this._blockOffset = this._initialBlockOffset + this._dataStream.position;
        }
        this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, {
          abortSignal: options.abortSignal
        });
        await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
        this._initialized = true;
        if (this._objectIndex && this._objectIndex > 0) {
          for (let i2 = 0; i2 < this._objectIndex; i2++) {
            await this._itemType.read(this._dataStream, { abortSignal: options.abortSignal });
            this._itemsRemainingInBlock--;
          }
        }
      }
      hasNext() {
        return !this._initialized || this._itemsRemainingInBlock > 0;
      }
      async *parseObjects(options = {}) {
        if (!this._initialized) {
          await this.initialize(options);
        }
        while (this.hasNext()) {
          const result = await this._itemType.read(this._dataStream, {
            abortSignal: options.abortSignal
          });
          this._itemsRemainingInBlock--;
          this._objectIndex++;
          if (this._itemsRemainingInBlock === 0) {
            const marker = await AvroParser_js_1.AvroParser.readFixedBytes(this._dataStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, {
              abortSignal: options.abortSignal
            });
            this._blockOffset = this._initialBlockOffset + this._dataStream.position;
            this._objectIndex = 0;
            if (!(0, utils_common_js_1.arraysEqual)(this._syncMarker, marker)) {
              throw new Error("Stream is not a valid Avro file.");
            }
            try {
              this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, {
                abortSignal: options.abortSignal
              });
            } catch {
              this._itemsRemainingInBlock = 0;
            }
            if (this._itemsRemainingInBlock > 0) {
              await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
            }
          }
          yield result;
        }
      }
    };
    exports.AvroReader = AvroReader;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReadable.js
var require_AvroReadable = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReadable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AvroReadable = void 0;
    var AvroReadable = class {
    };
    exports.AvroReadable = AvroReadable;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReadableFromStream.js
var require_AvroReadableFromStream = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReadableFromStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AvroReadableFromStream = void 0;
    var AvroReadable_js_1 = require_AvroReadable();
    var abort_controller_1 = require_commonjs11();
    var buffer_1 = __require("buffer");
    var ABORT_ERROR = new abort_controller_1.AbortError("Reading from the avro stream was aborted.");
    var AvroReadableFromStream = class extends AvroReadable_js_1.AvroReadable {
      _position;
      _readable;
      toUint8Array(data) {
        if (typeof data === "string") {
          return buffer_1.Buffer.from(data);
        }
        return data;
      }
      constructor(readable) {
        super();
        this._readable = readable;
        this._position = 0;
      }
      get position() {
        return this._position;
      }
      async read(size, options = {}) {
        if (options.abortSignal?.aborted) {
          throw ABORT_ERROR;
        }
        if (size < 0) {
          throw new Error(`size parameter should be positive: ${size}`);
        }
        if (size === 0) {
          return new Uint8Array();
        }
        if (!this._readable.readable) {
          throw new Error("Stream no longer readable.");
        }
        const chunk2 = this._readable.read(size);
        if (chunk2) {
          this._position += chunk2.length;
          return this.toUint8Array(chunk2);
        } else {
          return new Promise((resolve, reject) => {
            const cleanUp = () => {
              this._readable.removeListener("readable", readableCallback);
              this._readable.removeListener("error", rejectCallback);
              this._readable.removeListener("end", rejectCallback);
              this._readable.removeListener("close", rejectCallback);
              if (options.abortSignal) {
                options.abortSignal.removeEventListener("abort", abortHandler);
              }
            };
            const readableCallback = () => {
              const callbackChunk = this._readable.read(size);
              if (callbackChunk) {
                this._position += callbackChunk.length;
                cleanUp();
                resolve(this.toUint8Array(callbackChunk));
              }
            };
            const rejectCallback = () => {
              cleanUp();
              reject();
            };
            const abortHandler = () => {
              cleanUp();
              reject(ABORT_ERROR);
            };
            this._readable.on("readable", readableCallback);
            this._readable.once("error", rejectCallback);
            this._readable.once("end", rejectCallback);
            this._readable.once("close", rejectCallback);
            if (options.abortSignal) {
              options.abortSignal.addEventListener("abort", abortHandler);
            }
          });
        }
      }
    };
    exports.AvroReadableFromStream = AvroReadableFromStream;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/index.js
var require_internal_avro = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/internal-avro/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AvroReadableFromStream = exports.AvroReadable = exports.AvroReader = void 0;
    var AvroReader_js_1 = require_AvroReader();
    Object.defineProperty(exports, "AvroReader", { enumerable: true, get: function() {
      return AvroReader_js_1.AvroReader;
    } });
    var AvroReadable_js_1 = require_AvroReadable();
    Object.defineProperty(exports, "AvroReadable", { enumerable: true, get: function() {
      return AvroReadable_js_1.AvroReadable;
    } });
    var AvroReadableFromStream_js_1 = require_AvroReadableFromStream();
    Object.defineProperty(exports, "AvroReadableFromStream", { enumerable: true, get: function() {
      return AvroReadableFromStream_js_1.AvroReadableFromStream;
    } });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/BlobQuickQueryStream.js
var require_BlobQuickQueryStream = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/utils/BlobQuickQueryStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobQuickQueryStream = void 0;
    var node_stream_1 = __require("stream");
    var index_js_1 = require_internal_avro();
    var BlobQuickQueryStream = class extends node_stream_1.Readable {
      source;
      avroReader;
      avroIter;
      avroPaused = true;
      onProgress;
      onError;
      /**
       * Creates an instance of BlobQuickQueryStream.
       *
       * @param source - The current ReadableStream returned from getter
       * @param options -
       */
      constructor(source, options = {}) {
        super();
        this.source = source;
        this.onProgress = options.onProgress;
        this.onError = options.onError;
        this.avroReader = new index_js_1.AvroReader(new index_js_1.AvroReadableFromStream(this.source));
        this.avroIter = this.avroReader.parseObjects({ abortSignal: options.abortSignal });
      }
      _read() {
        if (this.avroPaused) {
          this.readInternal().catch((err) => {
            this.emit("error", err);
          });
        }
      }
      async readInternal() {
        this.avroPaused = false;
        let avroNext;
        do {
          avroNext = await this.avroIter.next();
          if (avroNext.done) {
            break;
          }
          const obj = avroNext.value;
          const schema = obj.$schema;
          if (typeof schema !== "string") {
            throw Error("Missing schema in avro record.");
          }
          switch (schema) {
            case "com.microsoft.azure.storage.queryBlobContents.resultData":
              {
                const data = obj.data;
                if (data instanceof Uint8Array === false) {
                  throw Error("Invalid data in avro result record.");
                }
                if (!this.push(Buffer.from(data))) {
                  this.avroPaused = true;
                }
              }
              break;
            case "com.microsoft.azure.storage.queryBlobContents.progress":
              {
                const bytesScanned = obj.bytesScanned;
                if (typeof bytesScanned !== "number") {
                  throw Error("Invalid bytesScanned in avro progress record.");
                }
                if (this.onProgress) {
                  this.onProgress({ loadedBytes: bytesScanned });
                }
              }
              break;
            case "com.microsoft.azure.storage.queryBlobContents.end":
              if (this.onProgress) {
                const totalBytes = obj.totalBytes;
                if (typeof totalBytes !== "number") {
                  throw Error("Invalid totalBytes in avro end record.");
                }
                this.onProgress({ loadedBytes: totalBytes });
              }
              this.push(null);
              break;
            case "com.microsoft.azure.storage.queryBlobContents.error":
              if (this.onError) {
                const fatal = obj.fatal;
                if (typeof fatal !== "boolean") {
                  throw Error("Invalid fatal in avro error record.");
                }
                const name = obj.name;
                if (typeof name !== "string") {
                  throw Error("Invalid name in avro error record.");
                }
                const description = obj.description;
                if (typeof description !== "string") {
                  throw Error("Invalid description in avro error record.");
                }
                const position = obj.position;
                if (typeof position !== "number") {
                  throw Error("Invalid position in avro error record.");
                }
                this.onError({
                  position,
                  name,
                  isFatal: fatal,
                  description
                });
              }
              break;
            default:
              throw Error(`Unknown schema ${schema} in avro progress record.`);
          }
        } while (!avroNext.done && !this.avroPaused);
      }
    };
    exports.BlobQuickQueryStream = BlobQuickQueryStream;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobQueryResponse.js
var require_BlobQueryResponse = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/BlobQueryResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobQueryResponse = void 0;
    var core_util_1 = require_commonjs4();
    var BlobQuickQueryStream_js_1 = require_BlobQuickQueryStream();
    var BlobQueryResponse = class {
      /**
       * Indicates that the service supports
       * requests for partial file content.
       *
       * @readonly
       */
      get acceptRanges() {
        return this.originalResponse.acceptRanges;
      }
      /**
       * Returns if it was previously specified
       * for the file.
       *
       * @readonly
       */
      get cacheControl() {
        return this.originalResponse.cacheControl;
      }
      /**
       * Returns the value that was specified
       * for the 'x-ms-content-disposition' header and specifies how to process the
       * response.
       *
       * @readonly
       */
      get contentDisposition() {
        return this.originalResponse.contentDisposition;
      }
      /**
       * Returns the value that was specified
       * for the Content-Encoding request header.
       *
       * @readonly
       */
      get contentEncoding() {
        return this.originalResponse.contentEncoding;
      }
      /**
       * Returns the value that was specified
       * for the Content-Language request header.
       *
       * @readonly
       */
      get contentLanguage() {
        return this.originalResponse.contentLanguage;
      }
      /**
       * The current sequence number for a
       * page blob. This header is not returned for block blobs or append blobs.
       *
       * @readonly
       */
      get blobSequenceNumber() {
        return this.originalResponse.blobSequenceNumber;
      }
      /**
       * The blob's type. Possible values include:
       * 'BlockBlob', 'PageBlob', 'AppendBlob'.
       *
       * @readonly
       */
      get blobType() {
        return this.originalResponse.blobType;
      }
      /**
       * The number of bytes present in the
       * response body.
       *
       * @readonly
       */
      get contentLength() {
        return this.originalResponse.contentLength;
      }
      /**
       * If the file has an MD5 hash and the
       * request is to read the full file, this response header is returned so that
       * the client can check for message content integrity. If the request is to
       * read a specified range and the 'x-ms-range-get-content-md5' is set to
       * true, then the request returns an MD5 hash for the range, as long as the
       * range size is less than or equal to 4 MB. If neither of these sets of
       * conditions is true, then no value is returned for the 'Content-MD5'
       * header.
       *
       * @readonly
       */
      get contentMD5() {
        return this.originalResponse.contentMD5;
      }
      /**
       * Indicates the range of bytes returned if
       * the client requested a subset of the file by setting the Range request
       * header.
       *
       * @readonly
       */
      get contentRange() {
        return this.originalResponse.contentRange;
      }
      /**
       * The content type specified for the file.
       * The default content type is 'application/octet-stream'
       *
       * @readonly
       */
      get contentType() {
        return this.originalResponse.contentType;
      }
      /**
       * Conclusion time of the last attempted
       * Copy File operation where this file was the destination file. This value
       * can specify the time of a completed, aborted, or failed copy attempt.
       *
       * @readonly
       */
      get copyCompletedOn() {
        return void 0;
      }
      /**
       * String identifier for the last attempted Copy
       * File operation where this file was the destination file.
       *
       * @readonly
       */
      get copyId() {
        return this.originalResponse.copyId;
      }
      /**
       * Contains the number of bytes copied and
       * the total bytes in the source in the last attempted Copy File operation
       * where this file was the destination file. Can show between 0 and
       * Content-Length bytes copied.
       *
       * @readonly
       */
      get copyProgress() {
        return this.originalResponse.copyProgress;
      }
      /**
       * URL up to 2KB in length that specifies the
       * source file used in the last attempted Copy File operation where this file
       * was the destination file.
       *
       * @readonly
       */
      get copySource() {
        return this.originalResponse.copySource;
      }
      /**
       * State of the copy operation
       * identified by 'x-ms-copy-id'. Possible values include: 'pending',
       * 'success', 'aborted', 'failed'
       *
       * @readonly
       */
      get copyStatus() {
        return this.originalResponse.copyStatus;
      }
      /**
       * Only appears when
       * x-ms-copy-status is failed or pending. Describes cause of fatal or
       * non-fatal copy operation failure.
       *
       * @readonly
       */
      get copyStatusDescription() {
        return this.originalResponse.copyStatusDescription;
      }
      /**
       * When a blob is leased,
       * specifies whether the lease is of infinite or fixed duration. Possible
       * values include: 'infinite', 'fixed'.
       *
       * @readonly
       */
      get leaseDuration() {
        return this.originalResponse.leaseDuration;
      }
      /**
       * Lease state of the blob. Possible
       * values include: 'available', 'leased', 'expired', 'breaking', 'broken'.
       *
       * @readonly
       */
      get leaseState() {
        return this.originalResponse.leaseState;
      }
      /**
       * The current lease status of the
       * blob. Possible values include: 'locked', 'unlocked'.
       *
       * @readonly
       */
      get leaseStatus() {
        return this.originalResponse.leaseStatus;
      }
      /**
       * A UTC date/time value generated by the service that
       * indicates the time at which the response was initiated.
       *
       * @readonly
       */
      get date() {
        return this.originalResponse.date;
      }
      /**
       * The number of committed blocks
       * present in the blob. This header is returned only for append blobs.
       *
       * @readonly
       */
      get blobCommittedBlockCount() {
        return this.originalResponse.blobCommittedBlockCount;
      }
      /**
       * The ETag contains a value that you can use to
       * perform operations conditionally, in quotes.
       *
       * @readonly
       */
      get etag() {
        return this.originalResponse.etag;
      }
      /**
       * The error code.
       *
       * @readonly
       */
      get errorCode() {
        return this.originalResponse.errorCode;
      }
      /**
       * The value of this header is set to
       * true if the file data and application metadata are completely encrypted
       * using the specified algorithm. Otherwise, the value is set to false (when
       * the file is unencrypted, or if only parts of the file/application metadata
       * are encrypted).
       *
       * @readonly
       */
      get isServerEncrypted() {
        return this.originalResponse.isServerEncrypted;
      }
      /**
       * If the blob has a MD5 hash, and if
       * request contains range header (Range or x-ms-range), this response header
       * is returned with the value of the whole blob's MD5 value. This value may
       * or may not be equal to the value returned in Content-MD5 header, with the
       * latter calculated from the requested range.
       *
       * @readonly
       */
      get blobContentMD5() {
        return this.originalResponse.blobContentMD5;
      }
      /**
       * Returns the date and time the file was last
       * modified. Any operation that modifies the file or its properties updates
       * the last modified time.
       *
       * @readonly
       */
      get lastModified() {
        return this.originalResponse.lastModified;
      }
      /**
       * A name-value pair
       * to associate with a file storage object.
       *
       * @readonly
       */
      get metadata() {
        return this.originalResponse.metadata;
      }
      /**
       * This header uniquely identifies the request
       * that was made and can be used for troubleshooting the request.
       *
       * @readonly
       */
      get requestId() {
        return this.originalResponse.requestId;
      }
      /**
       * If a client request id header is sent in the request, this header will be present in the
       * response with the same value.
       *
       * @readonly
       */
      get clientRequestId() {
        return this.originalResponse.clientRequestId;
      }
      /**
       * Indicates the version of the File service used
       * to execute the request.
       *
       * @readonly
       */
      get version() {
        return this.originalResponse.version;
      }
      /**
       * The SHA-256 hash of the encryption key used to encrypt the blob. This value is only returned
       * when the blob was encrypted with a customer-provided key.
       *
       * @readonly
       */
      get encryptionKeySha256() {
        return this.originalResponse.encryptionKeySha256;
      }
      /**
       * If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to
       * true, then the request returns a crc64 for the range, as long as the range size is less than
       * or equal to 4 MB. If both x-ms-range-get-content-crc64 & x-ms-range-get-content-md5 is
       * specified in the same request, it will fail with 400(Bad Request)
       */
      get contentCrc64() {
        return this.originalResponse.contentCrc64;
      }
      /**
       * The response body as a browser Blob.
       * Always undefined in node.js.
       *
       * @readonly
       */
      get blobBody() {
        return void 0;
      }
      /**
       * The response body as a node.js Readable stream.
       * Always undefined in the browser.
       *
       * It will parse avor data returned by blob query.
       *
       * @readonly
       */
      get readableStreamBody() {
        return core_util_1.isNodeLike ? this.blobDownloadStream : void 0;
      }
      /**
       * The HTTP response.
       */
      get _response() {
        return this.originalResponse._response;
      }
      originalResponse;
      blobDownloadStream;
      /**
       * Creates an instance of BlobQueryResponse.
       *
       * @param originalResponse -
       * @param options -
       */
      constructor(originalResponse, options = {}) {
        this.originalResponse = originalResponse;
        this.blobDownloadStream = new BlobQuickQueryStream_js_1.BlobQuickQueryStream(this.originalResponse.readableStreamBody, options);
      }
    };
    exports.BlobQueryResponse = BlobQueryResponse;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/models.js
var require_models2 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/models.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageBlobAudience = exports.PremiumPageBlobTier = exports.BlockBlobTier = void 0;
    exports.toAccessTier = toAccessTier;
    exports.ensureCpkIfSpecified = ensureCpkIfSpecified;
    exports.getBlobServiceAccountAudience = getBlobServiceAccountAudience;
    var constants_js_1 = require_constants9();
    var BlockBlobTier;
    (function(BlockBlobTier2) {
      BlockBlobTier2["Hot"] = "Hot";
      BlockBlobTier2["Cool"] = "Cool";
      BlockBlobTier2["Cold"] = "Cold";
      BlockBlobTier2["Archive"] = "Archive";
    })(BlockBlobTier || (exports.BlockBlobTier = BlockBlobTier = {}));
    var PremiumPageBlobTier;
    (function(PremiumPageBlobTier2) {
      PremiumPageBlobTier2["P4"] = "P4";
      PremiumPageBlobTier2["P6"] = "P6";
      PremiumPageBlobTier2["P10"] = "P10";
      PremiumPageBlobTier2["P15"] = "P15";
      PremiumPageBlobTier2["P20"] = "P20";
      PremiumPageBlobTier2["P30"] = "P30";
      PremiumPageBlobTier2["P40"] = "P40";
      PremiumPageBlobTier2["P50"] = "P50";
      PremiumPageBlobTier2["P60"] = "P60";
      PremiumPageBlobTier2["P70"] = "P70";
      PremiumPageBlobTier2["P80"] = "P80";
    })(PremiumPageBlobTier || (exports.PremiumPageBlobTier = PremiumPageBlobTier = {}));
    function toAccessTier(tier) {
      if (tier === void 0) {
        return void 0;
      }
      return tier;
    }
    function ensureCpkIfSpecified(cpk, isHttps) {
      if (cpk && !isHttps) {
        throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
      }
      if (cpk && !cpk.encryptionAlgorithm) {
        cpk.encryptionAlgorithm = constants_js_1.EncryptionAlgorithmAES25;
      }
    }
    var StorageBlobAudience;
    (function(StorageBlobAudience2) {
      StorageBlobAudience2["StorageOAuthScopes"] = "https://storage.azure.com/.default";
      StorageBlobAudience2["DiskComputeOAuthScopes"] = "https://disk.compute.azure.com/.default";
    })(StorageBlobAudience || (exports.StorageBlobAudience = StorageBlobAudience = {}));
    function getBlobServiceAccountAudience(storageAccountName) {
      return `https://${storageAccountName}.blob.core.windows.net/.default`;
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/PageBlobRangeResponse.js
var require_PageBlobRangeResponse = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/PageBlobRangeResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rangeResponseFromModel = rangeResponseFromModel;
    function rangeResponseFromModel(response) {
      const pageRange = (response._response.parsedBody.pageRange || []).map((x) => ({
        offset: x.start,
        count: x.end - x.start
      }));
      const clearRange = (response._response.parsedBody.clearRange || []).map((x) => ({
        offset: x.start,
        count: x.end - x.start
      }));
      return {
        ...response,
        pageRange,
        clearRange,
        _response: {
          ...response._response,
          parsedBody: {
            pageRange,
            clearRange
          }
        }
      };
    }
  }
});

// node_modules/@azure/core-lro/dist/commonjs/logger.js
var require_logger2 = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = void 0;
    var logger_1 = require_commonjs2();
    exports.logger = (0, logger_1.createClientLogger)("core-lro");
  }
});

// node_modules/@azure/core-lro/dist/commonjs/poller/constants.js
var require_constants11 = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/poller/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.terminalStates = exports.POLL_INTERVAL_IN_MS = void 0;
    exports.POLL_INTERVAL_IN_MS = 2e3;
    exports.terminalStates = ["succeeded", "canceled", "failed"];
  }
});

// node_modules/@azure/core-lro/dist/commonjs/poller/operation.js
var require_operation = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/poller/operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pollOperation = exports.initOperation = exports.deserializeState = void 0;
    var logger_js_1 = require_logger2();
    var constants_js_1 = require_constants11();
    function deserializeState(serializedState) {
      try {
        return JSON.parse(serializedState).state;
      } catch (e) {
        throw new Error(`Unable to deserialize input state: ${serializedState}`);
      }
    }
    exports.deserializeState = deserializeState;
    function setStateError(inputs) {
      const { state, stateProxy, isOperationError } = inputs;
      return (error2) => {
        if (isOperationError(error2)) {
          stateProxy.setError(state, error2);
          stateProxy.setFailed(state);
        }
        throw error2;
      };
    }
    function appendReadableErrorMessage(currentMessage, innerMessage) {
      let message = currentMessage;
      if (message.slice(-1) !== ".") {
        message = message + ".";
      }
      return message + " " + innerMessage;
    }
    function simplifyError(err) {
      let message = err.message;
      let code = err.code;
      let curErr = err;
      while (curErr.innererror) {
        curErr = curErr.innererror;
        code = curErr.code;
        message = appendReadableErrorMessage(message, curErr.message);
      }
      return {
        code,
        message
      };
    }
    function processOperationStatus(result) {
      const { state, stateProxy, status, isDone, processResult, getError, response, setErrorAsResult } = result;
      switch (status) {
        case "succeeded": {
          stateProxy.setSucceeded(state);
          break;
        }
        case "failed": {
          const err = getError === null || getError === void 0 ? void 0 : getError(response);
          let postfix = "";
          if (err) {
            const { code, message } = simplifyError(err);
            postfix = `. ${code}. ${message}`;
          }
          const errStr = `The long-running operation has failed${postfix}`;
          stateProxy.setError(state, new Error(errStr));
          stateProxy.setFailed(state);
          logger_js_1.logger.warning(errStr);
          break;
        }
        case "canceled": {
          stateProxy.setCanceled(state);
          break;
        }
      }
      if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === void 0 && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status)) {
        stateProxy.setResult(state, buildResult({
          response,
          state,
          processResult
        }));
      }
    }
    function buildResult(inputs) {
      const { processResult, response, state } = inputs;
      return processResult ? processResult(response, state) : response;
    }
    async function initOperation(inputs) {
      const { init: init2, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult } = inputs;
      const { operationLocation, resourceLocation, metadata, response } = await init2();
      if (operationLocation)
        withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
      const config = {
        metadata,
        operationLocation,
        resourceLocation
      };
      logger_js_1.logger.verbose(`LRO: Operation description:`, config);
      const state = stateProxy.initState(config);
      const status = getOperationStatus({ response, state, operationLocation });
      processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult });
      return state;
    }
    exports.initOperation = initOperation;
    async function pollOperationHelper(inputs) {
      const { poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, isOperationError, options } = inputs;
      const response = await poll(operationLocation, options).catch(setStateError({
        state,
        stateProxy,
        isOperationError
      }));
      const status = getOperationStatus(response, state);
      logger_js_1.logger.verbose(`LRO: Status:
	Polling from: ${state.config.operationLocation}
	Operation status: ${status}
	Polling status: ${constants_js_1.terminalStates.includes(status) ? "Stopped" : "Running"}`);
      if (status === "succeeded") {
        const resourceLocation = getResourceLocation(response, state);
        if (resourceLocation !== void 0) {
          return {
            response: await poll(resourceLocation).catch(setStateError({ state, stateProxy, isOperationError })),
            status
          };
        }
      }
      return { response, status };
    }
    async function pollOperation(inputs) {
      const { poll, state, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, isOperationError, withOperationLocation, getPollingInterval, processResult, getError, updateState, setDelay, isDone, setErrorAsResult } = inputs;
      const { operationLocation } = state.config;
      if (operationLocation !== void 0) {
        const { response, status } = await pollOperationHelper({
          poll,
          getOperationStatus,
          state,
          stateProxy,
          operationLocation,
          getResourceLocation,
          isOperationError,
          options
        });
        processOperationStatus({
          status,
          response,
          state,
          stateProxy,
          isDone,
          processResult,
          getError,
          setErrorAsResult
        });
        if (!constants_js_1.terminalStates.includes(status)) {
          const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);
          if (intervalInMs)
            setDelay(intervalInMs);
          const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);
          if (location !== void 0) {
            const isUpdated = operationLocation !== location;
            state.config.operationLocation = location;
            withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);
          } else
            withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
        }
        updateState === null || updateState === void 0 ? void 0 : updateState(state, response);
      }
    }
    exports.pollOperation = pollOperation;
  }
});

// node_modules/@azure/core-lro/dist/commonjs/http/operation.js
var require_operation2 = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/http/operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pollHttpOperation = exports.isOperationError = exports.getResourceLocation = exports.getOperationStatus = exports.getOperationLocation = exports.initHttpOperation = exports.getStatusFromInitialResponse = exports.getErrorFromResponse = exports.parseRetryAfter = exports.inferLroMode = void 0;
    var operation_js_1 = require_operation();
    var logger_js_1 = require_logger2();
    function getOperationLocationPollingUrl(inputs) {
      const { azureAsyncOperation, operationLocation } = inputs;
      return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;
    }
    function getLocationHeader(rawResponse) {
      return rawResponse.headers["location"];
    }
    function getOperationLocationHeader(rawResponse) {
      return rawResponse.headers["operation-location"];
    }
    function getAzureAsyncOperationHeader(rawResponse) {
      return rawResponse.headers["azure-asyncoperation"];
    }
    function findResourceLocation(inputs) {
      var _a;
      const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
      switch (requestMethod) {
        case "PUT": {
          return requestPath;
        }
        case "DELETE": {
          return void 0;
        }
        case "PATCH": {
          return (_a = getDefault()) !== null && _a !== void 0 ? _a : requestPath;
        }
        default: {
          return getDefault();
        }
      }
      function getDefault() {
        switch (resourceLocationConfig) {
          case "azure-async-operation": {
            return void 0;
          }
          case "original-uri": {
            return requestPath;
          }
          case "location":
          default: {
            return location;
          }
        }
      }
    }
    function inferLroMode(inputs) {
      const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;
      const operationLocation = getOperationLocationHeader(rawResponse);
      const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);
      const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });
      const location = getLocationHeader(rawResponse);
      const normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();
      if (pollingUrl !== void 0) {
        return {
          mode: "OperationLocation",
          operationLocation: pollingUrl,
          resourceLocation: findResourceLocation({
            requestMethod: normalizedRequestMethod,
            location,
            requestPath,
            resourceLocationConfig
          })
        };
      } else if (location !== void 0) {
        return {
          mode: "ResourceLocation",
          operationLocation: location
        };
      } else if (normalizedRequestMethod === "PUT" && requestPath) {
        return {
          mode: "Body",
          operationLocation: requestPath
        };
      } else {
        return void 0;
      }
    }
    exports.inferLroMode = inferLroMode;
    function transformStatus(inputs) {
      const { status, statusCode } = inputs;
      if (typeof status !== "string" && status !== void 0) {
        throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);
      }
      switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {
        case void 0:
          return toOperationStatus(statusCode);
        case "succeeded":
          return "succeeded";
        case "failed":
          return "failed";
        case "running":
        case "accepted":
        case "started":
        case "canceling":
        case "cancelling":
          return "running";
        case "canceled":
        case "cancelled":
          return "canceled";
        default: {
          logger_js_1.logger.verbose(`LRO: unrecognized operation status: ${status}`);
          return status;
        }
      }
    }
    function getStatus(rawResponse) {
      var _a;
      const { status } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
      return transformStatus({ status, statusCode: rawResponse.statusCode });
    }
    function getProvisioningState(rawResponse) {
      var _a, _b;
      const { properties, provisioningState } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
      const status = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;
      return transformStatus({ status, statusCode: rawResponse.statusCode });
    }
    function toOperationStatus(statusCode) {
      if (statusCode === 202) {
        return "running";
      } else if (statusCode < 300) {
        return "succeeded";
      } else {
        return "failed";
      }
    }
    function parseRetryAfter({ rawResponse }) {
      const retryAfter = rawResponse.headers["retry-after"];
      if (retryAfter !== void 0) {
        const retryAfterInSeconds = parseInt(retryAfter);
        return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1e3;
      }
      return void 0;
    }
    exports.parseRetryAfter = parseRetryAfter;
    function getErrorFromResponse(response) {
      const error2 = accessBodyProperty(response, "error");
      if (!error2) {
        logger_js_1.logger.warning(`The long-running operation failed but there is no error property in the response's body`);
        return;
      }
      if (!error2.code || !error2.message) {
        logger_js_1.logger.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);
        return;
      }
      return error2;
    }
    exports.getErrorFromResponse = getErrorFromResponse;
    function calculatePollingIntervalFromDate(retryAfterDate) {
      const timeNow = Math.floor((/* @__PURE__ */ new Date()).getTime());
      const retryAfterTime = retryAfterDate.getTime();
      if (timeNow < retryAfterTime) {
        return retryAfterTime - timeNow;
      }
      return void 0;
    }
    function getStatusFromInitialResponse(inputs) {
      const { response, state, operationLocation } = inputs;
      function helper() {
        var _a;
        const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
        switch (mode) {
          case void 0:
            return toOperationStatus(response.rawResponse.statusCode);
          case "Body":
            return getOperationStatus(response, state);
          default:
            return "running";
        }
      }
      const status = helper();
      return status === "running" && operationLocation === void 0 ? "succeeded" : status;
    }
    exports.getStatusFromInitialResponse = getStatusFromInitialResponse;
    async function initHttpOperation(inputs) {
      const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;
      return (0, operation_js_1.initOperation)({
        init: async () => {
          const response = await lro.sendInitialRequest();
          const config = inferLroMode({
            rawResponse: response.rawResponse,
            requestPath: lro.requestPath,
            requestMethod: lro.requestMethod,
            resourceLocationConfig
          });
          return Object.assign({ response, operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation, resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation }, (config === null || config === void 0 ? void 0 : config.mode) ? { metadata: { mode: config.mode } } : {});
        },
        stateProxy,
        processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse,
        getOperationStatus: getStatusFromInitialResponse,
        setErrorAsResult
      });
    }
    exports.initHttpOperation = initHttpOperation;
    function getOperationLocation({ rawResponse }, state) {
      var _a;
      const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
      switch (mode) {
        case "OperationLocation": {
          return getOperationLocationPollingUrl({
            operationLocation: getOperationLocationHeader(rawResponse),
            azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
          });
        }
        case "ResourceLocation": {
          return getLocationHeader(rawResponse);
        }
        case "Body":
        default: {
          return void 0;
        }
      }
    }
    exports.getOperationLocation = getOperationLocation;
    function getOperationStatus({ rawResponse }, state) {
      var _a;
      const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
      switch (mode) {
        case "OperationLocation": {
          return getStatus(rawResponse);
        }
        case "ResourceLocation": {
          return toOperationStatus(rawResponse.statusCode);
        }
        case "Body": {
          return getProvisioningState(rawResponse);
        }
        default:
          throw new Error(`Internal error: Unexpected operation mode: ${mode}`);
      }
    }
    exports.getOperationStatus = getOperationStatus;
    function accessBodyProperty({ flatResponse, rawResponse }, prop) {
      var _a, _b;
      return (_a = flatResponse === null || flatResponse === void 0 ? void 0 : flatResponse[prop]) !== null && _a !== void 0 ? _a : (_b = rawResponse.body) === null || _b === void 0 ? void 0 : _b[prop];
    }
    function getResourceLocation(res, state) {
      const loc = accessBodyProperty(res, "resourceLocation");
      if (loc && typeof loc === "string") {
        state.config.resourceLocation = loc;
      }
      return state.config.resourceLocation;
    }
    exports.getResourceLocation = getResourceLocation;
    function isOperationError(e) {
      return e.name === "RestError";
    }
    exports.isOperationError = isOperationError;
    async function pollHttpOperation(inputs) {
      const { lro, stateProxy, options, processResult, updateState, setDelay, state, setErrorAsResult } = inputs;
      return (0, operation_js_1.pollOperation)({
        state,
        stateProxy,
        setDelay,
        processResult: processResult ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState) : ({ flatResponse }) => flatResponse,
        getError: getErrorFromResponse,
        updateState,
        getPollingInterval: parseRetryAfter,
        getOperationLocation,
        getOperationStatus,
        isOperationError,
        getResourceLocation,
        options,
        /**
         * The expansion here is intentional because `lro` could be an object that
         * references an inner this, so we need to preserve a reference to it.
         */
        poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),
        setErrorAsResult
      });
    }
    exports.pollHttpOperation = pollHttpOperation;
  }
});

// node_modules/@azure/core-lro/dist/commonjs/poller/poller.js
var require_poller = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/poller/poller.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildCreatePoller = void 0;
    var operation_js_1 = require_operation();
    var constants_js_1 = require_constants11();
    var core_util_1 = require_commonjs4();
    var createStateProxy = () => ({
      /**
       * The state at this point is created to be of type OperationState<TResult>.
       * It will be updated later to be of type TState when the
       * customer-provided callback, `updateState`, is called during polling.
       */
      initState: (config) => ({ status: "running", config }),
      setCanceled: (state) => state.status = "canceled",
      setError: (state, error2) => state.error = error2,
      setResult: (state, result) => state.result = result,
      setRunning: (state) => state.status = "running",
      setSucceeded: (state) => state.status = "succeeded",
      setFailed: (state) => state.status = "failed",
      getError: (state) => state.error,
      getResult: (state) => state.result,
      isCanceled: (state) => state.status === "canceled",
      isFailed: (state) => state.status === "failed",
      isRunning: (state) => state.status === "running",
      isSucceeded: (state) => state.status === "succeeded"
    });
    function buildCreatePoller(inputs) {
      const { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, isOperationError, getResourceLocation, getPollingInterval, getError, resolveOnUnsuccessful } = inputs;
      return async ({ init: init2, poll }, options) => {
        const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, restoreFrom } = options || {};
        const stateProxy = createStateProxy();
        const withOperationLocation = withOperationLocationCallback ? /* @__PURE__ */ (() => {
          let called = false;
          return (operationLocation, isUpdated) => {
            if (isUpdated)
              withOperationLocationCallback(operationLocation);
            else if (!called)
              withOperationLocationCallback(operationLocation);
            called = true;
          };
        })() : void 0;
        const state = restoreFrom ? (0, operation_js_1.deserializeState)(restoreFrom) : await (0, operation_js_1.initOperation)({
          init: init2,
          stateProxy,
          processResult,
          getOperationStatus: getStatusFromInitialResponse,
          withOperationLocation,
          setErrorAsResult: !resolveOnUnsuccessful
        });
        let resultPromise;
        const abortController = new AbortController();
        const handlers = /* @__PURE__ */ new Map();
        const handleProgressEvents = async () => handlers.forEach((h2) => h2(state));
        const cancelErrMsg = "Operation was canceled";
        let currentPollIntervalInMs = intervalInMs;
        const poller = {
          getOperationState: () => state,
          getResult: () => state.result,
          isDone: () => ["succeeded", "failed", "canceled"].includes(state.status),
          isStopped: () => resultPromise === void 0,
          stopPolling: () => {
            abortController.abort();
          },
          toString: () => JSON.stringify({
            state
          }),
          onProgress: (callback) => {
            const s = /* @__PURE__ */ Symbol();
            handlers.set(s, callback);
            return () => handlers.delete(s);
          },
          pollUntilDone: (pollOptions) => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = (async () => {
            const { abortSignal: inputAbortSignal } = pollOptions || {};
            function abortListener() {
              abortController.abort();
            }
            const abortSignal2 = abortController.signal;
            if (inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.aborted) {
              abortController.abort();
            } else if (!abortSignal2.aborted) {
              inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.addEventListener("abort", abortListener, { once: true });
            }
            try {
              if (!poller.isDone()) {
                await poller.poll({ abortSignal: abortSignal2 });
                while (!poller.isDone()) {
                  await (0, core_util_1.delay)(currentPollIntervalInMs, { abortSignal: abortSignal2 });
                  await poller.poll({ abortSignal: abortSignal2 });
                }
              }
            } finally {
              inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.removeEventListener("abort", abortListener);
            }
            if (resolveOnUnsuccessful) {
              return poller.getResult();
            } else {
              switch (state.status) {
                case "succeeded":
                  return poller.getResult();
                case "canceled":
                  throw new Error(cancelErrMsg);
                case "failed":
                  throw state.error;
                case "notStarted":
                case "running":
                  throw new Error(`Polling completed without succeeding or failing`);
              }
            }
          })().finally(() => {
            resultPromise = void 0;
          }),
          async poll(pollOptions) {
            if (resolveOnUnsuccessful) {
              if (poller.isDone())
                return;
            } else {
              switch (state.status) {
                case "succeeded":
                  return;
                case "canceled":
                  throw new Error(cancelErrMsg);
                case "failed":
                  throw state.error;
              }
            }
            await (0, operation_js_1.pollOperation)({
              poll,
              state,
              stateProxy,
              getOperationLocation,
              isOperationError,
              withOperationLocation,
              getPollingInterval,
              getOperationStatus: getStatusFromPollResponse,
              getResourceLocation,
              processResult,
              getError,
              updateState,
              options: pollOptions,
              setDelay: (pollIntervalInMs) => {
                currentPollIntervalInMs = pollIntervalInMs;
              },
              setErrorAsResult: !resolveOnUnsuccessful
            });
            await handleProgressEvents();
            if (!resolveOnUnsuccessful) {
              switch (state.status) {
                case "canceled":
                  throw new Error(cancelErrMsg);
                case "failed":
                  throw state.error;
              }
            }
          }
        };
        return poller;
      };
    }
    exports.buildCreatePoller = buildCreatePoller;
  }
});

// node_modules/@azure/core-lro/dist/commonjs/http/poller.js
var require_poller2 = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/http/poller.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHttpPoller = void 0;
    var operation_js_1 = require_operation2();
    var poller_js_1 = require_poller();
    async function createHttpPoller(lro, options) {
      const { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, resolveOnUnsuccessful = false } = options || {};
      return (0, poller_js_1.buildCreatePoller)({
        getStatusFromInitialResponse: operation_js_1.getStatusFromInitialResponse,
        getStatusFromPollResponse: operation_js_1.getOperationStatus,
        isOperationError: operation_js_1.isOperationError,
        getOperationLocation: operation_js_1.getOperationLocation,
        getResourceLocation: operation_js_1.getResourceLocation,
        getPollingInterval: operation_js_1.parseRetryAfter,
        getError: operation_js_1.getErrorFromResponse,
        resolveOnUnsuccessful
      })({
        init: async () => {
          const response = await lro.sendInitialRequest();
          const config = (0, operation_js_1.inferLroMode)({
            rawResponse: response.rawResponse,
            requestPath: lro.requestPath,
            requestMethod: lro.requestMethod,
            resourceLocationConfig
          });
          return Object.assign({ response, operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation, resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation }, (config === null || config === void 0 ? void 0 : config.mode) ? { metadata: { mode: config.mode } } : {});
        },
        poll: lro.sendPollRequest
      }, {
        intervalInMs,
        withOperationLocation,
        restoreFrom,
        updateState,
        processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse
      });
    }
    exports.createHttpPoller = createHttpPoller;
  }
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/operation.js
var require_operation3 = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GenericPollOperation = void 0;
    var operation_js_1 = require_operation2();
    var logger_js_1 = require_logger2();
    var createStateProxy = () => ({
      initState: (config) => ({ config, isStarted: true }),
      setCanceled: (state) => state.isCancelled = true,
      setError: (state, error2) => state.error = error2,
      setResult: (state, result) => state.result = result,
      setRunning: (state) => state.isStarted = true,
      setSucceeded: (state) => state.isCompleted = true,
      setFailed: () => {
      },
      getError: (state) => state.error,
      getResult: (state) => state.result,
      isCanceled: (state) => !!state.isCancelled,
      isFailed: (state) => !!state.error,
      isRunning: (state) => !!state.isStarted,
      isSucceeded: (state) => Boolean(state.isCompleted && !state.isCancelled && !state.error)
    });
    var GenericPollOperation = class {
      constructor(state, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {
        this.state = state;
        this.lro = lro;
        this.setErrorAsResult = setErrorAsResult;
        this.lroResourceLocationConfig = lroResourceLocationConfig;
        this.processResult = processResult;
        this.updateState = updateState;
        this.isDone = isDone;
      }
      setPollerConfig(pollerConfig) {
        this.pollerConfig = pollerConfig;
      }
      async update(options) {
        var _a;
        const stateProxy = createStateProxy();
        if (!this.state.isStarted) {
          this.state = Object.assign(Object.assign({}, this.state), await (0, operation_js_1.initHttpOperation)({
            lro: this.lro,
            stateProxy,
            resourceLocationConfig: this.lroResourceLocationConfig,
            processResult: this.processResult,
            setErrorAsResult: this.setErrorAsResult
          }));
        }
        const updateState = this.updateState;
        const isDone = this.isDone;
        if (!this.state.isCompleted && this.state.error === void 0) {
          await (0, operation_js_1.pollHttpOperation)({
            lro: this.lro,
            state: this.state,
            stateProxy,
            processResult: this.processResult,
            updateState: updateState ? (state, { rawResponse }) => updateState(state, rawResponse) : void 0,
            isDone: isDone ? ({ flatResponse }, state) => isDone(flatResponse, state) : void 0,
            options,
            setDelay: (intervalInMs) => {
              this.pollerConfig.intervalInMs = intervalInMs;
            },
            setErrorAsResult: this.setErrorAsResult
          });
        }
        (_a = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _a === void 0 ? void 0 : _a.call(options, this.state);
        return this;
      }
      async cancel() {
        logger_js_1.logger.error("`cancelOperation` is deprecated because it wasn't implemented");
        return this;
      }
      /**
       * Serializes the Poller operation.
       */
      toString() {
        return JSON.stringify({
          state: this.state
        });
      }
    };
    exports.GenericPollOperation = GenericPollOperation;
  }
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/poller.js
var require_poller3 = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/legacy/poller.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Poller = exports.PollerCancelledError = exports.PollerStoppedError = void 0;
    var PollerStoppedError = class _PollerStoppedError extends Error {
      constructor(message) {
        super(message);
        this.name = "PollerStoppedError";
        Object.setPrototypeOf(this, _PollerStoppedError.prototype);
      }
    };
    exports.PollerStoppedError = PollerStoppedError;
    var PollerCancelledError = class _PollerCancelledError extends Error {
      constructor(message) {
        super(message);
        this.name = "PollerCancelledError";
        Object.setPrototypeOf(this, _PollerCancelledError.prototype);
      }
    };
    exports.PollerCancelledError = PollerCancelledError;
    var Poller = class {
      /**
       * A poller needs to be initialized by passing in at least the basic properties of the `PollOperation<TState, TResult>`.
       *
       * When writing an implementation of a Poller, this implementation needs to deal with the initialization
       * of any custom state beyond the basic definition of the poller. The basic poller assumes that the poller's
       * operation has already been defined, at least its basic properties. The code below shows how to approach
       * the definition of the constructor of a new custom poller.
       *
       * ```ts
       * export class MyPoller extends Poller<MyOperationState, string> {
       *   constructor({
       *     // Anything you might need outside of the basics
       *   }) {
       *     let state: MyOperationState = {
       *       privateProperty: private,
       *       publicProperty: public,
       *     };
       *
       *     const operation = {
       *       state,
       *       update,
       *       cancel,
       *       toString
       *     }
       *
       *     // Sending the operation to the parent's constructor.
       *     super(operation);
       *
       *     // You can assign more local properties here.
       *   }
       * }
       * ```
       *
       * Inside of this constructor, a new promise is created. This will be used to
       * tell the user when the poller finishes (see `pollUntilDone()`). The promise's
       * resolve and reject methods are also used internally to control when to resolve
       * or reject anyone waiting for the poller to finish.
       *
       * The constructor of a custom implementation of a poller is where any serialized version of
       * a previous poller's operation should be deserialized into the operation sent to the
       * base constructor. For example:
       *
       * ```ts
       * export class MyPoller extends Poller<MyOperationState, string> {
       *   constructor(
       *     baseOperation: string | undefined
       *   ) {
       *     let state: MyOperationState = {};
       *     if (baseOperation) {
       *       state = {
       *         ...JSON.parse(baseOperation).state,
       *         ...state
       *       };
       *     }
       *     const operation = {
       *       state,
       *       // ...
       *     }
       *     super(operation);
       *   }
       * }
       * ```
       *
       * @param operation - Must contain the basic properties of `PollOperation<State, TResult>`.
       */
      constructor(operation) {
        this.resolveOnUnsuccessful = false;
        this.stopped = true;
        this.pollProgressCallbacks = [];
        this.operation = operation;
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
        this.promise.catch(() => {
        });
      }
      /**
       * Starts a loop that will break only if the poller is done
       * or if the poller is stopped.
       */
      async startPolling(pollOptions = {}) {
        if (this.stopped) {
          this.stopped = false;
        }
        while (!this.isStopped() && !this.isDone()) {
          await this.poll(pollOptions);
          await this.delay();
        }
      }
      /**
       * pollOnce does one polling, by calling to the update method of the underlying
       * poll operation to make any relevant change effective.
       *
       * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
       *
       * @param options - Optional properties passed to the operation's update method.
       */
      async pollOnce(options = {}) {
        if (!this.isDone()) {
          this.operation = await this.operation.update({
            abortSignal: options.abortSignal,
            fireProgress: this.fireProgress.bind(this)
          });
        }
        this.processUpdatedState();
      }
      /**
       * fireProgress calls the functions passed in via onProgress the method of the poller.
       *
       * It loops over all of the callbacks received from onProgress, and executes them, sending them
       * the current operation state.
       *
       * @param state - The current operation state.
       */
      fireProgress(state) {
        for (const callback of this.pollProgressCallbacks) {
          callback(state);
        }
      }
      /**
       * Invokes the underlying operation's cancel method.
       */
      async cancelOnce(options = {}) {
        this.operation = await this.operation.cancel(options);
      }
      /**
       * Returns a promise that will resolve once a single polling request finishes.
       * It does this by calling the update method of the Poller's operation.
       *
       * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
       *
       * @param options - Optional properties passed to the operation's update method.
       */
      poll(options = {}) {
        if (!this.pollOncePromise) {
          this.pollOncePromise = this.pollOnce(options);
          const clearPollOncePromise = () => {
            this.pollOncePromise = void 0;
          };
          this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
        }
        return this.pollOncePromise;
      }
      processUpdatedState() {
        if (this.operation.state.error) {
          this.stopped = true;
          if (!this.resolveOnUnsuccessful) {
            this.reject(this.operation.state.error);
            throw this.operation.state.error;
          }
        }
        if (this.operation.state.isCancelled) {
          this.stopped = true;
          if (!this.resolveOnUnsuccessful) {
            const error2 = new PollerCancelledError("Operation was canceled");
            this.reject(error2);
            throw error2;
          }
        }
        if (this.isDone() && this.resolve) {
          this.resolve(this.getResult());
        }
      }
      /**
       * Returns a promise that will resolve once the underlying operation is completed.
       */
      async pollUntilDone(pollOptions = {}) {
        if (this.stopped) {
          this.startPolling(pollOptions).catch(this.reject);
        }
        this.processUpdatedState();
        return this.promise;
      }
      /**
       * Invokes the provided callback after each polling is completed,
       * sending the current state of the poller's operation.
       *
       * It returns a method that can be used to stop receiving updates on the given callback function.
       */
      onProgress(callback) {
        this.pollProgressCallbacks.push(callback);
        return () => {
          this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c3) => c3 !== callback);
        };
      }
      /**
       * Returns true if the poller has finished polling.
       */
      isDone() {
        const state = this.operation.state;
        return Boolean(state.isCompleted || state.isCancelled || state.error);
      }
      /**
       * Stops the poller from continuing to poll.
       */
      stopPolling() {
        if (!this.stopped) {
          this.stopped = true;
          if (this.reject) {
            this.reject(new PollerStoppedError("This poller is already stopped"));
          }
        }
      }
      /**
       * Returns true if the poller is stopped.
       */
      isStopped() {
        return this.stopped;
      }
      /**
       * Attempts to cancel the underlying operation.
       *
       * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
       *
       * If it's called again before it finishes, it will throw an error.
       *
       * @param options - Optional properties passed to the operation's update method.
       */
      cancelOperation(options = {}) {
        if (!this.cancelPromise) {
          this.cancelPromise = this.cancelOnce(options);
        } else if (options.abortSignal) {
          throw new Error("A cancel request is currently pending");
        }
        return this.cancelPromise;
      }
      /**
       * Returns the state of the operation.
       *
       * Even though TState will be the same type inside any of the methods of any extension of the Poller class,
       * implementations of the pollers can customize what's shared with the public by writing their own
       * version of the `getOperationState` method, and by defining two types, one representing the internal state of the poller
       * and a public type representing a safe to share subset of the properties of the internal state.
       * Their definition of getOperationState can then return their public type.
       *
       * Example:
       *
       * ```ts
       * // Let's say we have our poller's operation state defined as:
       * interface MyOperationState extends PollOperationState<ResultType> {
       *   privateProperty?: string;
       *   publicProperty?: string;
       * }
       *
       * // To allow us to have a true separation of public and private state, we have to define another interface:
       * interface PublicState extends PollOperationState<ResultType> {
       *   publicProperty?: string;
       * }
       *
       * // Then, we define our Poller as follows:
       * export class MyPoller extends Poller<MyOperationState, ResultType> {
       *   // ... More content is needed here ...
       *
       *   public getOperationState(): PublicState {
       *     const state: PublicState = this.operation.state;
       *     return {
       *       // Properties from PollOperationState<TResult>
       *       isStarted: state.isStarted,
       *       isCompleted: state.isCompleted,
       *       isCancelled: state.isCancelled,
       *       error: state.error,
       *       result: state.result,
       *
       *       // The only other property needed by PublicState.
       *       publicProperty: state.publicProperty
       *     }
       *   }
       * }
       * ```
       *
       * You can see this in the tests of this repository, go to the file:
       * `../test/utils/testPoller.ts`
       * and look for the getOperationState implementation.
       */
      getOperationState() {
        return this.operation.state;
      }
      /**
       * Returns the result value of the operation,
       * regardless of the state of the poller.
       * It can return undefined or an incomplete form of the final TResult value
       * depending on the implementation.
       */
      getResult() {
        const state = this.operation.state;
        return state.result;
      }
      /**
       * Returns a serialized version of the poller's operation
       * by invoking the operation's toString method.
       */
      toString() {
        return this.operation.toString();
      }
    };
    exports.Poller = Poller;
  }
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/lroEngine.js
var require_lroEngine = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/lroEngine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LroEngine = void 0;
    var operation_js_1 = require_operation3();
    var constants_js_1 = require_constants11();
    var poller_js_1 = require_poller3();
    var operation_js_2 = require_operation();
    var LroEngine = class extends poller_js_1.Poller {
      constructor(lro, options) {
        const { intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, resumeFrom, resolveOnUnsuccessful = false, isDone, lroResourceLocationConfig, processResult, updateState } = options || {};
        const state = resumeFrom ? (0, operation_js_2.deserializeState)(resumeFrom) : {};
        const operation = new operation_js_1.GenericPollOperation(state, lro, !resolveOnUnsuccessful, lroResourceLocationConfig, processResult, updateState, isDone);
        super(operation);
        this.resolveOnUnsuccessful = resolveOnUnsuccessful;
        this.config = { intervalInMs };
        operation.setPollerConfig(this.config);
      }
      /**
       * The method used by the poller to wait before attempting to update its operation.
       */
      delay() {
        return new Promise((resolve) => setTimeout(() => resolve(), this.config.intervalInMs));
      }
    };
    exports.LroEngine = LroEngine;
  }
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/index.js
var require_lroEngine2 = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LroEngine = void 0;
    var lroEngine_js_1 = require_lroEngine();
    Object.defineProperty(exports, "LroEngine", { enumerable: true, get: function() {
      return lroEngine_js_1.LroEngine;
    } });
  }
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/pollOperation.js
var require_pollOperation = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/legacy/pollOperation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@azure/core-lro/dist/commonjs/index.js
var require_commonjs14 = __commonJS({
  "node_modules/@azure/core-lro/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHttpPoller = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var poller_js_1 = require_poller2();
    Object.defineProperty(exports, "createHttpPoller", { enumerable: true, get: function() {
      return poller_js_1.createHttpPoller;
    } });
    tslib_1.__exportStar(require_lroEngine2(), exports);
    tslib_1.__exportStar(require_poller3(), exports);
    tslib_1.__exportStar(require_pollOperation(), exports);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/pollers/BlobStartCopyFromUrlPoller.js
var require_BlobStartCopyFromUrlPoller = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/pollers/BlobStartCopyFromUrlPoller.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobBeginCopyFromUrlPoller = void 0;
    var core_util_1 = require_commonjs4();
    var core_lro_1 = require_commonjs14();
    var BlobBeginCopyFromUrlPoller = class extends core_lro_1.Poller {
      intervalInMs;
      constructor(options) {
        const { blobClient, copySource, intervalInMs = 15e3, onProgress, resumeFrom, startCopyFromURLOptions } = options;
        let state;
        if (resumeFrom) {
          state = JSON.parse(resumeFrom).state;
        }
        const operation = makeBlobBeginCopyFromURLPollOperation({
          ...state,
          blobClient,
          copySource,
          startCopyFromURLOptions
        });
        super(operation);
        if (typeof onProgress === "function") {
          this.onProgress(onProgress);
        }
        this.intervalInMs = intervalInMs;
      }
      delay() {
        return (0, core_util_1.delay)(this.intervalInMs);
      }
    };
    exports.BlobBeginCopyFromUrlPoller = BlobBeginCopyFromUrlPoller;
    var cancel = async function cancel2(options = {}) {
      const state = this.state;
      const { copyId } = state;
      if (state.isCompleted) {
        return makeBlobBeginCopyFromURLPollOperation(state);
      }
      if (!copyId) {
        state.isCancelled = true;
        return makeBlobBeginCopyFromURLPollOperation(state);
      }
      await state.blobClient.abortCopyFromURL(copyId, {
        abortSignal: options.abortSignal
      });
      state.isCancelled = true;
      return makeBlobBeginCopyFromURLPollOperation(state);
    };
    var update = async function update2(options = {}) {
      const state = this.state;
      const { blobClient, copySource, startCopyFromURLOptions } = state;
      if (!state.isStarted) {
        state.isStarted = true;
        const result = await blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);
        state.copyId = result.copyId;
        if (result.copyStatus === "success") {
          state.result = result;
          state.isCompleted = true;
        }
      } else if (!state.isCompleted) {
        try {
          const result = await state.blobClient.getProperties({ abortSignal: options.abortSignal });
          const { copyStatus, copyProgress } = result;
          const prevCopyProgress = state.copyProgress;
          if (copyProgress) {
            state.copyProgress = copyProgress;
          }
          if (copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options.fireProgress === "function") {
            options.fireProgress(state);
          } else if (copyStatus === "success") {
            state.result = result;
            state.isCompleted = true;
          } else if (copyStatus === "failed") {
            state.error = new Error(`Blob copy failed with reason: "${result.copyStatusDescription || "unknown"}"`);
            state.isCompleted = true;
          }
        } catch (err) {
          state.error = err;
          state.isCompleted = true;
        }
      }
      return makeBlobBeginCopyFromURLPollOperation(state);
    };
    var toString2 = function toString3() {
      return JSON.stringify({ state: this.state }, (key, value) => {
        if (key === "blobClient") {
          return void 0;
        }
        return value;
      });
    };
    function makeBlobBeginCopyFromURLPollOperation(state) {
      return {
        state: { ...state },
        cancel,
        toString: toString2,
        update
      };
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/Range.js
var require_Range = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/Range.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rangeToString = rangeToString;
    function rangeToString(iRange) {
      if (iRange.offset < 0) {
        throw new RangeError(`Range.offset cannot be smaller than 0.`);
      }
      if (iRange.count && iRange.count <= 0) {
        throw new RangeError(`Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.`);
      }
      return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/Batch.js
var require_Batch = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/utils/Batch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Batch = void 0;
    var events_1 = __require("events");
    var BatchStates;
    (function(BatchStates2) {
      BatchStates2[BatchStates2["Good"] = 0] = "Good";
      BatchStates2[BatchStates2["Error"] = 1] = "Error";
    })(BatchStates || (BatchStates = {}));
    var Batch = class {
      /**
       * Concurrency. Must be lager than 0.
       */
      concurrency;
      /**
       * Number of active operations under execution.
       */
      actives = 0;
      /**
       * Number of completed operations under execution.
       */
      completed = 0;
      /**
       * Offset of next operation to be executed.
       */
      offset = 0;
      /**
       * Operation array to be executed.
       */
      operations = [];
      /**
       * States of Batch. When an error happens, state will turn into error.
       * Batch will stop execute left operations.
       */
      state = BatchStates.Good;
      /**
       * A private emitter used to pass events inside this class.
       */
      emitter;
      /**
       * Creates an instance of Batch.
       * @param concurrency -
       */
      constructor(concurrency = 5) {
        if (concurrency < 1) {
          throw new RangeError("concurrency must be larger than 0");
        }
        this.concurrency = concurrency;
        this.emitter = new events_1.EventEmitter();
      }
      /**
       * Add a operation into queue.
       *
       * @param operation -
       */
      addOperation(operation) {
        this.operations.push(async () => {
          try {
            this.actives++;
            await operation();
            this.actives--;
            this.completed++;
            this.parallelExecute();
          } catch (error2) {
            this.emitter.emit("error", error2);
          }
        });
      }
      /**
       * Start execute operations in the queue.
       *
       */
      async do() {
        if (this.operations.length === 0) {
          return Promise.resolve();
        }
        this.parallelExecute();
        return new Promise((resolve, reject) => {
          this.emitter.on("finish", resolve);
          this.emitter.on("error", (error2) => {
            this.state = BatchStates.Error;
            reject(error2);
          });
        });
      }
      /**
       * Get next operation to be executed. Return null when reaching ends.
       *
       */
      nextOperation() {
        if (this.offset < this.operations.length) {
          return this.operations[this.offset++];
        }
        return null;
      }
      /**
       * Start execute operations. One one the most important difference between
       * this method with do() is that do() wraps as an sync method.
       *
       */
      parallelExecute() {
        if (this.state === BatchStates.Error) {
          return;
        }
        if (this.completed >= this.operations.length) {
          this.emitter.emit("finish");
          return;
        }
        while (this.actives < this.concurrency) {
          const operation = this.nextOperation();
          if (operation) {
            operation();
          } else {
            return;
          }
        }
      }
    };
    exports.Batch = Batch;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/utils.js
var require_utils4 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/utils/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fsCreateReadStream = exports.fsStat = void 0;
    exports.streamToBuffer = streamToBuffer;
    exports.streamToBuffer2 = streamToBuffer2;
    exports.streamToBuffer3 = streamToBuffer3;
    exports.readStreamToLocalFile = readStreamToLocalFile;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_fs_1 = tslib_1.__importDefault(__require("fs"));
    var node_util_1 = tslib_1.__importDefault(__require("util"));
    var constants_js_1 = require_constants9();
    async function streamToBuffer(stream2, buffer, offset, end, encoding) {
      let pos = 0;
      const count = end - offset;
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => reject(new Error(`The operation cannot be completed in timeout.`)), constants_js_1.REQUEST_TIMEOUT);
        stream2.on("readable", () => {
          if (pos >= count) {
            clearTimeout(timeout);
            resolve();
            return;
          }
          let chunk2 = stream2.read();
          if (!chunk2) {
            return;
          }
          if (typeof chunk2 === "string") {
            chunk2 = Buffer.from(chunk2, encoding);
          }
          const chunkLength = pos + chunk2.length > count ? count - pos : chunk2.length;
          buffer.fill(chunk2.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
          pos += chunkLength;
        });
        stream2.on("end", () => {
          clearTimeout(timeout);
          if (pos < count) {
            reject(new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
          }
          resolve();
        });
        stream2.on("error", (msg) => {
          clearTimeout(timeout);
          reject(msg);
        });
      });
    }
    async function streamToBuffer2(stream2, buffer, encoding) {
      let pos = 0;
      const bufferSize = buffer.length;
      return new Promise((resolve, reject) => {
        stream2.on("readable", () => {
          let chunk2 = stream2.read();
          if (!chunk2) {
            return;
          }
          if (typeof chunk2 === "string") {
            chunk2 = Buffer.from(chunk2, encoding);
          }
          if (pos + chunk2.length > bufferSize) {
            reject(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
            return;
          }
          buffer.fill(chunk2, pos, pos + chunk2.length);
          pos += chunk2.length;
        });
        stream2.on("end", () => {
          resolve(pos);
        });
        stream2.on("error", reject);
      });
    }
    async function streamToBuffer3(readableStream, encoding) {
      return new Promise((resolve, reject) => {
        const chunks = [];
        readableStream.on("data", (data) => {
          chunks.push(typeof data === "string" ? Buffer.from(data, encoding) : data);
        });
        readableStream.on("end", () => {
          resolve(Buffer.concat(chunks));
        });
        readableStream.on("error", reject);
      });
    }
    async function readStreamToLocalFile(rs, file) {
      return new Promise((resolve, reject) => {
        const ws = node_fs_1.default.createWriteStream(file);
        rs.on("error", (err) => {
          reject(err);
        });
        ws.on("error", (err) => {
          reject(err);
        });
        ws.on("close", resolve);
        rs.pipe(ws);
      });
    }
    exports.fsStat = node_util_1.default.promisify(node_fs_1.default.stat);
    exports.fsCreateReadStream = node_fs_1.default.createReadStream;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/Clients.js
var require_Clients = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/Clients.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageBlobClient = exports.BlockBlobClient = exports.AppendBlobClient = exports.BlobClient = void 0;
    var core_rest_pipeline_1 = require_commonjs6();
    var core_auth_1 = require_commonjs7();
    var core_util_1 = require_commonjs4();
    var core_util_2 = require_commonjs4();
    var BlobDownloadResponse_js_1 = require_BlobDownloadResponse();
    var BlobQueryResponse_js_1 = require_BlobQueryResponse();
    var AnonymousCredential_js_1 = require_AnonymousCredential();
    var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential();
    var models_js_1 = require_models2();
    var PageBlobRangeResponse_js_1 = require_PageBlobRangeResponse();
    var Pipeline_js_1 = require_Pipeline();
    var BlobStartCopyFromUrlPoller_js_1 = require_BlobStartCopyFromUrlPoller();
    var Range_js_1 = require_Range();
    var StorageClient_js_1 = require_StorageClient();
    var Batch_js_1 = require_Batch();
    var storage_common_1 = require_commonjs13();
    var constants_js_1 = require_constants9();
    var tracing_js_1 = require_tracing();
    var utils_common_js_1 = require_utils_common();
    var utils_js_1 = require_utils4();
    var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
    var BlobLeaseClient_js_1 = require_BlobLeaseClient();
    var BlobClient = class _BlobClient extends StorageClient_js_1.StorageClient {
      /**
       * blobContext provided by protocol layer.
       */
      blobContext;
      _name;
      _containerName;
      _versionId;
      _snapshot;
      /**
       * The name of the blob.
       */
      get name() {
        return this._name;
      }
      /**
       * The name of the storage container the blob is associated with.
       */
      get containerName() {
        return this._containerName;
      }
      constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
        options = options || {};
        let pipeline;
        let url;
        if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          pipeline = credentialOrPipelineOrContainerName;
        } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          options = blobNameOrOptions;
          pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
        } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
          url = urlOrConnectionString;
          if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
            options = blobNameOrOptions;
          }
          pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
        } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
          const containerName = credentialOrPipelineOrContainerName;
          const blobName = blobNameOrOptions;
          const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
          if (extractedCreds.kind === "AccountConnString") {
            if (core_util_1.isNodeLike) {
              const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
              url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
              if (!options.proxyOptions) {
                options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
              }
              pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
            } else {
              throw new Error("Account connection string is only supported in Node.js environment");
            }
          } else if (extractedCreds.kind === "SASConnString") {
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
            pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
          } else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
          }
        } else {
          throw new Error("Expecting non-empty strings for containerName and blobName parameters");
        }
        super(url, pipeline);
        ({ blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl());
        this.blobContext = this.storageClientContext.blob;
        this._snapshot = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT);
        this._versionId = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID);
      }
      /**
       * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.
       * Provide "" will remove the snapshot and return a Client to the base blob.
       *
       * @param snapshot - The snapshot timestamp.
       * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp
       */
      withSnapshot(snapshot) {
        return new _BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
      }
      /**
       * Creates a new BlobClient object pointing to a version of this blob.
       * Provide "" will remove the versionId and return a Client to the base blob.
       *
       * @param versionId - The versionId.
       * @returns A new BlobClient object pointing to the version of this blob.
       */
      withVersion(versionId) {
        return new _BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID, versionId.length === 0 ? void 0 : versionId), this.pipeline);
      }
      /**
       * Creates a AppendBlobClient object.
       *
       */
      getAppendBlobClient() {
        return new AppendBlobClient(this.url, this.pipeline);
      }
      /**
       * Creates a BlockBlobClient object.
       *
       */
      getBlockBlobClient() {
        return new BlockBlobClient(this.url, this.pipeline);
      }
      /**
       * Creates a PageBlobClient object.
       *
       */
      getPageBlobClient() {
        return new PageBlobClient(this.url, this.pipeline);
      }
      /**
       * Reads or downloads a blob from the system, including its metadata and properties.
       * You can also call Get Blob to read a snapshot.
       *
       * * In Node.js, data returns in a Readable stream readableStreamBody
       * * In browsers, data returns in a promise blobBody
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/get-blob
       *
       * @param offset - From which position of the blob to download, greater than or equal to 0
       * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
       * @param options - Optional options to Blob Download operation.
       *
       *
       * Example usage (Node.js):
       *
       * ```ts snippet:ReadmeSampleDownloadBlob_Node
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const blobClient = containerClient.getBlobClient(blobName);
       *
       * // Get blob content from position 0 to the end
       * // In Node.js, get downloaded data by accessing downloadBlockBlobResponse.readableStreamBody
       * const downloadBlockBlobResponse = await blobClient.download();
       * if (downloadBlockBlobResponse.readableStreamBody) {
       *   const downloaded = await streamToString(downloadBlockBlobResponse.readableStreamBody);
       *   console.log(`Downloaded blob content: ${downloaded}`);
       * }
       *
       * async function streamToString(stream: NodeJS.ReadableStream): Promise<string> {
       *   const result = await new Promise<Buffer<ArrayBuffer>>((resolve, reject) => {
       *     const chunks: Buffer[] = [];
       *     stream.on("data", (data) => {
       *       chunks.push(Buffer.isBuffer(data) ? data : Buffer.from(data));
       *     });
       *     stream.on("end", () => {
       *       resolve(Buffer.concat(chunks));
       *     });
       *     stream.on("error", reject);
       *   });
       *   return result.toString();
       * }
       * ```
       *
       * Example usage (browser):
       *
       * ```ts snippet:ReadmeSampleDownloadBlob_Browser
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const blobClient = containerClient.getBlobClient(blobName);
       *
       * // Get blob content from position 0 to the end
       * // In browsers, get downloaded data by accessing downloadBlockBlobResponse.blobBody
       * const downloadBlockBlobResponse = await blobClient.download();
       * const blobBody = await downloadBlockBlobResponse.blobBody;
       * if (blobBody) {
       *   const downloaded = await blobBody.text();
       *   console.log(`Downloaded blob content: ${downloaded}`);
       * }
       * ```
       */
      async download(offset = 0, count, options = {}) {
        options.conditions = options.conditions || {};
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlobClient-download", options, async (updatedOptions) => {
          const res = (0, utils_common_js_1.assertResponse)(await this.blobContext.download({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            requestOptions: {
              onDownloadProgress: core_util_1.isNodeLike ? void 0 : options.onProgress
              // for Node.js, progress is reported by RetriableReadableStream
            },
            range: offset === 0 && !count ? void 0 : (0, Range_js_1.rangeToString)({ offset, count }),
            rangeGetContentMD5: options.rangeGetContentMD5,
            rangeGetContentCRC64: options.rangeGetContentCrc64,
            snapshot: options.snapshot,
            cpkInfo: options.customerProvidedKey,
            tracingOptions: updatedOptions.tracingOptions
          }));
          const wrappedRes = {
            ...res,
            _response: res._response,
            // _response is made non-enumerable
            objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
            objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
          };
          if (!core_util_1.isNodeLike) {
            return wrappedRes;
          }
          if (options.maxRetryRequests === void 0 || options.maxRetryRequests < 0) {
            options.maxRetryRequests = constants_js_1.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
          }
          if (res.contentLength === void 0) {
            throw new RangeError(`File download response doesn't contain valid content length header`);
          }
          if (!res.etag) {
            throw new RangeError(`File download response doesn't contain valid etag header`);
          }
          return new BlobDownloadResponse_js_1.BlobDownloadResponse(wrappedRes, async (start) => {
            const updatedDownloadOptions = {
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: {
                ifMatch: options.conditions.ifMatch || res.etag,
                ifModifiedSince: options.conditions.ifModifiedSince,
                ifNoneMatch: options.conditions.ifNoneMatch,
                ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,
                ifTags: options.conditions?.tagConditions
              },
              range: (0, Range_js_1.rangeToString)({
                count: offset + res.contentLength - start,
                offset: start
              }),
              rangeGetContentMD5: options.rangeGetContentMD5,
              rangeGetContentCRC64: options.rangeGetContentCrc64,
              snapshot: options.snapshot,
              cpkInfo: options.customerProvidedKey
            };
            return (await this.blobContext.download({
              abortSignal: options.abortSignal,
              ...updatedDownloadOptions
            })).readableStreamBody;
          }, offset, res.contentLength, {
            maxRetryRequests: options.maxRetryRequests,
            onProgress: options.onProgress
          });
        });
      }
      /**
       * Returns true if the Azure blob resource represented by this client exists; false otherwise.
       *
       * NOTE: use this function with care since an existing blob might be deleted by other clients or
       * applications. Vice versa new blobs might be added by other clients or applications after this
       * function completes.
       *
       * @param options - options to Exists operation.
       */
      async exists(options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-exists", options, async (updatedOptions) => {
          try {
            (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
            await this.getProperties({
              abortSignal: options.abortSignal,
              customerProvidedKey: options.customerProvidedKey,
              conditions: options.conditions,
              tracingOptions: updatedOptions.tracingOptions
            });
            return true;
          } catch (e) {
            if (e.statusCode === 404) {
              return false;
            } else if (e.statusCode === 409 && (e.details.errorCode === constants_js_1.BlobUsesCustomerSpecifiedEncryptionMsg || e.details.errorCode === constants_js_1.BlobDoesNotUseCustomerSpecifiedEncryption)) {
              return true;
            }
            throw e;
          }
        });
      }
      /**
       * Returns all user-defined metadata, standard HTTP properties, and system properties
       * for the blob. It does not return the content of the blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-properties
       *
       * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
       * they originally contained uppercase characters. This differs from the metadata keys returned by
       * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which
       * will retain their original casing.
       *
       * @param options - Optional options to Get Properties operation.
       */
      async getProperties(options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlobClient-getProperties", options, async (updatedOptions) => {
          const res = (0, utils_common_js_1.assertResponse)(await this.blobContext.getProperties({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            cpkInfo: options.customerProvidedKey,
            tracingOptions: updatedOptions.tracingOptions
          }));
          return {
            ...res,
            _response: res._response,
            // _response is made non-enumerable
            objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
            objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
          };
        });
      }
      /**
       * Marks the specified blob or snapshot for deletion. The blob is later deleted
       * during garbage collection. Note that in order to delete a blob, you must delete
       * all of its snapshots. You can delete both at the same time with the Delete
       * Blob operation.
       * @see https://learn.microsoft.com/rest/api/storageservices/delete-blob
       *
       * @param options - Optional options to Blob Delete operation.
       */
      async delete(options = {}) {
        options.conditions = options.conditions || {};
        return tracing_js_1.tracingClient.withSpan("BlobClient-delete", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.delete({
            abortSignal: options.abortSignal,
            deleteSnapshots: options.deleteSnapshots,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted
       * during garbage collection. Note that in order to delete a blob, you must delete
       * all of its snapshots. You can delete both at the same time with the Delete
       * Blob operation.
       * @see https://learn.microsoft.com/rest/api/storageservices/delete-blob
       *
       * @param options - Optional options to Blob Delete operation.
       */
      async deleteIfExists(options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-deleteIfExists", options, async (updatedOptions) => {
          try {
            const res = (0, utils_common_js_1.assertResponse)(await this.delete(updatedOptions));
            return {
              succeeded: true,
              ...res,
              _response: res._response
              // _response is made non-enumerable
            };
          } catch (e) {
            if (e.details?.errorCode === "BlobNotFound") {
              return {
                succeeded: false,
                ...e.response?.parsedHeaders,
                _response: e.response
              };
            }
            throw e;
          }
        });
      }
      /**
       * Restores the contents and metadata of soft deleted blob and any associated
       * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29
       * or later.
       * @see https://learn.microsoft.com/rest/api/storageservices/undelete-blob
       *
       * @param options - Optional options to Blob Undelete operation.
       */
      async undelete(options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-undelete", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.undelete({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Sets system properties on the blob.
       *
       * If no value provided, or no value provided for the specified blob HTTP headers,
       * these blob HTTP headers without a value will be cleared.
       * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
       *
       * @param blobHTTPHeaders - If no value provided, or no value provided for
       *                                                   the specified blob HTTP headers, these blob HTTP
       *                                                   headers without a value will be cleared.
       *                                                   A common header to set is `blobContentType`
       *                                                   enabling the browser to provide functionality
       *                                                   based on file type.
       * @param options - Optional options to Blob Set HTTP Headers operation.
       */
      async setHTTPHeaders(blobHTTPHeaders, options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlobClient-setHTTPHeaders", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.setHttpHeaders({
            abortSignal: options.abortSignal,
            blobHttpHeaders: blobHTTPHeaders,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            // cpkInfo: options.customerProvidedKey, // CPK is not included in Swagger, should change this back when this issue is fixed in Swagger.
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Sets user-defined metadata for the specified blob as one or more name-value pairs.
       *
       * If no option provided, or no metadata defined in the parameter, the blob
       * metadata will be removed.
       * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-metadata
       *
       * @param metadata - Replace existing metadata with this value.
       *                               If no value provided the existing metadata will be removed.
       * @param options - Optional options to Set Metadata operation.
       */
      async setMetadata(metadata, options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlobClient-setMetadata", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.setMetadata({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            metadata,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Sets tags on the underlying blob.
       * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.
       * Valid tag key and value characters include lower and upper case letters, digits (0-9),
       * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').
       *
       * @param tags -
       * @param options -
       */
      async setTags(tags, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-setTags", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTags({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions,
            tags: (0, utils_common_js_1.toBlobTags)(tags)
          }));
        });
      }
      /**
       * Gets the tags associated with the underlying blob.
       *
       * @param options -
       */
      async getTags(options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-getTags", options, async (updatedOptions) => {
          const response = (0, utils_common_js_1.assertResponse)(await this.blobContext.getTags({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          }));
          const wrappedResponse = {
            ...response,
            _response: response._response,
            // _response is made non-enumerable
            tags: (0, utils_common_js_1.toTags)({ blobTagSet: response.blobTagSet }) || {}
          };
          return wrappedResponse;
        });
      }
      /**
       * Get a {@link BlobLeaseClient} that manages leases on the blob.
       *
       * @param proposeLeaseId - Initial proposed lease Id.
       * @returns A new BlobLeaseClient object for managing leases on the blob.
       */
      getBlobLeaseClient(proposeLeaseId) {
        return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
      }
      /**
       * Creates a read-only snapshot of a blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/snapshot-blob
       *
       * @param options - Optional options to the Blob Create Snapshot operation.
       */
      async createSnapshot(options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlobClient-createSnapshot", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.createSnapshot({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            metadata: options.metadata,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Asynchronously copies a blob to a destination within the storage account.
       * This method returns a long running operation poller that allows you to wait
       * indefinitely until the copy is completed.
       * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.
       * Note that the onProgress callback will not be invoked if the operation completes in the first
       * request, and attempting to cancel a completed copy will result in an error being thrown.
       *
       * In version 2012-02-12 and later, the source for a Copy Blob operation can be
       * a committed blob in any Azure storage account.
       * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
       * an Azure file in any Azure storage account.
       * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
       * operation to copy from another storage account.
       * @see https://learn.microsoft.com/rest/api/storageservices/copy-blob
       *
       * ```ts snippet:ClientsBeginCopyFromURL
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const blobClient = containerClient.getBlobClient(blobName);
       *
       * // Example using automatic polling
       * const automaticCopyPoller = await blobClient.beginCopyFromURL("url");
       * const automaticResult = await automaticCopyPoller.pollUntilDone();
       *
       * // Example using manual polling
       * const manualCopyPoller = await blobClient.beginCopyFromURL("url");
       * while (!manualCopyPoller.isDone()) {
       *   await manualCopyPoller.poll();
       * }
       * const manualResult = manualCopyPoller.getResult();
       *
       * // Example using progress updates
       * const progressUpdatesCopyPoller = await blobClient.beginCopyFromURL("url", {
       *   onProgress(state) {
       *     console.log(`Progress: ${state.copyProgress}`);
       *   },
       * });
       * const progressUpdatesResult = await progressUpdatesCopyPoller.pollUntilDone();
       *
       * // Example using a changing polling interval (default 15 seconds)
       * const pollingIntervalCopyPoller = await blobClient.beginCopyFromURL("url", {
       *   intervalInMs: 1000, // poll blob every 1 second for copy progress
       * });
       * const pollingIntervalResult = await pollingIntervalCopyPoller.pollUntilDone();
       *
       * // Example using copy cancellation:
       * const cancelCopyPoller = await blobClient.beginCopyFromURL("url");
       * // cancel operation after starting it.
       * try {
       *   await cancelCopyPoller.cancelOperation();
       *   // calls to get the result now throw PollerCancelledError
       *   cancelCopyPoller.getResult();
       * } catch (err: any) {
       *   if (err.name === "PollerCancelledError") {
       *     console.log("The copy was cancelled.");
       *   }
       * }
       * ```
       *
       * @param copySource - url to the source Azure Blob/File.
       * @param options - Optional options to the Blob Start Copy From URL operation.
       */
      async beginCopyFromURL(copySource, options = {}) {
        const client = {
          abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),
          getProperties: (...args) => this.getProperties(...args),
          startCopyFromURL: (...args) => this.startCopyFromURL(...args)
        };
        const poller = new BlobStartCopyFromUrlPoller_js_1.BlobBeginCopyFromUrlPoller({
          blobClient: client,
          copySource,
          intervalInMs: options.intervalInMs,
          onProgress: options.onProgress,
          resumeFrom: options.resumeFrom,
          startCopyFromURLOptions: options
        });
        await poller.poll();
        return poller;
      }
      /**
       * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero
       * length and full metadata. Version 2012-02-12 and newer.
       * @see https://learn.microsoft.com/rest/api/storageservices/abort-copy-blob
       *
       * @param copyId - Id of the Copy From URL operation.
       * @param options - Optional options to the Blob Abort Copy From URL operation.
       */
      async abortCopyFromURL(copyId, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-abortCopyFromURL", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.abortCopyFromURL(copyId, {
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not
       * return a response until the copy is complete.
       * @see https://learn.microsoft.com/rest/api/storageservices/copy-blob-from-url
       *
       * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication
       * @param options -
       */
      async syncCopyFromURL(copySource, options = {}) {
        options.conditions = options.conditions || {};
        options.sourceConditions = options.sourceConditions || {};
        return tracing_js_1.tracingClient.withSpan("BlobClient-syncCopyFromURL", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.copyFromURL(copySource, {
            abortSignal: options.abortSignal,
            metadata: options.metadata,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            sourceModifiedAccessConditions: {
              sourceIfMatch: options.sourceConditions?.ifMatch,
              sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
              sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
              sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
            },
            sourceContentMD5: options.sourceContentMD5,
            copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
            tier: (0, models_js_1.toAccessTier)(options.tier),
            blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
            immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
            immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
            legalHold: options.legalHold,
            encryptionScope: options.encryptionScope,
            copySourceTags: options.copySourceTags,
            fileRequestIntent: options.sourceShareTokenIntent,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Sets the tier on a blob. The operation is allowed on a page blob in a premium
       * storage account and on a block blob in a blob storage account (locally redundant
       * storage only). A premium page blob's tier determines the allowed size, IOPS,
       * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive
       * storage type. This operation does not update the blob's ETag.
       * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-tier
       *
       * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.
       * @param options - Optional options to the Blob Set Tier operation.
       */
      async setAccessTier(tier, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-setAccessTier", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTier((0, models_js_1.toAccessTier)(tier), {
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            rehydratePriority: options.rehydratePriority,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      async downloadToBuffer(param1, param2, param3, param4 = {}) {
        let buffer;
        let offset = 0;
        let count = 0;
        let options = param4;
        if (param1 instanceof Buffer) {
          buffer = param1;
          offset = param2 || 0;
          count = typeof param3 === "number" ? param3 : 0;
        } else {
          offset = typeof param1 === "number" ? param1 : 0;
          count = typeof param2 === "number" ? param2 : 0;
          options = param3 || {};
        }
        let blockSize = options.blockSize ?? 0;
        if (blockSize < 0) {
          throw new RangeError("blockSize option must be >= 0");
        }
        if (blockSize === 0) {
          blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
        }
        if (offset < 0) {
          throw new RangeError("offset option must be >= 0");
        }
        if (count && count <= 0) {
          throw new RangeError("count option must be greater than 0");
        }
        if (!options.conditions) {
          options.conditions = {};
        }
        return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToBuffer", options, async (updatedOptions) => {
          if (!count) {
            const response = await this.getProperties({
              ...options,
              tracingOptions: updatedOptions.tracingOptions
            });
            count = response.contentLength - offset;
            if (count < 0) {
              throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);
            }
          }
          if (!buffer) {
            try {
              buffer = Buffer.alloc(count);
            } catch (error2) {
              throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".	 ${error2.message}`);
            }
          }
          if (buffer.length < count) {
            throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
          }
          let transferProgress = 0;
          const batch = new Batch_js_1.Batch(options.concurrency);
          for (let off = offset; off < offset + count; off = off + blockSize) {
            batch.addOperation(async () => {
              let chunkEnd = offset + count;
              if (off + blockSize < chunkEnd) {
                chunkEnd = off + blockSize;
              }
              const response = await this.download(off, chunkEnd - off, {
                abortSignal: options.abortSignal,
                conditions: options.conditions,
                maxRetryRequests: options.maxRetryRequestsPerBlock,
                customerProvidedKey: options.customerProvidedKey,
                tracingOptions: updatedOptions.tracingOptions
              });
              const stream2 = response.readableStreamBody;
              await (0, utils_js_1.streamToBuffer)(stream2, buffer, off - offset, chunkEnd - offset);
              transferProgress += chunkEnd - off;
              if (options.onProgress) {
                options.onProgress({ loadedBytes: transferProgress });
              }
            });
          }
          await batch.do();
          return buffer;
        });
      }
      /**
       * ONLY AVAILABLE IN NODE.JS RUNTIME.
       *
       * Downloads an Azure Blob to a local file.
       * Fails if the the given file path already exits.
       * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
       *
       * @param filePath -
       * @param offset - From which position of the block blob to download.
       * @param count - How much data to be downloaded. Will download to the end when passing undefined.
       * @param options - Options to Blob download options.
       * @returns The response data for blob download operation,
       *                                                 but with readableStreamBody set to undefined since its
       *                                                 content is already read and written into a local file
       *                                                 at the specified path.
       */
      async downloadToFile(filePath, offset = 0, count, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToFile", options, async (updatedOptions) => {
          const response = await this.download(offset, count, {
            ...options,
            tracingOptions: updatedOptions.tracingOptions
          });
          if (response.readableStreamBody) {
            await (0, utils_js_1.readStreamToLocalFile)(response.readableStreamBody, filePath);
          }
          response.blobDownloadStream = void 0;
          return response;
        });
      }
      getBlobAndContainerNamesFromUrl() {
        let containerName;
        let blobName;
        try {
          const parsedUrl = new URL(this.url);
          if (parsedUrl.host.split(".")[1] === "blob") {
            const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
            containerName = pathComponents[1];
            blobName = pathComponents[3];
          } else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl)) {
            const pathComponents = parsedUrl.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
            containerName = pathComponents[2];
            blobName = pathComponents[4];
          } else {
            const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
            containerName = pathComponents[1];
            blobName = pathComponents[3];
          }
          containerName = decodeURIComponent(containerName);
          blobName = decodeURIComponent(blobName);
          blobName = blobName.replace(/\\/g, "/");
          if (!containerName) {
            throw new Error("Provided containerName is invalid.");
          }
          return { blobName, containerName };
        } catch (error2) {
          throw new Error("Unable to extract blobName and containerName with provided information.");
        }
      }
      /**
       * Asynchronously copies a blob to a destination within the storage account.
       * In version 2012-02-12 and later, the source for a Copy Blob operation can be
       * a committed blob in any Azure storage account.
       * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
       * an Azure file in any Azure storage account.
       * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
       * operation to copy from another storage account.
       * @see https://learn.microsoft.com/rest/api/storageservices/copy-blob
       *
       * @param copySource - url to the source Azure Blob/File.
       * @param options - Optional options to the Blob Start Copy From URL operation.
       */
      async startCopyFromURL(copySource, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-startCopyFromURL", options, async (updatedOptions) => {
          options.conditions = options.conditions || {};
          options.sourceConditions = options.sourceConditions || {};
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.startCopyFromURL(copySource, {
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            metadata: options.metadata,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            sourceModifiedAccessConditions: {
              sourceIfMatch: options.sourceConditions.ifMatch,
              sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
              sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
              sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,
              sourceIfTags: options.sourceConditions.tagConditions
            },
            immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
            immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
            legalHold: options.legalHold,
            rehydratePriority: options.rehydratePriority,
            tier: (0, models_js_1.toAccessTier)(options.tier),
            blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
            sealBlob: options.sealBlob,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Only available for BlobClient constructed with a shared key credential.
       *
       * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties
       * and parameters passed in. The SAS is signed by the shared key credential of the client.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
       *
       * @param options - Optional parameters.
       * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      generateSasUrl(options) {
        return new Promise((resolve) => {
          if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
            throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
          }
          const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
            containerName: this._containerName,
            blobName: this._name,
            snapshotTime: this._snapshot,
            versionId: this._versionId,
            ...options
          }, this.credential).toString();
          resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
        });
      }
      /**
       * Only available for BlobClient constructed with a shared key credential.
       *
       * Generates string to sign for a Blob Service Shared Access Signature (SAS) URI based on
       * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
       *
       * @param options - Optional parameters.
       * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/
      generateSasStringToSign(options) {
        if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...options
        }, this.credential).stringToSign;
      }
      /**
       *
       * Generates a Blob Service Shared Access Signature (SAS) URI based on
       * the client properties and parameters passed in. The SAS is signed by the input user delegation key.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
       *
       * @param options - Optional parameters.
       * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
       * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      generateUserDelegationSasUrl(options, userDelegationKey) {
        return new Promise((resolve) => {
          const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
            containerName: this._containerName,
            blobName: this._name,
            snapshotTime: this._snapshot,
            versionId: this._versionId,
            ...options
          }, userDelegationKey, this.accountName).toString();
          resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
        });
      }
      /**
       * Only available for BlobClient constructed with a shared key credential.
       *
       * Generates string to sign for a Blob Service Shared Access Signature (SAS) URI based on
       * the client properties and parameters passed in. The SAS is signed by the input user delegation key.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
       *
       * @param options - Optional parameters.
       * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
       * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      generateUserDelegationSasStringToSign(options, userDelegationKey) {
        return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...options
        }, userDelegationKey, this.accountName).stringToSign;
      }
      /**
       * Delete the immutablility policy on the blob.
       *
       * @param options - Optional options to delete immutability policy on the blob.
       */
      async deleteImmutabilityPolicy(options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-deleteImmutabilityPolicy", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.deleteImmutabilityPolicy({
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Set immutability policy on the blob.
       *
       * @param options - Optional options to set immutability policy on the blob.
       */
      async setImmutabilityPolicy(immutabilityPolicy, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-setImmutabilityPolicy", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.setImmutabilityPolicy({
            immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,
            immutabilityPolicyMode: immutabilityPolicy.policyMode,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Set legal hold on the blob.
       *
       * @param options - Optional options to set legal hold on the blob.
       */
      async setLegalHold(legalHoldEnabled, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-setLegalHold", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.setLegalHold(legalHoldEnabled, {
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * The Get Account Information operation returns the sku name and account kind
       * for the specified account.
       * The Get Account Information operation is available on service versions beginning
       * with version 2018-03-28.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-account-information
       *
       * @param options - Options to the Service Get Account Info operation.
       * @returns Response data for the Service Get Account Info operation.
       */
      async getAccountInfo(options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobClient-getAccountInfo", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blobContext.getAccountInfo({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
    };
    exports.BlobClient = BlobClient;
    var AppendBlobClient = class _AppendBlobClient extends BlobClient {
      /**
       * appendBlobsContext provided by protocol layer.
       */
      appendBlobContext;
      constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
        let pipeline;
        let url;
        options = options || {};
        if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          pipeline = credentialOrPipelineOrContainerName;
        } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          options = blobNameOrOptions;
          pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
        } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
          url = urlOrConnectionString;
          pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
        } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
          const containerName = credentialOrPipelineOrContainerName;
          const blobName = blobNameOrOptions;
          const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
          if (extractedCreds.kind === "AccountConnString") {
            if (core_util_1.isNodeLike) {
              const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
              url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
              if (!options.proxyOptions) {
                options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
              }
              pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
            } else {
              throw new Error("Account connection string is only supported in Node.js environment");
            }
          } else if (extractedCreds.kind === "SASConnString") {
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
            pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
          } else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
          }
        } else {
          throw new Error("Expecting non-empty strings for containerName and blobName parameters");
        }
        super(url, pipeline);
        this.appendBlobContext = this.storageClientContext.appendBlob;
      }
      /**
       * Creates a new AppendBlobClient object identical to the source but with the
       * specified snapshot timestamp.
       * Provide "" will remove the snapshot and return a Client to the base blob.
       *
       * @param snapshot - The snapshot timestamp.
       * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.
       */
      withSnapshot(snapshot) {
        return new _AppendBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
      }
      /**
       * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
       *
       * @param options - Options to the Append Block Create operation.
       *
       *
       * Example usage:
       *
       * ```ts snippet:ClientsCreateAppendBlob
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       *
       * const appendBlobClient = containerClient.getAppendBlobClient(blobName);
       * await appendBlobClient.create();
       * ```
       */
      async create(options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("AppendBlobClient-create", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.create(0, {
            abortSignal: options.abortSignal,
            blobHttpHeaders: options.blobHTTPHeaders,
            leaseAccessConditions: options.conditions,
            metadata: options.metadata,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
            immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
            legalHold: options.legalHold,
            blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
       * If the blob with the same name already exists, the content of the existing blob will remain unchanged.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
       *
       * @param options -
       */
      async createIfNotExists(options = {}) {
        const conditions = { ifNoneMatch: constants_js_1.ETagAny };
        return tracing_js_1.tracingClient.withSpan("AppendBlobClient-createIfNotExists", options, async (updatedOptions) => {
          try {
            const res = (0, utils_common_js_1.assertResponse)(await this.create({
              ...updatedOptions,
              conditions
            }));
            return {
              succeeded: true,
              ...res,
              _response: res._response
              // _response is made non-enumerable
            };
          } catch (e) {
            if (e.details?.errorCode === "BlobAlreadyExists") {
              return {
                succeeded: false,
                ...e.response?.parsedHeaders,
                _response: e.response
              };
            }
            throw e;
          }
        });
      }
      /**
       * Seals the append blob, making it read only.
       *
       * @param options -
       */
      async seal(options = {}) {
        options.conditions = options.conditions || {};
        return tracing_js_1.tracingClient.withSpan("AppendBlobClient-seal", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.seal({
            abortSignal: options.abortSignal,
            appendPositionAccessConditions: options.conditions,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Commits a new block of data to the end of the existing append blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/append-block
       *
       * @param body - Data to be appended.
       * @param contentLength - Length of the body in bytes.
       * @param options - Options to the Append Block operation.
       *
       *
       * Example usage:
       *
       * ```ts snippet:ClientsAppendBlock
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       *
       * const content = "Hello World!";
       *
       * // Create a new append blob and append data to the blob.
       * const newAppendBlobClient = containerClient.getAppendBlobClient(blobName);
       * await newAppendBlobClient.create();
       * await newAppendBlobClient.appendBlock(content, content.length);
       *
       * // Append data to an existing append blob.
       * const existingAppendBlobClient = containerClient.getAppendBlobClient(blobName);
       * await existingAppendBlobClient.appendBlock(content, content.length);
       * ```
       */
      async appendBlock(body, contentLength, options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlock", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlock(contentLength, body, {
            abortSignal: options.abortSignal,
            appendPositionAccessConditions: options.conditions,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            requestOptions: {
              onUploadProgress: options.onProgress
            },
            transactionalContentMD5: options.transactionalContentMD5,
            transactionalContentCrc64: options.transactionalContentCrc64,
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * The Append Block operation commits a new block of data to the end of an existing append blob
       * where the contents are read from a source url.
       * @see https://learn.microsoft.com/rest/api/storageservices/append-block-from-url
       *
       * @param sourceURL -
       *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can
       *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob
       *                 must either be public or must be authenticated via a shared access signature. If the source blob is
       *                 public, no authentication is required to perform the operation.
       * @param sourceOffset - Offset in source to be appended
       * @param count - Number of bytes to be appended as a block
       * @param options -
       */
      async appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {
        options.conditions = options.conditions || {};
        options.sourceConditions = options.sourceConditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlockFromURL", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
            abortSignal: options.abortSignal,
            sourceRange: (0, Range_js_1.rangeToString)({ offset: sourceOffset, count }),
            sourceContentMD5: options.sourceContentMD5,
            sourceContentCrc64: options.sourceContentCrc64,
            leaseAccessConditions: options.conditions,
            appendPositionAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            sourceModifiedAccessConditions: {
              sourceIfMatch: options.sourceConditions?.ifMatch,
              sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
              sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
              sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
            },
            copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            fileRequestIntent: options.sourceShareTokenIntent,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
    };
    exports.AppendBlobClient = AppendBlobClient;
    var BlockBlobClient = class _BlockBlobClient extends BlobClient {
      /**
       * blobContext provided by protocol layer.
       *
       * Note. Ideally BlobClient should set BlobClient.blobContext to protected. However, API
       * extractor has issue blocking that. Here we redecelare _blobContext in BlockBlobClient.
       */
      _blobContext;
      /**
       * blockBlobContext provided by protocol layer.
       */
      blockBlobContext;
      constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
        let pipeline;
        let url;
        options = options || {};
        if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          pipeline = credentialOrPipelineOrContainerName;
        } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          options = blobNameOrOptions;
          pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
        } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
          url = urlOrConnectionString;
          if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
            options = blobNameOrOptions;
          }
          pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
        } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
          const containerName = credentialOrPipelineOrContainerName;
          const blobName = blobNameOrOptions;
          const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
          if (extractedCreds.kind === "AccountConnString") {
            if (core_util_1.isNodeLike) {
              const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
              url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
              if (!options.proxyOptions) {
                options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
              }
              pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
            } else {
              throw new Error("Account connection string is only supported in Node.js environment");
            }
          } else if (extractedCreds.kind === "SASConnString") {
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
            pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
          } else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
          }
        } else {
          throw new Error("Expecting non-empty strings for containerName and blobName parameters");
        }
        super(url, pipeline);
        this.blockBlobContext = this.storageClientContext.blockBlob;
        this._blobContext = this.storageClientContext.blob;
      }
      /**
       * Creates a new BlockBlobClient object identical to the source but with the
       * specified snapshot timestamp.
       * Provide "" will remove the snapshot and return a URL to the base blob.
       *
       * @param snapshot - The snapshot timestamp.
       * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.
       */
      withSnapshot(snapshot) {
        return new _BlockBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
      }
      /**
       * ONLY AVAILABLE IN NODE.JS RUNTIME.
       *
       * Quick query for a JSON or CSV formatted blob.
       *
       * Example usage (Node.js):
       *
       * ```ts snippet:ClientsQuery
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const blockBlobClient = containerClient.getBlockBlobClient(blobName);
       *
       * // Query and convert a blob to a string
       * const queryBlockBlobResponse = await blockBlobClient.query("select from BlobStorage");
       * if (queryBlockBlobResponse.readableStreamBody) {
       *   const downloadedBuffer = await streamToBuffer(queryBlockBlobResponse.readableStreamBody);
       *   const downloaded = downloadedBuffer.toString();
       *   console.log(`Query blob content: ${downloaded}`);
       * }
       *
       * async function streamToBuffer(readableStream: NodeJS.ReadableStream): Promise<Buffer> {
       *   return new Promise((resolve, reject) => {
       *     const chunks: Buffer[] = [];
       *     readableStream.on("data", (data) => {
       *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));
       *     });
       *     readableStream.on("end", () => {
       *       resolve(Buffer.concat(chunks));
       *     });
       *     readableStream.on("error", reject);
       *   });
       * }
       * ```
       *
       * @param query -
       * @param options -
       */
      async query(query, options = {}) {
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        if (!core_util_1.isNodeLike) {
          throw new Error("This operation currently is only supported in Node.js.");
        }
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-query", options, async (updatedOptions) => {
          const response = (0, utils_common_js_1.assertResponse)(await this._blobContext.query({
            abortSignal: options.abortSignal,
            queryRequest: {
              queryType: "SQL",
              expression: query,
              inputSerialization: (0, utils_common_js_1.toQuerySerialization)(options.inputTextConfiguration),
              outputSerialization: (0, utils_common_js_1.toQuerySerialization)(options.outputTextConfiguration)
            },
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            cpkInfo: options.customerProvidedKey,
            tracingOptions: updatedOptions.tracingOptions
          }));
          return new BlobQueryResponse_js_1.BlobQueryResponse(response, {
            abortSignal: options.abortSignal,
            onProgress: options.onProgress,
            onError: options.onError
          });
        });
      }
      /**
       * Creates a new block blob, or updates the content of an existing block blob.
       * Updating an existing block blob overwrites any existing metadata on the blob.
       * Partial updates are not supported; the content of the existing blob is
       * overwritten with the new content. To perform a partial update of a block blob's,
       * use {@link stageBlock} and {@link commitBlockList}.
       *
       * This is a non-parallel uploading method, please use {@link uploadFile},
       * {@link uploadStream} or {@link uploadBrowserData} for better performance
       * with concurrency uploading.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
       *
       * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
       *                               which returns a new Readable stream whose offset is from data source beginning.
       * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
       *                               string including non non-Base64/Hex-encoded characters.
       * @param options - Options to the Block Blob Upload operation.
       * @returns Response data for the Block Blob Upload operation.
       *
       * Example usage:
       *
       * ```ts snippet:ClientsUpload
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const blockBlobClient = containerClient.getBlockBlobClient(blobName);
       *
       * const content = "Hello world!";
       * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
       * ```
       */
      async upload(body, contentLength, options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-upload", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.upload(contentLength, body, {
            abortSignal: options.abortSignal,
            blobHttpHeaders: options.blobHTTPHeaders,
            leaseAccessConditions: options.conditions,
            metadata: options.metadata,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            requestOptions: {
              onUploadProgress: options.onProgress
            },
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
            immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
            legalHold: options.legalHold,
            tier: (0, models_js_1.toAccessTier)(options.tier),
            blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Creates a new Block Blob where the contents of the blob are read from a given URL.
       * This API is supported beginning with the 2020-04-08 version. Partial updates
       * are not supported with Put Blob from URL; the content of an existing blob is overwritten with
       * the content of the new blob.  To perform partial updates to a block blobs contents using a
       * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.
       *
       * @param sourceURL - Specifies the URL of the blob. The value
       *                           may be a URL of up to 2 KB in length that specifies a blob.
       *                           The value should be URL-encoded as it would appear
       *                           in a request URI. The source blob must either be public
       *                           or must be authenticated via a shared access signature.
       *                           If the source blob is public, no authentication is required
       *                           to perform the operation. Here are some examples of source object URLs:
       *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob
       *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
       * @param options - Optional parameters.
       */
      async syncUploadFromURL(sourceURL, options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-syncUploadFromURL", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.putBlobFromUrl(0, sourceURL, {
            ...options,
            blobHttpHeaders: options.blobHTTPHeaders,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            sourceModifiedAccessConditions: {
              sourceIfMatch: options.sourceConditions?.ifMatch,
              sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
              sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
              sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince,
              sourceIfTags: options.sourceConditions?.tagConditions
            },
            cpkInfo: options.customerProvidedKey,
            copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
            tier: (0, models_js_1.toAccessTier)(options.tier),
            blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
            copySourceTags: options.copySourceTags,
            fileRequestIntent: options.sourceShareTokenIntent,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Uploads the specified block to the block blob's "staging area" to be later
       * committed by a call to commitBlockList.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-block
       *
       * @param blockId - A 64-byte value that is base64-encoded
       * @param body - Data to upload to the staging area.
       * @param contentLength - Number of bytes to upload.
       * @param options - Options to the Block Blob Stage Block operation.
       * @returns Response data for the Block Blob Stage Block operation.
       */
      async stageBlock(blockId, body, contentLength, options = {}) {
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlock", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlock(blockId, contentLength, body, {
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            requestOptions: {
              onUploadProgress: options.onProgress
            },
            transactionalContentMD5: options.transactionalContentMD5,
            transactionalContentCrc64: options.transactionalContentCrc64,
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * The Stage Block From URL operation creates a new block to be committed as part
       * of a blob where the contents are read from a URL.
       * This API is available starting in version 2018-03-28.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-block-from-url
       *
       * @param blockId - A 64-byte value that is base64-encoded
       * @param sourceURL - Specifies the URL of the blob. The value
       *                           may be a URL of up to 2 KB in length that specifies a blob.
       *                           The value should be URL-encoded as it would appear
       *                           in a request URI. The source blob must either be public
       *                           or must be authenticated via a shared access signature.
       *                           If the source blob is public, no authentication is required
       *                           to perform the operation. Here are some examples of source object URLs:
       *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob
       *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
       * @param offset - From which position of the blob to download, greater than or equal to 0
       * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
       * @param options - Options to the Block Blob Stage Block From URL operation.
       * @returns Response data for the Block Blob Stage Block From URL operation.
       */
      async stageBlockFromURL(blockId, sourceURL, offset = 0, count, options = {}) {
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlockFromURL", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, {
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            sourceContentMD5: options.sourceContentMD5,
            sourceContentCrc64: options.sourceContentCrc64,
            sourceRange: offset === 0 && !count ? void 0 : (0, Range_js_1.rangeToString)({ offset, count }),
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
            fileRequestIntent: options.sourceShareTokenIntent,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Writes a blob by specifying the list of block IDs that make up the blob.
       * In order to be written as part of a blob, a block must have been successfully written
       * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to
       * update a blob by uploading only those blocks that have changed, then committing the new and existing
       * blocks together. Any blocks not specified in the block list and permanently deleted.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-block-list
       *
       * @param blocks -  Array of 64-byte value that is base64-encoded
       * @param options - Options to the Block Blob Commit Block List operation.
       * @returns Response data for the Block Blob Commit Block List operation.
       */
      async commitBlockList(blocks, options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-commitBlockList", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.commitBlockList({ latest: blocks }, {
            abortSignal: options.abortSignal,
            blobHttpHeaders: options.blobHTTPHeaders,
            leaseAccessConditions: options.conditions,
            metadata: options.metadata,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
            immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
            legalHold: options.legalHold,
            tier: (0, models_js_1.toAccessTier)(options.tier),
            blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Returns the list of blocks that have been uploaded as part of a block blob
       * using the specified block list filter.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-block-list
       *
       * @param listType - Specifies whether to return the list of committed blocks,
       *                                        the list of uncommitted blocks, or both lists together.
       * @param options - Options to the Block Blob Get Block List operation.
       * @returns Response data for the Block Blob Get Block List operation.
       */
      async getBlockList(listType, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-getBlockList", options, async (updatedOptions) => {
          const res = (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.getBlockList(listType, {
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          }));
          if (!res.committedBlocks) {
            res.committedBlocks = [];
          }
          if (!res.uncommittedBlocks) {
            res.uncommittedBlocks = [];
          }
          return res;
        });
      }
      // High level functions
      /**
       * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.
       *
       * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is
       * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.
       * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}
       * to commit the block list.
       *
       * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is
       * `blobContentType`, enabling the browser to provide
       * functionality based on file type.
       *
       * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView
       * @param options -
       */
      async uploadData(data, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadData", options, async (updatedOptions) => {
          if (core_util_1.isNodeLike) {
            let buffer;
            if (data instanceof Buffer) {
              buffer = data;
            } else if (data instanceof ArrayBuffer) {
              buffer = Buffer.from(data);
            } else {
              data = data;
              buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
            }
            return this.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);
          } else {
            const browserBlob = new Blob([data]);
            return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
          }
        });
      }
      /**
       * ONLY AVAILABLE IN BROWSERS.
       *
       * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.
       *
       * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.
       * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call
       * {@link commitBlockList} to commit the block list.
       *
       * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is
       * `blobContentType`, enabling the browser to provide
       * functionality based on file type.
       *
       * @deprecated Use {@link uploadData} instead.
       *
       * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView
       * @param options - Options to upload browser data.
       * @returns Response data for the Blob Upload operation.
       */
      async uploadBrowserData(browserData, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadBrowserData", options, async (updatedOptions) => {
          const browserBlob = new Blob([browserData]);
          return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
        });
      }
      /**
       *
       * Uploads data to block blob. Requires a bodyFactory as the data source,
       * which need to return a {@link HttpRequestBody} object with the offset and size provided.
       *
       * When data length is no more than the specified {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is
       * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.
       * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}
       * to commit the block list.
       *
       * @param bodyFactory -
       * @param size - size of the data to upload.
       * @param options - Options to Upload to Block Blob operation.
       * @returns Response data for the Blob Upload operation.
       */
      async uploadSeekableInternal(bodyFactory, size, options = {}) {
        let blockSize = options.blockSize ?? 0;
        if (blockSize < 0 || blockSize > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {
          throw new RangeError(`blockSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);
        }
        const maxSingleShotSize = options.maxSingleShotSize ?? constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
        if (maxSingleShotSize < 0 || maxSingleShotSize > constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {
          throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);
        }
        if (blockSize === 0) {
          if (size > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * constants_js_1.BLOCK_BLOB_MAX_BLOCKS) {
            throw new RangeError(`${size} is too larger to upload to a block blob.`);
          }
          if (size > maxSingleShotSize) {
            blockSize = Math.ceil(size / constants_js_1.BLOCK_BLOB_MAX_BLOCKS);
            if (blockSize < constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {
              blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
            }
          }
        }
        if (!options.blobHTTPHeaders) {
          options.blobHTTPHeaders = {};
        }
        if (!options.conditions) {
          options.conditions = {};
        }
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadSeekableInternal", options, async (updatedOptions) => {
          if (size <= maxSingleShotSize) {
            return (0, utils_common_js_1.assertResponse)(await this.upload(bodyFactory(0, size), size, updatedOptions));
          }
          const numBlocks = Math.floor((size - 1) / blockSize) + 1;
          if (numBlocks > constants_js_1.BLOCK_BLOB_MAX_BLOCKS) {
            throw new RangeError(`The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= ${constants_js_1.BLOCK_BLOB_MAX_BLOCKS}`);
          }
          const blockList = [];
          const blockIDPrefix = (0, core_util_2.randomUUID)();
          let transferProgress = 0;
          const batch = new Batch_js_1.Batch(options.concurrency);
          for (let i2 = 0; i2 < numBlocks; i2++) {
            batch.addOperation(async () => {
              const blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, i2);
              const start = blockSize * i2;
              const end = i2 === numBlocks - 1 ? size : start + blockSize;
              const contentLength = end - start;
              blockList.push(blockID);
              await this.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {
                abortSignal: options.abortSignal,
                conditions: options.conditions,
                encryptionScope: options.encryptionScope,
                tracingOptions: updatedOptions.tracingOptions
              });
              transferProgress += contentLength;
              if (options.onProgress) {
                options.onProgress({
                  loadedBytes: transferProgress
                });
              }
            });
          }
          await batch.do();
          return this.commitBlockList(blockList, updatedOptions);
        });
      }
      /**
       * ONLY AVAILABLE IN NODE.JS RUNTIME.
       *
       * Uploads a local file in blocks to a block blob.
       *
       * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.
       * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList
       * to commit the block list.
       *
       * @param filePath - Full path of local file
       * @param options - Options to Upload to Block Blob operation.
       * @returns Response data for the Blob Upload operation.
       */
      async uploadFile(filePath, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadFile", options, async (updatedOptions) => {
          const size = (await (0, utils_js_1.fsStat)(filePath)).size;
          return this.uploadSeekableInternal((offset, count) => {
            return () => (0, utils_js_1.fsCreateReadStream)(filePath, {
              autoClose: true,
              end: count ? offset + count - 1 : Infinity,
              start: offset
            });
          }, size, {
            ...options,
            tracingOptions: updatedOptions.tracingOptions
          });
        });
      }
      /**
       * ONLY AVAILABLE IN NODE.JS RUNTIME.
       *
       * Uploads a Node.js Readable stream into block blob.
       *
       * PERFORMANCE IMPROVEMENT TIPS:
       * * Input stream highWaterMark is better to set a same value with bufferSize
       *    parameter, which will avoid Buffer.concat() operations.
       *
       * @param stream - Node.js Readable stream
       * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB
       * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,
       *                                 positive correlation with max uploading concurrency. Default value is 5
       * @param options - Options to Upload Stream to Block Blob operation.
       * @returns Response data for the Blob Upload operation.
       */
      async uploadStream(stream2, bufferSize = constants_js_1.DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {
        if (!options.blobHTTPHeaders) {
          options.blobHTTPHeaders = {};
        }
        if (!options.conditions) {
          options.conditions = {};
        }
        return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadStream", options, async (updatedOptions) => {
          let blockNum = 0;
          const blockIDPrefix = (0, core_util_2.randomUUID)();
          let transferProgress = 0;
          const blockList = [];
          const scheduler = new storage_common_1.BufferScheduler(
            stream2,
            bufferSize,
            maxConcurrency,
            async (body, length) => {
              const blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, blockNum);
              blockList.push(blockID);
              blockNum++;
              await this.stageBlock(blockID, body, length, {
                customerProvidedKey: options.customerProvidedKey,
                conditions: options.conditions,
                encryptionScope: options.encryptionScope,
                tracingOptions: updatedOptions.tracingOptions
              });
              transferProgress += length;
              if (options.onProgress) {
                options.onProgress({ loadedBytes: transferProgress });
              }
            },
            // concurrency should set a smaller value than maxConcurrency, which is helpful to
            // reduce the possibility when a outgoing handler waits for stream data, in
            // this situation, outgoing handlers are blocked.
            // Outgoing queue shouldn't be empty.
            Math.ceil(maxConcurrency / 4 * 3)
          );
          await scheduler.do();
          return (0, utils_common_js_1.assertResponse)(await this.commitBlockList(blockList, {
            ...options,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
    };
    exports.BlockBlobClient = BlockBlobClient;
    var PageBlobClient = class _PageBlobClient extends BlobClient {
      /**
       * pageBlobsContext provided by protocol layer.
       */
      pageBlobContext;
      constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
        let pipeline;
        let url;
        options = options || {};
        if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          pipeline = credentialOrPipelineOrContainerName;
        } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          options = blobNameOrOptions;
          pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
        } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
          url = urlOrConnectionString;
          pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
        } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
          const containerName = credentialOrPipelineOrContainerName;
          const blobName = blobNameOrOptions;
          const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
          if (extractedCreds.kind === "AccountConnString") {
            if (core_util_1.isNodeLike) {
              const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
              url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
              if (!options.proxyOptions) {
                options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
              }
              pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
            } else {
              throw new Error("Account connection string is only supported in Node.js environment");
            }
          } else if (extractedCreds.kind === "SASConnString") {
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
            pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
          } else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
          }
        } else {
          throw new Error("Expecting non-empty strings for containerName and blobName parameters");
        }
        super(url, pipeline);
        this.pageBlobContext = this.storageClientContext.pageBlob;
      }
      /**
       * Creates a new PageBlobClient object identical to the source but with the
       * specified snapshot timestamp.
       * Provide "" will remove the snapshot and return a Client to the base blob.
       *
       * @param snapshot - The snapshot timestamp.
       * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.
       */
      withSnapshot(snapshot) {
        return new _PageBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
      }
      /**
       * Creates a page blob of the specified length. Call uploadPages to upload data
       * data to a page blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
       *
       * @param size - size of the page blob.
       * @param options - Options to the Page Blob Create operation.
       * @returns Response data for the Page Blob Create operation.
       */
      async create(size, options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-create", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.create(0, size, {
            abortSignal: options.abortSignal,
            blobHttpHeaders: options.blobHTTPHeaders,
            blobSequenceNumber: options.blobSequenceNumber,
            leaseAccessConditions: options.conditions,
            metadata: options.metadata,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
            immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
            legalHold: options.legalHold,
            tier: (0, models_js_1.toAccessTier)(options.tier),
            blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Creates a page blob of the specified length. Call uploadPages to upload data
       * data to a page blob. If the blob with the same name already exists, the content
       * of the existing blob will remain unchanged.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
       *
       * @param size - size of the page blob.
       * @param options -
       */
      async createIfNotExists(size, options = {}) {
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-createIfNotExists", options, async (updatedOptions) => {
          try {
            const conditions = { ifNoneMatch: constants_js_1.ETagAny };
            const res = (0, utils_common_js_1.assertResponse)(await this.create(size, {
              ...options,
              conditions,
              tracingOptions: updatedOptions.tracingOptions
            }));
            return {
              succeeded: true,
              ...res,
              _response: res._response
              // _response is made non-enumerable
            };
          } catch (e) {
            if (e.details?.errorCode === "BlobAlreadyExists") {
              return {
                succeeded: false,
                ...e.response?.parsedHeaders,
                _response: e.response
              };
            }
            throw e;
          }
        });
      }
      /**
       * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-page
       *
       * @param body - Data to upload
       * @param offset - Offset of destination page blob
       * @param count - Content length of the body, also number of bytes to be uploaded
       * @param options - Options to the Page Blob Upload Pages operation.
       * @returns Response data for the Page Blob Upload Pages operation.
       */
      async uploadPages(body, offset, count, options = {}) {
        options.conditions = options.conditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPages", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPages(count, body, {
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            requestOptions: {
              onUploadProgress: options.onProgress
            },
            range: (0, Range_js_1.rangeToString)({ offset, count }),
            sequenceNumberAccessConditions: options.conditions,
            transactionalContentMD5: options.transactionalContentMD5,
            transactionalContentCrc64: options.transactionalContentCrc64,
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * The Upload Pages operation writes a range of pages to a page blob where the
       * contents are read from a URL.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-page-from-url
       *
       * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication
       * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob
       * @param destOffset - Offset of destination page blob
       * @param count - Number of bytes to be uploaded from source page blob
       * @param options -
       */
      async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {
        options.conditions = options.conditions || {};
        options.sourceConditions = options.sourceConditions || {};
        (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPagesFromURL", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPagesFromURL(sourceURL, (0, Range_js_1.rangeToString)({ offset: sourceOffset, count }), 0, (0, Range_js_1.rangeToString)({ offset: destOffset, count }), {
            abortSignal: options.abortSignal,
            sourceContentMD5: options.sourceContentMD5,
            sourceContentCrc64: options.sourceContentCrc64,
            leaseAccessConditions: options.conditions,
            sequenceNumberAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            sourceModifiedAccessConditions: {
              sourceIfMatch: options.sourceConditions?.ifMatch,
              sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
              sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
              sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
            },
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
            fileRequestIntent: options.sourceShareTokenIntent,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Frees the specified pages from the page blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/put-page
       *
       * @param offset - Starting byte position of the pages to clear.
       * @param count - Number of bytes to clear.
       * @param options - Options to the Page Blob Clear Pages operation.
       * @returns Response data for the Page Blob Clear Pages operation.
       */
      async clearPages(offset = 0, count, options = {}) {
        options.conditions = options.conditions || {};
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-clearPages", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.clearPages(0, {
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            range: (0, Range_js_1.rangeToString)({ offset, count }),
            sequenceNumberAccessConditions: options.conditions,
            cpkInfo: options.customerProvidedKey,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Returns the list of valid page ranges for a page blob or snapshot of a page blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
       *
       * @param offset - Starting byte position of the page ranges.
       * @param count - Number of bytes to get.
       * @param options - Options to the Page Blob Get Ranges operation.
       * @returns Response data for the Page Blob Get Ranges operation.
       */
      async getPageRanges(offset = 0, count, options = {}) {
        options.conditions = options.conditions || {};
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRanges", options, async (updatedOptions) => {
          const response = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            range: (0, Range_js_1.rangeToString)({ offset, count }),
            tracingOptions: updatedOptions.tracingOptions
          }));
          return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response);
        });
      }
      /**
       * getPageRangesSegment returns a single segment of page ranges starting from the
       * specified Marker. Use an empty Marker to start enumeration from the beginning.
       * After getting a segment, process it, and then call getPageRangesSegment again
       * (passing the the previously-returned Marker) to get the next segment.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
       *
       * @param offset - Starting byte position of the page ranges.
       * @param count - Number of bytes to get.
       * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
       * @param options - Options to PageBlob Get Page Ranges Segment operation.
       */
      async listPageRangesSegment(offset = 0, count, marker, options = {}) {
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesSegment", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            range: (0, Range_js_1.rangeToString)({ offset, count }),
            marker,
            maxPageSize: options.maxPageSize,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesResponseModel}
       *
       * @param offset - Starting byte position of the page ranges.
       * @param count - Number of bytes to get.
       * @param marker - A string value that identifies the portion of
       *                          the get of page ranges to be returned with the next getting operation. The
       *                          operation returns the ContinuationToken value within the response body if the
       *                          getting operation did not return all page ranges remaining within the current page.
       *                          The ContinuationToken value can be used as the value for
       *                          the marker parameter in a subsequent call to request the next page of get
       *                          items. The marker value is opaque to the client.
       * @param options - Options to List Page Ranges operation.
       */
      async *listPageRangeItemSegments(offset = 0, count, marker, options = {}) {
        let getPageRangeItemSegmentsResponse;
        if (!!marker || marker === void 0) {
          do {
            getPageRangeItemSegmentsResponse = await this.listPageRangesSegment(offset, count, marker, options);
            marker = getPageRangeItemSegmentsResponse.continuationToken;
            yield await getPageRangeItemSegmentsResponse;
          } while (marker);
        }
      }
      /**
       * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects
       *
       * @param offset - Starting byte position of the page ranges.
       * @param count - Number of bytes to get.
       * @param options - Options to List Page Ranges operation.
       */
      async *listPageRangeItems(offset = 0, count, options = {}) {
        let marker;
        for await (const getPageRangesSegment of this.listPageRangeItemSegments(offset, count, marker, options)) {
          yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
        }
      }
      /**
       * Returns an async iterable iterator to list of page ranges for a page blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
       *
       *  .byPage() returns an async iterable iterator to list of page ranges for a page blob.
       *
       * ```ts snippet:ClientsListPageBlobs
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const pageBlobClient = containerClient.getPageBlobClient(blobName);
       *
       * // Example using `for await` syntax
       * let i = 1;
       * for await (const pageRange of pageBlobClient.listPageRanges()) {
       *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
       * }
       *
       * // Example using `iter.next()` syntax
       * i = 1;
       * const iter = pageBlobClient.listPageRanges();
       * let { value, done } = await iter.next();
       * while (!done) {
       *   console.log(`Page range ${i++}: ${value.start} - ${value.end}`);
       *   ({ value, done } = await iter.next());
       * }
       *
       * // Example using `byPage()` syntax
       * i = 1;
       * for await (const page of pageBlobClient.listPageRanges().byPage({ maxPageSize: 20 })) {
       *   for (const pageRange of page.pageRange || []) {
       *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
       *   }
       * }
       *
       * // Example using paging with a marker
       * i = 1;
       * let iterator = pageBlobClient.listPageRanges().byPage({ maxPageSize: 2 });
       * let response = (await iterator.next()).value;
       * // Prints 2 page ranges
       * if (response.pageRange) {
       *   for (const pageRange of response.pageRange) {
       *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
       *   }
       * }
       * // Gets next marker
       * let marker = response.continuationToken;
       * // Passing next marker as continuationToken
       * iterator = pageBlobClient.listPageRanges().byPage({ continuationToken: marker, maxPageSize: 10 });
       * response = (await iterator.next()).value;
       * // Prints 10 page ranges
       * if (response.pageRange) {
       *   for (const pageRange of response.pageRange) {
       *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
       *   }
       * }
       * ```
       *
       * @param offset - Starting byte position of the page ranges.
       * @param count - Number of bytes to get.
       * @param options - Options to the Page Blob Get Ranges operation.
       * @returns An asyncIterableIterator that supports paging.
       */
      listPageRanges(offset = 0, count, options = {}) {
        options.conditions = options.conditions || {};
        const iter = this.listPageRangeItems(offset, count, options);
        return {
          /**
           * The next method, part of the iteration protocol
           */
          next() {
            return iter.next();
          },
          /**
           * The connection to the async iterator, part of the iteration protocol
           */
          [Symbol.asyncIterator]() {
            return this;
          },
          /**
           * Return an AsyncIterableIterator that works a page at a time
           */
          byPage: (settings = {}) => {
            return this.listPageRangeItemSegments(offset, count, settings.continuationToken, {
              maxPageSize: settings.maxPageSize,
              ...options
            });
          }
        };
      }
      /**
       * Gets the collection of page ranges that differ between a specified snapshot and this page blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
       *
       * @param offset - Starting byte position of the page blob
       * @param count - Number of bytes to get ranges diff.
       * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.
       * @param options - Options to the Page Blob Get Page Ranges Diff operation.
       * @returns Response data for the Page Blob Get Page Range Diff operation.
       */
      async getPageRangesDiff(offset, count, prevSnapshot, options = {}) {
        options.conditions = options.conditions || {};
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiff", options, async (updatedOptions) => {
          const result = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            prevsnapshot: prevSnapshot,
            range: (0, Range_js_1.rangeToString)({ offset, count }),
            tracingOptions: updatedOptions.tracingOptions
          }));
          return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(result);
        });
      }
      /**
       * getPageRangesDiffSegment returns a single segment of page ranges starting from the
       * specified Marker for difference between previous snapshot and the target page blob.
       * Use an empty Marker to start enumeration from the beginning.
       * After getting a segment, process it, and then call getPageRangesDiffSegment again
       * (passing the the previously-returned Marker) to get the next segment.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
       *
       * @param offset - Starting byte position of the page ranges.
       * @param count - Number of bytes to get.
       * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
       * @param marker - A string value that identifies the portion of the get to be returned with the next get operation.
       * @param options - Options to the Page Blob Get Page Ranges Diff operation.
       */
      async listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options = {}) {
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiffSegment", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
            abortSignal: options?.abortSignal,
            leaseAccessConditions: options?.conditions,
            modifiedAccessConditions: {
              ...options?.conditions,
              ifTags: options?.conditions?.tagConditions
            },
            prevsnapshot: prevSnapshotOrUrl,
            range: (0, Range_js_1.rangeToString)({
              offset,
              count
            }),
            marker,
            maxPageSize: options?.maxPageSize,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesDiffResponseModel}
       *
       *
       * @param offset - Starting byte position of the page ranges.
       * @param count - Number of bytes to get.
       * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
       * @param marker - A string value that identifies the portion of
       *                          the get of page ranges to be returned with the next getting operation. The
       *                          operation returns the ContinuationToken value within the response body if the
       *                          getting operation did not return all page ranges remaining within the current page.
       *                          The ContinuationToken value can be used as the value for
       *                          the marker parameter in a subsequent call to request the next page of get
       *                          items. The marker value is opaque to the client.
       * @param options - Options to the Page Blob Get Page Ranges Diff operation.
       */
      async *listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options) {
        let getPageRangeItemSegmentsResponse;
        if (!!marker || marker === void 0) {
          do {
            getPageRangeItemSegmentsResponse = await this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options);
            marker = getPageRangeItemSegmentsResponse.continuationToken;
            yield await getPageRangeItemSegmentsResponse;
          } while (marker);
        }
      }
      /**
       * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects
       *
       * @param offset - Starting byte position of the page ranges.
       * @param count - Number of bytes to get.
       * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
       * @param options - Options to the Page Blob Get Page Ranges Diff operation.
       */
      async *listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {
        let marker;
        for await (const getPageRangesSegment of this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options)) {
          yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
        }
      }
      /**
       * Returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
       *
       *  .byPage() returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.
       *
       * ```ts snippet:ClientsListPageBlobsDiff
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const pageBlobClient = containerClient.getPageBlobClient(blobName);
       *
       * const offset = 0;
       * const count = 1024;
       * const previousSnapshot = "<previous snapshot>";
       * // Example using `for await` syntax
       * let i = 1;
       * for await (const pageRange of pageBlobClient.listPageRangesDiff(offset, count, previousSnapshot)) {
       *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
       * }
       *
       * // Example using `iter.next()` syntax
       * i = 1;
       * const iter = pageBlobClient.listPageRangesDiff(offset, count, previousSnapshot);
       * let { value, done } = await iter.next();
       * while (!done) {
       *   console.log(`Page range ${i++}: ${value.start} - ${value.end}`);
       *   ({ value, done } = await iter.next());
       * }
       *
       * // Example using `byPage()` syntax
       * i = 1;
       * for await (const page of pageBlobClient
       *   .listPageRangesDiff(offset, count, previousSnapshot)
       *   .byPage({ maxPageSize: 20 })) {
       *   for (const pageRange of page.pageRange || []) {
       *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
       *   }
       * }
       *
       * // Example using paging with a marker
       * i = 1;
       * let iterator = pageBlobClient
       *   .listPageRangesDiff(offset, count, previousSnapshot)
       *   .byPage({ maxPageSize: 2 });
       * let response = (await iterator.next()).value;
       * // Prints 2 page ranges
       * if (response.pageRange) {
       *   for (const pageRange of response.pageRange) {
       *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
       *   }
       * }
       * // Gets next marker
       * let marker = response.continuationToken;
       * // Passing next marker as continuationToken
       * iterator = pageBlobClient
       *   .listPageRangesDiff(offset, count, previousSnapshot)
       *   .byPage({ continuationToken: marker, maxPageSize: 10 });
       * response = (await iterator.next()).value;
       * // Prints 10 page ranges
       * if (response.pageRange) {
       *   for (const pageRange of response.pageRange) {
       *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
       *   }
       * }
       * ```
       *
       * @param offset - Starting byte position of the page ranges.
       * @param count - Number of bytes to get.
       * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.
       * @param options - Options to the Page Blob Get Ranges operation.
       * @returns An asyncIterableIterator that supports paging.
       */
      listPageRangesDiff(offset, count, prevSnapshot, options = {}) {
        options.conditions = options.conditions || {};
        const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, {
          ...options
        });
        return {
          /**
           * The next method, part of the iteration protocol
           */
          next() {
            return iter.next();
          },
          /**
           * The connection to the async iterator, part of the iteration protocol
           */
          [Symbol.asyncIterator]() {
            return this;
          },
          /**
           * Return an AsyncIterableIterator that works a page at a time
           */
          byPage: (settings = {}) => {
            return this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, {
              maxPageSize: settings.maxPageSize,
              ...options
            });
          }
        };
      }
      /**
       * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
       *
       * @param offset - Starting byte position of the page blob
       * @param count - Number of bytes to get ranges diff.
       * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.
       * @param options - Options to the Page Blob Get Page Ranges Diff operation.
       * @returns Response data for the Page Blob Get Page Range Diff operation.
       */
      async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options = {}) {
        options.conditions = options.conditions || {};
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options, async (updatedOptions) => {
          const response = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            prevSnapshotUrl,
            range: (0, Range_js_1.rangeToString)({ offset, count }),
            tracingOptions: updatedOptions.tracingOptions
          }));
          return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response);
        });
      }
      /**
       * Resizes the page blob to the specified size (which must be a multiple of 512).
       * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
       *
       * @param size - Target size
       * @param options - Options to the Page Blob Resize operation.
       * @returns Response data for the Page Blob Resize operation.
       */
      async resize(size, options = {}) {
        options.conditions = options.conditions || {};
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-resize", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.resize(size, {
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Sets a page blob's sequence number.
       * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
       *
       * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.
       * @param sequenceNumber - Required if sequenceNumberAction is max or update
       * @param options - Options to the Page Blob Update Sequence Number operation.
       * @returns Response data for the Page Blob Update Sequence Number operation.
       */
      async updateSequenceNumber(sequenceNumberAction, sequenceNumber, options = {}) {
        options.conditions = options.conditions || {};
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-updateSequenceNumber", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, {
            abortSignal: options.abortSignal,
            blobSequenceNumber: sequenceNumber,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.
       * The snapshot is copied such that only the differential changes between the previously
       * copied snapshot are transferred to the destination.
       * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.
       * @see https://learn.microsoft.com/rest/api/storageservices/incremental-copy-blob
       * @see https://learn.microsoft.com/azure/virtual-machines/windows/incremental-snapshots
       *
       * @param copySource - Specifies the name of the source page blob snapshot. For example,
       *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
       * @param options - Options to the Page Blob Copy Incremental operation.
       * @returns Response data for the Page Blob Copy Incremental operation.
       */
      async startCopyIncremental(copySource, options = {}) {
        return tracing_js_1.tracingClient.withSpan("PageBlobClient-startCopyIncremental", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.copyIncremental(copySource, {
            abortSignal: options.abortSignal,
            modifiedAccessConditions: {
              ...options.conditions,
              ifTags: options.conditions?.tagConditions
            },
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
    };
    exports.PageBlobClient = PageBlobClient;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BatchUtils.js
var require_BatchUtils = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/BatchUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBodyAsText = getBodyAsText;
    exports.utf8ByteLength = utf8ByteLength;
    var utils_js_1 = require_utils4();
    var constants_js_1 = require_constants9();
    async function getBodyAsText(batchResponse) {
      let buffer = Buffer.alloc(constants_js_1.BATCH_MAX_PAYLOAD_IN_BYTES);
      const responseLength = await (0, utils_js_1.streamToBuffer2)(batchResponse.readableStreamBody, buffer);
      buffer = buffer.slice(0, responseLength);
      return buffer.toString();
    }
    function utf8ByteLength(str) {
      return Buffer.byteLength(str);
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BatchResponseParser.js
var require_BatchResponseParser = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/BatchResponseParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchResponseParser = void 0;
    var core_rest_pipeline_1 = require_commonjs6();
    var core_http_compat_1 = require_commonjs9();
    var constants_js_1 = require_constants9();
    var BatchUtils_js_1 = require_BatchUtils();
    var log_js_1 = require_log5();
    var HTTP_HEADER_DELIMITER = ": ";
    var SPACE_DELIMITER = " ";
    var NOT_FOUND = -1;
    var BatchResponseParser = class {
      batchResponse;
      responseBatchBoundary;
      perResponsePrefix;
      batchResponseEnding;
      subRequests;
      constructor(batchResponse, subRequests) {
        if (!batchResponse || !batchResponse.contentType) {
          throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
        }
        if (!subRequests || subRequests.size === 0) {
          throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
        }
        this.batchResponse = batchResponse;
        this.subRequests = subRequests;
        this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1];
        this.perResponsePrefix = `--${this.responseBatchBoundary}${constants_js_1.HTTP_LINE_ENDING}`;
        this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
      }
      // For example of response, please refer to https://learn.microsoft.com/rest/api/storageservices/blob-batch#response
      async parseBatchResponse() {
        if (this.batchResponse._response.status !== constants_js_1.HTTPURLConnection.HTTP_ACCEPTED) {
          throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
        }
        const responseBodyAsText = await (0, BatchUtils_js_1.getBodyAsText)(this.batchResponse);
        const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1);
        const subResponseCount = subResponses.length;
        if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {
          throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
        }
        const deserializedSubResponses = new Array(subResponseCount);
        let subResponsesSucceededCount = 0;
        let subResponsesFailedCount = 0;
        for (let index = 0; index < subResponseCount; index++) {
          const subResponse = subResponses[index];
          const deserializedSubResponse = {};
          deserializedSubResponse.headers = (0, core_http_compat_1.toHttpHeadersLike)((0, core_rest_pipeline_1.createHttpHeaders)());
          const responseLines = subResponse.split(`${constants_js_1.HTTP_LINE_ENDING}`);
          let subRespHeaderStartFound = false;
          let subRespHeaderEndFound = false;
          let subRespFailed = false;
          let contentId = NOT_FOUND;
          for (const responseLine of responseLines) {
            if (!subRespHeaderStartFound) {
              if (responseLine.startsWith(constants_js_1.HeaderConstants.CONTENT_ID)) {
                contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
              }
              if (responseLine.startsWith(constants_js_1.HTTP_VERSION_1_1)) {
                subRespHeaderStartFound = true;
                const tokens = responseLine.split(SPACE_DELIMITER);
                deserializedSubResponse.status = parseInt(tokens[1]);
                deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
              }
              continue;
            }
            if (responseLine.trim() === "") {
              if (!subRespHeaderEndFound) {
                subRespHeaderEndFound = true;
              }
              continue;
            }
            if (!subRespHeaderEndFound) {
              if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {
                throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
              }
              const tokens = responseLine.split(HTTP_HEADER_DELIMITER);
              deserializedSubResponse.headers.set(tokens[0], tokens[1]);
              if (tokens[0] === constants_js_1.HeaderConstants.X_MS_ERROR_CODE) {
                deserializedSubResponse.errorCode = tokens[1];
                subRespFailed = true;
              }
            } else {
              if (!deserializedSubResponse.bodyAsText) {
                deserializedSubResponse.bodyAsText = "";
              }
              deserializedSubResponse.bodyAsText += responseLine;
            }
          }
          if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === void 0) {
            deserializedSubResponse._request = this.subRequests.get(contentId);
            deserializedSubResponses[contentId] = deserializedSubResponse;
          } else {
            log_js_1.logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
          }
          if (subRespFailed) {
            subResponsesFailedCount++;
          } else {
            subResponsesSucceededCount++;
          }
        }
        return {
          subResponses: deserializedSubResponses,
          subResponsesSucceededCount,
          subResponsesFailedCount
        };
      }
    };
    exports.BatchResponseParser = BatchResponseParser;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/utils/Mutex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mutex = void 0;
    var MutexLockStatus;
    (function(MutexLockStatus2) {
      MutexLockStatus2[MutexLockStatus2["LOCKED"] = 0] = "LOCKED";
      MutexLockStatus2[MutexLockStatus2["UNLOCKED"] = 1] = "UNLOCKED";
    })(MutexLockStatus || (MutexLockStatus = {}));
    var Mutex = class {
      /**
       * Lock for a specific key. If the lock has been acquired by another customer, then
       * will wait until getting the lock.
       *
       * @param key - lock key
       */
      static async lock(key) {
        return new Promise((resolve) => {
          if (this.keys[key] === void 0 || this.keys[key] === MutexLockStatus.UNLOCKED) {
            this.keys[key] = MutexLockStatus.LOCKED;
            resolve();
          } else {
            this.onUnlockEvent(key, () => {
              this.keys[key] = MutexLockStatus.LOCKED;
              resolve();
            });
          }
        });
      }
      /**
       * Unlock a key.
       *
       * @param key -
       */
      static async unlock(key) {
        return new Promise((resolve) => {
          if (this.keys[key] === MutexLockStatus.LOCKED) {
            this.emitUnlockEvent(key);
          }
          delete this.keys[key];
          resolve();
        });
      }
      static keys = {};
      static listeners = {};
      static onUnlockEvent(key, handler) {
        if (this.listeners[key] === void 0) {
          this.listeners[key] = [handler];
        } else {
          this.listeners[key].push(handler);
        }
      }
      static emitUnlockEvent(key) {
        if (this.listeners[key] !== void 0 && this.listeners[key].length > 0) {
          const handler = this.listeners[key].shift();
          setImmediate(() => {
            handler.call(this);
          });
        }
      }
    };
    exports.Mutex = Mutex;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobBatch.js
var require_BlobBatch = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/BlobBatch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobBatch = void 0;
    var core_util_1 = require_commonjs4();
    var core_auth_1 = require_commonjs7();
    var core_rest_pipeline_1 = require_commonjs6();
    var core_util_2 = require_commonjs4();
    var AnonymousCredential_js_1 = require_AnonymousCredential();
    var Clients_js_1 = require_Clients();
    var Mutex_js_1 = require_Mutex();
    var Pipeline_js_1 = require_Pipeline();
    var utils_common_js_1 = require_utils_common();
    var core_xml_1 = require_commonjs10();
    var constants_js_1 = require_constants9();
    var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential();
    var tracing_js_1 = require_tracing();
    var core_client_1 = require_commonjs8();
    var StorageSharedKeyCredentialPolicyV2_js_1 = require_StorageSharedKeyCredentialPolicyV22();
    var BlobBatch = class {
      batchRequest;
      batch = "batch";
      batchType;
      constructor() {
        this.batchRequest = new InnerBatchRequest();
      }
      /**
       * Get the value of Content-Type for a batch request.
       * The value must be multipart/mixed with a batch boundary.
       * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252
       */
      getMultiPartContentType() {
        return this.batchRequest.getMultipartContentType();
      }
      /**
       * Get assembled HTTP request body for sub requests.
       */
      getHttpRequestBody() {
        return this.batchRequest.getHttpRequestBody();
      }
      /**
       * Get sub requests that are added into the batch request.
       */
      getSubRequests() {
        return this.batchRequest.getSubRequests();
      }
      async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
        await Mutex_js_1.Mutex.lock(this.batch);
        try {
          this.batchRequest.preAddSubRequest(subRequest);
          await assembleSubRequestFunc();
          this.batchRequest.postAddSubRequest(subRequest);
        } finally {
          await Mutex_js_1.Mutex.unlock(this.batch);
        }
      }
      setBatchType(batchType) {
        if (!this.batchType) {
          this.batchType = batchType;
        }
        if (this.batchType !== batchType) {
          throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
        }
      }
      async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {
        let url;
        let credential;
        if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrOptions instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrOptions))) {
          url = urlOrBlobClient;
          credential = credentialOrOptions;
        } else if (urlOrBlobClient instanceof Clients_js_1.BlobClient) {
          url = urlOrBlobClient.url;
          credential = urlOrBlobClient.credential;
          options = credentialOrOptions;
        } else {
          throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
        }
        if (!options) {
          options = {};
        }
        return tracing_js_1.tracingClient.withSpan("BatchDeleteRequest-addSubRequest", options, async (updatedOptions) => {
          this.setBatchType("delete");
          await this.addSubRequestInternal({
            url,
            credential
          }, async () => {
            await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
          });
        });
      }
      async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {
        let url;
        let credential;
        let tier;
        if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrTier instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrTier))) {
          url = urlOrBlobClient;
          credential = credentialOrTier;
          tier = tierOrOptions;
        } else if (urlOrBlobClient instanceof Clients_js_1.BlobClient) {
          url = urlOrBlobClient.url;
          credential = urlOrBlobClient.credential;
          tier = credentialOrTier;
          options = tierOrOptions;
        } else {
          throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
        }
        if (!options) {
          options = {};
        }
        return tracing_js_1.tracingClient.withSpan("BatchSetTierRequest-addSubRequest", options, async (updatedOptions) => {
          this.setBatchType("setAccessTier");
          await this.addSubRequestInternal({
            url,
            credential
          }, async () => {
            await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);
          });
        });
      }
    };
    exports.BlobBatch = BlobBatch;
    var InnerBatchRequest = class {
      operationCount;
      body;
      subRequests;
      boundary;
      subRequestPrefix;
      multipartContentType;
      batchRequestEnding;
      constructor() {
        this.operationCount = 0;
        this.body = "";
        const tempGuid = (0, core_util_1.randomUUID)();
        this.boundary = `batch_${tempGuid}`;
        this.subRequestPrefix = `--${this.boundary}${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TYPE}: application/http${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;
        this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;
        this.batchRequestEnding = `--${this.boundary}--`;
        this.subRequests = /* @__PURE__ */ new Map();
      }
      /**
       * Create pipeline to assemble sub requests. The idea here is to use existing
       * credential and serialization/deserialization components, with additional policies to
       * filter unnecessary headers, assemble sub requests into request's body
       * and intercept request from going to wire.
       * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
       */
      createPipeline(credential) {
        const corePipeline = (0, core_rest_pipeline_1.createEmptyPipeline)();
        corePipeline.addPolicy((0, core_client_1.serializationPolicy)({
          stringifyXML: core_xml_1.stringifyXML,
          serializerOptions: {
            xml: {
              xmlCharKey: "#"
            }
          }
        }), { phase: "Serialize" });
        corePipeline.addPolicy(batchHeaderFilterPolicy());
        corePipeline.addPolicy(batchRequestAssemblePolicy(this), { afterPhase: "Sign" });
        if ((0, core_auth_1.isTokenCredential)(credential)) {
          corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
            credential,
            scopes: constants_js_1.StorageOAuthScopes,
            challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
          }), { phase: "Sign" });
        } else if (credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential) {
          corePipeline.addPolicy((0, StorageSharedKeyCredentialPolicyV2_js_1.storageSharedKeyCredentialPolicy)({
            accountName: credential.accountName,
            accountKey: credential.accountKey
          }), { phase: "Sign" });
        }
        const pipeline = new Pipeline_js_1.Pipeline([]);
        pipeline._credential = credential;
        pipeline._corePipeline = corePipeline;
        return pipeline;
      }
      appendSubRequestToBody(request) {
        this.body += [
          this.subRequestPrefix,
          // sub request constant prefix
          `${constants_js_1.HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
          // sub request's content ID
          "",
          // empty line after sub request's content ID
          `${request.method.toString()} ${(0, utils_common_js_1.getURLPathAndQuery)(request.url)} ${constants_js_1.HTTP_VERSION_1_1}${constants_js_1.HTTP_LINE_ENDING}`
          // sub request start line with method
        ].join(constants_js_1.HTTP_LINE_ENDING);
        for (const [name, value] of request.headers) {
          this.body += `${name}: ${value}${constants_js_1.HTTP_LINE_ENDING}`;
        }
        this.body += constants_js_1.HTTP_LINE_ENDING;
      }
      preAddSubRequest(subRequest) {
        if (this.operationCount >= constants_js_1.BATCH_MAX_REQUEST) {
          throw new RangeError(`Cannot exceed ${constants_js_1.BATCH_MAX_REQUEST} sub requests in a single batch`);
        }
        const path2 = (0, utils_common_js_1.getURLPath)(subRequest.url);
        if (!path2 || path2 === "") {
          throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);
        }
      }
      postAddSubRequest(subRequest) {
        this.subRequests.set(this.operationCount, subRequest);
        this.operationCount++;
      }
      // Return the http request body with assembling the ending line to the sub request body.
      getHttpRequestBody() {
        return `${this.body}${this.batchRequestEnding}${constants_js_1.HTTP_LINE_ENDING}`;
      }
      getMultipartContentType() {
        return this.multipartContentType;
      }
      getSubRequests() {
        return this.subRequests;
      }
    };
    function batchRequestAssemblePolicy(batchRequest) {
      return {
        name: "batchRequestAssemblePolicy",
        async sendRequest(request) {
          batchRequest.appendSubRequestToBody(request);
          return {
            request,
            status: 200,
            headers: (0, core_rest_pipeline_1.createHttpHeaders)()
          };
        }
      };
    }
    function batchHeaderFilterPolicy() {
      return {
        name: "batchHeaderFilterPolicy",
        async sendRequest(request, next) {
          let xMsHeaderName = "";
          for (const [name] of request.headers) {
            if ((0, utils_common_js_1.iEqual)(name, constants_js_1.HeaderConstants.X_MS_VERSION)) {
              xMsHeaderName = name;
            }
          }
          if (xMsHeaderName !== "") {
            request.headers.delete(xMsHeaderName);
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobBatchClient.js
var require_BlobBatchClient = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/BlobBatchClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobBatchClient = void 0;
    var BatchResponseParser_js_1 = require_BatchResponseParser();
    var BatchUtils_js_1 = require_BatchUtils();
    var BlobBatch_js_1 = require_BlobBatch();
    var tracing_js_1 = require_tracing();
    var AnonymousCredential_js_1 = require_AnonymousCredential();
    var StorageContextClient_js_1 = require_StorageContextClient();
    var Pipeline_js_1 = require_Pipeline();
    var utils_common_js_1 = require_utils_common();
    var BlobBatchClient = class {
      serviceOrContainerContext;
      constructor(url, credentialOrPipeline, options) {
        let pipeline;
        if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline)) {
          pipeline = credentialOrPipeline;
        } else if (!credentialOrPipeline) {
          pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
        } else {
          pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options);
        }
        const storageClientContext = new StorageContextClient_js_1.StorageContextClient(url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline));
        const path2 = (0, utils_common_js_1.getURLPath)(url);
        if (path2 && path2 !== "/") {
          this.serviceOrContainerContext = storageClientContext.container;
        } else {
          this.serviceOrContainerContext = storageClientContext.service;
        }
      }
      /**
       * Creates a {@link BlobBatch}.
       * A BlobBatch represents an aggregated set of operations on blobs.
       */
      createBatch() {
        return new BlobBatch_js_1.BlobBatch();
      }
      async deleteBlobs(urlsOrBlobClients, credentialOrOptions, options) {
        const batch = new BlobBatch_js_1.BlobBatch();
        for (const urlOrBlobClient of urlsOrBlobClients) {
          if (typeof urlOrBlobClient === "string") {
            await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options);
          } else {
            await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
          }
        }
        return this.submitBatch(batch);
      }
      async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, options) {
        const batch = new BlobBatch_js_1.BlobBatch();
        for (const urlOrBlobClient of urlsOrBlobClients) {
          if (typeof urlOrBlobClient === "string") {
            await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options);
          } else {
            await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
          }
        }
        return this.submitBatch(batch);
      }
      /**
       * Submit batch request which consists of multiple subrequests.
       *
       * Get `blobBatchClient` and other details before running the snippets.
       * `blobServiceClient.getBlobBatchClient()` gives the `blobBatchClient`
       *
       * Example usage:
       *
       * ```ts snippet:BlobBatchClientSubmitBatch
       * import { DefaultAzureCredential } from "@azure/identity";
       * import { BlobServiceClient, BlobBatch } from "@azure/storage-blob";
       *
       * const account = "<account>";
       * const credential = new DefaultAzureCredential();
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   credential,
       * );
       *
       * const containerName = "<container name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const blobBatchClient = containerClient.getBlobBatchClient();
       *
       * const batchRequest = new BlobBatch();
       * await batchRequest.deleteBlob("<blob-url-1>", credential);
       * await batchRequest.deleteBlob("<blob-url-2>", credential, {
       *   deleteSnapshots: "include",
       * });
       * const batchResp = await blobBatchClient.submitBatch(batchRequest);
       * console.log(batchResp.subResponsesSucceededCount);
       * ```
       *
       * Example using a lease:
       *
       * ```ts snippet:BlobBatchClientSubmitBatchWithLease
       * import { DefaultAzureCredential } from "@azure/identity";
       * import { BlobServiceClient, BlobBatch } from "@azure/storage-blob";
       *
       * const account = "<account>";
       * const credential = new DefaultAzureCredential();
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   credential,
       * );
       *
       * const containerName = "<container name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const blobBatchClient = containerClient.getBlobBatchClient();
       * const blobClient = containerClient.getBlobClient("<blob name>");
       *
       * const batchRequest = new BlobBatch();
       * await batchRequest.setBlobAccessTier(blobClient, "Cool");
       * await batchRequest.setBlobAccessTier(blobClient, "Cool", {
       *   conditions: { leaseId: "<lease-id>" },
       * });
       * const batchResp = await blobBatchClient.submitBatch(batchRequest);
       * console.log(batchResp.subResponsesSucceededCount);
       * ```
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/blob-batch
       *
       * @param batchRequest - A set of Delete or SetTier operations.
       * @param options -
       */
      async submitBatch(batchRequest, options = {}) {
        if (!batchRequest || batchRequest.getSubRequests().size === 0) {
          throw new RangeError("Batch request should contain one or more sub requests.");
        }
        return tracing_js_1.tracingClient.withSpan("BlobBatchClient-submitBatch", options, async (updatedOptions) => {
          const batchRequestBody = batchRequest.getHttpRequestBody();
          const rawBatchResponse = (0, utils_common_js_1.assertResponse)(await this.serviceOrContainerContext.submitBatch((0, BatchUtils_js_1.utf8ByteLength)(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, {
            ...updatedOptions
          }));
          const batchResponseParser = new BatchResponseParser_js_1.BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests());
          const responseSummary = await batchResponseParser.parseBatchResponse();
          const res = {
            _response: rawBatchResponse._response,
            contentType: rawBatchResponse.contentType,
            errorCode: rawBatchResponse.errorCode,
            requestId: rawBatchResponse.requestId,
            clientRequestId: rawBatchResponse.clientRequestId,
            version: rawBatchResponse.version,
            subResponses: responseSummary.subResponses,
            subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
            subResponsesFailedCount: responseSummary.subResponsesFailedCount
          };
          return res;
        });
      }
    };
    exports.BlobBatchClient = BlobBatchClient;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/ContainerClient.js
var require_ContainerClient = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/ContainerClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerClient = void 0;
    var core_rest_pipeline_1 = require_commonjs6();
    var core_util_1 = require_commonjs4();
    var core_auth_1 = require_commonjs7();
    var AnonymousCredential_js_1 = require_AnonymousCredential();
    var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential();
    var Pipeline_js_1 = require_Pipeline();
    var StorageClient_js_1 = require_StorageClient();
    var tracing_js_1 = require_tracing();
    var utils_common_js_1 = require_utils_common();
    var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
    var BlobLeaseClient_js_1 = require_BlobLeaseClient();
    var Clients_js_1 = require_Clients();
    var BlobBatchClient_js_1 = require_BlobBatchClient();
    var ContainerClient = class extends StorageClient_js_1.StorageClient {
      /**
       * containerContext provided by protocol layer.
       */
      containerContext;
      _containerName;
      /**
       * The name of the container.
       */
      get containerName() {
        return this._containerName;
      }
      constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, options) {
        let pipeline;
        let url;
        options = options || {};
        if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          pipeline = credentialOrPipelineOrContainerName;
        } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
          url = urlOrConnectionString;
          pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
        } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
          url = urlOrConnectionString;
          pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
        } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string") {
          const containerName = credentialOrPipelineOrContainerName;
          const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
          if (extractedCreds.kind === "AccountConnString") {
            if (core_util_1.isNodeLike) {
              const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
              url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName));
              if (!options.proxyOptions) {
                options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
              }
              pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
            } else {
              throw new Error("Account connection string is only supported in Node.js environment");
            }
          } else if (extractedCreds.kind === "SASConnString") {
            url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas;
            pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
          } else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
          }
        } else {
          throw new Error("Expecting non-empty strings for containerName parameter");
        }
        super(url, pipeline);
        this._containerName = this.getContainerNameFromUrl();
        this.containerContext = this.storageClientContext.container;
      }
      /**
       * Creates a new container under the specified account. If the container with
       * the same name already exists, the operation fails.
       * @see https://learn.microsoft.com/rest/api/storageservices/create-container
       * Naming rules: @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
       *
       * @param options - Options to Container Create operation.
       *
       *
       * Example usage:
       *
       * ```ts snippet:ContainerClientCreate
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const createContainerResponse = await containerClient.create();
       * console.log("Container was created successfully", createContainerResponse.requestId);
       * ```
       */
      async create(options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-create", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.containerContext.create(updatedOptions));
        });
      }
      /**
       * Creates a new container under the specified account. If the container with
       * the same name already exists, it is not changed.
       * @see https://learn.microsoft.com/rest/api/storageservices/create-container
       * Naming rules: @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
       *
       * @param options -
       */
      async createIfNotExists(options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-createIfNotExists", options, async (updatedOptions) => {
          try {
            const res = await this.create(updatedOptions);
            return {
              succeeded: true,
              ...res,
              _response: res._response
              // _response is made non-enumerable
            };
          } catch (e) {
            if (e.details?.errorCode === "ContainerAlreadyExists") {
              return {
                succeeded: false,
                ...e.response?.parsedHeaders,
                _response: e.response
              };
            } else {
              throw e;
            }
          }
        });
      }
      /**
       * Returns true if the Azure container resource represented by this client exists; false otherwise.
       *
       * NOTE: use this function with care since an existing container might be deleted by other clients or
       * applications. Vice versa new containers with the same name might be added by other clients or
       * applications after this function completes.
       *
       * @param options -
       */
      async exists(options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-exists", options, async (updatedOptions) => {
          try {
            await this.getProperties({
              abortSignal: options.abortSignal,
              tracingOptions: updatedOptions.tracingOptions
            });
            return true;
          } catch (e) {
            if (e.statusCode === 404) {
              return false;
            }
            throw e;
          }
        });
      }
      /**
       * Creates a {@link BlobClient}
       *
       * @param blobName - A blob name
       * @returns A new BlobClient object for the given blob name.
       */
      getBlobClient(blobName) {
        return new Clients_js_1.BlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
      }
      /**
       * Creates an {@link AppendBlobClient}
       *
       * @param blobName - An append blob name
       */
      getAppendBlobClient(blobName) {
        return new Clients_js_1.AppendBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
      }
      /**
       * Creates a {@link BlockBlobClient}
       *
       * @param blobName - A block blob name
       *
       *
       * Example usage:
       *
       * ```ts snippet:ClientsUpload
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const blobName = "<blob name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       * const blockBlobClient = containerClient.getBlockBlobClient(blobName);
       *
       * const content = "Hello world!";
       * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
       * ```
       */
      getBlockBlobClient(blobName) {
        return new Clients_js_1.BlockBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
      }
      /**
       * Creates a {@link PageBlobClient}
       *
       * @param blobName - A page blob name
       */
      getPageBlobClient(blobName) {
        return new Clients_js_1.PageBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
      }
      /**
       * Returns all user-defined metadata and system properties for the specified
       * container. The data returned does not include the container's list of blobs.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-container-properties
       *
       * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
       * they originally contained uppercase characters. This differs from the metadata keys returned by
       * the `listContainers` method of {@link BlobServiceClient} using the `includeMetadata` option, which
       * will retain their original casing.
       *
       * @param options - Options to Container Get Properties operation.
       */
      async getProperties(options = {}) {
        if (!options.conditions) {
          options.conditions = {};
        }
        return tracing_js_1.tracingClient.withSpan("ContainerClient-getProperties", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.containerContext.getProperties({
            abortSignal: options.abortSignal,
            ...options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Marks the specified container for deletion. The container and any blobs
       * contained within it are later deleted during garbage collection.
       * @see https://learn.microsoft.com/rest/api/storageservices/delete-container
       *
       * @param options - Options to Container Delete operation.
       */
      async delete(options = {}) {
        if (!options.conditions) {
          options.conditions = {};
        }
        return tracing_js_1.tracingClient.withSpan("ContainerClient-delete", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.containerContext.delete({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Marks the specified container for deletion if it exists. The container and any blobs
       * contained within it are later deleted during garbage collection.
       * @see https://learn.microsoft.com/rest/api/storageservices/delete-container
       *
       * @param options - Options to Container Delete operation.
       */
      async deleteIfExists(options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteIfExists", options, async (updatedOptions) => {
          try {
            const res = await this.delete(updatedOptions);
            return {
              succeeded: true,
              ...res,
              _response: res._response
            };
          } catch (e) {
            if (e.details?.errorCode === "ContainerNotFound") {
              return {
                succeeded: false,
                ...e.response?.parsedHeaders,
                _response: e.response
              };
            }
            throw e;
          }
        });
      }
      /**
       * Sets one or more user-defined name-value pairs for the specified container.
       *
       * If no option provided, or no metadata defined in the parameter, the container
       * metadata will be removed.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/set-container-metadata
       *
       * @param metadata - Replace existing metadata with this value.
       *                            If no value provided the existing metadata will be removed.
       * @param options - Options to Container Set Metadata operation.
       */
      async setMetadata(metadata, options = {}) {
        if (!options.conditions) {
          options.conditions = {};
        }
        if (options.conditions.ifUnmodifiedSince) {
          throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
        }
        return tracing_js_1.tracingClient.withSpan("ContainerClient-setMetadata", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.containerContext.setMetadata({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            metadata,
            modifiedAccessConditions: options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Gets the permissions for the specified container. The permissions indicate
       * whether container data may be accessed publicly.
       *
       * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.
       * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/get-container-acl
       *
       * @param options - Options to Container Get Access Policy operation.
       */
      async getAccessPolicy(options = {}) {
        if (!options.conditions) {
          options.conditions = {};
        }
        return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccessPolicy", options, async (updatedOptions) => {
          const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccessPolicy({
            abortSignal: options.abortSignal,
            leaseAccessConditions: options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          }));
          const res = {
            _response: response._response,
            blobPublicAccess: response.blobPublicAccess,
            date: response.date,
            etag: response.etag,
            errorCode: response.errorCode,
            lastModified: response.lastModified,
            requestId: response.requestId,
            clientRequestId: response.clientRequestId,
            signedIdentifiers: [],
            version: response.version
          };
          for (const identifier of response) {
            let accessPolicy = void 0;
            if (identifier.accessPolicy) {
              accessPolicy = {
                permissions: identifier.accessPolicy.permissions
              };
              if (identifier.accessPolicy.expiresOn) {
                accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
              }
              if (identifier.accessPolicy.startsOn) {
                accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
              }
            }
            res.signedIdentifiers.push({
              accessPolicy,
              id: identifier.id
            });
          }
          return res;
        });
      }
      /**
       * Sets the permissions for the specified container. The permissions indicate
       * whether blobs in a container may be accessed publicly.
       *
       * When you set permissions for a container, the existing permissions are replaced.
       * If no access or containerAcl provided, the existing container ACL will be
       * removed.
       *
       * When you establish a stored access policy on a container, it may take up to 30 seconds to take effect.
       * During this interval, a shared access signature that is associated with the stored access policy will
       * fail with status code 403 (Forbidden), until the access policy becomes active.
       * @see https://learn.microsoft.com/rest/api/storageservices/set-container-acl
       *
       * @param access - The level of public access to data in the container.
       * @param containerAcl - Array of elements each having a unique Id and details of the access policy.
       * @param options - Options to Container Set Access Policy operation.
       */
      async setAccessPolicy(access, containerAcl, options = {}) {
        options.conditions = options.conditions || {};
        return tracing_js_1.tracingClient.withSpan("ContainerClient-setAccessPolicy", options, async (updatedOptions) => {
          const acl = [];
          for (const identifier of containerAcl || []) {
            acl.push({
              accessPolicy: {
                expiresOn: identifier.accessPolicy.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.expiresOn) : "",
                permissions: identifier.accessPolicy.permissions,
                startsOn: identifier.accessPolicy.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.startsOn) : ""
              },
              id: identifier.id
            });
          }
          return (0, utils_common_js_1.assertResponse)(await this.containerContext.setAccessPolicy({
            abortSignal: options.abortSignal,
            access,
            containerAcl: acl,
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Get a {@link BlobLeaseClient} that manages leases on the container.
       *
       * @param proposeLeaseId - Initial proposed lease Id.
       * @returns A new BlobLeaseClient object for managing leases on the container.
       */
      getBlobLeaseClient(proposeLeaseId) {
        return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
      }
      /**
       * Creates a new block blob, or updates the content of an existing block blob.
       *
       * Updating an existing block blob overwrites any existing metadata on the blob.
       * Partial updates are not supported; the content of the existing blob is
       * overwritten with the new content. To perform a partial update of a block blob's,
       * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.
       *
       * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},
       * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better
       * performance with concurrency uploading.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
       *
       * @param blobName - Name of the block blob to create or update.
       * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
       *                               which returns a new Readable stream whose offset is from data source beginning.
       * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
       *                               string including non non-Base64/Hex-encoded characters.
       * @param options - Options to configure the Block Blob Upload operation.
       * @returns Block Blob upload response data and the corresponding BlockBlobClient instance.
       */
      async uploadBlockBlob(blobName, body, contentLength, options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-uploadBlockBlob", options, async (updatedOptions) => {
          const blockBlobClient = this.getBlockBlobClient(blobName);
          const response = await blockBlobClient.upload(body, contentLength, updatedOptions);
          return {
            blockBlobClient,
            response
          };
        });
      }
      /**
       * Marks the specified blob or snapshot for deletion. The blob is later deleted
       * during garbage collection. Note that in order to delete a blob, you must delete
       * all of its snapshots. You can delete both at the same time with the Delete
       * Blob operation.
       * @see https://learn.microsoft.com/rest/api/storageservices/delete-blob
       *
       * @param blobName -
       * @param options - Options to Blob Delete operation.
       * @returns Block blob deletion response data.
       */
      async deleteBlob(blobName, options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteBlob", options, async (updatedOptions) => {
          let blobClient = this.getBlobClient(blobName);
          if (options.versionId) {
            blobClient = blobClient.withVersion(options.versionId);
          }
          return blobClient.delete(updatedOptions);
        });
      }
      /**
       * listBlobFlatSegment returns a single segment of blobs starting from the
       * specified Marker. Use an empty Marker to start enumeration from the beginning.
       * After getting a segment, process it, and then call listBlobsFlatSegment again
       * (passing the the previously-returned Marker) to get the next segment.
       * @see https://learn.microsoft.com/rest/api/storageservices/list-blobs
       *
       * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
       * @param options - Options to Container List Blob Flat Segment operation.
       */
      async listBlobFlatSegment(marker, options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobFlatSegment", options, async (updatedOptions) => {
          const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobFlatSegment({
            marker,
            ...options,
            tracingOptions: updatedOptions.tracingOptions
          }));
          const wrappedResponse = {
            ...response,
            _response: {
              ...response._response,
              parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobFlat)(response._response.parsedBody)
            },
            // _response is made non-enumerable
            segment: {
              ...response.segment,
              blobItems: response.segment.blobItems.map((blobItemInternal) => {
                const blobItem = {
                  ...blobItemInternal,
                  name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
                  tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
                  objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
                };
                return blobItem;
              })
            }
          };
          return wrappedResponse;
        });
      }
      /**
       * listBlobHierarchySegment returns a single segment of blobs starting from
       * the specified Marker. Use an empty Marker to start enumeration from the
       * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment
       * again (passing the the previously-returned Marker) to get the next segment.
       * @see https://learn.microsoft.com/rest/api/storageservices/list-blobs
       *
       * @param delimiter - The character or string used to define the virtual hierarchy
       * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
       * @param options - Options to Container List Blob Hierarchy Segment operation.
       */
      async listBlobHierarchySegment(delimiter, marker, options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobHierarchySegment", options, async (updatedOptions) => {
          const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobHierarchySegment(delimiter, {
            marker,
            ...options,
            tracingOptions: updatedOptions.tracingOptions
          }));
          const wrappedResponse = {
            ...response,
            _response: {
              ...response._response,
              parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobHierarchy)(response._response.parsedBody)
            },
            // _response is made non-enumerable
            segment: {
              ...response.segment,
              blobItems: response.segment.blobItems.map((blobItemInternal) => {
                const blobItem = {
                  ...blobItemInternal,
                  name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
                  tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
                  objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
                };
                return blobItem;
              }),
              blobPrefixes: response.segment.blobPrefixes?.map((blobPrefixInternal) => {
                const blobPrefix = {
                  ...blobPrefixInternal,
                  name: (0, utils_common_js_1.BlobNameToString)(blobPrefixInternal.name)
                };
                return blobPrefix;
              })
            }
          };
          return wrappedResponse;
        });
      }
      /**
       * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse
       *
       * @param marker - A string value that identifies the portion of
       *                          the list of blobs to be returned with the next listing operation. The
       *                          operation returns the ContinuationToken value within the response body if the
       *                          listing operation did not return all blobs remaining to be listed
       *                          with the current page. The ContinuationToken value can be used as the value for
       *                          the marker parameter in a subsequent call to request the next page of list
       *                          items. The marker value is opaque to the client.
       * @param options - Options to list blobs operation.
       */
      async *listSegments(marker, options = {}) {
        let listBlobsFlatSegmentResponse;
        if (!!marker || marker === void 0) {
          do {
            listBlobsFlatSegmentResponse = await this.listBlobFlatSegment(marker, options);
            marker = listBlobsFlatSegmentResponse.continuationToken;
            yield await listBlobsFlatSegmentResponse;
          } while (marker);
        }
      }
      /**
       * Returns an AsyncIterableIterator of {@link BlobItem} objects
       *
       * @param options - Options to list blobs operation.
       */
      async *listItems(options = {}) {
        let marker;
        for await (const listBlobsFlatSegmentResponse of this.listSegments(marker, options)) {
          yield* listBlobsFlatSegmentResponse.segment.blobItems;
        }
      }
      /**
       * Returns an async iterable iterator to list all the blobs
       * under the specified account.
       *
       * .byPage() returns an async iterable iterator to list the blobs in pages.
       *
       * ```ts snippet:ReadmeSampleListBlobs_Multiple
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       *
       * // Example using `for await` syntax
       * let i = 1;
       * const blobs = containerClient.listBlobsFlat();
       * for await (const blob of blobs) {
       *   console.log(`Blob ${i++}: ${blob.name}`);
       * }
       *
       * // Example using `iter.next()` syntax
       * i = 1;
       * const iter = containerClient.listBlobsFlat();
       * let { value, done } = await iter.next();
       * while (!done) {
       *   console.log(`Blob ${i++}: ${value.name}`);
       *   ({ value, done } = await iter.next());
       * }
       *
       * // Example using `byPage()` syntax
       * i = 1;
       * for await (const page of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {
       *   for (const blob of page.segment.blobItems) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       *
       * // Example using paging with a marker
       * i = 1;
       * let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });
       * let response = (await iterator.next()).value;
       * // Prints 2 blob names
       * if (response.segment.blobItems) {
       *   for (const blob of response.segment.blobItems) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       * // Gets next marker
       * let marker = response.continuationToken;
       * // Passing next marker as continuationToken
       * iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });
       * response = (await iterator.next()).value;
       * // Prints 10 blob names
       * if (response.segment.blobItems) {
       *   for (const blob of response.segment.blobItems) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       * ```
       *
       * @param options - Options to list blobs.
       * @returns An asyncIterableIterator that supports paging.
       */
      listBlobsFlat(options = {}) {
        const include = [];
        if (options.includeCopy) {
          include.push("copy");
        }
        if (options.includeDeleted) {
          include.push("deleted");
        }
        if (options.includeMetadata) {
          include.push("metadata");
        }
        if (options.includeSnapshots) {
          include.push("snapshots");
        }
        if (options.includeVersions) {
          include.push("versions");
        }
        if (options.includeUncommitedBlobs) {
          include.push("uncommittedblobs");
        }
        if (options.includeTags) {
          include.push("tags");
        }
        if (options.includeDeletedWithVersions) {
          include.push("deletedwithversions");
        }
        if (options.includeImmutabilityPolicy) {
          include.push("immutabilitypolicy");
        }
        if (options.includeLegalHold) {
          include.push("legalhold");
        }
        if (options.prefix === "") {
          options.prefix = void 0;
        }
        const updatedOptions = {
          ...options,
          ...include.length > 0 ? { include } : {}
        };
        const iter = this.listItems(updatedOptions);
        return {
          /**
           * The next method, part of the iteration protocol
           */
          next() {
            return iter.next();
          },
          /**
           * The connection to the async iterator, part of the iteration protocol
           */
          [Symbol.asyncIterator]() {
            return this;
          },
          /**
           * Return an AsyncIterableIterator that works a page at a time
           */
          byPage: (settings = {}) => {
            return this.listSegments(settings.continuationToken, {
              maxPageSize: settings.maxPageSize,
              ...updatedOptions
            });
          }
        };
      }
      /**
       * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse
       *
       * @param delimiter - The character or string used to define the virtual hierarchy
       * @param marker - A string value that identifies the portion of
       *                          the list of blobs to be returned with the next listing operation. The
       *                          operation returns the ContinuationToken value within the response body if the
       *                          listing operation did not return all blobs remaining to be listed
       *                          with the current page. The ContinuationToken value can be used as the value for
       *                          the marker parameter in a subsequent call to request the next page of list
       *                          items. The marker value is opaque to the client.
       * @param options - Options to list blobs operation.
       */
      async *listHierarchySegments(delimiter, marker, options = {}) {
        let listBlobsHierarchySegmentResponse;
        if (!!marker || marker === void 0) {
          do {
            listBlobsHierarchySegmentResponse = await this.listBlobHierarchySegment(delimiter, marker, options);
            marker = listBlobsHierarchySegmentResponse.continuationToken;
            yield await listBlobsHierarchySegmentResponse;
          } while (marker);
        }
      }
      /**
       * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.
       *
       * @param delimiter - The character or string used to define the virtual hierarchy
       * @param options - Options to list blobs operation.
       */
      async *listItemsByHierarchy(delimiter, options = {}) {
        let marker;
        for await (const listBlobsHierarchySegmentResponse of this.listHierarchySegments(delimiter, marker, options)) {
          const segment = listBlobsHierarchySegmentResponse.segment;
          if (segment.blobPrefixes) {
            for (const prefix of segment.blobPrefixes) {
              yield {
                kind: "prefix",
                ...prefix
              };
            }
          }
          for (const blob of segment.blobItems) {
            yield { kind: "blob", ...blob };
          }
        }
      }
      /**
       * Returns an async iterable iterator to list all the blobs by hierarchy.
       * under the specified account.
       *
       * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.
       *
       * ```ts snippet:ReadmeSampleListBlobsByHierarchy
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       *
       * // Example using `for await` syntax
       * let i = 1;
       * const blobs = containerClient.listBlobsByHierarchy("/");
       * for await (const blob of blobs) {
       *   if (blob.kind === "prefix") {
       *     console.log(`\tBlobPrefix: ${blob.name}`);
       *   } else {
       *     console.log(`\tBlobItem: name - ${blob.name}`);
       *   }
       * }
       *
       * // Example using `iter.next()` syntax
       * i = 1;
       * const iter = containerClient.listBlobsByHierarchy("/");
       * let { value, done } = await iter.next();
       * while (!done) {
       *   if (value.kind === "prefix") {
       *     console.log(`\tBlobPrefix: ${value.name}`);
       *   } else {
       *     console.log(`\tBlobItem: name - ${value.name}`);
       *   }
       *   ({ value, done } = await iter.next());
       * }
       *
       * // Example using `byPage()` syntax
       * i = 1;
       * for await (const page of containerClient.listBlobsByHierarchy("/").byPage({ maxPageSize: 20 })) {
       *   const segment = page.segment;
       *   if (segment.blobPrefixes) {
       *     for (const prefix of segment.blobPrefixes) {
       *       console.log(`\tBlobPrefix: ${prefix.name}`);
       *     }
       *   }
       *   for (const blob of page.segment.blobItems) {
       *     console.log(`\tBlobItem: name - ${blob.name}`);
       *   }
       * }
       *
       * // Example using paging with a marker
       * i = 1;
       * let iterator = containerClient.listBlobsByHierarchy("/").byPage({ maxPageSize: 2 });
       * let response = (await iterator.next()).value;
       * // Prints 2 blob names
       * if (response.blobPrefixes) {
       *   for (const prefix of response.blobPrefixes) {
       *     console.log(`\tBlobPrefix: ${prefix.name}`);
       *   }
       * }
       * if (response.segment.blobItems) {
       *   for (const blob of response.segment.blobItems) {
       *     console.log(`\tBlobItem: name - ${blob.name}`);
       *   }
       * }
       * // Gets next marker
       * let marker = response.continuationToken;
       * // Passing next marker as continuationToken
       * iterator = containerClient
       *   .listBlobsByHierarchy("/")
       *   .byPage({ continuationToken: marker, maxPageSize: 10 });
       * response = (await iterator.next()).value;
       * // Prints 10 blob names
       * if (response.blobPrefixes) {
       *   for (const prefix of response.blobPrefixes) {
       *     console.log(`\tBlobPrefix: ${prefix.name}`);
       *   }
       * }
       * if (response.segment.blobItems) {
       *   for (const blob of response.segment.blobItems) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       * ```
       *
       * @param delimiter - The character or string used to define the virtual hierarchy
       * @param options - Options to list blobs operation.
       */
      listBlobsByHierarchy(delimiter, options = {}) {
        if (delimiter === "") {
          throw new RangeError("delimiter should contain one or more characters");
        }
        const include = [];
        if (options.includeCopy) {
          include.push("copy");
        }
        if (options.includeDeleted) {
          include.push("deleted");
        }
        if (options.includeMetadata) {
          include.push("metadata");
        }
        if (options.includeSnapshots) {
          include.push("snapshots");
        }
        if (options.includeVersions) {
          include.push("versions");
        }
        if (options.includeUncommitedBlobs) {
          include.push("uncommittedblobs");
        }
        if (options.includeTags) {
          include.push("tags");
        }
        if (options.includeDeletedWithVersions) {
          include.push("deletedwithversions");
        }
        if (options.includeImmutabilityPolicy) {
          include.push("immutabilitypolicy");
        }
        if (options.includeLegalHold) {
          include.push("legalhold");
        }
        if (options.prefix === "") {
          options.prefix = void 0;
        }
        const updatedOptions = {
          ...options,
          ...include.length > 0 ? { include } : {}
        };
        const iter = this.listItemsByHierarchy(delimiter, updatedOptions);
        return {
          /**
           * The next method, part of the iteration protocol
           */
          async next() {
            return iter.next();
          },
          /**
           * The connection to the async iterator, part of the iteration protocol
           */
          [Symbol.asyncIterator]() {
            return this;
          },
          /**
           * Return an AsyncIterableIterator that works a page at a time
           */
          byPage: (settings = {}) => {
            return this.listHierarchySegments(delimiter, settings.continuationToken, {
              maxPageSize: settings.maxPageSize,
              ...updatedOptions
            });
          }
        };
      }
      /**
       * The Filter Blobs operation enables callers to list blobs in the container whose tags
       * match a given search expression.
       *
       * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.
       *                                        The given expression must evaluate to true for a blob to be returned in the results.
       *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
       *                                        however, only a subset of the OData filter syntax is supported in the Blob service.
       * @param marker - A string value that identifies the portion of
       *                          the list of blobs to be returned with the next listing operation. The
       *                          operation returns the continuationToken value within the response body if the
       *                          listing operation did not return all blobs remaining to be listed
       *                          with the current page. The continuationToken value can be used as the value for
       *                          the marker parameter in a subsequent call to request the next page of list
       *                          items. The marker value is opaque to the client.
       * @param options - Options to find blobs by tags.
       */
      async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
          const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.filterBlobs({
            abortSignal: options.abortSignal,
            where: tagFilterSqlExpression,
            marker,
            maxPageSize: options.maxPageSize,
            tracingOptions: updatedOptions.tracingOptions
          }));
          const wrappedResponse = {
            ...response,
            _response: response._response,
            // _response is made non-enumerable
            blobs: response.blobs.map((blob) => {
              let tagValue = "";
              if (blob.tags?.blobTagSet.length === 1) {
                tagValue = blob.tags.blobTagSet[0].value;
              }
              return { ...blob, tags: (0, utils_common_js_1.toTags)(blob.tags), tagValue };
            })
          };
          return wrappedResponse;
        });
      }
      /**
       * Returns an AsyncIterableIterator for ContainerFindBlobsByTagsSegmentResponse.
       *
       * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
       *                                         The given expression must evaluate to true for a blob to be returned in the results.
       *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
       *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
       * @param marker - A string value that identifies the portion of
       *                          the list of blobs to be returned with the next listing operation. The
       *                          operation returns the continuationToken value within the response body if the
       *                          listing operation did not return all blobs remaining to be listed
       *                          with the current page. The continuationToken value can be used as the value for
       *                          the marker parameter in a subsequent call to request the next page of list
       *                          items. The marker value is opaque to the client.
       * @param options - Options to find blobs by tags.
       */
      async *findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
        let response;
        if (!!marker || marker === void 0) {
          do {
            response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);
            response.blobs = response.blobs || [];
            marker = response.continuationToken;
            yield response;
          } while (marker);
        }
      }
      /**
       * Returns an AsyncIterableIterator for blobs.
       *
       * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
       *                                         The given expression must evaluate to true for a blob to be returned in the results.
       *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
       *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
       * @param options - Options to findBlobsByTagsItems.
       */
      async *findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
        let marker;
        for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)) {
          yield* segment.blobs;
        }
      }
      /**
       * Returns an async iterable iterator to find all blobs with specified tag
       * under the specified container.
       *
       * .byPage() returns an async iterable iterator to list the blobs in pages.
       *
       * Example using `for await` syntax:
       *
       * ```ts snippet:ReadmeSampleFindBlobsByTags
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerName = "<container name>";
       * const containerClient = blobServiceClient.getContainerClient(containerName);
       *
       * // Example using `for await` syntax
       * let i = 1;
       * for await (const blob of containerClient.findBlobsByTags("tagkey='tagvalue'")) {
       *   console.log(`Blob ${i++}: ${blob.name}`);
       * }
       *
       * // Example using `iter.next()` syntax
       * i = 1;
       * const iter = containerClient.findBlobsByTags("tagkey='tagvalue'");
       * let { value, done } = await iter.next();
       * while (!done) {
       *   console.log(`Blob ${i++}: ${value.name}`);
       *   ({ value, done } = await iter.next());
       * }
       *
       * // Example using `byPage()` syntax
       * i = 1;
       * for await (const page of containerClient
       *   .findBlobsByTags("tagkey='tagvalue'")
       *   .byPage({ maxPageSize: 20 })) {
       *   for (const blob of page.blobs) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       *
       * // Example using paging with a marker
       * i = 1;
       * let iterator = containerClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 2 });
       * let response = (await iterator.next()).value;
       * // Prints 2 blob names
       * if (response.blobs) {
       *   for (const blob of response.blobs) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       * // Gets next marker
       * let marker = response.continuationToken;
       * // Passing next marker as continuationToken
       * iterator = containerClient
       *   .findBlobsByTags("tagkey='tagvalue'")
       *   .byPage({ continuationToken: marker, maxPageSize: 10 });
       * response = (await iterator.next()).value;
       * // Prints 10 blob names
       * if (response.blobs) {
       *   for (const blob of response.blobs) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       * ```
       *
       * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
       *                                         The given expression must evaluate to true for a blob to be returned in the results.
       *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
       *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
       * @param options - Options to find blobs by tags.
       */
      findBlobsByTags(tagFilterSqlExpression, options = {}) {
        const listSegmentOptions = {
          ...options
        };
        const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
        return {
          /**
           * The next method, part of the iteration protocol
           */
          next() {
            return iter.next();
          },
          /**
           * The connection to the async iterator, part of the iteration protocol
           */
          [Symbol.asyncIterator]() {
            return this;
          },
          /**
           * Return an AsyncIterableIterator that works a page at a time
           */
          byPage: (settings = {}) => {
            return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
              maxPageSize: settings.maxPageSize,
              ...listSegmentOptions
            });
          }
        };
      }
      /**
       * The Get Account Information operation returns the sku name and account kind
       * for the specified account.
       * The Get Account Information operation is available on service versions beginning
       * with version 2018-03-28.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-account-information
       *
       * @param options - Options to the Service Get Account Info operation.
       * @returns Response data for the Service Get Account Info operation.
       */
      async getAccountInfo(options = {}) {
        return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccountInfo", options, async (updatedOptions) => {
          return (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccountInfo({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      getContainerNameFromUrl() {
        let containerName;
        try {
          const parsedUrl = new URL(this.url);
          if (parsedUrl.hostname.split(".")[1] === "blob") {
            containerName = parsedUrl.pathname.split("/")[1];
          } else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl)) {
            containerName = parsedUrl.pathname.split("/")[2];
          } else {
            containerName = parsedUrl.pathname.split("/")[1];
          }
          containerName = decodeURIComponent(containerName);
          if (!containerName) {
            throw new Error("Provided containerName is invalid.");
          }
          return containerName;
        } catch (error2) {
          throw new Error("Unable to extract containerName with provided information.");
        }
      }
      /**
       * Only available for ContainerClient constructed with a shared key credential.
       *
       * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties
       * and parameters passed in. The SAS is signed by the shared key credential of the client.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
       *
       * @param options - Optional parameters.
       * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      generateSasUrl(options) {
        return new Promise((resolve) => {
          if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
            throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
          }
          const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
            containerName: this._containerName,
            ...options
          }, this.credential).toString();
          resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
        });
      }
      /**
       * Only available for ContainerClient constructed with a shared key credential.
       *
       * Generates string to sign for a Blob Container Service Shared Access Signature (SAS) URI
       * based on the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
       *
       * @param options - Optional parameters.
       * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/
      generateSasStringToSign(options) {
        if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
          containerName: this._containerName,
          ...options
        }, this.credential).stringToSign;
      }
      /**
       * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties
       * and parameters passed in. The SAS is signed by the input user delegation key.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
       *
       * @param options - Optional parameters.
       * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
       * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      generateUserDelegationSasUrl(options, userDelegationKey) {
        return new Promise((resolve) => {
          const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
            containerName: this._containerName,
            ...options
          }, userDelegationKey, this.accountName).toString();
          resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
        });
      }
      /**
       * Generates string to sign for a Blob Container Service Shared Access Signature (SAS) URI
       * based on the client properties and parameters passed in. The SAS is signed by the input user delegation key.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
       *
       * @param options - Optional parameters.
       * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
       * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      generateUserDelegationSasStringToSign(options, userDelegationKey) {
        return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
          containerName: this._containerName,
          ...options
        }, userDelegationKey, this.accountName).stringToSign;
      }
      /**
       * Creates a BlobBatchClient object to conduct batch operations.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/blob-batch
       *
       * @returns A new BlobBatchClient object for this container.
       */
      getBlobBatchClient() {
        return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
      }
    };
    exports.ContainerClient = ContainerClient;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASPermissions.js
var require_AccountSASPermissions = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASPermissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountSASPermissions = void 0;
    var AccountSASPermissions = class _AccountSASPermissions {
      /**
       * Parse initializes the AccountSASPermissions fields from a string.
       *
       * @param permissions -
       */
      static parse(permissions) {
        const accountSASPermissions = new _AccountSASPermissions();
        for (const c3 of permissions) {
          switch (c3) {
            case "r":
              accountSASPermissions.read = true;
              break;
            case "w":
              accountSASPermissions.write = true;
              break;
            case "d":
              accountSASPermissions.delete = true;
              break;
            case "x":
              accountSASPermissions.deleteVersion = true;
              break;
            case "l":
              accountSASPermissions.list = true;
              break;
            case "a":
              accountSASPermissions.add = true;
              break;
            case "c":
              accountSASPermissions.create = true;
              break;
            case "u":
              accountSASPermissions.update = true;
              break;
            case "p":
              accountSASPermissions.process = true;
              break;
            case "t":
              accountSASPermissions.tag = true;
              break;
            case "f":
              accountSASPermissions.filter = true;
              break;
            case "i":
              accountSASPermissions.setImmutabilityPolicy = true;
              break;
            case "y":
              accountSASPermissions.permanentDelete = true;
              break;
            default:
              throw new RangeError(`Invalid permission character: ${c3}`);
          }
        }
        return accountSASPermissions;
      }
      /**
       * Creates a {@link AccountSASPermissions} from a raw object which contains same keys as it
       * and boolean values for them.
       *
       * @param permissionLike -
       */
      static from(permissionLike) {
        const accountSASPermissions = new _AccountSASPermissions();
        if (permissionLike.read) {
          accountSASPermissions.read = true;
        }
        if (permissionLike.write) {
          accountSASPermissions.write = true;
        }
        if (permissionLike.delete) {
          accountSASPermissions.delete = true;
        }
        if (permissionLike.deleteVersion) {
          accountSASPermissions.deleteVersion = true;
        }
        if (permissionLike.filter) {
          accountSASPermissions.filter = true;
        }
        if (permissionLike.tag) {
          accountSASPermissions.tag = true;
        }
        if (permissionLike.list) {
          accountSASPermissions.list = true;
        }
        if (permissionLike.add) {
          accountSASPermissions.add = true;
        }
        if (permissionLike.create) {
          accountSASPermissions.create = true;
        }
        if (permissionLike.update) {
          accountSASPermissions.update = true;
        }
        if (permissionLike.process) {
          accountSASPermissions.process = true;
        }
        if (permissionLike.setImmutabilityPolicy) {
          accountSASPermissions.setImmutabilityPolicy = true;
        }
        if (permissionLike.permanentDelete) {
          accountSASPermissions.permanentDelete = true;
        }
        return accountSASPermissions;
      }
      /**
       * Permission to read resources and list queues and tables granted.
       */
      read = false;
      /**
       * Permission to write resources granted.
       */
      write = false;
      /**
       * Permission to delete blobs and files granted.
       */
      delete = false;
      /**
       * Permission to delete versions granted.
       */
      deleteVersion = false;
      /**
       * Permission to list blob containers, blobs, shares, directories, and files granted.
       */
      list = false;
      /**
       * Permission to add messages, table entities, and append to blobs granted.
       */
      add = false;
      /**
       * Permission to create blobs and files granted.
       */
      create = false;
      /**
       * Permissions to update messages and table entities granted.
       */
      update = false;
      /**
       * Permission to get and delete messages granted.
       */
      process = false;
      /**
       * Specfies Tag access granted.
       */
      tag = false;
      /**
       * Permission to filter blobs.
       */
      filter = false;
      /**
       * Permission to set immutability policy.
       */
      setImmutabilityPolicy = false;
      /**
       * Specifies that Permanent Delete is permitted.
       */
      permanentDelete = false;
      /**
       * Produces the SAS permissions string for an Azure Storage account.
       * Call this method to set AccountSASSignatureValues Permissions field.
       *
       * Using this method will guarantee the resource types are in
       * an order accepted by the service.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-an-account-sas
       *
       */
      toString() {
        const permissions = [];
        if (this.read) {
          permissions.push("r");
        }
        if (this.write) {
          permissions.push("w");
        }
        if (this.delete) {
          permissions.push("d");
        }
        if (this.deleteVersion) {
          permissions.push("x");
        }
        if (this.filter) {
          permissions.push("f");
        }
        if (this.tag) {
          permissions.push("t");
        }
        if (this.list) {
          permissions.push("l");
        }
        if (this.add) {
          permissions.push("a");
        }
        if (this.create) {
          permissions.push("c");
        }
        if (this.update) {
          permissions.push("u");
        }
        if (this.process) {
          permissions.push("p");
        }
        if (this.setImmutabilityPolicy) {
          permissions.push("i");
        }
        if (this.permanentDelete) {
          permissions.push("y");
        }
        return permissions.join("");
      }
    };
    exports.AccountSASPermissions = AccountSASPermissions;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASResourceTypes.js
var require_AccountSASResourceTypes = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASResourceTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountSASResourceTypes = void 0;
    var AccountSASResourceTypes = class _AccountSASResourceTypes {
      /**
       * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
       * Error if it encounters a character that does not correspond to a valid resource type.
       *
       * @param resourceTypes -
       */
      static parse(resourceTypes) {
        const accountSASResourceTypes = new _AccountSASResourceTypes();
        for (const c3 of resourceTypes) {
          switch (c3) {
            case "s":
              accountSASResourceTypes.service = true;
              break;
            case "c":
              accountSASResourceTypes.container = true;
              break;
            case "o":
              accountSASResourceTypes.object = true;
              break;
            default:
              throw new RangeError(`Invalid resource type: ${c3}`);
          }
        }
        return accountSASResourceTypes;
      }
      /**
       * Permission to access service level APIs granted.
       */
      service = false;
      /**
       * Permission to access container level APIs (Blob Containers, Tables, Queues, File Shares) granted.
       */
      container = false;
      /**
       * Permission to access object level APIs (Blobs, Table Entities, Queue Messages, Files) granted.
       */
      object = false;
      /**
       * Converts the given resource types to a string.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/constructing-an-account-sas
       *
       */
      toString() {
        const resourceTypes = [];
        if (this.service) {
          resourceTypes.push("s");
        }
        if (this.container) {
          resourceTypes.push("c");
        }
        if (this.object) {
          resourceTypes.push("o");
        }
        return resourceTypes.join("");
      }
    };
    exports.AccountSASResourceTypes = AccountSASResourceTypes;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASServices.js
var require_AccountSASServices = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASServices.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountSASServices = void 0;
    var AccountSASServices = class _AccountSASServices {
      /**
       * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
       * Error if it encounters a character that does not correspond to a valid service.
       *
       * @param services -
       */
      static parse(services) {
        const accountSASServices = new _AccountSASServices();
        for (const c3 of services) {
          switch (c3) {
            case "b":
              accountSASServices.blob = true;
              break;
            case "f":
              accountSASServices.file = true;
              break;
            case "q":
              accountSASServices.queue = true;
              break;
            case "t":
              accountSASServices.table = true;
              break;
            default:
              throw new RangeError(`Invalid service character: ${c3}`);
          }
        }
        return accountSASServices;
      }
      /**
       * Permission to access blob resources granted.
       */
      blob = false;
      /**
       * Permission to access file resources granted.
       */
      file = false;
      /**
       * Permission to access queue resources granted.
       */
      queue = false;
      /**
       * Permission to access table resources granted.
       */
      table = false;
      /**
       * Converts the given services to a string.
       *
       */
      toString() {
        const services = [];
        if (this.blob) {
          services.push("b");
        }
        if (this.table) {
          services.push("t");
        }
        if (this.queue) {
          services.push("q");
        }
        if (this.file) {
          services.push("f");
        }
        return services.join("");
      }
    };
    exports.AccountSASServices = AccountSASServices;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASSignatureValues.js
var require_AccountSASSignatureValues = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASSignatureValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
    exports.generateAccountSASQueryParametersInternal = generateAccountSASQueryParametersInternal;
    var AccountSASPermissions_js_1 = require_AccountSASPermissions();
    var AccountSASResourceTypes_js_1 = require_AccountSASResourceTypes();
    var AccountSASServices_js_1 = require_AccountSASServices();
    var SasIPRange_js_1 = require_SasIPRange();
    var SASQueryParameters_js_1 = require_SASQueryParameters();
    var constants_js_1 = require_constants9();
    var utils_common_js_1 = require_utils_common();
    function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
      return generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential).sasQueryParameters;
    }
    function generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential) {
      const version = accountSASSignatureValues.version ? accountSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
      if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04") {
        throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
      }
      if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
      }
      if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
      }
      if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version < "2019-12-12") {
        throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
      }
      if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version < "2019-12-12") {
        throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
      }
      if (accountSASSignatureValues.encryptionScope && version < "2020-12-06") {
        throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
      }
      const parsedPermissions = AccountSASPermissions_js_1.AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString());
      const parsedServices = AccountSASServices_js_1.AccountSASServices.parse(accountSASSignatureValues.services).toString();
      const parsedResourceTypes = AccountSASResourceTypes_js_1.AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
      let stringToSign;
      if (version >= "2020-12-06") {
        stringToSign = [
          sharedKeyCredential.accountName,
          parsedPermissions,
          parsedServices,
          parsedResourceTypes,
          accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, false) : "",
          (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, false),
          accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
          accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
          version,
          accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
          ""
          // Account SAS requires an additional newline character
        ].join("\n");
      } else {
        stringToSign = [
          sharedKeyCredential.accountName,
          parsedPermissions,
          parsedServices,
          parsedResourceTypes,
          accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, false) : "",
          (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, false),
          accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
          accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
          version,
          ""
          // Account SAS requires an additional newline character
        ].join("\n");
      }
      const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
      return {
        sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(version, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, accountSASSignatureValues.encryptionScope),
        stringToSign
      };
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobServiceClient.js
var require_BlobServiceClient = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/BlobServiceClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobServiceClient = void 0;
    var core_auth_1 = require_commonjs7();
    var core_rest_pipeline_1 = require_commonjs6();
    var core_util_1 = require_commonjs4();
    var Pipeline_js_1 = require_Pipeline();
    var ContainerClient_js_1 = require_ContainerClient();
    var utils_common_js_1 = require_utils_common();
    var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential();
    var AnonymousCredential_js_1 = require_AnonymousCredential();
    var utils_common_js_2 = require_utils_common();
    var tracing_js_1 = require_tracing();
    var BlobBatchClient_js_1 = require_BlobBatchClient();
    var StorageClient_js_1 = require_StorageClient();
    var AccountSASPermissions_js_1 = require_AccountSASPermissions();
    var AccountSASSignatureValues_js_1 = require_AccountSASSignatureValues();
    var AccountSASServices_js_1 = require_AccountSASServices();
    var BlobServiceClient = class _BlobServiceClient extends StorageClient_js_1.StorageClient {
      /**
       * serviceContext provided by protocol layer.
       */
      serviceContext;
      /**
       *
       * Creates an instance of BlobServiceClient from connection string.
       *
       * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
       *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
       *                                  Account connection string example -
       *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
       *                                  SAS connection string example -
       *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
       * @param options - Optional. Options to configure the HTTP pipeline.
       */
      static fromConnectionString(connectionString, options) {
        options = options || {};
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(connectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            if (!options.proxyOptions) {
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            const pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
            return new _BlobServiceClient(extractedCreds.url, pipeline);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          const pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
          return new _BlobServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      }
      constructor(url, credentialOrPipeline, options) {
        let pipeline;
        if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline)) {
          pipeline = credentialOrPipeline;
        } else if (core_util_1.isNodeLike && credentialOrPipeline instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipeline)) {
          pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options);
        } else {
          pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
        }
        super(url, pipeline);
        this.serviceContext = this.storageClientContext.service;
      }
      /**
       * Creates a {@link ContainerClient} object
       *
       * @param containerName - A container name
       * @returns A new ContainerClient object for the given container name.
       *
       * Example usage:
       *
       * ```ts snippet:BlobServiceClientGetContainerClient
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * const containerClient = blobServiceClient.getContainerClient("<container name>");
       * ```
       */
      getContainerClient(containerName) {
        return new ContainerClient_js_1.ContainerClient((0, utils_common_js_1.appendToURLPath)(this.url, encodeURIComponent(containerName)), this.pipeline);
      }
      /**
       * Create a Blob container. @see https://learn.microsoft.com/rest/api/storageservices/create-container
       *
       * @param containerName - Name of the container to create.
       * @param options - Options to configure Container Create operation.
       * @returns Container creation response and the corresponding container client.
       */
      async createContainer(containerName, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-createContainer", options, async (updatedOptions) => {
          const containerClient = this.getContainerClient(containerName);
          const containerCreateResponse = await containerClient.create(updatedOptions);
          return {
            containerClient,
            containerCreateResponse
          };
        });
      }
      /**
       * Deletes a Blob container.
       *
       * @param containerName - Name of the container to delete.
       * @param options - Options to configure Container Delete operation.
       * @returns Container deletion response.
       */
      async deleteContainer(containerName, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-deleteContainer", options, async (updatedOptions) => {
          const containerClient = this.getContainerClient(containerName);
          return containerClient.delete(updatedOptions);
        });
      }
      /**
       * Restore a previously deleted Blob container.
       * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.
       *
       * @param deletedContainerName - Name of the previously deleted container.
       * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.
       * @param options - Options to configure Container Restore operation.
       * @returns Container deletion response.
       */
      async undeleteContainer(deletedContainerName, deletedContainerVersion, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-undeleteContainer", options, async (updatedOptions) => {
          const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName);
          const containerContext = containerClient["storageClientContext"].container;
          const containerUndeleteResponse = (0, utils_common_js_2.assertResponse)(await containerContext.restore({
            deletedContainerName,
            deletedContainerVersion,
            tracingOptions: updatedOptions.tracingOptions
          }));
          return { containerClient, containerUndeleteResponse };
        });
      }
      /**
       * Gets the properties of a storage accounts Blob service, including properties
       * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-service-properties
       *
       * @param options - Options to the Service Get Properties operation.
       * @returns Response data for the Service Get Properties operation.
       */
      async getProperties(options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getProperties", options, async (updatedOptions) => {
          return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getProperties({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Sets properties for a storage accounts Blob service endpoint, including properties
       * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
       * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-service-properties
       *
       * @param properties -
       * @param options - Options to the Service Set Properties operation.
       * @returns Response data for the Service Set Properties operation.
       */
      async setProperties(properties, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-setProperties", options, async (updatedOptions) => {
          return (0, utils_common_js_2.assertResponse)(await this.serviceContext.setProperties(properties, {
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Retrieves statistics related to replication for the Blob service. It is only
       * available on the secondary location endpoint when read-access geo-redundant
       * replication is enabled for the storage account.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-service-stats
       *
       * @param options - Options to the Service Get Statistics operation.
       * @returns Response data for the Service Get Statistics operation.
       */
      async getStatistics(options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getStatistics", options, async (updatedOptions) => {
          return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getStatistics({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * The Get Account Information operation returns the sku name and account kind
       * for the specified account.
       * The Get Account Information operation is available on service versions beginning
       * with version 2018-03-28.
       * @see https://learn.microsoft.com/rest/api/storageservices/get-account-information
       *
       * @param options - Options to the Service Get Account Info operation.
       * @returns Response data for the Service Get Account Info operation.
       */
      async getAccountInfo(options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getAccountInfo", options, async (updatedOptions) => {
          return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getAccountInfo({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * Returns a list of the containers under the specified account.
       * @see https://learn.microsoft.com/rest/api/storageservices/list-containers2
       *
       * @param marker - A string value that identifies the portion of
       *                        the list of containers to be returned with the next listing operation. The
       *                        operation returns the continuationToken value within the response body if the
       *                        listing operation did not return all containers remaining to be listed
       *                        with the current page. The continuationToken value can be used as the value for
       *                        the marker parameter in a subsequent call to request the next page of list
       *                        items. The marker value is opaque to the client.
       * @param options - Options to the Service List Container Segment operation.
       * @returns Response data for the Service List Container Segment operation.
       */
      async listContainersSegment(marker, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-listContainersSegment", options, async (updatedOptions) => {
          return (0, utils_common_js_2.assertResponse)(await this.serviceContext.listContainersSegment({
            abortSignal: options.abortSignal,
            marker,
            ...options,
            include: typeof options.include === "string" ? [options.include] : options.include,
            tracingOptions: updatedOptions.tracingOptions
          }));
        });
      }
      /**
       * The Filter Blobs operation enables callers to list blobs across all containers whose tags
       * match a given search expression. Filter blobs searches across all containers within a
       * storage account but can be scoped within the expression to a single container.
       *
       * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.
       *                                        The given expression must evaluate to true for a blob to be returned in the results.
       *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
       *                                        however, only a subset of the OData filter syntax is supported in the Blob service.
       * @param marker - A string value that identifies the portion of
       *                          the list of blobs to be returned with the next listing operation. The
       *                          operation returns the continuationToken value within the response body if the
       *                          listing operation did not return all blobs remaining to be listed
       *                          with the current page. The continuationToken value can be used as the value for
       *                          the marker parameter in a subsequent call to request the next page of list
       *                          items. The marker value is opaque to the client.
       * @param options - Options to find blobs by tags.
       */
      async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
          const response = (0, utils_common_js_2.assertResponse)(await this.serviceContext.filterBlobs({
            abortSignal: options.abortSignal,
            where: tagFilterSqlExpression,
            marker,
            maxPageSize: options.maxPageSize,
            tracingOptions: updatedOptions.tracingOptions
          }));
          const wrappedResponse = {
            ...response,
            _response: response._response,
            // _response is made non-enumerable
            blobs: response.blobs.map((blob) => {
              let tagValue = "";
              if (blob.tags?.blobTagSet.length === 1) {
                tagValue = blob.tags.blobTagSet[0].value;
              }
              return { ...blob, tags: (0, utils_common_js_1.toTags)(blob.tags), tagValue };
            })
          };
          return wrappedResponse;
        });
      }
      /**
       * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.
       *
       * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
       *                                         The given expression must evaluate to true for a blob to be returned in the results.
       *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
       *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
       * @param marker - A string value that identifies the portion of
       *                          the list of blobs to be returned with the next listing operation. The
       *                          operation returns the continuationToken value within the response body if the
       *                          listing operation did not return all blobs remaining to be listed
       *                          with the current page. The continuationToken value can be used as the value for
       *                          the marker parameter in a subsequent call to request the next page of list
       *                          items. The marker value is opaque to the client.
       * @param options - Options to find blobs by tags.
       */
      async *findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
        let response;
        if (!!marker || marker === void 0) {
          do {
            response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);
            response.blobs = response.blobs || [];
            marker = response.continuationToken;
            yield response;
          } while (marker);
        }
      }
      /**
       * Returns an AsyncIterableIterator for blobs.
       *
       * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
       *                                         The given expression must evaluate to true for a blob to be returned in the results.
       *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
       *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
       * @param options - Options to findBlobsByTagsItems.
       */
      async *findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
        let marker;
        for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)) {
          yield* segment.blobs;
        }
      }
      /**
       * Returns an async iterable iterator to find all blobs with specified tag
       * under the specified account.
       *
       * .byPage() returns an async iterable iterator to list the blobs in pages.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-service-properties
       *
       * ```ts snippet:BlobServiceClientFindBlobsByTags
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * // Use for await to iterate the blobs
       * let i = 1;
       * for await (const blob of blobServiceClient.findBlobsByTags("tagkey='tagvalue'")) {
       *   console.log(`Blob ${i++}: ${blob.name}`);
       * }
       *
       * // Use iter.next() to iterate the blobs
       * i = 1;
       * const iter = blobServiceClient.findBlobsByTags("tagkey='tagvalue'");
       * let { value, done } = await iter.next();
       * while (!done) {
       *   console.log(`Blob ${i++}: ${value.name}`);
       *   ({ value, done } = await iter.next());
       * }
       *
       * // Use byPage() to iterate the blobs
       * i = 1;
       * for await (const page of blobServiceClient
       *   .findBlobsByTags("tagkey='tagvalue'")
       *   .byPage({ maxPageSize: 20 })) {
       *   for (const blob of page.blobs) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       *
       * // Use paging with a marker
       * i = 1;
       * let iterator = blobServiceClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 2 });
       * let response = (await iterator.next()).value;
       * // Prints 2 blob names
       * if (response.blobs) {
       *   for (const blob of response.blobs) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       * // Gets next marker
       * let marker = response.continuationToken;
       * // Passing next marker as continuationToken
       * iterator = blobServiceClient
       *   .findBlobsByTags("tagkey='tagvalue'")
       *   .byPage({ continuationToken: marker, maxPageSize: 10 });
       * response = (await iterator.next()).value;
       *
       * // Prints blob names
       * if (response.blobs) {
       *   for (const blob of response.blobs) {
       *     console.log(`Blob ${i++}: ${blob.name}`);
       *   }
       * }
       * ```
       *
       * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
       *                                         The given expression must evaluate to true for a blob to be returned in the results.
       *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
       *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
       * @param options - Options to find blobs by tags.
       */
      findBlobsByTags(tagFilterSqlExpression, options = {}) {
        const listSegmentOptions = {
          ...options
        };
        const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
        return {
          /**
           * The next method, part of the iteration protocol
           */
          next() {
            return iter.next();
          },
          /**
           * The connection to the async iterator, part of the iteration protocol
           */
          [Symbol.asyncIterator]() {
            return this;
          },
          /**
           * Return an AsyncIterableIterator that works a page at a time
           */
          byPage: (settings = {}) => {
            return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
              maxPageSize: settings.maxPageSize,
              ...listSegmentOptions
            });
          }
        };
      }
      /**
       * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses
       *
       * @param marker - A string value that identifies the portion of
       *                        the list of containers to be returned with the next listing operation. The
       *                        operation returns the continuationToken value within the response body if the
       *                        listing operation did not return all containers remaining to be listed
       *                        with the current page. The continuationToken value can be used as the value for
       *                        the marker parameter in a subsequent call to request the next page of list
       *                        items. The marker value is opaque to the client.
       * @param options - Options to list containers operation.
       */
      async *listSegments(marker, options = {}) {
        let listContainersSegmentResponse;
        if (!!marker || marker === void 0) {
          do {
            listContainersSegmentResponse = await this.listContainersSegment(marker, options);
            listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];
            marker = listContainersSegmentResponse.continuationToken;
            yield await listContainersSegmentResponse;
          } while (marker);
        }
      }
      /**
       * Returns an AsyncIterableIterator for Container Items
       *
       * @param options - Options to list containers operation.
       */
      async *listItems(options = {}) {
        let marker;
        for await (const segment of this.listSegments(marker, options)) {
          yield* segment.containerItems;
        }
      }
      /**
       * Returns an async iterable iterator to list all the containers
       * under the specified account.
       *
       * .byPage() returns an async iterable iterator to list the containers in pages.
       *
       * ```ts snippet:BlobServiceClientListContainers
       * import { BlobServiceClient } from "@azure/storage-blob";
       * import { DefaultAzureCredential } from "@azure/identity";
       *
       * const account = "<account>";
       * const blobServiceClient = new BlobServiceClient(
       *   `https://${account}.blob.core.windows.net`,
       *   new DefaultAzureCredential(),
       * );
       *
       * // Use for await to iterate the containers
       * let i = 1;
       * for await (const container of blobServiceClient.listContainers()) {
       *   console.log(`Container ${i++}: ${container.name}`);
       * }
       *
       * // Use iter.next() to iterate the containers
       * i = 1;
       * const iter = blobServiceClient.listContainers();
       * let { value, done } = await iter.next();
       * while (!done) {
       *   console.log(`Container ${i++}: ${value.name}`);
       *   ({ value, done } = await iter.next());
       * }
       *
       * // Use byPage() to iterate the containers
       * i = 1;
       * for await (const page of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {
       *   for (const container of page.containerItems) {
       *     console.log(`Container ${i++}: ${container.name}`);
       *   }
       * }
       *
       * // Use paging with a marker
       * i = 1;
       * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });
       * let response = (await iterator.next()).value;
       *
       * // Prints 2 container names
       * if (response.containerItems) {
       *   for (const container of response.containerItems) {
       *     console.log(`Container ${i++}: ${container.name}`);
       *   }
       * }
       *
       * // Gets next marker
       * let marker = response.continuationToken;
       * // Passing next marker as continuationToken
       * iterator = blobServiceClient
       *   .listContainers()
       *   .byPage({ continuationToken: marker, maxPageSize: 10 });
       * response = (await iterator.next()).value;
       *
       * // Prints 10 container names
       * if (response.containerItems) {
       *   for (const container of response.containerItems) {
       *     console.log(`Container ${i++}: ${container.name}`);
       *   }
       * }
       * ```
       *
       * @param options - Options to list containers.
       * @returns An asyncIterableIterator that supports paging.
       */
      listContainers(options = {}) {
        if (options.prefix === "") {
          options.prefix = void 0;
        }
        const include = [];
        if (options.includeDeleted) {
          include.push("deleted");
        }
        if (options.includeMetadata) {
          include.push("metadata");
        }
        if (options.includeSystem) {
          include.push("system");
        }
        const listSegmentOptions = {
          ...options,
          ...include.length > 0 ? { include } : {}
        };
        const iter = this.listItems(listSegmentOptions);
        return {
          /**
           * The next method, part of the iteration protocol
           */
          next() {
            return iter.next();
          },
          /**
           * The connection to the async iterator, part of the iteration protocol
           */
          [Symbol.asyncIterator]() {
            return this;
          },
          /**
           * Return an AsyncIterableIterator that works a page at a time
           */
          byPage: (settings = {}) => {
            return this.listSegments(settings.continuationToken, {
              maxPageSize: settings.maxPageSize,
              ...listSegmentOptions
            });
          }
        };
      }
      /**
       * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).
       *
       * Retrieves a user delegation key for the Blob service. This is only a valid operation when using
       * bearer token authentication.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/get-user-delegation-key
       *
       * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time
       * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time
       */
      async getUserDelegationKey(startsOn, expiresOn, options = {}) {
        return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getUserDelegationKey", options, async (updatedOptions) => {
          const response = (0, utils_common_js_2.assertResponse)(await this.serviceContext.getUserDelegationKey({
            startsOn: (0, utils_common_js_2.truncatedISO8061Date)(startsOn, false),
            expiresOn: (0, utils_common_js_2.truncatedISO8061Date)(expiresOn, false)
          }, {
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          }));
          const userDelegationKey = {
            signedObjectId: response.signedObjectId,
            signedTenantId: response.signedTenantId,
            signedStartsOn: new Date(response.signedStartsOn),
            signedExpiresOn: new Date(response.signedExpiresOn),
            signedService: response.signedService,
            signedVersion: response.signedVersion,
            value: response.value
          };
          const res = {
            _response: response._response,
            requestId: response.requestId,
            clientRequestId: response.clientRequestId,
            version: response.version,
            date: response.date,
            errorCode: response.errorCode,
            ...userDelegationKey
          };
          return res;
        });
      }
      /**
       * Creates a BlobBatchClient object to conduct batch operations.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/blob-batch
       *
       * @returns A new BlobBatchClient object for this service.
       */
      getBlobBatchClient() {
        return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
      }
      /**
       * Only available for BlobServiceClient constructed with a shared key credential.
       *
       * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties
       * and parameters passed in. The SAS is signed by the shared key credential of the client.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/create-account-sas
       *
       * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.
       * @param permissions - Specifies the list of permissions to be associated with the SAS.
       * @param resourceTypes - Specifies the resource types associated with the shared access signature.
       * @param options - Optional parameters.
       * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
        if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
          throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
        }
        if (expiresOn === void 0) {
          const now = /* @__PURE__ */ new Date();
          expiresOn = new Date(now.getTime() + 3600 * 1e3);
        }
        const sas = (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParameters)({
          permissions,
          expiresOn,
          resourceTypes,
          services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
          ...options
        }, this.credential).toString();
        return (0, utils_common_js_1.appendToURLQuery)(this.url, sas);
      }
      /**
       * Only available for BlobServiceClient constructed with a shared key credential.
       *
       * Generates string to sign for a Blob account Shared Access Signature (SAS) URI based on
       * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
       *
       * @see https://learn.microsoft.com/rest/api/storageservices/create-account-sas
       *
       * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.
       * @param permissions - Specifies the list of permissions to be associated with the SAS.
       * @param resourceTypes - Specifies the resource types associated with the shared access signature.
       * @param options - Optional parameters.
       * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
       */
      generateSasStringToSign(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
        if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
          throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
        }
        if (expiresOn === void 0) {
          const now = /* @__PURE__ */ new Date();
          expiresOn = new Date(now.getTime() + 3600 * 1e3);
        }
        return (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParametersInternal)({
          permissions,
          expiresOn,
          resourceTypes,
          services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
          ...options
        }, this.credential).stringToSign;
      }
    };
    exports.BlobServiceClient = BlobServiceClient;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BatchResponse.js
var require_BatchResponse = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/BatchResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generatedModels.js
var require_generatedModels = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/generatedModels.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KnownEncryptionAlgorithmType = void 0;
    var KnownEncryptionAlgorithmType;
    (function(KnownEncryptionAlgorithmType2) {
      KnownEncryptionAlgorithmType2["AES256"] = "AES256";
    })(KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/index.js
var require_commonjs15 = __commonJS({
  "node_modules/@azure/storage-blob/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = exports.RestError = exports.BaseRequestPolicy = exports.StorageOAuthScopes = exports.newPipeline = exports.isPipelineLike = exports.Pipeline = exports.getBlobServiceAccountAudience = exports.StorageBlobAudience = exports.PremiumPageBlobTier = exports.BlockBlobTier = exports.generateBlobSASQueryParameters = exports.generateAccountSASQueryParameters = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var core_rest_pipeline_1 = require_commonjs6();
    Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
      return core_rest_pipeline_1.RestError;
    } });
    tslib_1.__exportStar(require_BlobServiceClient(), exports);
    tslib_1.__exportStar(require_Clients(), exports);
    tslib_1.__exportStar(require_ContainerClient(), exports);
    tslib_1.__exportStar(require_BlobLeaseClient(), exports);
    tslib_1.__exportStar(require_AccountSASPermissions(), exports);
    tslib_1.__exportStar(require_AccountSASResourceTypes(), exports);
    tslib_1.__exportStar(require_AccountSASServices(), exports);
    var AccountSASSignatureValues_js_1 = require_AccountSASSignatureValues();
    Object.defineProperty(exports, "generateAccountSASQueryParameters", { enumerable: true, get: function() {
      return AccountSASSignatureValues_js_1.generateAccountSASQueryParameters;
    } });
    tslib_1.__exportStar(require_BlobBatch(), exports);
    tslib_1.__exportStar(require_BlobBatchClient(), exports);
    tslib_1.__exportStar(require_BatchResponse(), exports);
    tslib_1.__exportStar(require_BlobSASPermissions(), exports);
    var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
    Object.defineProperty(exports, "generateBlobSASQueryParameters", { enumerable: true, get: function() {
      return BlobSASSignatureValues_js_1.generateBlobSASQueryParameters;
    } });
    tslib_1.__exportStar(require_StorageBrowserPolicyFactory2(), exports);
    tslib_1.__exportStar(require_ContainerSASPermissions(), exports);
    tslib_1.__exportStar(require_AnonymousCredential(), exports);
    tslib_1.__exportStar(require_Credential(), exports);
    tslib_1.__exportStar(require_StorageSharedKeyCredential(), exports);
    var models_js_1 = require_models2();
    Object.defineProperty(exports, "BlockBlobTier", { enumerable: true, get: function() {
      return models_js_1.BlockBlobTier;
    } });
    Object.defineProperty(exports, "PremiumPageBlobTier", { enumerable: true, get: function() {
      return models_js_1.PremiumPageBlobTier;
    } });
    Object.defineProperty(exports, "StorageBlobAudience", { enumerable: true, get: function() {
      return models_js_1.StorageBlobAudience;
    } });
    Object.defineProperty(exports, "getBlobServiceAccountAudience", { enumerable: true, get: function() {
      return models_js_1.getBlobServiceAccountAudience;
    } });
    var Pipeline_js_1 = require_Pipeline();
    Object.defineProperty(exports, "Pipeline", { enumerable: true, get: function() {
      return Pipeline_js_1.Pipeline;
    } });
    Object.defineProperty(exports, "isPipelineLike", { enumerable: true, get: function() {
      return Pipeline_js_1.isPipelineLike;
    } });
    Object.defineProperty(exports, "newPipeline", { enumerable: true, get: function() {
      return Pipeline_js_1.newPipeline;
    } });
    Object.defineProperty(exports, "StorageOAuthScopes", { enumerable: true, get: function() {
      return Pipeline_js_1.StorageOAuthScopes;
    } });
    tslib_1.__exportStar(require_StorageRetryPolicyFactory(), exports);
    var RequestPolicy_js_1 = require_RequestPolicy();
    Object.defineProperty(exports, "BaseRequestPolicy", { enumerable: true, get: function() {
      return RequestPolicy_js_1.BaseRequestPolicy;
    } });
    tslib_1.__exportStar(require_AnonymousCredentialPolicy(), exports);
    tslib_1.__exportStar(require_CredentialPolicy(), exports);
    tslib_1.__exportStar(require_StorageRetryPolicyFactory(), exports);
    tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicy(), exports);
    tslib_1.__exportStar(require_SASQueryParameters(), exports);
    tslib_1.__exportStar(require_generatedModels(), exports);
    var log_js_1 = require_log5();
    Object.defineProperty(exports, "logger", { enumerable: true, get: function() {
      return log_js_1.logger;
    } });
  }
});

// node_modules/@actions/cache/lib/internal/shared/errors.js
var require_errors3 = __commonJS({
  "node_modules/@actions/cache/lib/internal/shared/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UsageError = exports.NetworkError = exports.GHESNotSupportedError = exports.CacheNotFoundError = exports.InvalidResponseError = exports.FilesNotFoundError = void 0;
    var FilesNotFoundError = class extends Error {
      constructor(files = []) {
        let message = "No files were found to upload";
        if (files.length > 0) {
          message += `: ${files.join(", ")}`;
        }
        super(message);
        this.files = files;
        this.name = "FilesNotFoundError";
      }
    };
    exports.FilesNotFoundError = FilesNotFoundError;
    var InvalidResponseError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidResponseError";
      }
    };
    exports.InvalidResponseError = InvalidResponseError;
    var CacheNotFoundError = class extends Error {
      constructor(message = "Cache not found") {
        super(message);
        this.name = "CacheNotFoundError";
      }
    };
    exports.CacheNotFoundError = CacheNotFoundError;
    var GHESNotSupportedError = class extends Error {
      constructor(message = "@actions/cache v4.1.4+, actions/cache/save@v4+ and actions/cache/restore@v4+ are not currently supported on GHES.") {
        super(message);
        this.name = "GHESNotSupportedError";
      }
    };
    exports.GHESNotSupportedError = GHESNotSupportedError;
    var NetworkError = class extends Error {
      constructor(code) {
        const message = `Unable to make request: ${code}
If you are using self-hosted runners, please make sure your runner has access to all GitHub endpoints: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github`;
        super(message);
        this.code = code;
        this.name = "NetworkError";
      }
    };
    exports.NetworkError = NetworkError;
    NetworkError.isNetworkErrorCode = (code) => {
      if (!code)
        return false;
      return [
        "ECONNRESET",
        "ENOTFOUND",
        "ETIMEDOUT",
        "ECONNREFUSED",
        "EHOSTUNREACH"
      ].includes(code);
    };
    var UsageError = class extends Error {
      constructor() {
        const message = `Cache storage quota has been hit. Unable to upload any new cache entries. Usage is recalculated every 6-12 hours.
More info on storage limits: https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#calculating-minute-and-storage-spending`;
        super(message);
        this.name = "UsageError";
      }
    };
    exports.UsageError = UsageError;
    UsageError.isUsageErrorMessage = (msg) => {
      if (!msg)
        return false;
      return msg.includes("insufficient usage");
    };
  }
});

// node_modules/@actions/cache/lib/internal/uploadUtils.js
var require_uploadUtils = __commonJS({
  "node_modules/@actions/cache/lib/internal/uploadUtils.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uploadCacheArchiveSDK = exports.UploadProgress = void 0;
    var core = __importStar2(require_core());
    var storage_blob_1 = require_commonjs15();
    var errors_1 = require_errors3();
    var UploadProgress = class {
      constructor(contentLength) {
        this.contentLength = contentLength;
        this.sentBytes = 0;
        this.displayedComplete = false;
        this.startTime = Date.now();
      }
      /**
       * Sets the number of bytes sent
       *
       * @param sentBytes the number of bytes sent
       */
      setSentBytes(sentBytes) {
        this.sentBytes = sentBytes;
      }
      /**
       * Returns the total number of bytes transferred.
       */
      getTransferredBytes() {
        return this.sentBytes;
      }
      /**
       * Returns true if the upload is complete.
       */
      isDone() {
        return this.getTransferredBytes() === this.contentLength;
      }
      /**
       * Prints the current upload stats. Once the upload completes, this will print one
       * last line and then stop.
       */
      display() {
        if (this.displayedComplete) {
          return;
        }
        const transferredBytes = this.sentBytes;
        const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
        const elapsedTime = Date.now() - this.startTime;
        const uploadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1e3)).toFixed(1);
        core.info(`Sent ${transferredBytes} of ${this.contentLength} (${percentage}%), ${uploadSpeed} MBs/sec`);
        if (this.isDone()) {
          this.displayedComplete = true;
        }
      }
      /**
       * Returns a function used to handle TransferProgressEvents.
       */
      onProgress() {
        return (progress) => {
          this.setSentBytes(progress.loadedBytes);
        };
      }
      /**
       * Starts the timer that displays the stats.
       *
       * @param delayInMs the delay between each write
       */
      startDisplayTimer(delayInMs = 1e3) {
        const displayCallback = () => {
          this.display();
          if (!this.isDone()) {
            this.timeoutHandle = setTimeout(displayCallback, delayInMs);
          }
        };
        this.timeoutHandle = setTimeout(displayCallback, delayInMs);
      }
      /**
       * Stops the timer that displays the stats. As this typically indicates the upload
       * is complete, this will display one last line, unless the last line has already
       * been written.
       */
      stopDisplayTimer() {
        if (this.timeoutHandle) {
          clearTimeout(this.timeoutHandle);
          this.timeoutHandle = void 0;
        }
        this.display();
      }
    };
    exports.UploadProgress = UploadProgress;
    function uploadCacheArchiveSDK(signedUploadURL, archivePath, options) {
      var _a;
      return __awaiter7(this, void 0, void 0, function* () {
        const blobClient = new storage_blob_1.BlobClient(signedUploadURL);
        const blockBlobClient = blobClient.getBlockBlobClient();
        const uploadProgress = new UploadProgress((_a = options === null || options === void 0 ? void 0 : options.archiveSizeBytes) !== null && _a !== void 0 ? _a : 0);
        const uploadOptions = {
          blockSize: options === null || options === void 0 ? void 0 : options.uploadChunkSize,
          concurrency: options === null || options === void 0 ? void 0 : options.uploadConcurrency,
          maxSingleShotSize: 128 * 1024 * 1024,
          onProgress: uploadProgress.onProgress()
        };
        try {
          uploadProgress.startDisplayTimer();
          core.debug(`BlobClient: ${blobClient.name}:${blobClient.accountName}:${blobClient.containerName}`);
          const response = yield blockBlobClient.uploadFile(archivePath, uploadOptions);
          if (response._response.status >= 400) {
            throw new errors_1.InvalidResponseError(`uploadCacheArchiveSDK: upload failed with status code ${response._response.status}`);
          }
          return response;
        } catch (error2) {
          core.warning(`uploadCacheArchiveSDK: internal error uploading cache archive: ${error2.message}`);
          throw error2;
        } finally {
          uploadProgress.stopDisplayTimer();
        }
      });
    }
    exports.uploadCacheArchiveSDK = uploadCacheArchiveSDK;
  }
});

// node_modules/@actions/cache/lib/internal/requestUtils.js
var require_requestUtils = __commonJS({
  "node_modules/@actions/cache/lib/internal/requestUtils.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retryHttpClientResponse = exports.retryTypedResponse = exports.retry = exports.isRetryableStatusCode = exports.isServerErrorStatusCode = exports.isSuccessStatusCode = void 0;
    var core = __importStar2(require_core());
    var http_client_1 = require_lib();
    var constants_1 = require_constants6();
    function isSuccessStatusCode(statusCode) {
      if (!statusCode) {
        return false;
      }
      return statusCode >= 200 && statusCode < 300;
    }
    exports.isSuccessStatusCode = isSuccessStatusCode;
    function isServerErrorStatusCode(statusCode) {
      if (!statusCode) {
        return true;
      }
      return statusCode >= 500;
    }
    exports.isServerErrorStatusCode = isServerErrorStatusCode;
    function isRetryableStatusCode(statusCode) {
      if (!statusCode) {
        return false;
      }
      const retryableStatusCodes = [
        http_client_1.HttpCodes.BadGateway,
        http_client_1.HttpCodes.ServiceUnavailable,
        http_client_1.HttpCodes.GatewayTimeout
      ];
      return retryableStatusCodes.includes(statusCode);
    }
    exports.isRetryableStatusCode = isRetryableStatusCode;
    function sleep(milliseconds) {
      return __awaiter7(this, void 0, void 0, function* () {
        return new Promise((resolve) => setTimeout(resolve, milliseconds));
      });
    }
    function retry(name, method, getStatusCode, maxAttempts = constants_1.DefaultRetryAttempts, delay3 = constants_1.DefaultRetryDelay, onError = void 0) {
      return __awaiter7(this, void 0, void 0, function* () {
        let errorMessage = "";
        let attempt = 1;
        while (attempt <= maxAttempts) {
          let response = void 0;
          let statusCode = void 0;
          let isRetryable = false;
          try {
            response = yield method();
          } catch (error2) {
            if (onError) {
              response = onError(error2);
            }
            isRetryable = true;
            errorMessage = error2.message;
          }
          if (response) {
            statusCode = getStatusCode(response);
            if (!isServerErrorStatusCode(statusCode)) {
              return response;
            }
          }
          if (statusCode) {
            isRetryable = isRetryableStatusCode(statusCode);
            errorMessage = `Cache service responded with ${statusCode}`;
          }
          core.debug(`${name} - Attempt ${attempt} of ${maxAttempts} failed with error: ${errorMessage}`);
          if (!isRetryable) {
            core.debug(`${name} - Error is not retryable`);
            break;
          }
          yield sleep(delay3);
          attempt++;
        }
        throw Error(`${name} failed: ${errorMessage}`);
      });
    }
    exports.retry = retry;
    function retryTypedResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay3 = constants_1.DefaultRetryDelay) {
      return __awaiter7(this, void 0, void 0, function* () {
        return yield retry(
          name,
          method,
          (response) => response.statusCode,
          maxAttempts,
          delay3,
          // If the error object contains the statusCode property, extract it and return
          // an TypedResponse<T> so it can be processed by the retry logic.
          (error2) => {
            if (error2 instanceof http_client_1.HttpClientError) {
              return {
                statusCode: error2.statusCode,
                result: null,
                headers: {},
                error: error2
              };
            } else {
              return void 0;
            }
          }
        );
      });
    }
    exports.retryTypedResponse = retryTypedResponse;
    function retryHttpClientResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay3 = constants_1.DefaultRetryDelay) {
      return __awaiter7(this, void 0, void 0, function* () {
        return yield retry(name, method, (response) => response.message.statusCode, maxAttempts, delay3);
      });
    }
    exports.retryHttpClientResponse = retryHttpClientResponse;
  }
});

// node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js
function abortSignal(signal) {
  if (signal.aborted) {
    return;
  }
  if (signal.onabort) {
    signal.onabort.call(signal);
  }
  const listeners = listenersMap.get(signal);
  if (listeners) {
    listeners.slice().forEach((listener) => {
      listener.call(signal, { type: "abort" });
    });
  }
  abortedMap.set(signal, true);
}
var listenersMap, abortedMap, AbortSignal2;
var init_AbortSignal = __esm({
  "node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js"() {
    "use strict";
    listenersMap = /* @__PURE__ */ new WeakMap();
    abortedMap = /* @__PURE__ */ new WeakMap();
    AbortSignal2 = class _AbortSignal {
      constructor() {
        this.onabort = null;
        listenersMap.set(this, []);
        abortedMap.set(this, false);
      }
      /**
       * Status of whether aborted or not.
       *
       * @readonly
       */
      get aborted() {
        if (!abortedMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        return abortedMap.get(this);
      }
      /**
       * Creates a new AbortSignal instance that will never be aborted.
       *
       * @readonly
       */
      static get none() {
        return new _AbortSignal();
      }
      /**
       * Added new "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be added
       */
      addEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        listeners.push(listener);
      }
      /**
       * Remove "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be removed
       */
      removeEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
      /**
       * Dispatches a synthetic event to the AbortSignal.
       */
      dispatchEvent(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
      }
    };
  }
});

// node_modules/@azure/abort-controller/dist-esm/src/AbortController.js
var AbortError2, AbortController2;
var init_AbortController = __esm({
  "node_modules/@azure/abort-controller/dist-esm/src/AbortController.js"() {
    "use strict";
    init_AbortSignal();
    AbortError2 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    AbortController2 = class {
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      constructor(parentSignals) {
        this._signal = new AbortSignal2();
        if (!parentSignals) {
          return;
        }
        if (!Array.isArray(parentSignals)) {
          parentSignals = arguments;
        }
        for (const parentSignal of parentSignals) {
          if (parentSignal.aborted) {
            this.abort();
          } else {
            parentSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
      }
      /**
       * The AbortSignal associated with this controller that will signal aborted
       * when the abort method is called on this controller.
       *
       * @readonly
       */
      get signal() {
        return this._signal;
      }
      /**
       * Signal that any operations passed this controller's associated abort signal
       * to cancel any remaining work and throw an `AbortError`.
       */
      abort() {
        abortSignal(this._signal);
      }
      /**
       * Creates a new AbortSignal instance that will abort after the provided ms.
       * @param ms - Elapsed time in milliseconds to trigger an abort.
       */
      static timeout(ms) {
        const signal = new AbortSignal2();
        const timer2 = setTimeout(abortSignal, ms, signal);
        if (typeof timer2.unref === "function") {
          timer2.unref();
        }
        return signal;
      }
    };
  }
});

// node_modules/@azure/abort-controller/dist-esm/src/index.js
var src_exports = {};
__export(src_exports, {
  AbortController: () => AbortController2,
  AbortError: () => AbortError2,
  AbortSignal: () => AbortSignal2
});
var init_src = __esm({
  "node_modules/@azure/abort-controller/dist-esm/src/index.js"() {
    "use strict";
    init_AbortController();
    init_AbortSignal();
  }
});

// node_modules/@actions/cache/lib/internal/downloadUtils.js
var require_downloadUtils = __commonJS({
  "node_modules/@actions/cache/lib/internal/downloadUtils.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.downloadCacheStorageSDK = exports.downloadCacheHttpClientConcurrent = exports.downloadCacheHttpClient = exports.DownloadProgress = void 0;
    var core = __importStar2(require_core());
    var http_client_1 = require_lib();
    var storage_blob_1 = require_commonjs15();
    var buffer = __importStar2(__require("buffer"));
    var fs2 = __importStar2(__require("fs"));
    var stream2 = __importStar2(__require("stream"));
    var util = __importStar2(__require("util"));
    var utils = __importStar2(require_cacheUtils());
    var constants_1 = require_constants6();
    var requestUtils_1 = require_requestUtils();
    var abort_controller_1 = (init_src(), __toCommonJS(src_exports));
    function pipeResponseToStream(response, output) {
      return __awaiter7(this, void 0, void 0, function* () {
        const pipeline = util.promisify(stream2.pipeline);
        yield pipeline(response.message, output);
      });
    }
    var DownloadProgress = class {
      constructor(contentLength) {
        this.contentLength = contentLength;
        this.segmentIndex = 0;
        this.segmentSize = 0;
        this.segmentOffset = 0;
        this.receivedBytes = 0;
        this.displayedComplete = false;
        this.startTime = Date.now();
      }
      /**
       * Progress to the next segment. Only call this method when the previous segment
       * is complete.
       *
       * @param segmentSize the length of the next segment
       */
      nextSegment(segmentSize) {
        this.segmentOffset = this.segmentOffset + this.segmentSize;
        this.segmentIndex = this.segmentIndex + 1;
        this.segmentSize = segmentSize;
        this.receivedBytes = 0;
        core.debug(`Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`);
      }
      /**
       * Sets the number of bytes received for the current segment.
       *
       * @param receivedBytes the number of bytes received
       */
      setReceivedBytes(receivedBytes) {
        this.receivedBytes = receivedBytes;
      }
      /**
       * Returns the total number of bytes transferred.
       */
      getTransferredBytes() {
        return this.segmentOffset + this.receivedBytes;
      }
      /**
       * Returns true if the download is complete.
       */
      isDone() {
        return this.getTransferredBytes() === this.contentLength;
      }
      /**
       * Prints the current download stats. Once the download completes, this will print one
       * last line and then stop.
       */
      display() {
        if (this.displayedComplete) {
          return;
        }
        const transferredBytes = this.segmentOffset + this.receivedBytes;
        const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
        const elapsedTime = Date.now() - this.startTime;
        const downloadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1e3)).toFixed(1);
        core.info(`Received ${transferredBytes} of ${this.contentLength} (${percentage}%), ${downloadSpeed} MBs/sec`);
        if (this.isDone()) {
          this.displayedComplete = true;
        }
      }
      /**
       * Returns a function used to handle TransferProgressEvents.
       */
      onProgress() {
        return (progress) => {
          this.setReceivedBytes(progress.loadedBytes);
        };
      }
      /**
       * Starts the timer that displays the stats.
       *
       * @param delayInMs the delay between each write
       */
      startDisplayTimer(delayInMs = 1e3) {
        const displayCallback = () => {
          this.display();
          if (!this.isDone()) {
            this.timeoutHandle = setTimeout(displayCallback, delayInMs);
          }
        };
        this.timeoutHandle = setTimeout(displayCallback, delayInMs);
      }
      /**
       * Stops the timer that displays the stats. As this typically indicates the download
       * is complete, this will display one last line, unless the last line has already
       * been written.
       */
      stopDisplayTimer() {
        if (this.timeoutHandle) {
          clearTimeout(this.timeoutHandle);
          this.timeoutHandle = void 0;
        }
        this.display();
      }
    };
    exports.DownloadProgress = DownloadProgress;
    function downloadCacheHttpClient(archiveLocation, archivePath) {
      return __awaiter7(this, void 0, void 0, function* () {
        const writeStream = fs2.createWriteStream(archivePath);
        const httpClient = new http_client_1.HttpClient("actions/cache");
        const downloadResponse = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCache", () => __awaiter7(this, void 0, void 0, function* () {
          return httpClient.get(archiveLocation);
        }));
        downloadResponse.message.socket.setTimeout(constants_1.SocketTimeout, () => {
          downloadResponse.message.destroy();
          core.debug(`Aborting download, socket timed out after ${constants_1.SocketTimeout} ms`);
        });
        yield pipeResponseToStream(downloadResponse, writeStream);
        const contentLengthHeader = downloadResponse.message.headers["content-length"];
        if (contentLengthHeader) {
          const expectedLength = parseInt(contentLengthHeader);
          const actualLength = utils.getArchiveFileSizeInBytes(archivePath);
          if (actualLength !== expectedLength) {
            throw new Error(`Incomplete download. Expected file size: ${expectedLength}, actual file size: ${actualLength}`);
          }
        } else {
          core.debug("Unable to validate download, no Content-Length header");
        }
      });
    }
    exports.downloadCacheHttpClient = downloadCacheHttpClient;
    function downloadCacheHttpClientConcurrent(archiveLocation, archivePath, options) {
      var _a;
      return __awaiter7(this, void 0, void 0, function* () {
        const archiveDescriptor = yield fs2.promises.open(archivePath, "w");
        const httpClient = new http_client_1.HttpClient("actions/cache", void 0, {
          socketTimeout: options.timeoutInMs,
          keepAlive: true
        });
        try {
          const res = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCacheMetadata", () => __awaiter7(this, void 0, void 0, function* () {
            return yield httpClient.request("HEAD", archiveLocation, null, {});
          }));
          const lengthHeader = res.message.headers["content-length"];
          if (lengthHeader === void 0 || lengthHeader === null) {
            throw new Error("Content-Length not found on blob response");
          }
          const length = parseInt(lengthHeader);
          if (Number.isNaN(length)) {
            throw new Error(`Could not interpret Content-Length: ${length}`);
          }
          const downloads = [];
          const blockSize = 4 * 1024 * 1024;
          for (let offset = 0; offset < length; offset += blockSize) {
            const count = Math.min(blockSize, length - offset);
            downloads.push({
              offset,
              promiseGetter: () => __awaiter7(this, void 0, void 0, function* () {
                return yield downloadSegmentRetry(httpClient, archiveLocation, offset, count);
              })
            });
          }
          downloads.reverse();
          let actives = 0;
          let bytesDownloaded = 0;
          const progress = new DownloadProgress(length);
          progress.startDisplayTimer();
          const progressFn = progress.onProgress();
          const activeDownloads = [];
          let nextDownload;
          const waitAndWrite = () => __awaiter7(this, void 0, void 0, function* () {
            const segment = yield Promise.race(Object.values(activeDownloads));
            yield archiveDescriptor.write(segment.buffer, 0, segment.count, segment.offset);
            actives--;
            delete activeDownloads[segment.offset];
            bytesDownloaded += segment.count;
            progressFn({ loadedBytes: bytesDownloaded });
          });
          while (nextDownload = downloads.pop()) {
            activeDownloads[nextDownload.offset] = nextDownload.promiseGetter();
            actives++;
            if (actives >= ((_a = options.downloadConcurrency) !== null && _a !== void 0 ? _a : 10)) {
              yield waitAndWrite();
            }
          }
          while (actives > 0) {
            yield waitAndWrite();
          }
        } finally {
          httpClient.dispose();
          yield archiveDescriptor.close();
        }
      });
    }
    exports.downloadCacheHttpClientConcurrent = downloadCacheHttpClientConcurrent;
    function downloadSegmentRetry(httpClient, archiveLocation, offset, count) {
      return __awaiter7(this, void 0, void 0, function* () {
        const retries = 5;
        let failures = 0;
        while (true) {
          try {
            const timeout = 3e4;
            const result = yield promiseWithTimeout(timeout, downloadSegment(httpClient, archiveLocation, offset, count));
            if (typeof result === "string") {
              throw new Error("downloadSegmentRetry failed due to timeout");
            }
            return result;
          } catch (err) {
            if (failures >= retries) {
              throw err;
            }
            failures++;
          }
        }
      });
    }
    function downloadSegment(httpClient, archiveLocation, offset, count) {
      return __awaiter7(this, void 0, void 0, function* () {
        const partRes = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCachePart", () => __awaiter7(this, void 0, void 0, function* () {
          return yield httpClient.get(archiveLocation, {
            Range: `bytes=${offset}-${offset + count - 1}`
          });
        }));
        if (!partRes.readBodyBuffer) {
          throw new Error("Expected HttpClientResponse to implement readBodyBuffer");
        }
        return {
          offset,
          count,
          buffer: yield partRes.readBodyBuffer()
        };
      });
    }
    function downloadCacheStorageSDK(archiveLocation, archivePath, options) {
      var _a;
      return __awaiter7(this, void 0, void 0, function* () {
        const client = new storage_blob_1.BlockBlobClient(archiveLocation, void 0, {
          retryOptions: {
            // Override the timeout used when downloading each 4 MB chunk
            // The default is 2 min / MB, which is way too slow
            tryTimeoutInMs: options.timeoutInMs
          }
        });
        const properties = yield client.getProperties();
        const contentLength = (_a = properties.contentLength) !== null && _a !== void 0 ? _a : -1;
        if (contentLength < 0) {
          core.debug("Unable to determine content length, downloading file with http-client...");
          yield downloadCacheHttpClient(archiveLocation, archivePath);
        } else {
          const maxSegmentSize = Math.min(134217728, buffer.constants.MAX_LENGTH);
          const downloadProgress = new DownloadProgress(contentLength);
          const fd = fs2.openSync(archivePath, "w");
          try {
            downloadProgress.startDisplayTimer();
            const controller = new abort_controller_1.AbortController();
            const abortSignal2 = controller.signal;
            while (!downloadProgress.isDone()) {
              const segmentStart = downloadProgress.segmentOffset + downloadProgress.segmentSize;
              const segmentSize = Math.min(maxSegmentSize, contentLength - segmentStart);
              downloadProgress.nextSegment(segmentSize);
              const result = yield promiseWithTimeout(options.segmentTimeoutInMs || 36e5, client.downloadToBuffer(segmentStart, segmentSize, {
                abortSignal: abortSignal2,
                concurrency: options.downloadConcurrency,
                onProgress: downloadProgress.onProgress()
              }));
              if (result === "timeout") {
                controller.abort();
                throw new Error("Aborting cache download as the download time exceeded the timeout.");
              } else if (Buffer.isBuffer(result)) {
                fs2.writeFileSync(fd, result);
              }
            }
          } finally {
            downloadProgress.stopDisplayTimer();
            fs2.closeSync(fd);
          }
        }
      });
    }
    exports.downloadCacheStorageSDK = downloadCacheStorageSDK;
    var promiseWithTimeout = (timeoutMs, promise) => __awaiter7(void 0, void 0, void 0, function* () {
      let timeoutHandle;
      const timeoutPromise = new Promise((resolve) => {
        timeoutHandle = setTimeout(() => resolve("timeout"), timeoutMs);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
      });
    });
  }
});

// node_modules/@actions/cache/lib/options.js
var require_options = __commonJS({
  "node_modules/@actions/cache/lib/options.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDownloadOptions = exports.getUploadOptions = void 0;
    var core = __importStar2(require_core());
    function getUploadOptions(copy2) {
      const result = {
        useAzureSdk: false,
        uploadConcurrency: 4,
        uploadChunkSize: 32 * 1024 * 1024
      };
      if (copy2) {
        if (typeof copy2.useAzureSdk === "boolean") {
          result.useAzureSdk = copy2.useAzureSdk;
        }
        if (typeof copy2.uploadConcurrency === "number") {
          result.uploadConcurrency = copy2.uploadConcurrency;
        }
        if (typeof copy2.uploadChunkSize === "number") {
          result.uploadChunkSize = copy2.uploadChunkSize;
        }
      }
      result.uploadConcurrency = !isNaN(Number(process.env["CACHE_UPLOAD_CONCURRENCY"])) ? Math.min(32, Number(process.env["CACHE_UPLOAD_CONCURRENCY"])) : result.uploadConcurrency;
      result.uploadChunkSize = !isNaN(Number(process.env["CACHE_UPLOAD_CHUNK_SIZE"])) ? Math.min(128 * 1024 * 1024, Number(process.env["CACHE_UPLOAD_CHUNK_SIZE"]) * 1024 * 1024) : result.uploadChunkSize;
      core.debug(`Use Azure SDK: ${result.useAzureSdk}`);
      core.debug(`Upload concurrency: ${result.uploadConcurrency}`);
      core.debug(`Upload chunk size: ${result.uploadChunkSize}`);
      return result;
    }
    exports.getUploadOptions = getUploadOptions;
    function getDownloadOptions(copy2) {
      const result = {
        useAzureSdk: false,
        concurrentBlobDownloads: true,
        downloadConcurrency: 8,
        timeoutInMs: 3e4,
        segmentTimeoutInMs: 6e5,
        lookupOnly: false
      };
      if (copy2) {
        if (typeof copy2.useAzureSdk === "boolean") {
          result.useAzureSdk = copy2.useAzureSdk;
        }
        if (typeof copy2.concurrentBlobDownloads === "boolean") {
          result.concurrentBlobDownloads = copy2.concurrentBlobDownloads;
        }
        if (typeof copy2.downloadConcurrency === "number") {
          result.downloadConcurrency = copy2.downloadConcurrency;
        }
        if (typeof copy2.timeoutInMs === "number") {
          result.timeoutInMs = copy2.timeoutInMs;
        }
        if (typeof copy2.segmentTimeoutInMs === "number") {
          result.segmentTimeoutInMs = copy2.segmentTimeoutInMs;
        }
        if (typeof copy2.lookupOnly === "boolean") {
          result.lookupOnly = copy2.lookupOnly;
        }
      }
      const segmentDownloadTimeoutMins = process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"];
      if (segmentDownloadTimeoutMins && !isNaN(Number(segmentDownloadTimeoutMins)) && isFinite(Number(segmentDownloadTimeoutMins))) {
        result.segmentTimeoutInMs = Number(segmentDownloadTimeoutMins) * 60 * 1e3;
      }
      core.debug(`Use Azure SDK: ${result.useAzureSdk}`);
      core.debug(`Download concurrency: ${result.downloadConcurrency}`);
      core.debug(`Request timeout (ms): ${result.timeoutInMs}`);
      core.debug(`Cache segment download timeout mins env var: ${process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"]}`);
      core.debug(`Segment download timeout (ms): ${result.segmentTimeoutInMs}`);
      core.debug(`Lookup only: ${result.lookupOnly}`);
      return result;
    }
    exports.getDownloadOptions = getDownloadOptions;
  }
});

// node_modules/@actions/cache/lib/internal/config.js
var require_config = __commonJS({
  "node_modules/@actions/cache/lib/internal/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCacheServiceURL = exports.getCacheServiceVersion = exports.isGhes = void 0;
    function isGhes() {
      const ghUrl = new URL(process.env["GITHUB_SERVER_URL"] || "https://github.com");
      const hostname2 = ghUrl.hostname.trimEnd().toUpperCase();
      const isGitHubHost = hostname2 === "GITHUB.COM";
      const isGheHost = hostname2.endsWith(".GHE.COM");
      const isLocalHost = hostname2.endsWith(".LOCALHOST");
      return !isGitHubHost && !isGheHost && !isLocalHost;
    }
    exports.isGhes = isGhes;
    function getCacheServiceVersion() {
      if (isGhes())
        return "v1";
      return process.env["ACTIONS_CACHE_SERVICE_V2"] ? "v2" : "v1";
    }
    exports.getCacheServiceVersion = getCacheServiceVersion;
    function getCacheServiceURL() {
      const version = getCacheServiceVersion();
      switch (version) {
        case "v1":
          return process.env["ACTIONS_CACHE_URL"] || process.env["ACTIONS_RESULTS_URL"] || "";
        case "v2":
          return process.env["ACTIONS_RESULTS_URL"] || "";
        default:
          throw new Error(`Unsupported cache service version: ${version}`);
      }
    }
    exports.getCacheServiceURL = getCacheServiceURL;
  }
});

// node_modules/@actions/cache/package.json
var require_package = __commonJS({
  "node_modules/@actions/cache/package.json"(exports, module) {
    module.exports = {
      name: "@actions/cache",
      version: "4.1.0",
      preview: true,
      description: "Actions cache lib",
      keywords: [
        "github",
        "actions",
        "cache"
      ],
      homepage: "https://github.com/actions/toolkit/tree/main/packages/cache",
      license: "MIT",
      main: "lib/cache.js",
      types: "lib/cache.d.ts",
      directories: {
        lib: "lib",
        test: "__tests__"
      },
      files: [
        "lib",
        "!.DS_Store"
      ],
      publishConfig: {
        access: "public"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/actions/toolkit.git",
        directory: "packages/cache"
      },
      scripts: {
        "audit-moderate": "npm install && npm audit --json --audit-level=moderate > audit.json",
        test: 'echo "Error: run tests from root" && exit 1',
        tsc: "tsc"
      },
      bugs: {
        url: "https://github.com/actions/toolkit/issues"
      },
      dependencies: {
        "@actions/core": "^1.11.1",
        "@actions/exec": "^1.0.1",
        "@actions/glob": "^0.1.0",
        "@protobuf-ts/runtime-rpc": "^2.11.1",
        "@actions/http-client": "^2.1.1",
        "@actions/io": "^1.0.1",
        "@azure/abort-controller": "^1.1.0",
        "@azure/ms-rest-js": "^2.6.0",
        "@azure/storage-blob": "^12.13.0",
        semver: "^6.3.1"
      },
      devDependencies: {
        "@types/node": "^22.13.9",
        "@types/semver": "^6.0.0",
        "@protobuf-ts/plugin": "^2.9.4",
        typescript: "^5.2.2"
      }
    };
  }
});

// node_modules/@actions/cache/lib/internal/shared/user-agent.js
var require_user_agent = __commonJS({
  "node_modules/@actions/cache/lib/internal/shared/user-agent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUserAgentString = void 0;
    var packageJson = require_package();
    function getUserAgentString() {
      return `@actions/cache-${packageJson.version}`;
    }
    exports.getUserAgentString = getUserAgentString;
  }
});

// node_modules/@actions/cache/lib/internal/cacheHttpClient.js
var require_cacheHttpClient = __commonJS({
  "node_modules/@actions/cache/lib/internal/cacheHttpClient.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.saveCache = exports.reserveCache = exports.downloadCache = exports.getCacheEntry = void 0;
    var core = __importStar2(require_core());
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var fs2 = __importStar2(__require("fs"));
    var url_1 = __require("url");
    var utils = __importStar2(require_cacheUtils());
    var uploadUtils_1 = require_uploadUtils();
    var downloadUtils_1 = require_downloadUtils();
    var options_1 = require_options();
    var requestUtils_1 = require_requestUtils();
    var config_1 = require_config();
    var user_agent_1 = require_user_agent();
    function getCacheApiUrl(resource) {
      const baseUrl = (0, config_1.getCacheServiceURL)();
      if (!baseUrl) {
        throw new Error("Cache Service Url not found, unable to restore cache.");
      }
      const url = `${baseUrl}_apis/artifactcache/${resource}`;
      core.debug(`Resource Url: ${url}`);
      return url;
    }
    function createAcceptHeader(type2, apiVersion) {
      return `${type2};api-version=${apiVersion}`;
    }
    function getRequestOptions() {
      const requestOptions = {
        headers: {
          Accept: createAcceptHeader("application/json", "6.0-preview.1")
        }
      };
      return requestOptions;
    }
    function createHttpClient() {
      const token = process.env["ACTIONS_RUNTIME_TOKEN"] || "";
      const bearerCredentialHandler = new auth_1.BearerCredentialHandler(token);
      return new http_client_1.HttpClient((0, user_agent_1.getUserAgentString)(), [bearerCredentialHandler], getRequestOptions());
    }
    function getCacheEntry(keys, paths, options) {
      return __awaiter7(this, void 0, void 0, function* () {
        const httpClient = createHttpClient();
        const version = utils.getCacheVersion(paths, options === null || options === void 0 ? void 0 : options.compressionMethod, options === null || options === void 0 ? void 0 : options.enableCrossOsArchive);
        const resource = `cache?keys=${encodeURIComponent(keys.join(","))}&version=${version}`;
        const response = yield (0, requestUtils_1.retryTypedResponse)("getCacheEntry", () => __awaiter7(this, void 0, void 0, function* () {
          return httpClient.getJson(getCacheApiUrl(resource));
        }));
        if (response.statusCode === 204) {
          if (core.isDebug()) {
            yield printCachesListForDiagnostics(keys[0], httpClient, version);
          }
          return null;
        }
        if (!(0, requestUtils_1.isSuccessStatusCode)(response.statusCode)) {
          throw new Error(`Cache service responded with ${response.statusCode}`);
        }
        const cacheResult = response.result;
        const cacheDownloadUrl = cacheResult === null || cacheResult === void 0 ? void 0 : cacheResult.archiveLocation;
        if (!cacheDownloadUrl) {
          throw new Error("Cache not found.");
        }
        core.setSecret(cacheDownloadUrl);
        core.debug(`Cache Result:`);
        core.debug(JSON.stringify(cacheResult));
        return cacheResult;
      });
    }
    exports.getCacheEntry = getCacheEntry;
    function printCachesListForDiagnostics(key, httpClient, version) {
      return __awaiter7(this, void 0, void 0, function* () {
        const resource = `caches?key=${encodeURIComponent(key)}`;
        const response = yield (0, requestUtils_1.retryTypedResponse)("listCache", () => __awaiter7(this, void 0, void 0, function* () {
          return httpClient.getJson(getCacheApiUrl(resource));
        }));
        if (response.statusCode === 200) {
          const cacheListResult = response.result;
          const totalCount = cacheListResult === null || cacheListResult === void 0 ? void 0 : cacheListResult.totalCount;
          if (totalCount && totalCount > 0) {
            core.debug(`No matching cache found for cache key '${key}', version '${version} and scope ${process.env["GITHUB_REF"]}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key 
Other caches with similar key:`);
            for (const cacheEntry of (cacheListResult === null || cacheListResult === void 0 ? void 0 : cacheListResult.artifactCaches) || []) {
              core.debug(`Cache Key: ${cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.cacheKey}, Cache Version: ${cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.cacheVersion}, Cache Scope: ${cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.scope}, Cache Created: ${cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.creationTime}`);
            }
          }
        }
      });
    }
    function downloadCache(archiveLocation, archivePath, options) {
      return __awaiter7(this, void 0, void 0, function* () {
        const archiveUrl = new url_1.URL(archiveLocation);
        const downloadOptions = (0, options_1.getDownloadOptions)(options);
        if (archiveUrl.hostname.endsWith(".blob.core.windows.net")) {
          if (downloadOptions.useAzureSdk) {
            yield (0, downloadUtils_1.downloadCacheStorageSDK)(archiveLocation, archivePath, downloadOptions);
          } else if (downloadOptions.concurrentBlobDownloads) {
            yield (0, downloadUtils_1.downloadCacheHttpClientConcurrent)(archiveLocation, archivePath, downloadOptions);
          } else {
            yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
          }
        } else {
          yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
        }
      });
    }
    exports.downloadCache = downloadCache;
    function reserveCache(key, paths, options) {
      return __awaiter7(this, void 0, void 0, function* () {
        const httpClient = createHttpClient();
        const version = utils.getCacheVersion(paths, options === null || options === void 0 ? void 0 : options.compressionMethod, options === null || options === void 0 ? void 0 : options.enableCrossOsArchive);
        const reserveCacheRequest = {
          key,
          version,
          cacheSize: options === null || options === void 0 ? void 0 : options.cacheSize
        };
        const response = yield (0, requestUtils_1.retryTypedResponse)("reserveCache", () => __awaiter7(this, void 0, void 0, function* () {
          return httpClient.postJson(getCacheApiUrl("caches"), reserveCacheRequest);
        }));
        return response;
      });
    }
    exports.reserveCache = reserveCache;
    function getContentRange(start, end) {
      return `bytes ${start}-${end}/*`;
    }
    function uploadChunk(httpClient, resourceUrl, openStream, start, end) {
      return __awaiter7(this, void 0, void 0, function* () {
        core.debug(`Uploading chunk of size ${end - start + 1} bytes at offset ${start} with content range: ${getContentRange(start, end)}`);
        const additionalHeaders = {
          "Content-Type": "application/octet-stream",
          "Content-Range": getContentRange(start, end)
        };
        const uploadChunkResponse = yield (0, requestUtils_1.retryHttpClientResponse)(`uploadChunk (start: ${start}, end: ${end})`, () => __awaiter7(this, void 0, void 0, function* () {
          return httpClient.sendStream("PATCH", resourceUrl, openStream(), additionalHeaders);
        }));
        if (!(0, requestUtils_1.isSuccessStatusCode)(uploadChunkResponse.message.statusCode)) {
          throw new Error(`Cache service responded with ${uploadChunkResponse.message.statusCode} during upload chunk.`);
        }
      });
    }
    function uploadFile(httpClient, cacheId, archivePath, options) {
      return __awaiter7(this, void 0, void 0, function* () {
        const fileSize = utils.getArchiveFileSizeInBytes(archivePath);
        const resourceUrl = getCacheApiUrl(`caches/${cacheId.toString()}`);
        const fd = fs2.openSync(archivePath, "r");
        const uploadOptions = (0, options_1.getUploadOptions)(options);
        const concurrency = utils.assertDefined("uploadConcurrency", uploadOptions.uploadConcurrency);
        const maxChunkSize = utils.assertDefined("uploadChunkSize", uploadOptions.uploadChunkSize);
        const parallelUploads = [...new Array(concurrency).keys()];
        core.debug("Awaiting all uploads");
        let offset = 0;
        try {
          yield Promise.all(parallelUploads.map(() => __awaiter7(this, void 0, void 0, function* () {
            while (offset < fileSize) {
              const chunkSize = Math.min(fileSize - offset, maxChunkSize);
              const start = offset;
              const end = offset + chunkSize - 1;
              offset += maxChunkSize;
              yield uploadChunk(httpClient, resourceUrl, () => fs2.createReadStream(archivePath, {
                fd,
                start,
                end,
                autoClose: false
              }).on("error", (error2) => {
                throw new Error(`Cache upload failed because file read failed with ${error2.message}`);
              }), start, end);
            }
          })));
        } finally {
          fs2.closeSync(fd);
        }
        return;
      });
    }
    function commitCache(httpClient, cacheId, filesize) {
      return __awaiter7(this, void 0, void 0, function* () {
        const commitCacheRequest = { size: filesize };
        return yield (0, requestUtils_1.retryTypedResponse)("commitCache", () => __awaiter7(this, void 0, void 0, function* () {
          return httpClient.postJson(getCacheApiUrl(`caches/${cacheId.toString()}`), commitCacheRequest);
        }));
      });
    }
    function saveCache2(cacheId, archivePath, signedUploadURL, options) {
      return __awaiter7(this, void 0, void 0, function* () {
        const uploadOptions = (0, options_1.getUploadOptions)(options);
        if (uploadOptions.useAzureSdk) {
          if (!signedUploadURL) {
            throw new Error("Azure Storage SDK can only be used when a signed URL is provided.");
          }
          yield (0, uploadUtils_1.uploadCacheArchiveSDK)(signedUploadURL, archivePath, options);
        } else {
          const httpClient = createHttpClient();
          core.debug("Upload cache");
          yield uploadFile(httpClient, cacheId, archivePath, options);
          core.debug("Commiting cache");
          const cacheSize = utils.getArchiveFileSizeInBytes(archivePath);
          core.info(`Cache Size: ~${Math.round(cacheSize / (1024 * 1024))} MB (${cacheSize} B)`);
          const commitCacheResponse = yield commitCache(httpClient, cacheId, cacheSize);
          if (!(0, requestUtils_1.isSuccessStatusCode)(commitCacheResponse.statusCode)) {
            throw new Error(`Cache service responded with ${commitCacheResponse.statusCode} during commit cache.`);
          }
          core.info("Cache saved successfully");
        }
      });
    }
    exports.saveCache = saveCache2;
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js
function typeofJsonValue(value) {
  let t = typeof value;
  if (t == "object") {
    if (Array.isArray(value))
      return "array";
    if (value === null)
      return "null";
  }
  return t;
}
function isJsonObject(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}
var init_json_typings = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js"() {
    "use strict";
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/base64.js
function base64decode(base64Str) {
  let es = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es -= 1;
  let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
  for (let i2 = 0; i2 < base64Str.length; i2++) {
    b = decTable[base64Str.charCodeAt(i2)];
    if (b === void 0) {
      switch (base64Str[i2]) {
        case "=":
          groupPos = 0;
        // reset state when padding found
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error(`invalid base64 string.`);
      }
    }
    switch (groupPos) {
      case 0:
        p = b;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p << 2 | (b & 48) >> 4;
        p = b;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
        p = b;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p & 3) << 6 | b;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error(`invalid base64 string.`);
  return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
  let base64 = "", groupPos = 0, b, p = 0;
  for (let i2 = 0; i2 < bytes.length; i2++) {
    b = bytes[i2];
    switch (groupPos) {
      case 0:
        base64 += encTable[b >> 2];
        p = (b & 3) << 4;
        groupPos = 1;
        break;
      case 1:
        base64 += encTable[p | b >> 4];
        p = (b & 15) << 2;
        groupPos = 2;
        break;
      case 2:
        base64 += encTable[p | b >> 6];
        base64 += encTable[b & 63];
        groupPos = 0;
        break;
    }
  }
  if (groupPos) {
    base64 += encTable[p];
    base64 += "=";
    if (groupPos == 1)
      base64 += "=";
  }
  return base64;
}
var encTable, decTable;
var init_base64 = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/base64.js"() {
    "use strict";
    encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    decTable = [];
    for (let i2 = 0; i2 < encTable.length; i2++)
      decTable[encTable[i2].charCodeAt(0)] = i2;
    decTable["-".charCodeAt(0)] = encTable.indexOf("+");
    decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/protobufjs-utf8.js
function utf8read(bytes) {
  if (bytes.length < 1)
    return "";
  let pos = 0, parts = [], chunk2 = [], i2 = 0, t;
  let len = bytes.length;
  while (pos < len) {
    t = bytes[pos++];
    if (t < 128)
      chunk2[i2++] = t;
    else if (t > 191 && t < 224)
      chunk2[i2++] = (t & 31) << 6 | bytes[pos++] & 63;
    else if (t > 239 && t < 365) {
      t = ((t & 7) << 18 | (bytes[pos++] & 63) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63) - 65536;
      chunk2[i2++] = 55296 + (t >> 10);
      chunk2[i2++] = 56320 + (t & 1023);
    } else
      chunk2[i2++] = (t & 15) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63;
    if (i2 > 8191) {
      parts.push(fromCharCodes(chunk2));
      i2 = 0;
    }
  }
  if (parts.length) {
    if (i2)
      parts.push(fromCharCodes(chunk2.slice(0, i2)));
    return parts.join("");
  }
  return fromCharCodes(chunk2.slice(0, i2));
}
var fromCharCodes;
var init_protobufjs_utf8 = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/protobufjs-utf8.js"() {
    "use strict";
    fromCharCodes = (chunk2) => String.fromCharCode.apply(String, chunk2);
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js
function mergeBinaryOptions(a2, b) {
  return Object.assign(Object.assign({}, a2), b);
}
var UnknownFieldHandler, WireType;
var init_binary_format_contract = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js"() {
    "use strict";
    (function(UnknownFieldHandler2) {
      UnknownFieldHandler2.symbol = /* @__PURE__ */ Symbol.for("protobuf-ts/unknown");
      UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
        let container = is2(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
        container.push({ no: fieldNo, wireType, data });
      };
      UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
        for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
          writer.tag(no, wireType).raw(data);
      };
      UnknownFieldHandler2.list = (message, fieldNo) => {
        if (is2(message)) {
          let all2 = message[UnknownFieldHandler2.symbol];
          return fieldNo ? all2.filter((uf) => uf.no == fieldNo) : all2;
        }
        return [];
      };
      UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
      const is2 = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
    })(UnknownFieldHandler || (UnknownFieldHandler = {}));
    (function(WireType2) {
      WireType2[WireType2["Varint"] = 0] = "Varint";
      WireType2[WireType2["Bit64"] = 1] = "Bit64";
      WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
      WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
      WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
      WireType2[WireType2["Bit32"] = 5] = "Bit32";
    })(WireType || (WireType = {}));
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i2 = 0; i2 < 28; i2 = i2 + 7) {
    const shift = lo >>> i2;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i2 = 3; i2 < 31; i2 = i2 + 7) {
    const shift = hi >>> i2;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
function int64fromString(dec) {
  let minus = dec[0] == "-";
  if (minus)
    dec = dec.slice(1);
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return [minus, lowBits, highBits];
}
function int64toString(bitsLow, bitsHigh) {
  if (bitsHigh >>> 0 <= 2097151) {
    return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
  }
  let low = bitsLow & 16777215;
  let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  let high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  let base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    let partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(
    digitC,
    /*needLeadingZeros=*/
    0
  ) + decimalFrom1e7(
    digitB,
    /*needLeadingZeros=*/
    digitC
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  decimalFrom1e7(
    digitA,
    /*needLeadingZeros=*/
    1
  );
}
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i2 = 0; i2 < 9; i2++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}
var TWO_PWR_32_DBL;
var init_goog_varint = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js"() {
    "use strict";
    TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js
function detectBi() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
  BI = ok ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: dv
  } : void 0;
}
function assertBi(bi) {
  if (!bi)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
var BI, RE_DECIMAL_STR, TWO_PWR_32_DBL2, HALF_2_PWR_32, SharedPbLong, PbULong, PbLong;
var init_pb_long = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js"() {
    "use strict";
    init_goog_varint();
    detectBi();
    RE_DECIMAL_STR = /^-?[0-9]+$/;
    TWO_PWR_32_DBL2 = 4294967296;
    HALF_2_PWR_32 = 2147483648;
    SharedPbLong = class {
      /**
       * Create a new instance with the given bits.
       */
      constructor(lo, hi) {
        this.lo = lo | 0;
        this.hi = hi | 0;
      }
      /**
       * Is this instance equal to 0?
       */
      isZero() {
        return this.lo == 0 && this.hi == 0;
      }
      /**
       * Convert to a native number.
       */
      toNumber() {
        let result = this.hi * TWO_PWR_32_DBL2 + (this.lo >>> 0);
        if (!Number.isSafeInteger(result))
          throw new Error("cannot convert to safe number");
        return result;
      }
    };
    PbULong = class _PbULong extends SharedPbLong {
      /**
       * Create instance from a `string`, `number` or `bigint`.
       */
      static from(value) {
        if (BI)
          switch (typeof value) {
            case "string":
              if (value == "0")
                return this.ZERO;
              if (value == "")
                throw new Error("string is no integer");
              value = BI.C(value);
            case "number":
              if (value === 0)
                return this.ZERO;
              value = BI.C(value);
            case "bigint":
              if (!value)
                return this.ZERO;
              if (value < BI.UMIN)
                throw new Error("signed value for ulong");
              if (value > BI.UMAX)
                throw new Error("ulong too large");
              BI.V.setBigUint64(0, value, true);
              return new _PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
          }
        else
          switch (typeof value) {
            case "string":
              if (value == "0")
                return this.ZERO;
              value = value.trim();
              if (!RE_DECIMAL_STR.test(value))
                throw new Error("string is no integer");
              let [minus, lo, hi] = int64fromString(value);
              if (minus)
                throw new Error("signed value for ulong");
              return new _PbULong(lo, hi);
            case "number":
              if (value == 0)
                return this.ZERO;
              if (!Number.isSafeInteger(value))
                throw new Error("number is no integer");
              if (value < 0)
                throw new Error("signed value for ulong");
              return new _PbULong(value, value / TWO_PWR_32_DBL2);
          }
        throw new Error("unknown value " + typeof value);
      }
      /**
       * Convert to decimal string.
       */
      toString() {
        return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
      }
      /**
       * Convert to native bigint.
       */
      toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigUint64(0, true);
      }
    };
    PbULong.ZERO = new PbULong(0, 0);
    PbLong = class _PbLong extends SharedPbLong {
      /**
       * Create instance from a `string`, `number` or `bigint`.
       */
      static from(value) {
        if (BI)
          switch (typeof value) {
            case "string":
              if (value == "0")
                return this.ZERO;
              if (value == "")
                throw new Error("string is no integer");
              value = BI.C(value);
            case "number":
              if (value === 0)
                return this.ZERO;
              value = BI.C(value);
            case "bigint":
              if (!value)
                return this.ZERO;
              if (value < BI.MIN)
                throw new Error("signed long too small");
              if (value > BI.MAX)
                throw new Error("signed long too large");
              BI.V.setBigInt64(0, value, true);
              return new _PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
          }
        else
          switch (typeof value) {
            case "string":
              if (value == "0")
                return this.ZERO;
              value = value.trim();
              if (!RE_DECIMAL_STR.test(value))
                throw new Error("string is no integer");
              let [minus, lo, hi] = int64fromString(value);
              if (minus) {
                if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
                  throw new Error("signed long too small");
              } else if (hi >= HALF_2_PWR_32)
                throw new Error("signed long too large");
              let pbl = new _PbLong(lo, hi);
              return minus ? pbl.negate() : pbl;
            case "number":
              if (value == 0)
                return this.ZERO;
              if (!Number.isSafeInteger(value))
                throw new Error("number is no integer");
              return value > 0 ? new _PbLong(value, value / TWO_PWR_32_DBL2) : new _PbLong(-value, -value / TWO_PWR_32_DBL2).negate();
          }
        throw new Error("unknown value " + typeof value);
      }
      /**
       * Do we have a minus sign?
       */
      isNegative() {
        return (this.hi & HALF_2_PWR_32) !== 0;
      }
      /**
       * Negate two's complement.
       * Invert all the bits and add one to the result.
       */
      negate() {
        let hi = ~this.hi, lo = this.lo;
        if (lo)
          lo = ~lo + 1;
        else
          hi += 1;
        return new _PbLong(lo, hi);
      }
      /**
       * Convert to decimal string.
       */
      toString() {
        if (BI)
          return this.toBigInt().toString();
        if (this.isNegative()) {
          let n2 = this.negate();
          return "-" + int64toString(n2.lo, n2.hi);
        }
        return int64toString(this.lo, this.hi);
      }
      /**
       * Convert to native bigint.
       */
      toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigInt64(0, true);
      }
    };
    PbLong.ZERO = new PbLong(0, 0);
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js
function binaryReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
var defaultsRead, BinaryReader;
var init_binary_reader = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js"() {
    "use strict";
    init_binary_format_contract();
    init_pb_long();
    init_goog_varint();
    defaultsRead = {
      readUnknownField: true,
      readerFactory: (bytes) => new BinaryReader(bytes)
    };
    BinaryReader = class {
      constructor(buf, textDecoder) {
        this.varint64 = varint64read;
        this.uint32 = varint32read;
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
          fatal: true,
          ignoreBOM: true
        });
      }
      /**
       * Reads a tag - field number and wire type.
       */
      tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
          throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
      }
      /**
       * Skip one element on the wire and return the skipped data.
       * Supports WireType.StartGroup since v2.0.0-alpha.23.
       */
      skip(wireType) {
        let start = this.pos;
        switch (wireType) {
          case WireType.Varint:
            while (this.buf[this.pos++] & 128) {
            }
            break;
          case WireType.Bit64:
            this.pos += 4;
          case WireType.Bit32:
            this.pos += 4;
            break;
          case WireType.LengthDelimited:
            let len = this.uint32();
            this.pos += len;
            break;
          case WireType.StartGroup:
            let t;
            while ((t = this.tag()[1]) !== WireType.EndGroup) {
              this.skip(t);
            }
            break;
          default:
            throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
      }
      /**
       * Throws error if position in byte array is out of range.
       */
      assertBounds() {
        if (this.pos > this.len)
          throw new RangeError("premature EOF");
      }
      /**
       * Read a `int32` field, a signed 32 bit varint.
       */
      int32() {
        return this.uint32() | 0;
      }
      /**
       * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
       */
      sint32() {
        let zze = this.uint32();
        return zze >>> 1 ^ -(zze & 1);
      }
      /**
       * Read a `int64` field, a signed 64-bit varint.
       */
      int64() {
        return new PbLong(...this.varint64());
      }
      /**
       * Read a `uint64` field, an unsigned 64-bit varint.
       */
      uint64() {
        return new PbULong(...this.varint64());
      }
      /**
       * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64() {
        let [lo, hi] = this.varint64();
        let s = -(lo & 1);
        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
        hi = hi >>> 1 ^ s;
        return new PbLong(lo, hi);
      }
      /**
       * Read a `bool` field, a variant.
       */
      bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
      }
      /**
       * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
       */
      fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
       */
      sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
       */
      fixed64() {
        return new PbULong(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
       */
      sfixed64() {
        return new PbLong(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `float` field, 32-bit floating point number.
       */
      float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `double` field, a 64-bit floating point number.
       */
      double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
      }
      /**
       * Read a `bytes` field, length-delimited arbitrary data.
       */
      bytes() {
        let len = this.uint32();
        let start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
      }
      /**
       * Read a `string` field, length-delimited data converted to UTF-8 text.
       */
      string() {
        return this.textDecoder.decode(this.bytes());
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/assert.js
function assert2(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function assertNever(value, msg) {
  throw new Error(msg !== null && msg !== void 0 ? msg : "Unexpected object: " + value);
}
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}
var FLOAT32_MAX, FLOAT32_MIN, UINT32_MAX, INT32_MAX, INT32_MIN;
var init_assert = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/assert.js"() {
    "use strict";
    FLOAT32_MAX = 34028234663852886e22;
    FLOAT32_MIN = -34028234663852886e22;
    UINT32_MAX = 4294967295;
    INT32_MAX = 2147483647;
    INT32_MIN = -2147483648;
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js
function binaryWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
var defaultsWrite, BinaryWriter;
var init_binary_writer = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js"() {
    "use strict";
    init_pb_long();
    init_goog_varint();
    init_assert();
    defaultsWrite = {
      writeUnknownFields: true,
      writerFactory: () => new BinaryWriter()
    };
    BinaryWriter = class {
      constructor(textEncoder3) {
        this.stack = [];
        this.textEncoder = textEncoder3 !== null && textEncoder3 !== void 0 ? textEncoder3 : new TextEncoder();
        this.chunks = [];
        this.buf = [];
      }
      /**
       * Return all bytes written and reset this writer.
       */
      finish() {
        this.chunks.push(new Uint8Array(this.buf));
        let len = 0;
        for (let i2 = 0; i2 < this.chunks.length; i2++)
          len += this.chunks[i2].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i2 = 0; i2 < this.chunks.length; i2++) {
          bytes.set(this.chunks[i2], offset);
          offset += this.chunks[i2].length;
        }
        this.chunks = [];
        return bytes;
      }
      /**
       * Start a new fork for length-delimited data like a message
       * or a packed repeated field.
       *
       * Must be joined later with `join()`.
       */
      fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
      }
      /**
       * Join the last fork. Write its length and bytes, then
       * return to the previous state.
       */
      join() {
        let chunk2 = this.finish();
        let prev = this.stack.pop();
        if (!prev)
          throw new Error("invalid state, fork stack empty");
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        this.uint32(chunk2.byteLength);
        return this.raw(chunk2);
      }
      /**
       * Writes a tag (field number and wire type).
       *
       * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
       *
       * Generated code should compute the tag ahead of time and call `uint32()`.
       */
      tag(fieldNo, type2) {
        return this.uint32((fieldNo << 3 | type2) >>> 0);
      }
      /**
       * Write a chunk of raw bytes.
       */
      raw(chunk2) {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        this.chunks.push(chunk2);
        return this;
      }
      /**
       * Write a `uint32` value, an unsigned 32 bit varint.
       */
      uint32(value) {
        assertUInt32(value);
        while (value > 127) {
          this.buf.push(value & 127 | 128);
          value = value >>> 7;
        }
        this.buf.push(value);
        return this;
      }
      /**
       * Write a `int32` value, a signed 32 bit varint.
       */
      int32(value) {
        assertInt32(value);
        varint32write(value, this.buf);
        return this;
      }
      /**
       * Write a `bool` value, a variant.
       */
      bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
      }
      /**
       * Write a `bytes` value, length-delimited arbitrary data.
       */
      bytes(value) {
        this.uint32(value.byteLength);
        return this.raw(value);
      }
      /**
       * Write a `string` value, length-delimited data converted to UTF-8 text.
       */
      string(value) {
        let chunk2 = this.textEncoder.encode(value);
        this.uint32(chunk2.byteLength);
        return this.raw(chunk2);
      }
      /**
       * Write a `float` value, 32-bit floating point number.
       */
      float(value) {
        assertFloat32(value);
        let chunk2 = new Uint8Array(4);
        new DataView(chunk2.buffer).setFloat32(0, value, true);
        return this.raw(chunk2);
      }
      /**
       * Write a `double` value, a 64-bit floating point number.
       */
      double(value) {
        let chunk2 = new Uint8Array(8);
        new DataView(chunk2.buffer).setFloat64(0, value, true);
        return this.raw(chunk2);
      }
      /**
       * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
       */
      fixed32(value) {
        assertUInt32(value);
        let chunk2 = new Uint8Array(4);
        new DataView(chunk2.buffer).setUint32(0, value, true);
        return this.raw(chunk2);
      }
      /**
       * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
       */
      sfixed32(value) {
        assertInt32(value);
        let chunk2 = new Uint8Array(4);
        new DataView(chunk2.buffer).setInt32(0, value, true);
        return this.raw(chunk2);
      }
      /**
       * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
       */
      sint32(value) {
        assertInt32(value);
        value = (value << 1 ^ value >> 31) >>> 0;
        varint32write(value, this.buf);
        return this;
      }
      /**
       * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
       */
      sfixed64(value) {
        let chunk2 = new Uint8Array(8);
        let view = new DataView(chunk2.buffer);
        let long = PbLong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk2);
      }
      /**
       * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
       */
      fixed64(value) {
        let chunk2 = new Uint8Array(8);
        let view = new DataView(chunk2.buffer);
        let long = PbULong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk2);
      }
      /**
       * Write a `int64` value, a signed 64-bit varint.
       */
      int64(value) {
        let long = PbLong.from(value);
        varint64write(long.lo, long.hi, this.buf);
        return this;
      }
      /**
       * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64(value) {
        let long = PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
        varint64write(lo, hi, this.buf);
        return this;
      }
      /**
       * Write a `uint64` value, an unsigned 64-bit varint.
       */
      uint64(value) {
        let long = PbULong.from(value);
        varint64write(long.lo, long.hi, this.buf);
        return this;
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js
function jsonReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead2), options) : defaultsRead2;
}
function jsonWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite2), options) : defaultsWrite2;
}
function mergeJsonOptions(a2, b) {
  var _a, _b;
  let c3 = Object.assign(Object.assign({}, a2), b);
  c3.typeRegistry = [...(_a = a2 === null || a2 === void 0 ? void 0 : a2.typeRegistry) !== null && _a !== void 0 ? _a : [], ...(_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : []];
  return c3;
}
var defaultsWrite2, defaultsRead2;
var init_json_format_contract = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js"() {
    "use strict";
    defaultsWrite2 = {
      emitDefaultValues: false,
      enumAsInteger: false,
      useProtoFieldName: false,
      prettySpaces: 0
    };
    defaultsRead2 = {
      ignoreUnknownFields: false
    };
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js
var MESSAGE_TYPE;
var init_message_type_contract = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js"() {
    "use strict";
    MESSAGE_TYPE = /* @__PURE__ */ Symbol.for("protobuf-ts/message-type");
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js
function lowerCamelCase(snakeCase) {
  let capNext = false;
  const sb = [];
  for (let i2 = 0; i2 < snakeCase.length; i2++) {
    let next = snakeCase.charAt(i2);
    if (next == "_") {
      capNext = true;
    } else if (/\d/.test(next)) {
      sb.push(next);
      capNext = true;
    } else if (capNext) {
      sb.push(next.toUpperCase());
      capNext = false;
    } else if (i2 == 0) {
      sb.push(next.toLowerCase());
    } else {
      sb.push(next);
    }
  }
  return sb.join("");
}
var init_lower_camel_case = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js"() {
    "use strict";
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js
function normalizeFieldInfo(field) {
  var _a, _b, _c, _d;
  field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
  field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
  field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
  field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
  return field;
}
function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
  var _a;
  const options = (_a = messageType.fields.find((m, i2) => m.localName == fieldName || i2 == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
  return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : void 0;
}
function readFieldOption(messageType, fieldName, extensionName, extensionType) {
  var _a;
  const options = (_a = messageType.fields.find((m, i2) => m.localName == fieldName || i2 == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
  if (!options) {
    return void 0;
  }
  const optionVal = options[extensionName];
  if (optionVal === void 0) {
    return optionVal;
  }
  return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readMessageOption(messageType, extensionName, extensionType) {
  const options = messageType.options;
  const optionVal = options[extensionName];
  if (optionVal === void 0) {
    return optionVal;
  }
  return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
var ScalarType, LongType, RepeatType;
var init_reflection_info = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js"() {
    "use strict";
    init_lower_camel_case();
    (function(ScalarType2) {
      ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
      ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
      ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
      ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
      ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
      ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
      ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
      ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
      ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
      ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
      ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
      ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
      ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
      ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
      ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
    })(ScalarType || (ScalarType = {}));
    (function(LongType2) {
      LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
      LongType2[LongType2["STRING"] = 1] = "STRING";
      LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
    })(LongType || (LongType = {}));
    (function(RepeatType2) {
      RepeatType2[RepeatType2["NO"] = 0] = "NO";
      RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
      RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
    })(RepeatType || (RepeatType = {}));
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/oneof.js
function isOneofGroup(any) {
  if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
    return false;
  }
  switch (typeof any.oneofKind) {
    case "string":
      if (any[any.oneofKind] === void 0)
        return false;
      return Object.keys(any).length == 2;
    case "undefined":
      return Object.keys(any).length == 1;
    default:
      return false;
  }
}
function getOneofValue(oneof, kind) {
  return oneof[kind];
}
function setOneofValue(oneof, kind, value) {
  if (oneof.oneofKind !== void 0) {
    delete oneof[oneof.oneofKind];
  }
  oneof.oneofKind = kind;
  if (value !== void 0) {
    oneof[kind] = value;
  }
}
function clearOneofValue(oneof) {
  if (oneof.oneofKind !== void 0) {
    delete oneof[oneof.oneofKind];
  }
  oneof.oneofKind = void 0;
}
function getSelectedOneofValue(oneof) {
  if (oneof.oneofKind === void 0) {
    return void 0;
  }
  return oneof[oneof.oneofKind];
}
var init_oneof = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/oneof.js"() {
    "use strict";
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js
var ReflectionTypeCheck;
var init_reflection_type_check = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js"() {
    "use strict";
    init_reflection_info();
    init_oneof();
    ReflectionTypeCheck = class {
      constructor(info2) {
        var _a;
        this.fields = (_a = info2.fields) !== null && _a !== void 0 ? _a : [];
      }
      prepare() {
        if (this.data)
          return;
        const req = [], known = [], oneofs = [];
        for (let field of this.fields) {
          if (field.oneof) {
            if (!oneofs.includes(field.oneof)) {
              oneofs.push(field.oneof);
              req.push(field.oneof);
              known.push(field.oneof);
            }
          } else {
            known.push(field.localName);
            switch (field.kind) {
              case "scalar":
              case "enum":
                if (!field.opt || field.repeat)
                  req.push(field.localName);
                break;
              case "message":
                if (field.repeat)
                  req.push(field.localName);
                break;
              case "map":
                req.push(field.localName);
                break;
            }
          }
        }
        this.data = { req, known, oneofs: Object.values(oneofs) };
      }
      /**
       * Is the argument a valid message as specified by the
       * reflection information?
       *
       * Checks all field types recursively. The `depth`
       * specifies how deep into the structure the check will be.
       *
       * With a depth of 0, only the presence of fields
       * is checked.
       *
       * With a depth of 1 or more, the field types are checked.
       *
       * With a depth of 2 or more, the members of map, repeated
       * and message fields are checked.
       *
       * Message fields will be checked recursively with depth - 1.
       *
       * The number of map entries / repeated values being checked
       * is < depth.
       */
      is(message, depth, allowExcessProperties = false) {
        if (depth < 0)
          return true;
        if (message === null || message === void 0 || typeof message != "object")
          return false;
        this.prepare();
        let keys = Object.keys(message), data = this.data;
        if (keys.length < data.req.length || data.req.some((n2) => !keys.includes(n2)))
          return false;
        if (!allowExcessProperties) {
          if (keys.some((k) => !data.known.includes(k)))
            return false;
        }
        if (depth < 1) {
          return true;
        }
        for (const name of data.oneofs) {
          const group = message[name];
          if (!isOneofGroup(group))
            return false;
          if (group.oneofKind === void 0)
            continue;
          const field = this.fields.find((f) => f.localName === group.oneofKind);
          if (!field)
            return false;
          if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
            return false;
        }
        for (const field of this.fields) {
          if (field.oneof !== void 0)
            continue;
          if (!this.field(message[field.localName], field, allowExcessProperties, depth))
            return false;
        }
        return true;
      }
      field(arg, field, allowExcessProperties, depth) {
        let repeated = field.repeat;
        switch (field.kind) {
          case "scalar":
            if (arg === void 0)
              return field.opt;
            if (repeated)
              return this.scalars(arg, field.T, depth, field.L);
            return this.scalar(arg, field.T, field.L);
          case "enum":
            if (arg === void 0)
              return field.opt;
            if (repeated)
              return this.scalars(arg, ScalarType.INT32, depth);
            return this.scalar(arg, ScalarType.INT32);
          case "message":
            if (arg === void 0)
              return true;
            if (repeated)
              return this.messages(arg, field.T(), allowExcessProperties, depth);
            return this.message(arg, field.T(), allowExcessProperties, depth);
          case "map":
            if (typeof arg != "object" || arg === null)
              return false;
            if (depth < 2)
              return true;
            if (!this.mapKeys(arg, field.K, depth))
              return false;
            switch (field.V.kind) {
              case "scalar":
                return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
              case "enum":
                return this.scalars(Object.values(arg), ScalarType.INT32, depth);
              case "message":
                return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
            }
            break;
        }
        return true;
      }
      message(arg, type2, allowExcessProperties, depth) {
        if (allowExcessProperties) {
          return type2.isAssignable(arg, depth);
        }
        return type2.is(arg, depth);
      }
      messages(arg, type2, allowExcessProperties, depth) {
        if (!Array.isArray(arg))
          return false;
        if (depth < 2)
          return true;
        if (allowExcessProperties) {
          for (let i2 = 0; i2 < arg.length && i2 < depth; i2++)
            if (!type2.isAssignable(arg[i2], depth - 1))
              return false;
        } else {
          for (let i2 = 0; i2 < arg.length && i2 < depth; i2++)
            if (!type2.is(arg[i2], depth - 1))
              return false;
        }
        return true;
      }
      scalar(arg, type2, longType) {
        let argType = typeof arg;
        switch (type2) {
          case ScalarType.UINT64:
          case ScalarType.FIXED64:
          case ScalarType.INT64:
          case ScalarType.SFIXED64:
          case ScalarType.SINT64:
            switch (longType) {
              case LongType.BIGINT:
                return argType == "bigint";
              case LongType.NUMBER:
                return argType == "number" && !isNaN(arg);
              default:
                return argType == "string";
            }
          case ScalarType.BOOL:
            return argType == "boolean";
          case ScalarType.STRING:
            return argType == "string";
          case ScalarType.BYTES:
            return arg instanceof Uint8Array;
          case ScalarType.DOUBLE:
          case ScalarType.FLOAT:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "number" && Number.isInteger(arg);
        }
      }
      scalars(arg, type2, depth, longType) {
        if (!Array.isArray(arg))
          return false;
        if (depth < 2)
          return true;
        if (Array.isArray(arg)) {
          for (let i2 = 0; i2 < arg.length && i2 < depth; i2++)
            if (!this.scalar(arg[i2], type2, longType))
              return false;
        }
        return true;
      }
      mapKeys(map, type2, depth) {
        let keys = Object.keys(map);
        switch (type2) {
          case ScalarType.INT32:
          case ScalarType.FIXED32:
          case ScalarType.SFIXED32:
          case ScalarType.SINT32:
          case ScalarType.UINT32:
            return this.scalars(keys.slice(0, depth).map((k) => parseInt(k)), type2, depth);
          case ScalarType.BOOL:
            return this.scalars(keys.slice(0, depth).map((k) => k == "true" ? true : k == "false" ? false : k), type2, depth);
          default:
            return this.scalars(keys, type2, depth, LongType.STRING);
        }
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js
function reflectionLongConvert(long, type2) {
  switch (type2) {
    case LongType.BIGINT:
      return long.toBigInt();
    case LongType.NUMBER:
      return long.toNumber();
    default:
      return long.toString();
  }
}
var init_reflection_long_convert = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js"() {
    "use strict";
    init_reflection_info();
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js
var ReflectionJsonReader;
var init_reflection_json_reader = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js"() {
    "use strict";
    init_json_typings();
    init_base64();
    init_reflection_info();
    init_pb_long();
    init_assert();
    init_reflection_long_convert();
    ReflectionJsonReader = class {
      constructor(info2) {
        this.info = info2;
      }
      prepare() {
        var _a;
        if (this.fMap === void 0) {
          this.fMap = {};
          const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
          for (const field of fieldsInput) {
            this.fMap[field.name] = field;
            this.fMap[field.jsonName] = field;
            this.fMap[field.localName] = field;
          }
        }
      }
      // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
      assert(condition, fieldName, jsonValue) {
        if (!condition) {
          let what = typeofJsonValue(jsonValue);
          if (what == "number" || what == "boolean")
            what = jsonValue.toString();
          throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
        }
      }
      /**
       * Reads a message from canonical JSON format into the target message.
       *
       * Repeated fields are appended. Map entries are added, overwriting
       * existing keys.
       *
       * If a message field is already present, it will be merged with the
       * new data.
       */
      read(input, message, options) {
        this.prepare();
        const oneofsHandled = [];
        for (const [jsonKey, jsonValue] of Object.entries(input)) {
          const field = this.fMap[jsonKey];
          if (!field) {
            if (!options.ignoreUnknownFields)
              throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
            continue;
          }
          const localName = field.localName;
          let target;
          if (field.oneof) {
            if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
              continue;
            }
            if (oneofsHandled.includes(field.oneof))
              throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
            oneofsHandled.push(field.oneof);
            target = message[field.oneof] = {
              oneofKind: localName
            };
          } else {
            target = message;
          }
          if (field.kind == "map") {
            if (jsonValue === null) {
              continue;
            }
            this.assert(isJsonObject(jsonValue), field.name, jsonValue);
            const fieldObj = target[localName];
            for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
              this.assert(jsonObjValue !== null, field.name + " map value", null);
              let val;
              switch (field.V.kind) {
                case "message":
                  val = field.V.T().internalJsonRead(jsonObjValue, options);
                  break;
                case "enum":
                  val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                  if (val === false)
                    continue;
                  break;
                case "scalar":
                  val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                  break;
              }
              this.assert(val !== void 0, field.name + " map value", jsonObjValue);
              let key = jsonObjKey;
              if (field.K == ScalarType.BOOL)
                key = key == "true" ? true : key == "false" ? false : key;
              key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
              fieldObj[key] = val;
            }
          } else if (field.repeat) {
            if (jsonValue === null)
              continue;
            this.assert(Array.isArray(jsonValue), field.name, jsonValue);
            const fieldArr = target[localName];
            for (const jsonItem of jsonValue) {
              this.assert(jsonItem !== null, field.name, null);
              let val;
              switch (field.kind) {
                case "message":
                  val = field.T().internalJsonRead(jsonItem, options);
                  break;
                case "enum":
                  val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                  if (val === false)
                    continue;
                  break;
                case "scalar":
                  val = this.scalar(jsonItem, field.T, field.L, field.name);
                  break;
              }
              this.assert(val !== void 0, field.name, jsonValue);
              fieldArr.push(val);
            }
          } else {
            switch (field.kind) {
              case "message":
                if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
                  this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
                  continue;
                }
                target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                break;
              case "enum":
                if (jsonValue === null)
                  continue;
                let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                if (val === false)
                  continue;
                target[localName] = val;
                break;
              case "scalar":
                if (jsonValue === null)
                  continue;
                target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                break;
            }
          }
        }
      }
      /**
       * Returns `false` for unrecognized string representations.
       *
       * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
       */
      enum(type2, json, fieldName, ignoreUnknownFields) {
        if (type2[0] == "google.protobuf.NullValue")
          assert2(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type2[0]} only accepts null.`);
        if (json === null)
          return 0;
        switch (typeof json) {
          case "number":
            assert2(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
            return json;
          case "string":
            let localEnumName = json;
            if (type2[2] && json.substring(0, type2[2].length) === type2[2])
              localEnumName = json.substring(type2[2].length);
            let enumNumber = type2[1][localEnumName];
            if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
              return false;
            }
            assert2(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type2[0]} has no value for "${json}".`);
            return enumNumber;
        }
        assert2(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
      }
      scalar(json, type2, longType, fieldName) {
        let e;
        try {
          switch (type2) {
            // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
            // Either numbers or strings are accepted. Exponent notation is also accepted.
            case ScalarType.DOUBLE:
            case ScalarType.FLOAT:
              if (json === null)
                return 0;
              if (json === "NaN")
                return Number.NaN;
              if (json === "Infinity")
                return Number.POSITIVE_INFINITY;
              if (json === "-Infinity")
                return Number.NEGATIVE_INFINITY;
              if (json === "") {
                e = "empty string";
                break;
              }
              if (typeof json == "string" && json.trim().length !== json.length) {
                e = "extra whitespace";
                break;
              }
              if (typeof json != "string" && typeof json != "number") {
                break;
              }
              let float = Number(json);
              if (Number.isNaN(float)) {
                e = "not a number";
                break;
              }
              if (!Number.isFinite(float)) {
                e = "too large or small";
                break;
              }
              if (type2 == ScalarType.FLOAT)
                assertFloat32(float);
              return float;
            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
            case ScalarType.INT32:
            case ScalarType.FIXED32:
            case ScalarType.SFIXED32:
            case ScalarType.SINT32:
            case ScalarType.UINT32:
              if (json === null)
                return 0;
              let int32;
              if (typeof json == "number")
                int32 = json;
              else if (json === "")
                e = "empty string";
              else if (typeof json == "string") {
                if (json.trim().length !== json.length)
                  e = "extra whitespace";
                else
                  int32 = Number(json);
              }
              if (int32 === void 0)
                break;
              if (type2 == ScalarType.UINT32)
                assertUInt32(int32);
              else
                assertInt32(int32);
              return int32;
            // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
            case ScalarType.INT64:
            case ScalarType.SFIXED64:
            case ScalarType.SINT64:
              if (json === null)
                return reflectionLongConvert(PbLong.ZERO, longType);
              if (typeof json != "number" && typeof json != "string")
                break;
              return reflectionLongConvert(PbLong.from(json), longType);
            case ScalarType.FIXED64:
            case ScalarType.UINT64:
              if (json === null)
                return reflectionLongConvert(PbULong.ZERO, longType);
              if (typeof json != "number" && typeof json != "string")
                break;
              return reflectionLongConvert(PbULong.from(json), longType);
            // bool:
            case ScalarType.BOOL:
              if (json === null)
                return false;
              if (typeof json !== "boolean")
                break;
              return json;
            // string:
            case ScalarType.STRING:
              if (json === null)
                return "";
              if (typeof json !== "string") {
                e = "extra whitespace";
                break;
              }
              try {
                encodeURIComponent(json);
              } catch (e2) {
                e2 = "invalid UTF8";
                break;
              }
              return json;
            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
            // Either standard or URL-safe base64 encoding with/without paddings are accepted.
            case ScalarType.BYTES:
              if (json === null || json === "")
                return new Uint8Array(0);
              if (typeof json !== "string")
                break;
              return base64decode(json);
          }
        } catch (error2) {
          e = error2.message;
        }
        this.assert(false, fieldName + (e ? " - " + e : ""), json);
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js
var ReflectionJsonWriter;
var init_reflection_json_writer = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js"() {
    "use strict";
    init_base64();
    init_pb_long();
    init_reflection_info();
    init_assert();
    ReflectionJsonWriter = class {
      constructor(info2) {
        var _a;
        this.fields = (_a = info2.fields) !== null && _a !== void 0 ? _a : [];
      }
      /**
       * Converts the message to a JSON object, based on the field descriptors.
       */
      write(message, options) {
        const json = {}, source = message;
        for (const field of this.fields) {
          if (!field.oneof) {
            let jsonValue2 = this.field(field, source[field.localName], options);
            if (jsonValue2 !== void 0)
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
            continue;
          }
          const group = source[field.oneof];
          if (group.oneofKind !== field.localName)
            continue;
          const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
          let jsonValue = this.field(field, group[field.localName], opt);
          assert2(jsonValue !== void 0);
          json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
        }
        return json;
      }
      field(field, value, options) {
        let jsonValue = void 0;
        if (field.kind == "map") {
          assert2(typeof value == "object" && value !== null);
          const jsonObj = {};
          switch (field.V.kind) {
            case "scalar":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                assert2(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
            case "message":
              const messageType = field.V.T();
              for (const [entryKey, entryValue] of Object.entries(value)) {
                const val = this.message(messageType, entryValue, field.name, options);
                assert2(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
            case "enum":
              const enumInfo = field.V.T();
              for (const [entryKey, entryValue] of Object.entries(value)) {
                assert2(entryValue === void 0 || typeof entryValue == "number");
                const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                assert2(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
          }
          if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
            jsonValue = jsonObj;
        } else if (field.repeat) {
          assert2(Array.isArray(value));
          const jsonArr = [];
          switch (field.kind) {
            case "scalar":
              for (let i2 = 0; i2 < value.length; i2++) {
                const val = this.scalar(field.T, value[i2], field.name, field.opt, true);
                assert2(val !== void 0);
                jsonArr.push(val);
              }
              break;
            case "enum":
              const enumInfo = field.T();
              for (let i2 = 0; i2 < value.length; i2++) {
                assert2(value[i2] === void 0 || typeof value[i2] == "number");
                const val = this.enum(enumInfo, value[i2], field.name, field.opt, true, options.enumAsInteger);
                assert2(val !== void 0);
                jsonArr.push(val);
              }
              break;
            case "message":
              const messageType = field.T();
              for (let i2 = 0; i2 < value.length; i2++) {
                const val = this.message(messageType, value[i2], field.name, options);
                assert2(val !== void 0);
                jsonArr.push(val);
              }
              break;
          }
          if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
            jsonValue = jsonArr;
        } else {
          switch (field.kind) {
            case "scalar":
              jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
              break;
            case "enum":
              jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
              break;
            case "message":
              jsonValue = this.message(field.T(), value, field.name, options);
              break;
          }
        }
        return jsonValue;
      }
      /**
       * Returns `null` as the default for google.protobuf.NullValue.
       */
      enum(type2, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
        if (type2[0] == "google.protobuf.NullValue")
          return !emitDefaultValues && !optional ? void 0 : null;
        if (value === void 0) {
          assert2(optional);
          return void 0;
        }
        if (value === 0 && !emitDefaultValues && !optional)
          return void 0;
        assert2(typeof value == "number");
        assert2(Number.isInteger(value));
        if (enumAsInteger || !type2[1].hasOwnProperty(value))
          return value;
        if (type2[2])
          return type2[2] + type2[1][value];
        return type2[1][value];
      }
      message(type2, value, fieldName, options) {
        if (value === void 0)
          return options.emitDefaultValues ? null : void 0;
        return type2.internalJsonWrite(value, options);
      }
      scalar(type2, value, fieldName, optional, emitDefaultValues) {
        if (value === void 0) {
          assert2(optional);
          return void 0;
        }
        const ed = emitDefaultValues || optional;
        switch (type2) {
          // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
          case ScalarType.INT32:
          case ScalarType.SFIXED32:
          case ScalarType.SINT32:
            if (value === 0)
              return ed ? 0 : void 0;
            assertInt32(value);
            return value;
          case ScalarType.FIXED32:
          case ScalarType.UINT32:
            if (value === 0)
              return ed ? 0 : void 0;
            assertUInt32(value);
            return value;
          // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
          // Either numbers or strings are accepted. Exponent notation is also accepted.
          case ScalarType.FLOAT:
            assertFloat32(value);
          case ScalarType.DOUBLE:
            if (value === 0)
              return ed ? 0 : void 0;
            assert2(typeof value == "number");
            if (Number.isNaN(value))
              return "NaN";
            if (value === Number.POSITIVE_INFINITY)
              return "Infinity";
            if (value === Number.NEGATIVE_INFINITY)
              return "-Infinity";
            return value;
          // string:
          case ScalarType.STRING:
            if (value === "")
              return ed ? "" : void 0;
            assert2(typeof value == "string");
            return value;
          // bool:
          case ScalarType.BOOL:
            if (value === false)
              return ed ? false : void 0;
            assert2(typeof value == "boolean");
            return value;
          // JSON value will be a decimal string. Either numbers or strings are accepted.
          case ScalarType.UINT64:
          case ScalarType.FIXED64:
            assert2(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
            let ulong = PbULong.from(value);
            if (ulong.isZero() && !ed)
              return void 0;
            return ulong.toString();
          // JSON value will be a decimal string. Either numbers or strings are accepted.
          case ScalarType.INT64:
          case ScalarType.SFIXED64:
          case ScalarType.SINT64:
            assert2(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
            let long = PbLong.from(value);
            if (long.isZero() && !ed)
              return void 0;
            return long.toString();
          // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
          // Either standard or URL-safe base64 encoding with/without paddings are accepted.
          case ScalarType.BYTES:
            assert2(value instanceof Uint8Array);
            if (!value.byteLength)
              return ed ? "" : void 0;
            return base64encode(value);
        }
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js
function reflectionScalarDefault(type2, longType = LongType.STRING) {
  switch (type2) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return reflectionLongConvert(PbULong.ZERO, longType);
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return reflectionLongConvert(PbLong.ZERO, longType);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
var init_reflection_scalar_default = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js"() {
    "use strict";
    init_reflection_info();
    init_reflection_long_convert();
    init_pb_long();
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js
var ReflectionBinaryReader;
var init_reflection_binary_reader = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js"() {
    "use strict";
    init_binary_format_contract();
    init_reflection_info();
    init_reflection_long_convert();
    init_reflection_scalar_default();
    ReflectionBinaryReader = class {
      constructor(info2) {
        this.info = info2;
      }
      prepare() {
        var _a;
        if (!this.fieldNoToField) {
          const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
          this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
        }
      }
      /**
       * Reads a message from binary format into the target message.
       *
       * Repeated fields are appended. Map entries are added, overwriting
       * existing keys.
       *
       * If a message field is already present, it will be merged with the
       * new data.
       */
      read(reader, message, options, length) {
        this.prepare();
        const end = length === void 0 ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
          if (!field) {
            let u2 = options.readUnknownField;
            if (u2 == "throw")
              throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
            let d = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? UnknownFieldHandler.onRead : u2)(this.info.typeName, message, fieldNo, wireType, d);
            continue;
          }
          let target = message, repeated = field.repeat, localName = field.localName;
          if (field.oneof) {
            target = target[field.oneof];
            if (target.oneofKind !== localName)
              target = message[field.oneof] = {
                oneofKind: localName
              };
          }
          switch (field.kind) {
            case "scalar":
            case "enum":
              let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
              let L = field.kind == "scalar" ? field.L : void 0;
              if (repeated) {
                let arr = target[localName];
                if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
                  let e = reader.uint32() + reader.pos;
                  while (reader.pos < e)
                    arr.push(this.scalar(reader, T, L));
                } else
                  arr.push(this.scalar(reader, T, L));
              } else
                target[localName] = this.scalar(reader, T, L);
              break;
            case "message":
              if (repeated) {
                let arr = target[localName];
                let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                arr.push(msg);
              } else
                target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
              break;
            case "map":
              let [mapKey, mapVal] = this.mapEntry(field, reader, options);
              target[localName][mapKey] = mapVal;
              break;
          }
        }
      }
      /**
       * Read a map field, expecting key field = 1, value field = 2
       */
      mapEntry(field, reader, options) {
        let length = reader.uint32();
        let end = reader.pos + length;
        let key = void 0;
        let val = void 0;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              if (field.K == ScalarType.BOOL)
                key = reader.bool().toString();
              else
                key = this.scalar(reader, field.K, LongType.STRING);
              break;
            case 2:
              switch (field.V.kind) {
                case "scalar":
                  val = this.scalar(reader, field.V.T, field.V.L);
                  break;
                case "enum":
                  val = reader.int32();
                  break;
                case "message":
                  val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                  break;
              }
              break;
            default:
              throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
          }
        }
        if (key === void 0) {
          let keyRaw = reflectionScalarDefault(field.K);
          key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
        }
        if (val === void 0)
          switch (field.V.kind) {
            case "scalar":
              val = reflectionScalarDefault(field.V.T, field.V.L);
              break;
            case "enum":
              val = 0;
              break;
            case "message":
              val = field.V.T().create();
              break;
          }
        return [key, val];
      }
      scalar(reader, type2, longType) {
        switch (type2) {
          case ScalarType.INT32:
            return reader.int32();
          case ScalarType.STRING:
            return reader.string();
          case ScalarType.BOOL:
            return reader.bool();
          case ScalarType.DOUBLE:
            return reader.double();
          case ScalarType.FLOAT:
            return reader.float();
          case ScalarType.INT64:
            return reflectionLongConvert(reader.int64(), longType);
          case ScalarType.UINT64:
            return reflectionLongConvert(reader.uint64(), longType);
          case ScalarType.FIXED64:
            return reflectionLongConvert(reader.fixed64(), longType);
          case ScalarType.FIXED32:
            return reader.fixed32();
          case ScalarType.BYTES:
            return reader.bytes();
          case ScalarType.UINT32:
            return reader.uint32();
          case ScalarType.SFIXED32:
            return reader.sfixed32();
          case ScalarType.SFIXED64:
            return reflectionLongConvert(reader.sfixed64(), longType);
          case ScalarType.SINT32:
            return reader.sint32();
          case ScalarType.SINT64:
            return reflectionLongConvert(reader.sint64(), longType);
        }
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js
var ReflectionBinaryWriter;
var init_reflection_binary_writer = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js"() {
    "use strict";
    init_binary_format_contract();
    init_reflection_info();
    init_assert();
    init_pb_long();
    ReflectionBinaryWriter = class {
      constructor(info2) {
        this.info = info2;
      }
      prepare() {
        if (!this.fields) {
          const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
          this.fields = fieldsInput.sort((a2, b) => a2.no - b.no);
        }
      }
      /**
       * Writes the message to binary format.
       */
      write(message, writer, options) {
        this.prepare();
        for (const field of this.fields) {
          let value, emitDefault, repeated = field.repeat, localName = field.localName;
          if (field.oneof) {
            const group = message[field.oneof];
            if (group.oneofKind !== localName)
              continue;
            value = group[localName];
            emitDefault = true;
          } else {
            value = message[localName];
            emitDefault = false;
          }
          switch (field.kind) {
            case "scalar":
            case "enum":
              let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
              if (repeated) {
                assert2(Array.isArray(value));
                if (repeated == RepeatType.PACKED)
                  this.packed(writer, T, field.no, value);
                else
                  for (const item of value)
                    this.scalar(writer, T, field.no, item, true);
              } else if (value === void 0)
                assert2(field.opt);
              else
                this.scalar(writer, T, field.no, value, emitDefault || field.opt);
              break;
            case "message":
              if (repeated) {
                assert2(Array.isArray(value));
                for (const item of value)
                  this.message(writer, options, field.T(), field.no, item);
              } else {
                this.message(writer, options, field.T(), field.no, value);
              }
              break;
            case "map":
              assert2(typeof value == "object" && value !== null);
              for (const [key, val] of Object.entries(value))
                this.mapEntry(writer, options, field, key, val);
              break;
          }
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 === true ? UnknownFieldHandler.onWrite : u2)(this.info.typeName, message, writer);
      }
      mapEntry(writer, options, field, key, value) {
        writer.tag(field.no, WireType.LengthDelimited);
        writer.fork();
        let keyValue = key;
        switch (field.K) {
          case ScalarType.INT32:
          case ScalarType.FIXED32:
          case ScalarType.UINT32:
          case ScalarType.SFIXED32:
          case ScalarType.SINT32:
            keyValue = Number.parseInt(key);
            break;
          case ScalarType.BOOL:
            assert2(key == "true" || key == "false");
            keyValue = key == "true";
            break;
        }
        this.scalar(writer, field.K, 1, keyValue, true);
        switch (field.V.kind) {
          case "scalar":
            this.scalar(writer, field.V.T, 2, value, true);
            break;
          case "enum":
            this.scalar(writer, ScalarType.INT32, 2, value, true);
            break;
          case "message":
            this.message(writer, options, field.V.T(), 2, value);
            break;
        }
        writer.join();
      }
      message(writer, options, handler, fieldNo, value) {
        if (value === void 0)
          return;
        handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
        writer.join();
      }
      /**
       * Write a single scalar value.
       */
      scalar(writer, type2, fieldNo, value, emitDefault) {
        let [wireType, method, isDefault] = this.scalarInfo(type2, value);
        if (!isDefault || emitDefault) {
          writer.tag(fieldNo, wireType);
          writer[method](value);
        }
      }
      /**
       * Write an array of scalar values in packed format.
       */
      packed(writer, type2, fieldNo, value) {
        if (!value.length)
          return;
        assert2(type2 !== ScalarType.BYTES && type2 !== ScalarType.STRING);
        writer.tag(fieldNo, WireType.LengthDelimited);
        writer.fork();
        let [, method] = this.scalarInfo(type2);
        for (let i2 = 0; i2 < value.length; i2++)
          writer[method](value[i2]);
        writer.join();
      }
      /**
       * Get information for writing a scalar value.
       *
       * Returns tuple:
       * [0]: appropriate WireType
       * [1]: name of the appropriate method of IBinaryWriter
       * [2]: whether the given value is a default value
       *
       * If argument `value` is omitted, [2] is always false.
       */
      scalarInfo(type2, value) {
        let t = WireType.Varint;
        let m;
        let i2 = value === void 0;
        let d = value === 0;
        switch (type2) {
          case ScalarType.INT32:
            m = "int32";
            break;
          case ScalarType.STRING:
            d = i2 || !value.length;
            t = WireType.LengthDelimited;
            m = "string";
            break;
          case ScalarType.BOOL:
            d = value === false;
            m = "bool";
            break;
          case ScalarType.UINT32:
            m = "uint32";
            break;
          case ScalarType.DOUBLE:
            t = WireType.Bit64;
            m = "double";
            break;
          case ScalarType.FLOAT:
            t = WireType.Bit32;
            m = "float";
            break;
          case ScalarType.INT64:
            d = i2 || PbLong.from(value).isZero();
            m = "int64";
            break;
          case ScalarType.UINT64:
            d = i2 || PbULong.from(value).isZero();
            m = "uint64";
            break;
          case ScalarType.FIXED64:
            d = i2 || PbULong.from(value).isZero();
            t = WireType.Bit64;
            m = "fixed64";
            break;
          case ScalarType.BYTES:
            d = i2 || !value.byteLength;
            t = WireType.LengthDelimited;
            m = "bytes";
            break;
          case ScalarType.FIXED32:
            t = WireType.Bit32;
            m = "fixed32";
            break;
          case ScalarType.SFIXED32:
            t = WireType.Bit32;
            m = "sfixed32";
            break;
          case ScalarType.SFIXED64:
            d = i2 || PbLong.from(value).isZero();
            t = WireType.Bit64;
            m = "sfixed64";
            break;
          case ScalarType.SINT32:
            m = "sint32";
            break;
          case ScalarType.SINT64:
            d = i2 || PbLong.from(value).isZero();
            m = "sint64";
            break;
        }
        return [t, m, i2 || d];
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js
function reflectionCreate(type2) {
  const msg = type2.messagePrototype ? Object.create(type2.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type2 });
  for (let field of type2.fields) {
    let name = field.localName;
    if (field.opt)
      continue;
    if (field.oneof)
      msg[field.oneof] = { oneofKind: void 0 };
    else if (field.repeat)
      msg[name] = [];
    else
      switch (field.kind) {
        case "scalar":
          msg[name] = reflectionScalarDefault(field.T, field.L);
          break;
        case "enum":
          msg[name] = 0;
          break;
        case "map":
          msg[name] = {};
          break;
      }
  }
  return msg;
}
var init_reflection_create = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js"() {
    "use strict";
    init_reflection_scalar_default();
    init_message_type_contract();
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js
function reflectionMergePartial(info2, target, source) {
  let fieldValue, input = source, output;
  for (let field of info2.fields) {
    let name = field.localName;
    if (field.oneof) {
      const group = input[field.oneof];
      if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) {
        continue;
      }
      fieldValue = group[name];
      output = target[field.oneof];
      output.oneofKind = group.oneofKind;
      if (fieldValue == void 0) {
        delete output[name];
        continue;
      }
    } else {
      fieldValue = input[name];
      output = target;
      if (fieldValue == void 0) {
        continue;
      }
    }
    if (field.repeat)
      output[name].length = fieldValue.length;
    switch (field.kind) {
      case "scalar":
      case "enum":
        if (field.repeat)
          for (let i2 = 0; i2 < fieldValue.length; i2++)
            output[name][i2] = fieldValue[i2];
        else
          output[name] = fieldValue;
        break;
      case "message":
        let T = field.T();
        if (field.repeat)
          for (let i2 = 0; i2 < fieldValue.length; i2++)
            output[name][i2] = T.create(fieldValue[i2]);
        else if (output[name] === void 0)
          output[name] = T.create(fieldValue);
        else
          T.mergePartial(output[name], fieldValue);
        break;
      case "map":
        switch (field.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(output[name], fieldValue);
            break;
          case "message":
            let T2 = field.V.T();
            for (let k of Object.keys(fieldValue))
              output[name][k] = T2.create(fieldValue[k]);
            break;
        }
        break;
    }
  }
}
var init_reflection_merge_partial = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js"() {
    "use strict";
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js
function reflectionEquals(info2, a2, b) {
  if (a2 === b)
    return true;
  if (!a2 || !b)
    return false;
  for (let field of info2.fields) {
    let localName = field.localName;
    let val_a = field.oneof ? a2[field.oneof][localName] : a2[localName];
    let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
    switch (field.kind) {
      case "enum":
      case "scalar":
        let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b)))
          return false;
        break;
      case "map":
        if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
          return false;
        break;
      case "message":
        let T = field.T();
        if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
          return false;
        break;
    }
  }
  return true;
}
function primitiveEq(type2, a2, b) {
  if (a2 === b)
    return true;
  if (type2 !== ScalarType.BYTES)
    return false;
  let ba = a2;
  let bb = b;
  if (ba.length !== bb.length)
    return false;
  for (let i2 = 0; i2 < ba.length; i2++)
    if (ba[i2] != bb[i2])
      return false;
  return true;
}
function repeatedPrimitiveEq(type2, a2, b) {
  if (a2.length !== b.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!primitiveEq(type2, a2[i2], b[i2]))
      return false;
  return true;
}
function repeatedMsgEq(type2, a2, b) {
  if (a2.length !== b.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!type2.equals(a2[i2], b[i2]))
      return false;
  return true;
}
var objectValues;
var init_reflection_equals = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js"() {
    "use strict";
    init_reflection_info();
    objectValues = Object.values;
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/message-type.js
var baseDescriptors, messageTypeDescriptor, MessageType;
var init_message_type = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/message-type.js"() {
    "use strict";
    init_message_type_contract();
    init_reflection_info();
    init_reflection_type_check();
    init_reflection_json_reader();
    init_reflection_json_writer();
    init_reflection_binary_reader();
    init_reflection_binary_writer();
    init_reflection_create();
    init_reflection_merge_partial();
    init_json_typings();
    init_json_format_contract();
    init_reflection_equals();
    init_binary_writer();
    init_binary_reader();
    baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
    messageTypeDescriptor = baseDescriptors[MESSAGE_TYPE] = {};
    MessageType = class {
      constructor(name, fields, options) {
        this.defaultCheckDepth = 16;
        this.typeName = name;
        this.fields = fields.map(normalizeFieldInfo);
        this.options = options !== null && options !== void 0 ? options : {};
        messageTypeDescriptor.value = this;
        this.messagePrototype = Object.create(null, baseDescriptors);
        this.refTypeCheck = new ReflectionTypeCheck(this);
        this.refJsonReader = new ReflectionJsonReader(this);
        this.refJsonWriter = new ReflectionJsonWriter(this);
        this.refBinReader = new ReflectionBinaryReader(this);
        this.refBinWriter = new ReflectionBinaryWriter(this);
      }
      create(value) {
        let message = reflectionCreate(this);
        if (value !== void 0) {
          reflectionMergePartial(this, message, value);
        }
        return message;
      }
      /**
       * Clone the message.
       *
       * Unknown fields are discarded.
       */
      clone(message) {
        let copy2 = this.create();
        reflectionMergePartial(this, copy2, message);
        return copy2;
      }
      /**
       * Determines whether two message of the same type have the same field values.
       * Checks for deep equality, traversing repeated fields, oneof groups, maps
       * and messages recursively.
       * Will also return true if both messages are `undefined`.
       */
      equals(a2, b) {
        return reflectionEquals(this, a2, b);
      }
      /**
       * Is the given value assignable to our message type
       * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
       */
      is(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, false);
      }
      /**
       * Is the given value assignable to our message type,
       * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
       */
      isAssignable(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, true);
      }
      /**
       * Copy partial data into the target message.
       */
      mergePartial(target, source) {
        reflectionMergePartial(this, target, source);
      }
      /**
       * Create a new message from binary format.
       */
      fromBinary(data, options) {
        let opt = binaryReadOptions(options);
        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
      }
      /**
       * Read a new message from a JSON value.
       */
      fromJson(json, options) {
        return this.internalJsonRead(json, jsonReadOptions(options));
      }
      /**
       * Read a new message from a JSON string.
       * This is equivalent to `T.fromJson(JSON.parse(json))`.
       */
      fromJsonString(json, options) {
        let value = JSON.parse(json);
        return this.fromJson(value, options);
      }
      /**
       * Write the message to canonical JSON value.
       */
      toJson(message, options) {
        return this.internalJsonWrite(message, jsonWriteOptions(options));
      }
      /**
       * Convert the message to canonical JSON string.
       * This is equivalent to `JSON.stringify(T.toJson(t))`
       */
      toJsonString(message, options) {
        var _a;
        let value = this.toJson(message, options);
        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
      }
      /**
       * Write the message to binary format.
       */
      toBinary(message, options) {
        let opt = binaryWriteOptions(options);
        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
      }
      /**
       * This is an internal method. If you just want to read a message from
       * JSON, use `fromJson()` or `fromJsonString()`.
       *
       * Reads JSON value and merges the fields into the target
       * according to protobuf rules. If the target is omitted,
       * a new instance is created first.
       */
      internalJsonRead(json, options, target) {
        if (json !== null && typeof json == "object" && !Array.isArray(json)) {
          let message = target !== null && target !== void 0 ? target : this.create();
          this.refJsonReader.read(json, message, options);
          return message;
        }
        throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
      }
      /**
       * This is an internal method. If you just want to write a message
       * to JSON, use `toJson()` or `toJsonString().
       *
       * Writes JSON value and returns it.
       */
      internalJsonWrite(message, options) {
        return this.refJsonWriter.write(message, options);
      }
      /**
       * This is an internal method. If you just want to write a message
       * in binary format, use `toBinary()`.
       *
       * Serializes the message in binary format and appends it to the given
       * writer. Returns passed writer.
       */
      internalBinaryWrite(message, writer, options) {
        this.refBinWriter.write(message, writer, options);
        return writer;
      }
      /**
       * This is an internal method. If you just want to read a message from
       * binary data, use `fromBinary()`.
       *
       * Reads data from binary format and merges the fields into
       * the target according to protobuf rules. If the target is
       * omitted, a new instance is created first.
       */
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create();
        this.refBinReader.read(reader, message, options, length);
        return message;
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-contains-message-type.js
function containsMessageType(msg) {
  return msg[MESSAGE_TYPE] != null;
}
var init_reflection_contains_message_type = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/reflection-contains-message-type.js"() {
    "use strict";
    init_message_type_contract();
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/enum-object.js
function isEnumObject(arg) {
  if (typeof arg != "object" || arg === null) {
    return false;
  }
  if (!arg.hasOwnProperty(0)) {
    return false;
  }
  for (let k of Object.keys(arg)) {
    let num = parseInt(k);
    if (!Number.isNaN(num)) {
      let nam = arg[num];
      if (nam === void 0)
        return false;
      if (arg[nam] !== num)
        return false;
    } else {
      let num2 = arg[k];
      if (num2 === void 0)
        return false;
      if (typeof num2 !== "number")
        return false;
      if (arg[num2] === void 0)
        return false;
    }
  }
  return true;
}
function listEnumValues(enumObject) {
  if (!isEnumObject(enumObject))
    throw new Error("not a typescript enum object");
  let values = [];
  for (let [name, number] of Object.entries(enumObject))
    if (typeof number == "number")
      values.push({ name, number });
  return values;
}
function listEnumNames(enumObject) {
  return listEnumValues(enumObject).map((val) => val.name);
}
function listEnumNumbers(enumObject) {
  return listEnumValues(enumObject).map((val) => val.number).filter((num, index, arr) => arr.indexOf(num) == index);
}
var init_enum_object = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/enum-object.js"() {
    "use strict";
  }
});

// node_modules/@protobuf-ts/runtime/build/es2015/index.js
var es2015_exports = {};
__export(es2015_exports, {
  BinaryReader: () => BinaryReader,
  BinaryWriter: () => BinaryWriter,
  LongType: () => LongType,
  MESSAGE_TYPE: () => MESSAGE_TYPE,
  MessageType: () => MessageType,
  PbLong: () => PbLong,
  PbULong: () => PbULong,
  ReflectionBinaryReader: () => ReflectionBinaryReader,
  ReflectionBinaryWriter: () => ReflectionBinaryWriter,
  ReflectionJsonReader: () => ReflectionJsonReader,
  ReflectionJsonWriter: () => ReflectionJsonWriter,
  ReflectionTypeCheck: () => ReflectionTypeCheck,
  RepeatType: () => RepeatType,
  ScalarType: () => ScalarType,
  UnknownFieldHandler: () => UnknownFieldHandler,
  WireType: () => WireType,
  assert: () => assert2,
  assertFloat32: () => assertFloat32,
  assertInt32: () => assertInt32,
  assertNever: () => assertNever,
  assertUInt32: () => assertUInt32,
  base64decode: () => base64decode,
  base64encode: () => base64encode,
  binaryReadOptions: () => binaryReadOptions,
  binaryWriteOptions: () => binaryWriteOptions,
  clearOneofValue: () => clearOneofValue,
  containsMessageType: () => containsMessageType,
  getOneofValue: () => getOneofValue,
  getSelectedOneofValue: () => getSelectedOneofValue,
  isEnumObject: () => isEnumObject,
  isJsonObject: () => isJsonObject,
  isOneofGroup: () => isOneofGroup,
  jsonReadOptions: () => jsonReadOptions,
  jsonWriteOptions: () => jsonWriteOptions,
  listEnumNames: () => listEnumNames,
  listEnumNumbers: () => listEnumNumbers,
  listEnumValues: () => listEnumValues,
  lowerCamelCase: () => lowerCamelCase,
  mergeBinaryOptions: () => mergeBinaryOptions,
  mergeJsonOptions: () => mergeJsonOptions,
  normalizeFieldInfo: () => normalizeFieldInfo,
  readFieldOption: () => readFieldOption,
  readFieldOptions: () => readFieldOptions,
  readMessageOption: () => readMessageOption,
  reflectionCreate: () => reflectionCreate,
  reflectionEquals: () => reflectionEquals,
  reflectionMergePartial: () => reflectionMergePartial,
  reflectionScalarDefault: () => reflectionScalarDefault,
  setOneofValue: () => setOneofValue,
  typeofJsonValue: () => typeofJsonValue,
  utf8read: () => utf8read
});
var init_es2015 = __esm({
  "node_modules/@protobuf-ts/runtime/build/es2015/index.js"() {
    "use strict";
    init_json_typings();
    init_base64();
    init_protobufjs_utf8();
    init_binary_format_contract();
    init_binary_reader();
    init_binary_writer();
    init_pb_long();
    init_json_format_contract();
    init_message_type_contract();
    init_message_type();
    init_reflection_info();
    init_reflection_type_check();
    init_reflection_create();
    init_reflection_scalar_default();
    init_reflection_merge_partial();
    init_reflection_equals();
    init_reflection_binary_reader();
    init_reflection_binary_writer();
    init_reflection_json_reader();
    init_reflection_json_writer();
    init_reflection_contains_message_type();
    init_oneof();
    init_enum_object();
    init_lower_camel_case();
    init_assert();
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/reflection-info.js
function normalizeMethodInfo(method, service) {
  var _a, _b, _c;
  let m = method;
  m.service = service;
  m.localName = (_a = m.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(m.name);
  m.serverStreaming = !!m.serverStreaming;
  m.clientStreaming = !!m.clientStreaming;
  m.options = (_b = m.options) !== null && _b !== void 0 ? _b : {};
  m.idempotency = (_c = m.idempotency) !== null && _c !== void 0 ? _c : void 0;
  return m;
}
function readMethodOptions(service, methodName, extensionName, extensionType) {
  var _a;
  const options = (_a = service.methods.find((m, i2) => m.localName === methodName || i2 === methodName)) === null || _a === void 0 ? void 0 : _a.options;
  return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : void 0;
}
function readMethodOption(service, methodName, extensionName, extensionType) {
  var _a;
  const options = (_a = service.methods.find((m, i2) => m.localName === methodName || i2 === methodName)) === null || _a === void 0 ? void 0 : _a.options;
  if (!options) {
    return void 0;
  }
  const optionVal = options[extensionName];
  if (optionVal === void 0) {
    return optionVal;
  }
  return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readServiceOption(service, extensionName, extensionType) {
  const options = service.options;
  if (!options) {
    return void 0;
  }
  const optionVal = options[extensionName];
  if (optionVal === void 0) {
    return optionVal;
  }
  return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
var init_reflection_info2 = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/reflection-info.js"() {
    "use strict";
    init_es2015();
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/service-type.js
var ServiceType;
var init_service_type = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/service-type.js"() {
    "use strict";
    init_reflection_info2();
    ServiceType = class {
      constructor(typeName, methods, options) {
        this.typeName = typeName;
        this.methods = methods.map((i2) => normalizeMethodInfo(i2, this));
        this.options = options !== null && options !== void 0 ? options : {};
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-error.js
var RpcError;
var init_rpc_error = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-error.js"() {
    "use strict";
    RpcError = class extends Error {
      constructor(message, code = "UNKNOWN", meta) {
        super(message);
        this.name = "RpcError";
        Object.setPrototypeOf(this, new.target.prototype);
        this.code = code;
        this.meta = meta !== null && meta !== void 0 ? meta : {};
      }
      toString() {
        const l = [this.name + ": " + this.message];
        if (this.code) {
          l.push("");
          l.push("Code: " + this.code);
        }
        if (this.serviceName && this.methodName) {
          l.push("Method: " + this.serviceName + "/" + this.methodName);
        }
        let m = Object.entries(this.meta);
        if (m.length) {
          l.push("");
          l.push("Meta:");
          for (let [k, v] of m) {
            l.push(`  ${k}: ${v}`);
          }
        }
        return l.join("\n");
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-options.js
function mergeRpcOptions(defaults2, options) {
  if (!options)
    return defaults2;
  let o2 = {};
  copy(defaults2, o2);
  copy(options, o2);
  for (let key of Object.keys(options)) {
    let val = options[key];
    switch (key) {
      case "jsonOptions":
        o2.jsonOptions = mergeJsonOptions(defaults2.jsonOptions, o2.jsonOptions);
        break;
      case "binaryOptions":
        o2.binaryOptions = mergeBinaryOptions(defaults2.binaryOptions, o2.binaryOptions);
        break;
      case "meta":
        o2.meta = {};
        copy(defaults2.meta, o2.meta);
        copy(options.meta, o2.meta);
        break;
      case "interceptors":
        o2.interceptors = defaults2.interceptors ? defaults2.interceptors.concat(val) : val.concat();
        break;
    }
  }
  return o2;
}
function copy(a2, into) {
  if (!a2)
    return;
  let c3 = into;
  for (let [k, v] of Object.entries(a2)) {
    if (v instanceof Date)
      c3[k] = new Date(v.getTime());
    else if (Array.isArray(v))
      c3[k] = v.concat();
    else
      c3[k] = v;
  }
}
var init_rpc_options = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-options.js"() {
    "use strict";
    init_es2015();
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/deferred.js
var DeferredState, Deferred;
var init_deferred = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/deferred.js"() {
    "use strict";
    (function(DeferredState2) {
      DeferredState2[DeferredState2["PENDING"] = 0] = "PENDING";
      DeferredState2[DeferredState2["REJECTED"] = 1] = "REJECTED";
      DeferredState2[DeferredState2["RESOLVED"] = 2] = "RESOLVED";
    })(DeferredState || (DeferredState = {}));
    Deferred = class {
      /**
       * @param preventUnhandledRejectionWarning - prevents the warning
       * "Unhandled Promise rejection" by adding a noop rejection handler.
       * Working with calls returned from the runtime-rpc package in an
       * async function usually means awaiting one call property after
       * the other. This means that the "status" is not being awaited when
       * an earlier await for the "headers" is rejected. This causes the
       * "unhandled promise reject" warning. A more correct behaviour for
       * calls might be to become aware whether at least one of the
       * promises is handled and swallow the rejection warning for the
       * others.
       */
      constructor(preventUnhandledRejectionWarning = true) {
        this._state = DeferredState.PENDING;
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
        if (preventUnhandledRejectionWarning) {
          this._promise.catch((_) => {
          });
        }
      }
      /**
       * Get the current state of the promise.
       */
      get state() {
        return this._state;
      }
      /**
       * Get the deferred promise.
       */
      get promise() {
        return this._promise;
      }
      /**
       * Resolve the promise. Throws if the promise is already resolved or rejected.
       */
      resolve(value) {
        if (this.state !== DeferredState.PENDING)
          throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
        this._resolve(value);
        this._state = DeferredState.RESOLVED;
      }
      /**
       * Reject the promise. Throws if the promise is already resolved or rejected.
       */
      reject(reason) {
        if (this.state !== DeferredState.PENDING)
          throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
        this._reject(reason);
        this._state = DeferredState.REJECTED;
      }
      /**
       * Resolve the promise. Ignore if not pending.
       */
      resolvePending(val) {
        if (this._state === DeferredState.PENDING)
          this.resolve(val);
      }
      /**
       * Reject the promise. Ignore if not pending.
       */
      rejectPending(reason) {
        if (this._state === DeferredState.PENDING)
          this.reject(reason);
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-output-stream.js
var RpcOutputStreamController;
var init_rpc_output_stream = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-output-stream.js"() {
    "use strict";
    init_deferred();
    init_es2015();
    RpcOutputStreamController = class {
      constructor() {
        this._lis = {
          nxt: [],
          msg: [],
          err: [],
          cmp: []
        };
        this._closed = false;
        this._itState = { q: [] };
      }
      // --- RpcOutputStream callback API
      onNext(callback) {
        return this.addLis(callback, this._lis.nxt);
      }
      onMessage(callback) {
        return this.addLis(callback, this._lis.msg);
      }
      onError(callback) {
        return this.addLis(callback, this._lis.err);
      }
      onComplete(callback) {
        return this.addLis(callback, this._lis.cmp);
      }
      addLis(callback, list) {
        list.push(callback);
        return () => {
          let i2 = list.indexOf(callback);
          if (i2 >= 0)
            list.splice(i2, 1);
        };
      }
      // remove all listeners
      clearLis() {
        for (let l of Object.values(this._lis))
          l.splice(0, l.length);
      }
      // --- Controller API
      /**
       * Is this stream already closed by a completion or error?
       */
      get closed() {
        return this._closed !== false;
      }
      /**
       * Emit message, close with error, or close successfully, but only one
       * at a time.
       * Can be used to wrap a stream by using the other stream's `onNext`.
       */
      notifyNext(message, error2, complete) {
        assert2((message ? 1 : 0) + (error2 ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time");
        if (message)
          this.notifyMessage(message);
        if (error2)
          this.notifyError(error2);
        if (complete)
          this.notifyComplete();
      }
      /**
       * Emits a new message. Throws if stream is closed.
       *
       * Triggers onNext and onMessage callbacks.
       */
      notifyMessage(message) {
        assert2(!this.closed, "stream is closed");
        this.pushIt({ value: message, done: false });
        this._lis.msg.forEach((l) => l(message));
        this._lis.nxt.forEach((l) => l(message, void 0, false));
      }
      /**
       * Closes the stream with an error. Throws if stream is closed.
       *
       * Triggers onNext and onError callbacks.
       */
      notifyError(error2) {
        assert2(!this.closed, "stream is closed");
        this._closed = error2;
        this.pushIt(error2);
        this._lis.err.forEach((l) => l(error2));
        this._lis.nxt.forEach((l) => l(void 0, error2, false));
        this.clearLis();
      }
      /**
       * Closes the stream successfully. Throws if stream is closed.
       *
       * Triggers onNext and onComplete callbacks.
       */
      notifyComplete() {
        assert2(!this.closed, "stream is closed");
        this._closed = true;
        this.pushIt({ value: null, done: true });
        this._lis.cmp.forEach((l) => l());
        this._lis.nxt.forEach((l) => l(void 0, void 0, true));
        this.clearLis();
      }
      /**
       * Creates an async iterator (that can be used with `for await {...}`)
       * to consume the stream.
       *
       * Some things to note:
       * - If an error occurs, the `for await` will throw it.
       * - If an error occurred before the `for await` was started, `for await`
       *   will re-throw it.
       * - If the stream is already complete, the `for await` will be empty.
       * - If your `for await` consumes slower than the stream produces,
       *   for example because you are relaying messages in a slow operation,
       *   messages are queued.
       */
      [Symbol.asyncIterator]() {
        if (this._closed === true)
          this.pushIt({ value: null, done: true });
        else if (this._closed !== false)
          this.pushIt(this._closed);
        return {
          next: () => {
            let state = this._itState;
            assert2(state, "bad state");
            assert2(!state.p, "iterator contract broken");
            let first = state.q.shift();
            if (first)
              return "value" in first ? Promise.resolve(first) : Promise.reject(first);
            state.p = new Deferred();
            return state.p.promise;
          }
        };
      }
      // "push" a new iterator result.
      // this either resolves a pending promise, or enqueues the result.
      pushIt(result) {
        let state = this._itState;
        if (state.p) {
          const p = state.p;
          assert2(p.state == DeferredState.PENDING, "iterator contract broken");
          "value" in result ? p.resolve(result) : p.reject(result);
          delete state.p;
        } else {
          state.q.push(result);
        }
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/unary-call.js
var __awaiter2, UnaryCall;
var init_unary_call = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/unary-call.js"() {
    "use strict";
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    UnaryCall = class {
      constructor(method, requestHeaders, request, headers, response, status, trailers) {
        this.method = method;
        this.requestHeaders = requestHeaders;
        this.request = request;
        this.headers = headers;
        this.response = response;
        this.status = status;
        this.trailers = trailers;
      }
      /**
       * If you are only interested in the final outcome of this call,
       * you can await it to receive a `FinishedUnaryCall`.
       */
      then(onfulfilled, onrejected) {
        return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
      }
      promiseFinished() {
        return __awaiter2(this, void 0, void 0, function* () {
          let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
          return {
            method: this.method,
            requestHeaders: this.requestHeaders,
            request: this.request,
            headers,
            response,
            status,
            trailers
          };
        });
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/server-streaming-call.js
var __awaiter3, ServerStreamingCall;
var init_server_streaming_call = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/server-streaming-call.js"() {
    "use strict";
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    ServerStreamingCall = class {
      constructor(method, requestHeaders, request, headers, response, status, trailers) {
        this.method = method;
        this.requestHeaders = requestHeaders;
        this.request = request;
        this.headers = headers;
        this.responses = response;
        this.status = status;
        this.trailers = trailers;
      }
      /**
       * Instead of awaiting the response status and trailers, you can
       * just as well await this call itself to receive the server outcome.
       * You should first setup some listeners to the `request` to
       * see the actual messages the server replied with.
       */
      then(onfulfilled, onrejected) {
        return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
      }
      promiseFinished() {
        return __awaiter3(this, void 0, void 0, function* () {
          let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
          return {
            method: this.method,
            requestHeaders: this.requestHeaders,
            request: this.request,
            headers,
            status,
            trailers
          };
        });
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/client-streaming-call.js
var __awaiter4, ClientStreamingCall;
var init_client_streaming_call = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/client-streaming-call.js"() {
    "use strict";
    __awaiter4 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    ClientStreamingCall = class {
      constructor(method, requestHeaders, request, headers, response, status, trailers) {
        this.method = method;
        this.requestHeaders = requestHeaders;
        this.requests = request;
        this.headers = headers;
        this.response = response;
        this.status = status;
        this.trailers = trailers;
      }
      /**
       * Instead of awaiting the response status and trailers, you can
       * just as well await this call itself to receive the server outcome.
       * Note that it may still be valid to send more request messages.
       */
      then(onfulfilled, onrejected) {
        return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
      }
      promiseFinished() {
        return __awaiter4(this, void 0, void 0, function* () {
          let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
          return {
            method: this.method,
            requestHeaders: this.requestHeaders,
            headers,
            response,
            status,
            trailers
          };
        });
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/duplex-streaming-call.js
var __awaiter5, DuplexStreamingCall;
var init_duplex_streaming_call = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/duplex-streaming-call.js"() {
    "use strict";
    __awaiter5 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    DuplexStreamingCall = class {
      constructor(method, requestHeaders, request, headers, response, status, trailers) {
        this.method = method;
        this.requestHeaders = requestHeaders;
        this.requests = request;
        this.headers = headers;
        this.responses = response;
        this.status = status;
        this.trailers = trailers;
      }
      /**
       * Instead of awaiting the response status and trailers, you can
       * just as well await this call itself to receive the server outcome.
       * Note that it may still be valid to send more request messages.
       */
      then(onfulfilled, onrejected) {
        return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
      }
      promiseFinished() {
        return __awaiter5(this, void 0, void 0, function* () {
          let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
          return {
            method: this.method,
            requestHeaders: this.requestHeaders,
            headers,
            status,
            trailers
          };
        });
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/test-transport.js
function delay2(ms, abort) {
  return (v) => new Promise((resolve, reject) => {
    if (abort === null || abort === void 0 ? void 0 : abort.aborted) {
      reject(new RpcError("user cancel", "CANCELLED"));
    } else {
      const id = setTimeout(() => resolve(v), ms);
      if (abort) {
        abort.addEventListener("abort", (ev) => {
          clearTimeout(id);
          reject(new RpcError("user cancel", "CANCELLED"));
        });
      }
    }
  });
}
var __awaiter6, TestTransport, TestInputStream;
var init_test_transport = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/test-transport.js"() {
    "use strict";
    init_rpc_error();
    init_es2015();
    init_rpc_output_stream();
    init_rpc_options();
    init_unary_call();
    init_server_streaming_call();
    init_client_streaming_call();
    init_duplex_streaming_call();
    __awaiter6 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    TestTransport = class _TestTransport {
      /**
       * Initialize with mock data. Omitted fields have default value.
       */
      constructor(data) {
        this.suppressUncaughtRejections = true;
        this.headerDelay = 10;
        this.responseDelay = 50;
        this.betweenResponseDelay = 10;
        this.afterResponseDelay = 10;
        this.data = data !== null && data !== void 0 ? data : {};
      }
      /**
       * Sent message(s) during the last operation.
       */
      get sentMessages() {
        if (this.lastInput instanceof TestInputStream) {
          return this.lastInput.sent;
        } else if (typeof this.lastInput == "object") {
          return [this.lastInput.single];
        }
        return [];
      }
      /**
       * Sending message(s) completed?
       */
      get sendComplete() {
        if (this.lastInput instanceof TestInputStream) {
          return this.lastInput.completed;
        } else if (typeof this.lastInput == "object") {
          return true;
        }
        return false;
      }
      // Creates a promise for response headers from the mock data.
      promiseHeaders() {
        var _a;
        const headers = (_a = this.data.headers) !== null && _a !== void 0 ? _a : _TestTransport.defaultHeaders;
        return headers instanceof RpcError ? Promise.reject(headers) : Promise.resolve(headers);
      }
      // Creates a promise for a single, valid, message from the mock data.
      promiseSingleResponse(method) {
        if (this.data.response instanceof RpcError) {
          return Promise.reject(this.data.response);
        }
        let r;
        if (Array.isArray(this.data.response)) {
          assert2(this.data.response.length > 0);
          r = this.data.response[0];
        } else if (this.data.response !== void 0) {
          r = this.data.response;
        } else {
          r = method.O.create();
        }
        assert2(method.O.is(r));
        return Promise.resolve(r);
      }
      /**
       * Pushes response messages from the mock data to the output stream.
       * If an error response, status or trailers are mocked, the stream is
       * closed with the respective error.
       * Otherwise, stream is completed successfully.
       *
       * The returned promise resolves when the stream is closed. It should
       * not reject. If it does, code is broken.
       */
      streamResponses(method, stream2, abort) {
        return __awaiter6(this, void 0, void 0, function* () {
          const messages = [];
          if (this.data.response === void 0) {
            messages.push(method.O.create());
          } else if (Array.isArray(this.data.response)) {
            for (let msg of this.data.response) {
              assert2(method.O.is(msg));
              messages.push(msg);
            }
          } else if (!(this.data.response instanceof RpcError)) {
            assert2(method.O.is(this.data.response));
            messages.push(this.data.response);
          }
          try {
            yield delay2(this.responseDelay, abort)(void 0);
          } catch (error2) {
            stream2.notifyError(error2);
            return;
          }
          if (this.data.response instanceof RpcError) {
            stream2.notifyError(this.data.response);
            return;
          }
          for (let msg of messages) {
            stream2.notifyMessage(msg);
            try {
              yield delay2(this.betweenResponseDelay, abort)(void 0);
            } catch (error2) {
              stream2.notifyError(error2);
              return;
            }
          }
          if (this.data.status instanceof RpcError) {
            stream2.notifyError(this.data.status);
            return;
          }
          if (this.data.trailers instanceof RpcError) {
            stream2.notifyError(this.data.trailers);
            return;
          }
          stream2.notifyComplete();
        });
      }
      // Creates a promise for response status from the mock data.
      promiseStatus() {
        var _a;
        const status = (_a = this.data.status) !== null && _a !== void 0 ? _a : _TestTransport.defaultStatus;
        return status instanceof RpcError ? Promise.reject(status) : Promise.resolve(status);
      }
      // Creates a promise for response trailers from the mock data.
      promiseTrailers() {
        var _a;
        const trailers = (_a = this.data.trailers) !== null && _a !== void 0 ? _a : _TestTransport.defaultTrailers;
        return trailers instanceof RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
      }
      maybeSuppressUncaught(...promise) {
        if (this.suppressUncaughtRejections) {
          for (let p of promise) {
            p.catch(() => {
            });
          }
        }
      }
      mergeOptions(options) {
        return mergeRpcOptions({}, options);
      }
      unary(method, input, options) {
        var _a;
        const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay2(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_) => {
        }).then(delay2(this.responseDelay, options.abort)).then((_) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_) => {
        }).then(delay2(this.afterResponseDelay, options.abort)).then((_) => this.promiseStatus()), trailersPromise = responsePromise.catch((_) => {
        }).then(delay2(this.afterResponseDelay, options.abort)).then((_) => this.promiseTrailers());
        this.maybeSuppressUncaught(statusPromise, trailersPromise);
        this.lastInput = { single: input };
        return new UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
      }
      serverStreaming(method, input, options) {
        var _a;
        const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay2(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay2(this.responseDelay, options.abort)).catch(() => {
        }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay2(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
        this.maybeSuppressUncaught(statusPromise, trailersPromise);
        this.lastInput = { single: input };
        return new ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
      }
      clientStreaming(method, options) {
        var _a;
        const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay2(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_) => {
        }).then(delay2(this.responseDelay, options.abort)).then((_) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_) => {
        }).then(delay2(this.afterResponseDelay, options.abort)).then((_) => this.promiseStatus()), trailersPromise = responsePromise.catch((_) => {
        }).then(delay2(this.afterResponseDelay, options.abort)).then((_) => this.promiseTrailers());
        this.maybeSuppressUncaught(statusPromise, trailersPromise);
        this.lastInput = new TestInputStream(this.data, options.abort);
        return new ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
      }
      duplex(method, options) {
        var _a;
        const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay2(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay2(this.responseDelay, options.abort)).catch(() => {
        }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay2(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
        this.maybeSuppressUncaught(statusPromise, trailersPromise);
        this.lastInput = new TestInputStream(this.data, options.abort);
        return new DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
      }
    };
    TestTransport.defaultHeaders = {
      responseHeader: "test"
    };
    TestTransport.defaultStatus = {
      code: "OK",
      detail: "all good"
    };
    TestTransport.defaultTrailers = {
      responseTrailer: "test"
    };
    TestInputStream = class {
      constructor(data, abort) {
        this._completed = false;
        this._sent = [];
        this.data = data;
        this.abort = abort;
      }
      get sent() {
        return this._sent;
      }
      get completed() {
        return this._completed;
      }
      send(message) {
        if (this.data.inputMessage instanceof RpcError) {
          return Promise.reject(this.data.inputMessage);
        }
        const delayMs = this.data.inputMessage === void 0 ? 10 : this.data.inputMessage;
        return Promise.resolve(void 0).then(() => {
          this._sent.push(message);
        }).then(delay2(delayMs, this.abort));
      }
      complete() {
        if (this.data.inputComplete instanceof RpcError) {
          return Promise.reject(this.data.inputComplete);
        }
        const delayMs = this.data.inputComplete === void 0 ? 10 : this.data.inputComplete;
        return Promise.resolve(void 0).then(() => {
          this._completed = true;
        }).then(delay2(delayMs, this.abort));
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js
function stackIntercept(kind, transport, method, options, input) {
  var _a, _b, _c, _d;
  if (kind == "unary") {
    let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
    for (const curr of ((_a = options.interceptors) !== null && _a !== void 0 ? _a : []).filter((i2) => i2.interceptUnary).reverse()) {
      const next = tail;
      tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
    }
    return tail(method, input, options);
  }
  if (kind == "serverStreaming") {
    let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
    for (const curr of ((_b = options.interceptors) !== null && _b !== void 0 ? _b : []).filter((i2) => i2.interceptServerStreaming).reverse()) {
      const next = tail;
      tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
    }
    return tail(method, input, options);
  }
  if (kind == "clientStreaming") {
    let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
    for (const curr of ((_c = options.interceptors) !== null && _c !== void 0 ? _c : []).filter((i2) => i2.interceptClientStreaming).reverse()) {
      const next = tail;
      tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
    }
    return tail(method, options);
  }
  if (kind == "duplex") {
    let tail = (mtd, opt) => transport.duplex(mtd, opt);
    for (const curr of ((_d = options.interceptors) !== null && _d !== void 0 ? _d : []).filter((i2) => i2.interceptDuplex).reverse()) {
      const next = tail;
      tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
    }
    return tail(method, options);
  }
  assertNever(kind);
}
function stackUnaryInterceptors(transport, method, input, options) {
  return stackIntercept("unary", transport, method, options, input);
}
function stackServerStreamingInterceptors(transport, method, input, options) {
  return stackIntercept("serverStreaming", transport, method, options, input);
}
function stackClientStreamingInterceptors(transport, method, options) {
  return stackIntercept("clientStreaming", transport, method, options);
}
function stackDuplexStreamingInterceptors(transport, method, options) {
  return stackIntercept("duplex", transport, method, options);
}
var init_rpc_interceptor = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js"() {
    "use strict";
    init_es2015();
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/server-call-context.js
var ServerCallContextController;
var init_server_call_context = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/server-call-context.js"() {
    "use strict";
    ServerCallContextController = class {
      constructor(method, headers, deadline, sendResponseHeadersFn, defaultStatus = { code: "OK", detail: "" }) {
        this._cancelled = false;
        this._listeners = [];
        this.method = method;
        this.headers = headers;
        this.deadline = deadline;
        this.trailers = {};
        this._sendRH = sendResponseHeadersFn;
        this.status = defaultStatus;
      }
      /**
       * Set the call cancelled.
       *
       * Invokes all callbacks registered with onCancel() and
       * sets `cancelled = true`.
       */
      notifyCancelled() {
        if (!this._cancelled) {
          this._cancelled = true;
          for (let l of this._listeners) {
            l();
          }
        }
      }
      /**
       * Send response headers.
       */
      sendResponseHeaders(data) {
        this._sendRH(data);
      }
      /**
       * Is the call cancelled?
       *
       * When the client closes the connection before the server
       * is done, the call is cancelled.
       *
       * If you want to cancel a request on the server, throw a
       * RpcError with the CANCELLED status code.
       */
      get cancelled() {
        return this._cancelled;
      }
      /**
       * Add a callback for cancellation.
       */
      onCancel(callback) {
        const l = this._listeners;
        l.push(callback);
        return () => {
          let i2 = l.indexOf(callback);
          if (i2 >= 0)
            l.splice(i2, 1);
        };
      }
    };
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/index.js
var es2015_exports2 = {};
__export(es2015_exports2, {
  ClientStreamingCall: () => ClientStreamingCall,
  Deferred: () => Deferred,
  DeferredState: () => DeferredState,
  DuplexStreamingCall: () => DuplexStreamingCall,
  RpcError: () => RpcError,
  RpcOutputStreamController: () => RpcOutputStreamController,
  ServerCallContextController: () => ServerCallContextController,
  ServerStreamingCall: () => ServerStreamingCall,
  ServiceType: () => ServiceType,
  TestTransport: () => TestTransport,
  UnaryCall: () => UnaryCall,
  mergeRpcOptions: () => mergeRpcOptions,
  readMethodOption: () => readMethodOption,
  readMethodOptions: () => readMethodOptions,
  readServiceOption: () => readServiceOption,
  stackClientStreamingInterceptors: () => stackClientStreamingInterceptors,
  stackDuplexStreamingInterceptors: () => stackDuplexStreamingInterceptors,
  stackIntercept: () => stackIntercept,
  stackServerStreamingInterceptors: () => stackServerStreamingInterceptors,
  stackUnaryInterceptors: () => stackUnaryInterceptors
});
var init_es20152 = __esm({
  "node_modules/@protobuf-ts/runtime-rpc/build/es2015/index.js"() {
    "use strict";
    init_service_type();
    init_reflection_info2();
    init_rpc_error();
    init_rpc_options();
    init_rpc_output_stream();
    init_test_transport();
    init_deferred();
    init_duplex_streaming_call();
    init_client_streaming_call();
    init_server_streaming_call();
    init_unary_call();
    init_rpc_interceptor();
    init_server_call_context();
  }
});

// node_modules/@actions/cache/lib/generated/results/entities/v1/cachescope.js
var require_cachescope = __commonJS({
  "node_modules/@actions/cache/lib/generated/results/entities/v1/cachescope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CacheScope = void 0;
    var runtime_1 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_2 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_3 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_4 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_5 = (init_es2015(), __toCommonJS(es2015_exports));
    var CacheScope$Type = class extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.entities.v1.CacheScope", [
          {
            no: 1,
            name: "scope",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "permission",
            kind: "scalar",
            T: 3
            /*ScalarType.INT64*/
          }
        ]);
      }
      create(value) {
        const message = { scope: "", permission: "0" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string scope */
            1:
              message.scope = reader.string();
              break;
            case /* int64 permission */
            2:
              message.permission = reader.int64().toString();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.scope !== "")
          writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.scope);
        if (message.permission !== "0")
          writer.tag(2, runtime_1.WireType.Varint).int64(message.permission);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    exports.CacheScope = new CacheScope$Type();
  }
});

// node_modules/@actions/cache/lib/generated/results/entities/v1/cachemetadata.js
var require_cachemetadata = __commonJS({
  "node_modules/@actions/cache/lib/generated/results/entities/v1/cachemetadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CacheMetadata = void 0;
    var runtime_1 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_2 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_3 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_4 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_5 = (init_es2015(), __toCommonJS(es2015_exports));
    var cachescope_1 = require_cachescope();
    var CacheMetadata$Type = class extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.entities.v1.CacheMetadata", [
          {
            no: 1,
            name: "repository_id",
            kind: "scalar",
            T: 3
            /*ScalarType.INT64*/
          },
          { no: 2, name: "scope", kind: "message", repeat: 1, T: () => cachescope_1.CacheScope }
        ]);
      }
      create(value) {
        const message = { repositoryId: "0", scope: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* int64 repository_id */
            1:
              message.repositoryId = reader.int64().toString();
              break;
            case /* repeated github.actions.results.entities.v1.CacheScope scope */
            2:
              message.scope.push(cachescope_1.CacheScope.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.repositoryId !== "0")
          writer.tag(1, runtime_1.WireType.Varint).int64(message.repositoryId);
        for (let i2 = 0; i2 < message.scope.length; i2++)
          cachescope_1.CacheScope.internalBinaryWrite(message.scope[i2], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    exports.CacheMetadata = new CacheMetadata$Type();
  }
});

// node_modules/@actions/cache/lib/generated/results/api/v1/cache.js
var require_cache3 = __commonJS({
  "node_modules/@actions/cache/lib/generated/results/api/v1/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CacheService = exports.GetCacheEntryDownloadURLResponse = exports.GetCacheEntryDownloadURLRequest = exports.FinalizeCacheEntryUploadResponse = exports.FinalizeCacheEntryUploadRequest = exports.CreateCacheEntryResponse = exports.CreateCacheEntryRequest = void 0;
    var runtime_rpc_1 = (init_es20152(), __toCommonJS(es2015_exports2));
    var runtime_1 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_2 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_3 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_4 = (init_es2015(), __toCommonJS(es2015_exports));
    var runtime_5 = (init_es2015(), __toCommonJS(es2015_exports));
    var cachemetadata_1 = require_cachemetadata();
    var CreateCacheEntryRequest$Type = class extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.CreateCacheEntryRequest", [
          { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
          {
            no: 2,
            name: "key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "version",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { key: "", version: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* github.actions.results.entities.v1.CacheMetadata metadata */
            1:
              message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
              break;
            case /* string key */
            2:
              message.key = reader.string();
              break;
            case /* string version */
            3:
              message.version = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.metadata)
          cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        if (message.key !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
        if (message.version !== "")
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.version);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    exports.CreateCacheEntryRequest = new CreateCacheEntryRequest$Type();
    var CreateCacheEntryResponse$Type = class extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.CreateCacheEntryResponse", [
          {
            no: 1,
            name: "ok",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "signed_upload_url",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "message",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { ok: false, signedUploadUrl: "", message: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* bool ok */
            1:
              message.ok = reader.bool();
              break;
            case /* string signed_upload_url */
            2:
              message.signedUploadUrl = reader.string();
              break;
            case /* string message */
            3:
              message.message = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.ok !== false)
          writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
        if (message.signedUploadUrl !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
        if (message.message !== "")
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.message);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    exports.CreateCacheEntryResponse = new CreateCacheEntryResponse$Type();
    var FinalizeCacheEntryUploadRequest$Type = class extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.FinalizeCacheEntryUploadRequest", [
          { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
          {
            no: 2,
            name: "key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "size_bytes",
            kind: "scalar",
            T: 3
            /*ScalarType.INT64*/
          },
          {
            no: 4,
            name: "version",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { key: "", sizeBytes: "0", version: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* github.actions.results.entities.v1.CacheMetadata metadata */
            1:
              message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
              break;
            case /* string key */
            2:
              message.key = reader.string();
              break;
            case /* int64 size_bytes */
            3:
              message.sizeBytes = reader.int64().toString();
              break;
            case /* string version */
            4:
              message.version = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.metadata)
          cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        if (message.key !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
        if (message.sizeBytes !== "0")
          writer.tag(3, runtime_1.WireType.Varint).int64(message.sizeBytes);
        if (message.version !== "")
          writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.version);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    exports.FinalizeCacheEntryUploadRequest = new FinalizeCacheEntryUploadRequest$Type();
    var FinalizeCacheEntryUploadResponse$Type = class extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.FinalizeCacheEntryUploadResponse", [
          {
            no: 1,
            name: "ok",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "entry_id",
            kind: "scalar",
            T: 3
            /*ScalarType.INT64*/
          },
          {
            no: 3,
            name: "message",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { ok: false, entryId: "0", message: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* bool ok */
            1:
              message.ok = reader.bool();
              break;
            case /* int64 entry_id */
            2:
              message.entryId = reader.int64().toString();
              break;
            case /* string message */
            3:
              message.message = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.ok !== false)
          writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
        if (message.entryId !== "0")
          writer.tag(2, runtime_1.WireType.Varint).int64(message.entryId);
        if (message.message !== "")
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.message);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    exports.FinalizeCacheEntryUploadResponse = new FinalizeCacheEntryUploadResponse$Type();
    var GetCacheEntryDownloadURLRequest$Type = class extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.GetCacheEntryDownloadURLRequest", [
          { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
          {
            no: 2,
            name: "key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "restore_keys",
            kind: "scalar",
            repeat: 2,
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 4,
            name: "version",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { key: "", restoreKeys: [], version: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* github.actions.results.entities.v1.CacheMetadata metadata */
            1:
              message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
              break;
            case /* string key */
            2:
              message.key = reader.string();
              break;
            case /* repeated string restore_keys */
            3:
              message.restoreKeys.push(reader.string());
              break;
            case /* string version */
            4:
              message.version = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.metadata)
          cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        if (message.key !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
        for (let i2 = 0; i2 < message.restoreKeys.length; i2++)
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.restoreKeys[i2]);
        if (message.version !== "")
          writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.version);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    exports.GetCacheEntryDownloadURLRequest = new GetCacheEntryDownloadURLRequest$Type();
    var GetCacheEntryDownloadURLResponse$Type = class extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.GetCacheEntryDownloadURLResponse", [
          {
            no: 1,
            name: "ok",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "signed_download_url",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "matched_key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { ok: false, signedDownloadUrl: "", matchedKey: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* bool ok */
            1:
              message.ok = reader.bool();
              break;
            case /* string signed_download_url */
            2:
              message.signedDownloadUrl = reader.string();
              break;
            case /* string matched_key */
            3:
              message.matchedKey = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.ok !== false)
          writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
        if (message.signedDownloadUrl !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedDownloadUrl);
        if (message.matchedKey !== "")
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.matchedKey);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    exports.GetCacheEntryDownloadURLResponse = new GetCacheEntryDownloadURLResponse$Type();
    exports.CacheService = new runtime_rpc_1.ServiceType("github.actions.results.api.v1.CacheService", [
      { name: "CreateCacheEntry", options: {}, I: exports.CreateCacheEntryRequest, O: exports.CreateCacheEntryResponse },
      { name: "FinalizeCacheEntryUpload", options: {}, I: exports.FinalizeCacheEntryUploadRequest, O: exports.FinalizeCacheEntryUploadResponse },
      { name: "GetCacheEntryDownloadURL", options: {}, I: exports.GetCacheEntryDownloadURLRequest, O: exports.GetCacheEntryDownloadURLResponse }
    ]);
  }
});

// node_modules/@actions/cache/lib/generated/results/api/v1/cache.twirp-client.js
var require_cache_twirp_client = __commonJS({
  "node_modules/@actions/cache/lib/generated/results/api/v1/cache.twirp-client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CacheServiceClientProtobuf = exports.CacheServiceClientJSON = void 0;
    var cache_1 = require_cache3();
    var CacheServiceClientJSON = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateCacheEntry.bind(this);
        this.FinalizeCacheEntryUpload.bind(this);
        this.GetCacheEntryDownloadURL.bind(this);
      }
      CreateCacheEntry(request) {
        const data = cache_1.CreateCacheEntryRequest.toJson(request, {
          useProtoFieldName: true,
          emitDefaultValues: false
        });
        const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/json", data);
        return promise.then((data2) => cache_1.CreateCacheEntryResponse.fromJson(data2, {
          ignoreUnknownFields: true
        }));
      }
      FinalizeCacheEntryUpload(request) {
        const data = cache_1.FinalizeCacheEntryUploadRequest.toJson(request, {
          useProtoFieldName: true,
          emitDefaultValues: false
        });
        const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/json", data);
        return promise.then((data2) => cache_1.FinalizeCacheEntryUploadResponse.fromJson(data2, {
          ignoreUnknownFields: true
        }));
      }
      GetCacheEntryDownloadURL(request) {
        const data = cache_1.GetCacheEntryDownloadURLRequest.toJson(request, {
          useProtoFieldName: true,
          emitDefaultValues: false
        });
        const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/json", data);
        return promise.then((data2) => cache_1.GetCacheEntryDownloadURLResponse.fromJson(data2, {
          ignoreUnknownFields: true
        }));
      }
    };
    exports.CacheServiceClientJSON = CacheServiceClientJSON;
    var CacheServiceClientProtobuf = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateCacheEntry.bind(this);
        this.FinalizeCacheEntryUpload.bind(this);
        this.GetCacheEntryDownloadURL.bind(this);
      }
      CreateCacheEntry(request) {
        const data = cache_1.CreateCacheEntryRequest.toBinary(request);
        const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/protobuf", data);
        return promise.then((data2) => cache_1.CreateCacheEntryResponse.fromBinary(data2));
      }
      FinalizeCacheEntryUpload(request) {
        const data = cache_1.FinalizeCacheEntryUploadRequest.toBinary(request);
        const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/protobuf", data);
        return promise.then((data2) => cache_1.FinalizeCacheEntryUploadResponse.fromBinary(data2));
      }
      GetCacheEntryDownloadURL(request) {
        const data = cache_1.GetCacheEntryDownloadURLRequest.toBinary(request);
        const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/protobuf", data);
        return promise.then((data2) => cache_1.GetCacheEntryDownloadURLResponse.fromBinary(data2));
      }
    };
    exports.CacheServiceClientProtobuf = CacheServiceClientProtobuf;
  }
});

// node_modules/@actions/cache/lib/internal/shared/util.js
var require_util9 = __commonJS({
  "node_modules/@actions/cache/lib/internal/shared/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maskSecretUrls = exports.maskSigUrl = void 0;
    var core_1 = require_core();
    function maskSigUrl(url) {
      if (!url)
        return;
      try {
        const parsedUrl = new URL(url);
        const signature = parsedUrl.searchParams.get("sig");
        if (signature) {
          (0, core_1.setSecret)(signature);
          (0, core_1.setSecret)(encodeURIComponent(signature));
        }
      } catch (error2) {
        (0, core_1.debug)(`Failed to parse URL: ${url} ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    }
    exports.maskSigUrl = maskSigUrl;
    function maskSecretUrls(body) {
      if (typeof body !== "object" || body === null) {
        (0, core_1.debug)("body is not an object or is null");
        return;
      }
      if ("signed_upload_url" in body && typeof body.signed_upload_url === "string") {
        maskSigUrl(body.signed_upload_url);
      }
      if ("signed_download_url" in body && typeof body.signed_download_url === "string") {
        maskSigUrl(body.signed_download_url);
      }
    }
    exports.maskSecretUrls = maskSecretUrls;
  }
});

// node_modules/@actions/cache/lib/internal/shared/cacheTwirpClient.js
var require_cacheTwirpClient = __commonJS({
  "node_modules/@actions/cache/lib/internal/shared/cacheTwirpClient.js"(exports) {
    "use strict";
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internalCacheTwirpClient = void 0;
    var core_1 = require_core();
    var user_agent_1 = require_user_agent();
    var errors_1 = require_errors3();
    var config_1 = require_config();
    var cacheUtils_1 = require_cacheUtils();
    var auth_1 = require_auth();
    var http_client_1 = require_lib();
    var cache_twirp_client_1 = require_cache_twirp_client();
    var util_1 = require_util9();
    var CacheServiceClient = class {
      constructor(userAgent, maxAttempts, baseRetryIntervalMilliseconds, retryMultiplier) {
        this.maxAttempts = 5;
        this.baseRetryIntervalMilliseconds = 3e3;
        this.retryMultiplier = 1.5;
        const token = (0, cacheUtils_1.getRuntimeToken)();
        this.baseUrl = (0, config_1.getCacheServiceURL)();
        if (maxAttempts) {
          this.maxAttempts = maxAttempts;
        }
        if (baseRetryIntervalMilliseconds) {
          this.baseRetryIntervalMilliseconds = baseRetryIntervalMilliseconds;
        }
        if (retryMultiplier) {
          this.retryMultiplier = retryMultiplier;
        }
        this.httpClient = new http_client_1.HttpClient(userAgent, [
          new auth_1.BearerCredentialHandler(token)
        ]);
      }
      // This function satisfies the Rpc interface. It is compatible with the JSON
      // JSON generated client.
      request(service, method, contentType, data) {
        return __awaiter7(this, void 0, void 0, function* () {
          const url = new URL(`/twirp/${service}/${method}`, this.baseUrl).href;
          (0, core_1.debug)(`[Request] ${method} ${url}`);
          const headers = {
            "Content-Type": contentType
          };
          try {
            const { body } = yield this.retryableRequest(() => __awaiter7(this, void 0, void 0, function* () {
              return this.httpClient.post(url, JSON.stringify(data), headers);
            }));
            return body;
          } catch (error2) {
            throw new Error(`Failed to ${method}: ${error2.message}`);
          }
        });
      }
      retryableRequest(operation) {
        return __awaiter7(this, void 0, void 0, function* () {
          let attempt = 0;
          let errorMessage = "";
          let rawBody = "";
          while (attempt < this.maxAttempts) {
            let isRetryable = false;
            try {
              const response = yield operation();
              const statusCode = response.message.statusCode;
              rawBody = yield response.readBody();
              (0, core_1.debug)(`[Response] - ${response.message.statusCode}`);
              (0, core_1.debug)(`Headers: ${JSON.stringify(response.message.headers, null, 2)}`);
              const body = JSON.parse(rawBody);
              (0, util_1.maskSecretUrls)(body);
              (0, core_1.debug)(`Body: ${JSON.stringify(body, null, 2)}`);
              if (this.isSuccessStatusCode(statusCode)) {
                return { response, body };
              }
              isRetryable = this.isRetryableHttpStatusCode(statusCode);
              errorMessage = `Failed request: (${statusCode}) ${response.message.statusMessage}`;
              if (body.msg) {
                if (errors_1.UsageError.isUsageErrorMessage(body.msg)) {
                  throw new errors_1.UsageError();
                }
                errorMessage = `${errorMessage}: ${body.msg}`;
              }
            } catch (error2) {
              if (error2 instanceof SyntaxError) {
                (0, core_1.debug)(`Raw Body: ${rawBody}`);
              }
              if (error2 instanceof errors_1.UsageError) {
                throw error2;
              }
              if (errors_1.NetworkError.isNetworkErrorCode(error2 === null || error2 === void 0 ? void 0 : error2.code)) {
                throw new errors_1.NetworkError(error2 === null || error2 === void 0 ? void 0 : error2.code);
              }
              isRetryable = true;
              errorMessage = error2.message;
            }
            if (!isRetryable) {
              throw new Error(`Received non-retryable error: ${errorMessage}`);
            }
            if (attempt + 1 === this.maxAttempts) {
              throw new Error(`Failed to make request after ${this.maxAttempts} attempts: ${errorMessage}`);
            }
            const retryTimeMilliseconds = this.getExponentialRetryTimeMilliseconds(attempt);
            (0, core_1.info)(`Attempt ${attempt + 1} of ${this.maxAttempts} failed with error: ${errorMessage}. Retrying request in ${retryTimeMilliseconds} ms...`);
            yield this.sleep(retryTimeMilliseconds);
            attempt++;
          }
          throw new Error(`Request failed`);
        });
      }
      isSuccessStatusCode(statusCode) {
        if (!statusCode)
          return false;
        return statusCode >= 200 && statusCode < 300;
      }
      isRetryableHttpStatusCode(statusCode) {
        if (!statusCode)
          return false;
        const retryableStatusCodes = [
          http_client_1.HttpCodes.BadGateway,
          http_client_1.HttpCodes.GatewayTimeout,
          http_client_1.HttpCodes.InternalServerError,
          http_client_1.HttpCodes.ServiceUnavailable,
          http_client_1.HttpCodes.TooManyRequests
        ];
        return retryableStatusCodes.includes(statusCode);
      }
      sleep(milliseconds) {
        return __awaiter7(this, void 0, void 0, function* () {
          return new Promise((resolve) => setTimeout(resolve, milliseconds));
        });
      }
      getExponentialRetryTimeMilliseconds(attempt) {
        if (attempt < 0) {
          throw new Error("attempt should be a positive integer");
        }
        if (attempt === 0) {
          return this.baseRetryIntervalMilliseconds;
        }
        const minTime = this.baseRetryIntervalMilliseconds * Math.pow(this.retryMultiplier, attempt);
        const maxTime = minTime * this.retryMultiplier;
        return Math.trunc(Math.random() * (maxTime - minTime) + minTime);
      }
    };
    function internalCacheTwirpClient(options) {
      const client = new CacheServiceClient((0, user_agent_1.getUserAgentString)(), options === null || options === void 0 ? void 0 : options.maxAttempts, options === null || options === void 0 ? void 0 : options.retryIntervalMs, options === null || options === void 0 ? void 0 : options.retryMultiplier);
      return new cache_twirp_client_1.CacheServiceClientJSON(client);
    }
    exports.internalCacheTwirpClient = internalCacheTwirpClient;
  }
});

// node_modules/@actions/cache/lib/internal/tar.js
var require_tar = __commonJS({
  "node_modules/@actions/cache/lib/internal/tar.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTar = exports.extractTar = exports.listTar = void 0;
    var exec_1 = require_exec();
    var io = __importStar2(require_io());
    var fs_1 = __require("fs");
    var path2 = __importStar2(__require("path"));
    var utils = __importStar2(require_cacheUtils());
    var constants_1 = require_constants6();
    var IS_WINDOWS = process.platform === "win32";
    function getTarPath() {
      return __awaiter7(this, void 0, void 0, function* () {
        switch (process.platform) {
          case "win32": {
            const gnuTar = yield utils.getGnuTarPathOnWindows();
            const systemTar = constants_1.SystemTarPathOnWindows;
            if (gnuTar) {
              return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
            } else if ((0, fs_1.existsSync)(systemTar)) {
              return { path: systemTar, type: constants_1.ArchiveToolType.BSD };
            }
            break;
          }
          case "darwin": {
            const gnuTar = yield io.which("gtar", false);
            if (gnuTar) {
              return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
            } else {
              return {
                path: yield io.which("tar", true),
                type: constants_1.ArchiveToolType.BSD
              };
            }
          }
          default:
            break;
        }
        return {
          path: yield io.which("tar", true),
          type: constants_1.ArchiveToolType.GNU
        };
      });
    }
    function getTarArgs(tarPath, compressionMethod, type2, archivePath = "") {
      return __awaiter7(this, void 0, void 0, function* () {
        const args = [`"${tarPath.path}"`];
        const cacheFileName = utils.getCacheFileName(compressionMethod);
        const tarFile = "cache.tar";
        const workingDirectory = getWorkingDirectory();
        const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
        switch (type2) {
          case "create":
            args.push("--posix", "-cf", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "--exclude", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "--files-from", constants_1.ManifestFilename);
            break;
          case "extract":
            args.push("-xf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path2.sep}`, "g"), "/"));
            break;
          case "list":
            args.push("-tf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "-P");
            break;
        }
        if (tarPath.type === constants_1.ArchiveToolType.GNU) {
          switch (process.platform) {
            case "win32":
              args.push("--force-local");
              break;
            case "darwin":
              args.push("--delay-directory-restore");
              break;
          }
        }
        return args;
      });
    }
    function getCommands(compressionMethod, type2, archivePath = "") {
      return __awaiter7(this, void 0, void 0, function* () {
        let args;
        const tarPath = yield getTarPath();
        const tarArgs = yield getTarArgs(tarPath, compressionMethod, type2, archivePath);
        const compressionArgs = type2 !== "create" ? yield getDecompressionProgram(tarPath, compressionMethod, archivePath) : yield getCompressionProgram(tarPath, compressionMethod);
        const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
        if (BSD_TAR_ZSTD && type2 !== "create") {
          args = [[...compressionArgs].join(" "), [...tarArgs].join(" ")];
        } else {
          args = [[...tarArgs].join(" "), [...compressionArgs].join(" ")];
        }
        if (BSD_TAR_ZSTD) {
          return args;
        }
        return [args.join(" ")];
      });
    }
    function getWorkingDirectory() {
      var _a;
      return (_a = process.env["GITHUB_WORKSPACE"]) !== null && _a !== void 0 ? _a : process.cwd();
    }
    function getDecompressionProgram(tarPath, compressionMethod, archivePath) {
      return __awaiter7(this, void 0, void 0, function* () {
        const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
        switch (compressionMethod) {
          case constants_1.CompressionMethod.Zstd:
            return BSD_TAR_ZSTD ? [
              "zstd -d --long=30 --force -o",
              constants_1.TarFilename,
              archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/")
            ] : [
              "--use-compress-program",
              IS_WINDOWS ? '"zstd -d --long=30"' : "unzstd --long=30"
            ];
          case constants_1.CompressionMethod.ZstdWithoutLong:
            return BSD_TAR_ZSTD ? [
              "zstd -d --force -o",
              constants_1.TarFilename,
              archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/")
            ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -d"' : "unzstd"];
          default:
            return ["-z"];
        }
      });
    }
    function getCompressionProgram(tarPath, compressionMethod) {
      return __awaiter7(this, void 0, void 0, function* () {
        const cacheFileName = utils.getCacheFileName(compressionMethod);
        const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
        switch (compressionMethod) {
          case constants_1.CompressionMethod.Zstd:
            return BSD_TAR_ZSTD ? [
              "zstd -T0 --long=30 --force -o",
              cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"),
              constants_1.TarFilename
            ] : [
              "--use-compress-program",
              IS_WINDOWS ? '"zstd -T0 --long=30"' : "zstdmt --long=30"
            ];
          case constants_1.CompressionMethod.ZstdWithoutLong:
            return BSD_TAR_ZSTD ? [
              "zstd -T0 --force -o",
              cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"),
              constants_1.TarFilename
            ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -T0"' : "zstdmt"];
          default:
            return ["-z"];
        }
      });
    }
    function execCommands(commands, cwd) {
      return __awaiter7(this, void 0, void 0, function* () {
        for (const command of commands) {
          try {
            yield (0, exec_1.exec)(command, void 0, {
              cwd,
              env: Object.assign(Object.assign({}, process.env), { MSYS: "winsymlinks:nativestrict" })
            });
          } catch (error2) {
            throw new Error(`${command.split(" ")[0]} failed with error: ${error2 === null || error2 === void 0 ? void 0 : error2.message}`);
          }
        }
      });
    }
    function listTar(archivePath, compressionMethod) {
      return __awaiter7(this, void 0, void 0, function* () {
        const commands = yield getCommands(compressionMethod, "list", archivePath);
        yield execCommands(commands);
      });
    }
    exports.listTar = listTar;
    function extractTar(archivePath, compressionMethod) {
      return __awaiter7(this, void 0, void 0, function* () {
        const workingDirectory = getWorkingDirectory();
        yield io.mkdirP(workingDirectory);
        const commands = yield getCommands(compressionMethod, "extract", archivePath);
        yield execCommands(commands);
      });
    }
    exports.extractTar = extractTar;
    function createTar(archiveFolder, sourceDirectories, compressionMethod) {
      return __awaiter7(this, void 0, void 0, function* () {
        (0, fs_1.writeFileSync)(path2.join(archiveFolder, constants_1.ManifestFilename), sourceDirectories.join("\n"));
        const commands = yield getCommands(compressionMethod, "create");
        yield execCommands(commands, archiveFolder);
      });
    }
    exports.createTar = createTar;
  }
});

// node_modules/@actions/cache/lib/cache.js
var require_cache4 = __commonJS({
  "node_modules/@actions/cache/lib/cache.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    }) : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.saveCache = exports.restoreCache = exports.isFeatureAvailable = exports.FinalizeCacheError = exports.ReserveCacheError = exports.ValidationError = void 0;
    var core = __importStar2(require_core());
    var path2 = __importStar2(__require("path"));
    var utils = __importStar2(require_cacheUtils());
    var cacheHttpClient = __importStar2(require_cacheHttpClient());
    var cacheTwirpClient = __importStar2(require_cacheTwirpClient());
    var config_1 = require_config();
    var tar_1 = require_tar();
    var http_client_1 = require_lib();
    var ValidationError = class _ValidationError extends Error {
      constructor(message) {
        super(message);
        this.name = "ValidationError";
        Object.setPrototypeOf(this, _ValidationError.prototype);
      }
    };
    exports.ValidationError = ValidationError;
    var ReserveCacheError = class _ReserveCacheError extends Error {
      constructor(message) {
        super(message);
        this.name = "ReserveCacheError";
        Object.setPrototypeOf(this, _ReserveCacheError.prototype);
      }
    };
    exports.ReserveCacheError = ReserveCacheError;
    var FinalizeCacheError = class _FinalizeCacheError extends Error {
      constructor(message) {
        super(message);
        this.name = "FinalizeCacheError";
        Object.setPrototypeOf(this, _FinalizeCacheError.prototype);
      }
    };
    exports.FinalizeCacheError = FinalizeCacheError;
    function checkPaths(paths) {
      if (!paths || paths.length === 0) {
        throw new ValidationError(`Path Validation Error: At least one directory or file path is required`);
      }
    }
    function checkKey(key) {
      if (key.length > 512) {
        throw new ValidationError(`Key Validation Error: ${key} cannot be larger than 512 characters.`);
      }
      const regex = /^[^,]*$/;
      if (!regex.test(key)) {
        throw new ValidationError(`Key Validation Error: ${key} cannot contain commas.`);
      }
    }
    function isFeatureAvailable() {
      const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
      switch (cacheServiceVersion) {
        case "v2":
          return !!process.env["ACTIONS_RESULTS_URL"];
        case "v1":
        default:
          return !!process.env["ACTIONS_CACHE_URL"];
      }
    }
    exports.isFeatureAvailable = isFeatureAvailable;
    function restoreCache2(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
      return __awaiter7(this, void 0, void 0, function* () {
        const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
        core.debug(`Cache service version: ${cacheServiceVersion}`);
        checkPaths(paths);
        switch (cacheServiceVersion) {
          case "v2":
            return yield restoreCacheV2(paths, primaryKey, restoreKeys, options, enableCrossOsArchive);
          case "v1":
          default:
            return yield restoreCacheV1(paths, primaryKey, restoreKeys, options, enableCrossOsArchive);
        }
      });
    }
    exports.restoreCache = restoreCache2;
    function restoreCacheV1(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
      return __awaiter7(this, void 0, void 0, function* () {
        restoreKeys = restoreKeys || [];
        const keys = [primaryKey, ...restoreKeys];
        core.debug("Resolved Keys:");
        core.debug(JSON.stringify(keys));
        if (keys.length > 10) {
          throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
        }
        for (const key of keys) {
          checkKey(key);
        }
        const compressionMethod = yield utils.getCompressionMethod();
        let archivePath = "";
        try {
          const cacheEntry = yield cacheHttpClient.getCacheEntry(keys, paths, {
            compressionMethod,
            enableCrossOsArchive
          });
          if (!(cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.archiveLocation)) {
            return void 0;
          }
          if (options === null || options === void 0 ? void 0 : options.lookupOnly) {
            core.info("Lookup only - skipping download");
            return cacheEntry.cacheKey;
          }
          archivePath = path2.join(yield utils.createTempDirectory(), utils.getCacheFileName(compressionMethod));
          core.debug(`Archive Path: ${archivePath}`);
          yield cacheHttpClient.downloadCache(cacheEntry.archiveLocation, archivePath, options);
          if (core.isDebug()) {
            yield (0, tar_1.listTar)(archivePath, compressionMethod);
          }
          const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
          core.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
          yield (0, tar_1.extractTar)(archivePath, compressionMethod);
          core.info("Cache restored successfully");
          return cacheEntry.cacheKey;
        } catch (error2) {
          const typedError = error2;
          if (typedError.name === ValidationError.name) {
            throw error2;
          } else {
            if (typedError instanceof http_client_1.HttpClientError && typeof typedError.statusCode === "number" && typedError.statusCode >= 500) {
              core.error(`Failed to restore: ${error2.message}`);
            } else {
              core.warning(`Failed to restore: ${error2.message}`);
            }
          }
        } finally {
          try {
            yield utils.unlinkFile(archivePath);
          } catch (error2) {
            core.debug(`Failed to delete archive: ${error2}`);
          }
        }
        return void 0;
      });
    }
    function restoreCacheV2(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
      return __awaiter7(this, void 0, void 0, function* () {
        options = Object.assign(Object.assign({}, options), { useAzureSdk: true });
        restoreKeys = restoreKeys || [];
        const keys = [primaryKey, ...restoreKeys];
        core.debug("Resolved Keys:");
        core.debug(JSON.stringify(keys));
        if (keys.length > 10) {
          throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
        }
        for (const key of keys) {
          checkKey(key);
        }
        let archivePath = "";
        try {
          const twirpClient = cacheTwirpClient.internalCacheTwirpClient();
          const compressionMethod = yield utils.getCompressionMethod();
          const request = {
            key: primaryKey,
            restoreKeys,
            version: utils.getCacheVersion(paths, compressionMethod, enableCrossOsArchive)
          };
          const response = yield twirpClient.GetCacheEntryDownloadURL(request);
          if (!response.ok) {
            core.debug(`Cache not found for version ${request.version} of keys: ${keys.join(", ")}`);
            return void 0;
          }
          const isRestoreKeyMatch = request.key !== response.matchedKey;
          if (isRestoreKeyMatch) {
            core.info(`Cache hit for restore-key: ${response.matchedKey}`);
          } else {
            core.info(`Cache hit for: ${response.matchedKey}`);
          }
          if (options === null || options === void 0 ? void 0 : options.lookupOnly) {
            core.info("Lookup only - skipping download");
            return response.matchedKey;
          }
          archivePath = path2.join(yield utils.createTempDirectory(), utils.getCacheFileName(compressionMethod));
          core.debug(`Archive path: ${archivePath}`);
          core.debug(`Starting download of archive to: ${archivePath}`);
          yield cacheHttpClient.downloadCache(response.signedDownloadUrl, archivePath, options);
          const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
          core.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
          if (core.isDebug()) {
            yield (0, tar_1.listTar)(archivePath, compressionMethod);
          }
          yield (0, tar_1.extractTar)(archivePath, compressionMethod);
          core.info("Cache restored successfully");
          return response.matchedKey;
        } catch (error2) {
          const typedError = error2;
          if (typedError.name === ValidationError.name) {
            throw error2;
          } else {
            if (typedError instanceof http_client_1.HttpClientError && typeof typedError.statusCode === "number" && typedError.statusCode >= 500) {
              core.error(`Failed to restore: ${error2.message}`);
            } else {
              core.warning(`Failed to restore: ${error2.message}`);
            }
          }
        } finally {
          try {
            if (archivePath) {
              yield utils.unlinkFile(archivePath);
            }
          } catch (error2) {
            core.debug(`Failed to delete archive: ${error2}`);
          }
        }
        return void 0;
      });
    }
    function saveCache2(paths, key, options, enableCrossOsArchive = false) {
      return __awaiter7(this, void 0, void 0, function* () {
        const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
        core.debug(`Cache service version: ${cacheServiceVersion}`);
        checkPaths(paths);
        checkKey(key);
        switch (cacheServiceVersion) {
          case "v2":
            return yield saveCacheV2(paths, key, options, enableCrossOsArchive);
          case "v1":
          default:
            return yield saveCacheV1(paths, key, options, enableCrossOsArchive);
        }
      });
    }
    exports.saveCache = saveCache2;
    function saveCacheV1(paths, key, options, enableCrossOsArchive = false) {
      var _a, _b, _c, _d, _e;
      return __awaiter7(this, void 0, void 0, function* () {
        const compressionMethod = yield utils.getCompressionMethod();
        let cacheId = -1;
        const cachePaths = yield utils.resolvePaths(paths);
        core.debug("Cache Paths:");
        core.debug(`${JSON.stringify(cachePaths)}`);
        if (cachePaths.length === 0) {
          throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
        }
        const archiveFolder = yield utils.createTempDirectory();
        const archivePath = path2.join(archiveFolder, utils.getCacheFileName(compressionMethod));
        core.debug(`Archive Path: ${archivePath}`);
        try {
          yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
          if (core.isDebug()) {
            yield (0, tar_1.listTar)(archivePath, compressionMethod);
          }
          const fileSizeLimit = 10 * 1024 * 1024 * 1024;
          const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
          core.debug(`File Size: ${archiveFileSize}`);
          if (archiveFileSize > fileSizeLimit && !(0, config_1.isGhes)()) {
            throw new Error(`Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the 10GB limit, not saving cache.`);
          }
          core.debug("Reserving Cache");
          const reserveCacheResponse = yield cacheHttpClient.reserveCache(key, paths, {
            compressionMethod,
            enableCrossOsArchive,
            cacheSize: archiveFileSize
          });
          if ((_a = reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.result) === null || _a === void 0 ? void 0 : _a.cacheId) {
            cacheId = (_b = reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.result) === null || _b === void 0 ? void 0 : _b.cacheId;
          } else if ((reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.statusCode) === 400) {
            throw new Error((_d = (_c = reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.error) === null || _c === void 0 ? void 0 : _c.message) !== null && _d !== void 0 ? _d : `Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the data cap limit, not saving cache.`);
          } else {
            throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache. More details: ${(_e = reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.error) === null || _e === void 0 ? void 0 : _e.message}`);
          }
          core.debug(`Saving Cache (ID: ${cacheId})`);
          yield cacheHttpClient.saveCache(cacheId, archivePath, "", options);
        } catch (error2) {
          const typedError = error2;
          if (typedError.name === ValidationError.name) {
            throw error2;
          } else if (typedError.name === ReserveCacheError.name) {
            core.info(`Failed to save: ${typedError.message}`);
          } else {
            if (typedError instanceof http_client_1.HttpClientError && typeof typedError.statusCode === "number" && typedError.statusCode >= 500) {
              core.error(`Failed to save: ${typedError.message}`);
            } else {
              core.warning(`Failed to save: ${typedError.message}`);
            }
          }
        } finally {
          try {
            yield utils.unlinkFile(archivePath);
          } catch (error2) {
            core.debug(`Failed to delete archive: ${error2}`);
          }
        }
        return cacheId;
      });
    }
    function saveCacheV2(paths, key, options, enableCrossOsArchive = false) {
      return __awaiter7(this, void 0, void 0, function* () {
        options = Object.assign(Object.assign({}, options), { uploadChunkSize: 64 * 1024 * 1024, uploadConcurrency: 8, useAzureSdk: true });
        const compressionMethod = yield utils.getCompressionMethod();
        const twirpClient = cacheTwirpClient.internalCacheTwirpClient();
        let cacheId = -1;
        const cachePaths = yield utils.resolvePaths(paths);
        core.debug("Cache Paths:");
        core.debug(`${JSON.stringify(cachePaths)}`);
        if (cachePaths.length === 0) {
          throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
        }
        const archiveFolder = yield utils.createTempDirectory();
        const archivePath = path2.join(archiveFolder, utils.getCacheFileName(compressionMethod));
        core.debug(`Archive Path: ${archivePath}`);
        try {
          yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
          if (core.isDebug()) {
            yield (0, tar_1.listTar)(archivePath, compressionMethod);
          }
          const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
          core.debug(`File Size: ${archiveFileSize}`);
          options.archiveSizeBytes = archiveFileSize;
          core.debug("Reserving Cache");
          const version = utils.getCacheVersion(paths, compressionMethod, enableCrossOsArchive);
          const request = {
            key,
            version
          };
          let signedUploadUrl;
          try {
            const response = yield twirpClient.CreateCacheEntry(request);
            if (!response.ok) {
              if (response.message) {
                core.warning(`Cache reservation failed: ${response.message}`);
              }
              throw new Error(response.message || "Response was not ok");
            }
            signedUploadUrl = response.signedUploadUrl;
          } catch (error2) {
            core.debug(`Failed to reserve cache: ${error2}`);
            throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache.`);
          }
          core.debug(`Attempting to upload cache located at: ${archivePath}`);
          yield cacheHttpClient.saveCache(cacheId, archivePath, signedUploadUrl, options);
          const finalizeRequest = {
            key,
            version,
            sizeBytes: `${archiveFileSize}`
          };
          const finalizeResponse = yield twirpClient.FinalizeCacheEntryUpload(finalizeRequest);
          core.debug(`FinalizeCacheEntryUploadResponse: ${finalizeResponse.ok}`);
          if (!finalizeResponse.ok) {
            if (finalizeResponse.message) {
              throw new FinalizeCacheError(finalizeResponse.message);
            }
            throw new Error(`Unable to finalize cache with key ${key}, another job may be finalizing this cache.`);
          }
          cacheId = parseInt(finalizeResponse.entryId);
        } catch (error2) {
          const typedError = error2;
          if (typedError.name === ValidationError.name) {
            throw error2;
          } else if (typedError.name === ReserveCacheError.name) {
            core.info(`Failed to save: ${typedError.message}`);
          } else if (typedError.name === FinalizeCacheError.name) {
            core.warning(typedError.message);
          } else {
            if (typedError instanceof http_client_1.HttpClientError && typeof typedError.statusCode === "number" && typedError.statusCode >= 500) {
              core.error(`Failed to save: ${typedError.message}`);
            } else {
              core.warning(`Failed to save: ${typedError.message}`);
            }
          }
        } finally {
          try {
            yield utils.unlinkFile(archivePath);
          } catch (error2) {
            core.debug(`Failed to delete archive: ${error2}`);
          }
        }
        return cacheId;
      });
    }
  }
});

// src/index.ts
var actionsCore2 = __toESM(require_core(), 1);
var actionsExec = __toESM(require_exec(), 1);

// node_modules/detsys-ts/dist/index.mjs
var actionsCore = __toESM(require_core(), 1);
var exec$1 = __toESM(require_exec(), 1);
import * as fs$1 from "fs";
import { constants, createWriteStream, readFileSync as readFileSync2 } from "fs";
import * as os$1 from "os";
import { tmpdir } from "os";
import { promisify as promisify4 } from "util";
import os2 from "os";
import fs, { chmod, copyFile, mkdir, readFile as readFile2, readdir, stat } from "fs/promises";
import { gzip } from "zlib";
import { createHash, randomUUID as randomUUID2 } from "crypto";

// node_modules/got/dist/source/create.js
import { setTimeout as delay } from "timers/promises";

// node_modules/@sindresorhus/is/distribution/utilities.js
function keysOf(value) {
  return Object.keys(value);
}

// node_modules/@sindresorhus/is/distribution/index.js
var typedArrayTypeNames = [
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function isTypedArrayName(name) {
  return typedArrayTypeNames.includes(name);
}
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Blob",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "WeakRef",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "FormData",
  "URLSearchParams",
  "HTMLElement",
  "NaN",
  ...typedArrayTypeNames
];
function isObjectTypeName(name) {
  return objectTypeNames.includes(name);
}
var primitiveTypeNames = [
  "null",
  "undefined",
  "string",
  "number",
  "bigint",
  "boolean",
  "symbol"
];
function isPrimitiveTypeName(name) {
  return primitiveTypeNames.includes(name);
}
var assertionTypeDescriptions = [
  "positive number",
  "negative number",
  "Class",
  "string with a number",
  "null or undefined",
  "Iterable",
  "AsyncIterable",
  "native Promise",
  "EnumCase",
  "string with a URL",
  "truthy",
  "falsy",
  "primitive",
  "integer",
  "plain object",
  "TypedArray",
  "array-like",
  "tuple-like",
  "Node.js Stream",
  "infinite number",
  "empty array",
  "non-empty array",
  "empty string",
  "empty string or whitespace",
  "non-empty string",
  "non-empty string and not whitespace",
  "empty object",
  "non-empty object",
  "empty set",
  "non-empty set",
  "empty map",
  "non-empty map",
  "PropertyKey",
  "even integer",
  "odd integer",
  "T",
  "in range",
  "predicate returns truthy for any value",
  "predicate returns truthy for all values",
  "valid Date",
  "valid length",
  "whitespace string",
  ...objectTypeNames,
  ...primitiveTypeNames
];
var getObjectType = (value) => {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (/HTML\w+Element/.test(objectTypeName) && isHtmlElement(value)) {
    return "HTMLElement";
  }
  if (isObjectTypeName(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
};
function detect(value) {
  if (value === null) {
    return "null";
  }
  switch (typeof value) {
    case "undefined": {
      return "undefined";
    }
    case "string": {
      return "string";
    }
    case "number": {
      return Number.isNaN(value) ? "NaN" : "number";
    }
    case "boolean": {
      return "boolean";
    }
    case "function": {
      return "Function";
    }
    case "bigint": {
      return "bigint";
    }
    case "symbol": {
      return "symbol";
    }
    default:
  }
  if (isObservable(value)) {
    return "Observable";
  }
  if (isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const tagType = getObjectType(value);
  if (tagType && tagType !== "Object") {
    return tagType;
  }
  if (hasPromiseApi(value)) {
    return "Promise";
  }
  if (value instanceof String || value instanceof Boolean || value instanceof Number) {
    throw new TypeError("Please don't use object wrappers for primitive types");
  }
  return "Object";
}
function hasPromiseApi(value) {
  return isFunction(value?.then) && isFunction(value?.catch);
}
var is = Object.assign(detect, {
  all: isAll,
  any: isAny,
  array: isArray,
  arrayBuffer: isArrayBuffer,
  arrayLike: isArrayLike,
  asyncFunction: isAsyncFunction,
  asyncGenerator: isAsyncGenerator,
  asyncGeneratorFunction: isAsyncGeneratorFunction,
  asyncIterable: isAsyncIterable,
  bigint: isBigint,
  bigInt64Array: isBigInt64Array,
  bigUint64Array: isBigUint64Array,
  blob: isBlob,
  boolean: isBoolean,
  boundFunction: isBoundFunction,
  buffer: isBuffer,
  class: isClass,
  dataView: isDataView,
  date: isDate,
  detect,
  directInstanceOf: isDirectInstanceOf,
  emptyArray: isEmptyArray,
  emptyMap: isEmptyMap,
  emptyObject: isEmptyObject,
  emptySet: isEmptySet,
  emptyString: isEmptyString,
  emptyStringOrWhitespace: isEmptyStringOrWhitespace,
  enumCase: isEnumCase,
  error: isError,
  evenInteger: isEvenInteger,
  falsy: isFalsy,
  float32Array: isFloat32Array,
  float64Array: isFloat64Array,
  formData: isFormData,
  function: isFunction,
  generator: isGenerator,
  generatorFunction: isGeneratorFunction,
  htmlElement: isHtmlElement,
  infinite: isInfinite,
  inRange: isInRange,
  int16Array: isInt16Array,
  int32Array: isInt32Array,
  int8Array: isInt8Array,
  integer: isInteger,
  iterable: isIterable,
  map: isMap,
  nan: isNan,
  nativePromise: isNativePromise,
  negativeNumber: isNegativeNumber,
  nodeStream: isNodeStream,
  nonEmptyArray: isNonEmptyArray,
  nonEmptyMap: isNonEmptyMap,
  nonEmptyObject: isNonEmptyObject,
  nonEmptySet: isNonEmptySet,
  nonEmptyString: isNonEmptyString,
  nonEmptyStringAndNotWhitespace: isNonEmptyStringAndNotWhitespace,
  null: isNull,
  nullOrUndefined: isNullOrUndefined,
  number: isNumber,
  numericString: isNumericString,
  object: isObject,
  observable: isObservable,
  oddInteger: isOddInteger,
  plainObject: isPlainObject,
  positiveNumber: isPositiveNumber,
  primitive: isPrimitive,
  promise: isPromise,
  propertyKey: isPropertyKey,
  regExp: isRegExp,
  safeInteger: isSafeInteger,
  set: isSet,
  sharedArrayBuffer: isSharedArrayBuffer,
  string: isString,
  symbol: isSymbol,
  truthy: isTruthy,
  tupleLike: isTupleLike,
  typedArray: isTypedArray,
  uint16Array: isUint16Array,
  uint32Array: isUint32Array,
  uint8Array: isUint8Array,
  uint8ClampedArray: isUint8ClampedArray,
  undefined: isUndefined,
  urlInstance: isUrlInstance,
  urlSearchParams: isUrlSearchParams,
  urlString: isUrlString,
  optional: isOptional,
  validDate: isValidDate,
  validLength: isValidLength,
  weakMap: isWeakMap,
  weakRef: isWeakRef,
  weakSet: isWeakSet,
  whitespaceString: isWhitespaceString
});
function isAbsoluteModule2(remainder) {
  return (value) => isInteger(value) && Math.abs(value % 2) === remainder;
}
function isAll(predicate, ...values) {
  return predicateOnArray(Array.prototype.every, predicate, values);
}
function isAny(predicate, ...values) {
  const predicates = isArray(predicate) ? predicate : [predicate];
  return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
}
function isOptional(value, predicate) {
  return isUndefined(value) || predicate(value);
}
function isArray(value, assertion) {
  if (!Array.isArray(value)) {
    return false;
  }
  if (!isFunction(assertion)) {
    return true;
  }
  return value.every((element) => assertion(element));
}
function isArrayBuffer(value) {
  return getObjectType(value) === "ArrayBuffer";
}
function isArrayLike(value) {
  return !isNullOrUndefined(value) && !isFunction(value) && isValidLength(value.length);
}
function isAsyncFunction(value) {
  return getObjectType(value) === "AsyncFunction";
}
function isAsyncGenerator(value) {
  return isAsyncIterable(value) && isFunction(value.next) && isFunction(value.throw);
}
function isAsyncGeneratorFunction(value) {
  return getObjectType(value) === "AsyncGeneratorFunction";
}
function isAsyncIterable(value) {
  return isFunction(value?.[Symbol.asyncIterator]);
}
function isBigint(value) {
  return typeof value === "bigint";
}
function isBigInt64Array(value) {
  return getObjectType(value) === "BigInt64Array";
}
function isBigUint64Array(value) {
  return getObjectType(value) === "BigUint64Array";
}
function isBlob(value) {
  return getObjectType(value) === "Blob";
}
function isBoolean(value) {
  return value === true || value === false;
}
function isBoundFunction(value) {
  return isFunction(value) && !Object.hasOwn(value, "prototype");
}
function isBuffer(value) {
  return value?.constructor?.isBuffer?.(value) ?? false;
}
function isClass(value) {
  return isFunction(value) && /^class(\s+|{)/.test(value.toString());
}
function isDataView(value) {
  return getObjectType(value) === "DataView";
}
function isDate(value) {
  return getObjectType(value) === "Date";
}
function isDirectInstanceOf(instance, class_) {
  if (instance === void 0 || instance === null) {
    return false;
  }
  return Object.getPrototypeOf(instance) === class_.prototype;
}
function isEmptyArray(value) {
  return isArray(value) && value.length === 0;
}
function isEmptyMap(value) {
  return isMap(value) && value.size === 0;
}
function isEmptyObject(value) {
  return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length === 0;
}
function isEmptySet(value) {
  return isSet(value) && value.size === 0;
}
function isEmptyString(value) {
  return isString(value) && value.length === 0;
}
function isEmptyStringOrWhitespace(value) {
  return isEmptyString(value) || isWhitespaceString(value);
}
function isEnumCase(value, targetEnum) {
  return Object.values(targetEnum).includes(value);
}
function isError(value) {
  return getObjectType(value) === "Error";
}
function isEvenInteger(value) {
  return isAbsoluteModule2(0)(value);
}
function isFalsy(value) {
  return !value;
}
function isFloat32Array(value) {
  return getObjectType(value) === "Float32Array";
}
function isFloat64Array(value) {
  return getObjectType(value) === "Float64Array";
}
function isFormData(value) {
  return getObjectType(value) === "FormData";
}
function isFunction(value) {
  return typeof value === "function";
}
function isGenerator(value) {
  return isIterable(value) && isFunction(value?.next) && isFunction(value?.throw);
}
function isGeneratorFunction(value) {
  return getObjectType(value) === "GeneratorFunction";
}
var NODE_TYPE_ELEMENT = 1;
var DOM_PROPERTIES_TO_CHECK = [
  "innerHTML",
  "ownerDocument",
  "style",
  "attributes",
  "nodeValue"
];
function isHtmlElement(value) {
  return isObject(value) && value.nodeType === NODE_TYPE_ELEMENT && isString(value.nodeName) && !isPlainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
}
function isInfinite(value) {
  return value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
}
function isInRange(value, range) {
  if (isNumber(range)) {
    return value >= Math.min(0, range) && value <= Math.max(range, 0);
  }
  if (isArray(range) && range.length === 2) {
    return value >= Math.min(...range) && value <= Math.max(...range);
  }
  throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
}
function isInt16Array(value) {
  return getObjectType(value) === "Int16Array";
}
function isInt32Array(value) {
  return getObjectType(value) === "Int32Array";
}
function isInt8Array(value) {
  return getObjectType(value) === "Int8Array";
}
function isInteger(value) {
  return Number.isInteger(value);
}
function isIterable(value) {
  return isFunction(value?.[Symbol.iterator]);
}
function isMap(value) {
  return getObjectType(value) === "Map";
}
function isNan(value) {
  return Number.isNaN(value);
}
function isNativePromise(value) {
  return getObjectType(value) === "Promise";
}
function isNegativeNumber(value) {
  return isNumber(value) && value < 0;
}
function isNodeStream(value) {
  return isObject(value) && isFunction(value.pipe) && !isObservable(value);
}
function isNonEmptyArray(value) {
  return isArray(value) && value.length > 0;
}
function isNonEmptyMap(value) {
  return isMap(value) && value.size > 0;
}
function isNonEmptyObject(value) {
  return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length > 0;
}
function isNonEmptySet(value) {
  return isSet(value) && value.size > 0;
}
function isNonEmptyString(value) {
  return isString(value) && value.length > 0;
}
function isNonEmptyStringAndNotWhitespace(value) {
  return isString(value) && !isEmptyStringOrWhitespace(value);
}
function isNull(value) {
  return value === null;
}
function isNullOrUndefined(value) {
  return isNull(value) || isUndefined(value);
}
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
function isNumericString(value) {
  return isString(value) && !isEmptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
}
function isObject(value) {
  return !isNull(value) && (typeof value === "object" || isFunction(value));
}
function isObservable(value) {
  if (!value) {
    return false;
  }
  if (Symbol.observable !== void 0 && value === value[Symbol.observable]?.()) {
    return true;
  }
  if (value === value["@@observable"]?.()) {
    return true;
  }
  return false;
}
function isOddInteger(value) {
  return isAbsoluteModule2(1)(value);
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function isPositiveNumber(value) {
  return isNumber(value) && value > 0;
}
function isPrimitive(value) {
  return isNull(value) || isPrimitiveTypeName(typeof value);
}
function isPromise(value) {
  return isNativePromise(value) || hasPromiseApi(value);
}
function isPropertyKey(value) {
  return isAny([isString, isNumber, isSymbol], value);
}
function isRegExp(value) {
  return getObjectType(value) === "RegExp";
}
function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}
function isSet(value) {
  return getObjectType(value) === "Set";
}
function isSharedArrayBuffer(value) {
  return getObjectType(value) === "SharedArrayBuffer";
}
function isString(value) {
  return typeof value === "string";
}
function isSymbol(value) {
  return typeof value === "symbol";
}
function isTruthy(value) {
  return Boolean(value);
}
function isTupleLike(value, guards) {
  if (isArray(guards) && isArray(value) && guards.length === value.length) {
    return guards.every((guard, index) => guard(value[index]));
  }
  return false;
}
function isTypedArray(value) {
  return isTypedArrayName(getObjectType(value));
}
function isUint16Array(value) {
  return getObjectType(value) === "Uint16Array";
}
function isUint32Array(value) {
  return getObjectType(value) === "Uint32Array";
}
function isUint8Array(value) {
  return getObjectType(value) === "Uint8Array";
}
function isUint8ClampedArray(value) {
  return getObjectType(value) === "Uint8ClampedArray";
}
function isUndefined(value) {
  return value === void 0;
}
function isUrlInstance(value) {
  return getObjectType(value) === "URL";
}
function isUrlSearchParams(value) {
  return getObjectType(value) === "URLSearchParams";
}
function isUrlString(value) {
  if (!isString(value)) {
    return false;
  }
  try {
    new URL(value);
    return true;
  } catch {
    return false;
  }
}
function isValidDate(value) {
  return isDate(value) && !isNan(Number(value));
}
function isValidLength(value) {
  return isSafeInteger(value) && value >= 0;
}
function isWeakMap(value) {
  return getObjectType(value) === "WeakMap";
}
function isWeakRef(value) {
  return getObjectType(value) === "WeakRef";
}
function isWeakSet(value) {
  return getObjectType(value) === "WeakSet";
}
function isWhitespaceString(value) {
  return isString(value) && /^\s+$/.test(value);
}
function predicateOnArray(method, predicate, values) {
  if (!isFunction(predicate)) {
    throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
  }
  if (values.length === 0) {
    throw new TypeError("Invalid number of values");
  }
  return method.call(values, predicate);
}
function typeErrorMessage(description, value) {
  return `Expected value which is \`${description}\`, received value of type \`${is(value)}\`.`;
}
function unique(values) {
  return Array.from(new Set(values));
}
var andFormatter = new Intl.ListFormat("en", { style: "long", type: "conjunction" });
var orFormatter = new Intl.ListFormat("en", { style: "long", type: "disjunction" });
function typeErrorMessageMultipleValues(expectedType, values) {
  const uniqueExpectedTypes = unique((isArray(expectedType) ? expectedType : [expectedType]).map((value) => `\`${value}\``));
  const uniqueValueTypes = unique(values.map((value) => `\`${is(value)}\``));
  return `Expected values which are ${orFormatter.format(uniqueExpectedTypes)}. Received values of type${uniqueValueTypes.length > 1 ? "s" : ""} ${andFormatter.format(uniqueValueTypes)}.`;
}
var assert = {
  all: assertAll,
  any: assertAny,
  optional: assertOptional,
  array: assertArray,
  arrayBuffer: assertArrayBuffer,
  arrayLike: assertArrayLike,
  asyncFunction: assertAsyncFunction,
  asyncGenerator: assertAsyncGenerator,
  asyncGeneratorFunction: assertAsyncGeneratorFunction,
  asyncIterable: assertAsyncIterable,
  bigint: assertBigint,
  bigInt64Array: assertBigInt64Array,
  bigUint64Array: assertBigUint64Array,
  blob: assertBlob,
  boolean: assertBoolean,
  boundFunction: assertBoundFunction,
  buffer: assertBuffer,
  class: assertClass,
  dataView: assertDataView,
  date: assertDate,
  directInstanceOf: assertDirectInstanceOf,
  emptyArray: assertEmptyArray,
  emptyMap: assertEmptyMap,
  emptyObject: assertEmptyObject,
  emptySet: assertEmptySet,
  emptyString: assertEmptyString,
  emptyStringOrWhitespace: assertEmptyStringOrWhitespace,
  enumCase: assertEnumCase,
  error: assertError,
  evenInteger: assertEvenInteger,
  falsy: assertFalsy,
  float32Array: assertFloat32Array,
  float64Array: assertFloat64Array,
  formData: assertFormData,
  function: assertFunction,
  generator: assertGenerator,
  generatorFunction: assertGeneratorFunction,
  htmlElement: assertHtmlElement,
  infinite: assertInfinite,
  inRange: assertInRange,
  int16Array: assertInt16Array,
  int32Array: assertInt32Array,
  int8Array: assertInt8Array,
  integer: assertInteger,
  iterable: assertIterable,
  map: assertMap,
  nan: assertNan,
  nativePromise: assertNativePromise,
  negativeNumber: assertNegativeNumber,
  nodeStream: assertNodeStream,
  nonEmptyArray: assertNonEmptyArray,
  nonEmptyMap: assertNonEmptyMap,
  nonEmptyObject: assertNonEmptyObject,
  nonEmptySet: assertNonEmptySet,
  nonEmptyString: assertNonEmptyString,
  nonEmptyStringAndNotWhitespace: assertNonEmptyStringAndNotWhitespace,
  null: assertNull,
  nullOrUndefined: assertNullOrUndefined,
  number: assertNumber,
  numericString: assertNumericString,
  object: assertObject,
  observable: assertObservable,
  oddInteger: assertOddInteger,
  plainObject: assertPlainObject,
  positiveNumber: assertPositiveNumber,
  primitive: assertPrimitive,
  promise: assertPromise,
  propertyKey: assertPropertyKey,
  regExp: assertRegExp,
  safeInteger: assertSafeInteger,
  set: assertSet,
  sharedArrayBuffer: assertSharedArrayBuffer,
  string: assertString,
  symbol: assertSymbol,
  truthy: assertTruthy,
  tupleLike: assertTupleLike,
  typedArray: assertTypedArray,
  uint16Array: assertUint16Array,
  uint32Array: assertUint32Array,
  uint8Array: assertUint8Array,
  uint8ClampedArray: assertUint8ClampedArray,
  undefined: assertUndefined,
  urlInstance: assertUrlInstance,
  urlSearchParams: assertUrlSearchParams,
  urlString: assertUrlString,
  validDate: assertValidDate,
  validLength: assertValidLength,
  weakMap: assertWeakMap,
  weakRef: assertWeakRef,
  weakSet: assertWeakSet,
  whitespaceString: assertWhitespaceString
};
var methodTypeMap = {
  isArray: "Array",
  isArrayBuffer: "ArrayBuffer",
  isArrayLike: "array-like",
  isAsyncFunction: "AsyncFunction",
  isAsyncGenerator: "AsyncGenerator",
  isAsyncGeneratorFunction: "AsyncGeneratorFunction",
  isAsyncIterable: "AsyncIterable",
  isBigint: "bigint",
  isBigInt64Array: "BigInt64Array",
  isBigUint64Array: "BigUint64Array",
  isBlob: "Blob",
  isBoolean: "boolean",
  isBoundFunction: "Function",
  isBuffer: "Buffer",
  isClass: "Class",
  isDataView: "DataView",
  isDate: "Date",
  isDirectInstanceOf: "T",
  isEmptyArray: "empty array",
  isEmptyMap: "empty map",
  isEmptyObject: "empty object",
  isEmptySet: "empty set",
  isEmptyString: "empty string",
  isEmptyStringOrWhitespace: "empty string or whitespace",
  isEnumCase: "EnumCase",
  isError: "Error",
  isEvenInteger: "even integer",
  isFalsy: "falsy",
  isFloat32Array: "Float32Array",
  isFloat64Array: "Float64Array",
  isFormData: "FormData",
  isFunction: "Function",
  isGenerator: "Generator",
  isGeneratorFunction: "GeneratorFunction",
  isHtmlElement: "HTMLElement",
  isInfinite: "infinite number",
  isInRange: "in range",
  isInt16Array: "Int16Array",
  isInt32Array: "Int32Array",
  isInt8Array: "Int8Array",
  isInteger: "integer",
  isIterable: "Iterable",
  isMap: "Map",
  isNan: "NaN",
  isNativePromise: "native Promise",
  isNegativeNumber: "negative number",
  isNodeStream: "Node.js Stream",
  isNonEmptyArray: "non-empty array",
  isNonEmptyMap: "non-empty map",
  isNonEmptyObject: "non-empty object",
  isNonEmptySet: "non-empty set",
  isNonEmptyString: "non-empty string",
  isNonEmptyStringAndNotWhitespace: "non-empty string and not whitespace",
  isNull: "null",
  isNullOrUndefined: "null or undefined",
  isNumber: "number",
  isNumericString: "string with a number",
  isObject: "Object",
  isObservable: "Observable",
  isOddInteger: "odd integer",
  isPlainObject: "plain object",
  isPositiveNumber: "positive number",
  isPrimitive: "primitive",
  isPromise: "Promise",
  isPropertyKey: "PropertyKey",
  isRegExp: "RegExp",
  isSafeInteger: "integer",
  isSet: "Set",
  isSharedArrayBuffer: "SharedArrayBuffer",
  isString: "string",
  isSymbol: "symbol",
  isTruthy: "truthy",
  isTupleLike: "tuple-like",
  isTypedArray: "TypedArray",
  isUint16Array: "Uint16Array",
  isUint32Array: "Uint32Array",
  isUint8Array: "Uint8Array",
  isUint8ClampedArray: "Uint8ClampedArray",
  isUndefined: "undefined",
  isUrlInstance: "URL",
  isUrlSearchParams: "URLSearchParams",
  isUrlString: "string with a URL",
  isValidDate: "valid Date",
  isValidLength: "valid length",
  isWeakMap: "WeakMap",
  isWeakRef: "WeakRef",
  isWeakSet: "WeakSet",
  isWhitespaceString: "whitespace string"
};
var isMethodNames = keysOf(methodTypeMap);
function isIsMethodName(value) {
  return isMethodNames.includes(value);
}
function assertAll(predicate, ...values) {
  if (!isAll(predicate, ...values)) {
    const expectedType = isIsMethodName(predicate.name) ? methodTypeMap[predicate.name] : "predicate returns truthy for all values";
    throw new TypeError(typeErrorMessageMultipleValues(expectedType, values));
  }
}
function assertAny(predicate, ...values) {
  if (!isAny(predicate, ...values)) {
    const predicates = isArray(predicate) ? predicate : [predicate];
    const expectedTypes = predicates.map((predicate2) => isIsMethodName(predicate2.name) ? methodTypeMap[predicate2.name] : "predicate returns truthy for any value");
    throw new TypeError(typeErrorMessageMultipleValues(expectedTypes, values));
  }
}
function assertOptional(value, assertion, message) {
  if (!isUndefined(value)) {
    assertion(value, message);
  }
}
function assertArray(value, assertion, message) {
  if (!isArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("Array", value));
  }
  if (assertion) {
    for (const element of value) {
      assertion(element, message);
    }
  }
}
function assertArrayBuffer(value, message) {
  if (!isArrayBuffer(value)) {
    throw new TypeError(message ?? typeErrorMessage("ArrayBuffer", value));
  }
}
function assertArrayLike(value, message) {
  if (!isArrayLike(value)) {
    throw new TypeError(message ?? typeErrorMessage("array-like", value));
  }
}
function assertAsyncFunction(value, message) {
  if (!isAsyncFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("AsyncFunction", value));
  }
}
function assertAsyncGenerator(value, message) {
  if (!isAsyncGenerator(value)) {
    throw new TypeError(message ?? typeErrorMessage("AsyncGenerator", value));
  }
}
function assertAsyncGeneratorFunction(value, message) {
  if (!isAsyncGeneratorFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("AsyncGeneratorFunction", value));
  }
}
function assertAsyncIterable(value, message) {
  if (!isAsyncIterable(value)) {
    throw new TypeError(message ?? typeErrorMessage("AsyncIterable", value));
  }
}
function assertBigint(value, message) {
  if (!isBigint(value)) {
    throw new TypeError(message ?? typeErrorMessage("bigint", value));
  }
}
function assertBigInt64Array(value, message) {
  if (!isBigInt64Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("BigInt64Array", value));
  }
}
function assertBigUint64Array(value, message) {
  if (!isBigUint64Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("BigUint64Array", value));
  }
}
function assertBlob(value, message) {
  if (!isBlob(value)) {
    throw new TypeError(message ?? typeErrorMessage("Blob", value));
  }
}
function assertBoolean(value, message) {
  if (!isBoolean(value)) {
    throw new TypeError(message ?? typeErrorMessage("boolean", value));
  }
}
function assertBoundFunction(value, message) {
  if (!isBoundFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("Function", value));
  }
}
function assertBuffer(value, message) {
  if (!isBuffer(value)) {
    throw new TypeError(message ?? typeErrorMessage("Buffer", value));
  }
}
function assertClass(value, message) {
  if (!isClass(value)) {
    throw new TypeError(message ?? typeErrorMessage("Class", value));
  }
}
function assertDataView(value, message) {
  if (!isDataView(value)) {
    throw new TypeError(message ?? typeErrorMessage("DataView", value));
  }
}
function assertDate(value, message) {
  if (!isDate(value)) {
    throw new TypeError(message ?? typeErrorMessage("Date", value));
  }
}
function assertDirectInstanceOf(instance, class_, message) {
  if (!isDirectInstanceOf(instance, class_)) {
    throw new TypeError(message ?? typeErrorMessage("T", instance));
  }
}
function assertEmptyArray(value, message) {
  if (!isEmptyArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty array", value));
  }
}
function assertEmptyMap(value, message) {
  if (!isEmptyMap(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty map", value));
  }
}
function assertEmptyObject(value, message) {
  if (!isEmptyObject(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty object", value));
  }
}
function assertEmptySet(value, message) {
  if (!isEmptySet(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty set", value));
  }
}
function assertEmptyString(value, message) {
  if (!isEmptyString(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty string", value));
  }
}
function assertEmptyStringOrWhitespace(value, message) {
  if (!isEmptyStringOrWhitespace(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty string or whitespace", value));
  }
}
function assertEnumCase(value, targetEnum, message) {
  if (!isEnumCase(value, targetEnum)) {
    throw new TypeError(message ?? typeErrorMessage("EnumCase", value));
  }
}
function assertError(value, message) {
  if (!isError(value)) {
    throw new TypeError(message ?? typeErrorMessage("Error", value));
  }
}
function assertEvenInteger(value, message) {
  if (!isEvenInteger(value)) {
    throw new TypeError(message ?? typeErrorMessage("even integer", value));
  }
}
function assertFalsy(value, message) {
  if (!isFalsy(value)) {
    throw new TypeError(message ?? typeErrorMessage("falsy", value));
  }
}
function assertFloat32Array(value, message) {
  if (!isFloat32Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Float32Array", value));
  }
}
function assertFloat64Array(value, message) {
  if (!isFloat64Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Float64Array", value));
  }
}
function assertFormData(value, message) {
  if (!isFormData(value)) {
    throw new TypeError(message ?? typeErrorMessage("FormData", value));
  }
}
function assertFunction(value, message) {
  if (!isFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("Function", value));
  }
}
function assertGenerator(value, message) {
  if (!isGenerator(value)) {
    throw new TypeError(message ?? typeErrorMessage("Generator", value));
  }
}
function assertGeneratorFunction(value, message) {
  if (!isGeneratorFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("GeneratorFunction", value));
  }
}
function assertHtmlElement(value, message) {
  if (!isHtmlElement(value)) {
    throw new TypeError(message ?? typeErrorMessage("HTMLElement", value));
  }
}
function assertInfinite(value, message) {
  if (!isInfinite(value)) {
    throw new TypeError(message ?? typeErrorMessage("infinite number", value));
  }
}
function assertInRange(value, range, message) {
  if (!isInRange(value, range)) {
    throw new TypeError(message ?? typeErrorMessage("in range", value));
  }
}
function assertInt16Array(value, message) {
  if (!isInt16Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Int16Array", value));
  }
}
function assertInt32Array(value, message) {
  if (!isInt32Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Int32Array", value));
  }
}
function assertInt8Array(value, message) {
  if (!isInt8Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Int8Array", value));
  }
}
function assertInteger(value, message) {
  if (!isInteger(value)) {
    throw new TypeError(message ?? typeErrorMessage("integer", value));
  }
}
function assertIterable(value, message) {
  if (!isIterable(value)) {
    throw new TypeError(message ?? typeErrorMessage("Iterable", value));
  }
}
function assertMap(value, message) {
  if (!isMap(value)) {
    throw new TypeError(message ?? typeErrorMessage("Map", value));
  }
}
function assertNan(value, message) {
  if (!isNan(value)) {
    throw new TypeError(message ?? typeErrorMessage("NaN", value));
  }
}
function assertNativePromise(value, message) {
  if (!isNativePromise(value)) {
    throw new TypeError(message ?? typeErrorMessage("native Promise", value));
  }
}
function assertNegativeNumber(value, message) {
  if (!isNegativeNumber(value)) {
    throw new TypeError(message ?? typeErrorMessage("negative number", value));
  }
}
function assertNodeStream(value, message) {
  if (!isNodeStream(value)) {
    throw new TypeError(message ?? typeErrorMessage("Node.js Stream", value));
  }
}
function assertNonEmptyArray(value, message) {
  if (!isNonEmptyArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty array", value));
  }
}
function assertNonEmptyMap(value, message) {
  if (!isNonEmptyMap(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty map", value));
  }
}
function assertNonEmptyObject(value, message) {
  if (!isNonEmptyObject(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty object", value));
  }
}
function assertNonEmptySet(value, message) {
  if (!isNonEmptySet(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty set", value));
  }
}
function assertNonEmptyString(value, message) {
  if (!isNonEmptyString(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty string", value));
  }
}
function assertNonEmptyStringAndNotWhitespace(value, message) {
  if (!isNonEmptyStringAndNotWhitespace(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty string and not whitespace", value));
  }
}
function assertNull(value, message) {
  if (!isNull(value)) {
    throw new TypeError(message ?? typeErrorMessage("null", value));
  }
}
function assertNullOrUndefined(value, message) {
  if (!isNullOrUndefined(value)) {
    throw new TypeError(message ?? typeErrorMessage("null or undefined", value));
  }
}
function assertNumber(value, message) {
  if (!isNumber(value)) {
    throw new TypeError(message ?? typeErrorMessage("number", value));
  }
}
function assertNumericString(value, message) {
  if (!isNumericString(value)) {
    throw new TypeError(message ?? typeErrorMessage("string with a number", value));
  }
}
function assertObject(value, message) {
  if (!isObject(value)) {
    throw new TypeError(message ?? typeErrorMessage("Object", value));
  }
}
function assertObservable(value, message) {
  if (!isObservable(value)) {
    throw new TypeError(message ?? typeErrorMessage("Observable", value));
  }
}
function assertOddInteger(value, message) {
  if (!isOddInteger(value)) {
    throw new TypeError(message ?? typeErrorMessage("odd integer", value));
  }
}
function assertPlainObject(value, message) {
  if (!isPlainObject(value)) {
    throw new TypeError(message ?? typeErrorMessage("plain object", value));
  }
}
function assertPositiveNumber(value, message) {
  if (!isPositiveNumber(value)) {
    throw new TypeError(message ?? typeErrorMessage("positive number", value));
  }
}
function assertPrimitive(value, message) {
  if (!isPrimitive(value)) {
    throw new TypeError(message ?? typeErrorMessage("primitive", value));
  }
}
function assertPromise(value, message) {
  if (!isPromise(value)) {
    throw new TypeError(message ?? typeErrorMessage("Promise", value));
  }
}
function assertPropertyKey(value, message) {
  if (!isPropertyKey(value)) {
    throw new TypeError(message ?? typeErrorMessage("PropertyKey", value));
  }
}
function assertRegExp(value, message) {
  if (!isRegExp(value)) {
    throw new TypeError(message ?? typeErrorMessage("RegExp", value));
  }
}
function assertSafeInteger(value, message) {
  if (!isSafeInteger(value)) {
    throw new TypeError(message ?? typeErrorMessage("integer", value));
  }
}
function assertSet(value, message) {
  if (!isSet(value)) {
    throw new TypeError(message ?? typeErrorMessage("Set", value));
  }
}
function assertSharedArrayBuffer(value, message) {
  if (!isSharedArrayBuffer(value)) {
    throw new TypeError(message ?? typeErrorMessage("SharedArrayBuffer", value));
  }
}
function assertString(value, message) {
  if (!isString(value)) {
    throw new TypeError(message ?? typeErrorMessage("string", value));
  }
}
function assertSymbol(value, message) {
  if (!isSymbol(value)) {
    throw new TypeError(message ?? typeErrorMessage("symbol", value));
  }
}
function assertTruthy(value, message) {
  if (!isTruthy(value)) {
    throw new TypeError(message ?? typeErrorMessage("truthy", value));
  }
}
function assertTupleLike(value, guards, message) {
  if (!isTupleLike(value, guards)) {
    throw new TypeError(message ?? typeErrorMessage("tuple-like", value));
  }
}
function assertTypedArray(value, message) {
  if (!isTypedArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("TypedArray", value));
  }
}
function assertUint16Array(value, message) {
  if (!isUint16Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Uint16Array", value));
  }
}
function assertUint32Array(value, message) {
  if (!isUint32Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Uint32Array", value));
  }
}
function assertUint8Array(value, message) {
  if (!isUint8Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Uint8Array", value));
  }
}
function assertUint8ClampedArray(value, message) {
  if (!isUint8ClampedArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("Uint8ClampedArray", value));
  }
}
function assertUndefined(value, message) {
  if (!isUndefined(value)) {
    throw new TypeError(message ?? typeErrorMessage("undefined", value));
  }
}
function assertUrlInstance(value, message) {
  if (!isUrlInstance(value)) {
    throw new TypeError(message ?? typeErrorMessage("URL", value));
  }
}
function assertUrlSearchParams(value, message) {
  if (!isUrlSearchParams(value)) {
    throw new TypeError(message ?? typeErrorMessage("URLSearchParams", value));
  }
}
function assertUrlString(value, message) {
  if (!isUrlString(value)) {
    throw new TypeError(message ?? typeErrorMessage("string with a URL", value));
  }
}
function assertValidDate(value, message) {
  if (!isValidDate(value)) {
    throw new TypeError(message ?? typeErrorMessage("valid Date", value));
  }
}
function assertValidLength(value, message) {
  if (!isValidLength(value)) {
    throw new TypeError(message ?? typeErrorMessage("valid length", value));
  }
}
function assertWeakMap(value, message) {
  if (!isWeakMap(value)) {
    throw new TypeError(message ?? typeErrorMessage("WeakMap", value));
  }
}
function assertWeakRef(value, message) {
  if (!isWeakRef(value)) {
    throw new TypeError(message ?? typeErrorMessage("WeakRef", value));
  }
}
function assertWeakSet(value, message) {
  if (!isWeakSet(value)) {
    throw new TypeError(message ?? typeErrorMessage("WeakSet", value));
  }
}
function assertWhitespaceString(value, message) {
  if (!isWhitespaceString(value)) {
    throw new TypeError(message ?? typeErrorMessage("whitespace string", value));
  }
}
var distribution_default = is;

// node_modules/got/dist/source/as-promise/index.js
import { EventEmitter as EventEmitter2 } from "events";

// node_modules/p-cancelable/index.js
var CancelError = class extends Error {
  constructor(reason) {
    super(reason || "Promise was canceled");
    this.name = "CancelError";
  }
  get isCanceled() {
    return true;
  }
};
var promiseState = Object.freeze({
  pending: /* @__PURE__ */ Symbol("pending"),
  canceled: /* @__PURE__ */ Symbol("canceled"),
  resolved: /* @__PURE__ */ Symbol("resolved"),
  rejected: /* @__PURE__ */ Symbol("rejected")
});
var PCancelable = class _PCancelable {
  static fn(userFunction) {
    return (...arguments_) => new _PCancelable((resolve, reject, onCancel) => {
      arguments_.push(onCancel);
      userFunction(...arguments_).then(resolve, reject);
    });
  }
  #cancelHandlers = [];
  #rejectOnCancel = true;
  #state = promiseState.pending;
  #promise;
  #reject;
  constructor(executor) {
    this.#promise = new Promise((resolve, reject) => {
      this.#reject = reject;
      const onResolve = (value) => {
        if (this.#state !== promiseState.canceled || !onCancel.shouldReject) {
          resolve(value);
          this.#setState(promiseState.resolved);
        }
      };
      const onReject = (error2) => {
        if (this.#state !== promiseState.canceled || !onCancel.shouldReject) {
          reject(error2);
          this.#setState(promiseState.rejected);
        }
      };
      const onCancel = (handler) => {
        if (this.#state !== promiseState.pending) {
          throw new Error(`The \`onCancel\` handler was attached after the promise ${this.#state.description}.`);
        }
        this.#cancelHandlers.push(handler);
      };
      Object.defineProperties(onCancel, {
        shouldReject: {
          get: () => this.#rejectOnCancel,
          set: (boolean) => {
            this.#rejectOnCancel = boolean;
          }
        }
      });
      executor(onResolve, onReject, onCancel);
    });
  }
  // eslint-disable-next-line unicorn/no-thenable
  then(onFulfilled, onRejected) {
    return this.#promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this.#promise.catch(onRejected);
  }
  finally(onFinally) {
    return this.#promise.finally(onFinally);
  }
  cancel(reason) {
    if (this.#state !== promiseState.pending) {
      return;
    }
    this.#setState(promiseState.canceled);
    if (this.#cancelHandlers.length > 0) {
      try {
        for (const handler of this.#cancelHandlers) {
          handler();
        }
      } catch (error2) {
        this.#reject(error2);
        return;
      }
    }
    if (this.#rejectOnCancel) {
      this.#reject(new CancelError(reason));
    }
  }
  get isCanceled() {
    return this.#state === promiseState.canceled;
  }
  #setState(state) {
    if (this.#state === promiseState.pending) {
      this.#state = state;
    }
  }
};
Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

// node_modules/got/dist/source/core/errors.js
function isRequest(x) {
  return distribution_default.object(x) && "_onResponse" in x;
}
var RequestError = class extends Error {
  name = "RequestError";
  code = "ERR_GOT_REQUEST_ERROR";
  input;
  stack;
  response;
  request;
  timings;
  constructor(message, error2, self2) {
    super(message, { cause: error2 });
    Error.captureStackTrace(this, this.constructor);
    if (error2.code) {
      this.code = error2.code;
    }
    this.input = error2.input;
    if (isRequest(self2)) {
      Object.defineProperty(this, "request", {
        enumerable: false,
        value: self2
      });
      Object.defineProperty(this, "response", {
        enumerable: false,
        value: self2.response
      });
      this.options = self2.options;
    } else {
      this.options = self2;
    }
    this.timings = this.request?.timings;
    if (distribution_default.string(error2.stack) && distribution_default.string(this.stack)) {
      const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
      const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
      const errorStackTrace = error2.stack.slice(error2.stack.indexOf(error2.message) + error2.message.length).split("\n").reverse();
      while (errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0]) {
        thisStackTrace.shift();
      }
      this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
    }
  }
};
var MaxRedirectsError = class extends RequestError {
  name = "MaxRedirectsError";
  code = "ERR_TOO_MANY_REDIRECTS";
  constructor(request) {
    super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
  }
};
var HTTPError = class extends RequestError {
  name = "HTTPError";
  code = "ERR_NON_2XX_3XX_RESPONSE";
  constructor(response) {
    super(`Request failed with status code ${response.statusCode} (${response.statusMessage}): ${response.request.options.method} ${response.request.options.url.toString()}`, {}, response.request);
  }
};
var CacheError = class extends RequestError {
  name = "CacheError";
  constructor(error2, request) {
    super(error2.message, error2, request);
    if (this.code === "ERR_GOT_REQUEST_ERROR") {
      this.code = "ERR_CACHE_ACCESS";
    }
  }
};
var UploadError = class extends RequestError {
  name = "UploadError";
  constructor(error2, request) {
    super(error2.message, error2, request);
    if (this.code === "ERR_GOT_REQUEST_ERROR") {
      this.code = "ERR_UPLOAD";
    }
  }
};
var TimeoutError = class extends RequestError {
  name = "TimeoutError";
  timings;
  event;
  constructor(error2, timings, request) {
    super(error2.message, error2, request);
    this.event = error2.event;
    this.timings = timings;
  }
};
var ReadError = class extends RequestError {
  name = "ReadError";
  constructor(error2, request) {
    super(error2.message, error2, request);
    if (this.code === "ERR_GOT_REQUEST_ERROR") {
      this.code = "ERR_READING_RESPONSE_STREAM";
    }
  }
};
var RetryError = class extends RequestError {
  name = "RetryError";
  code = "ERR_RETRYING";
  constructor(request) {
    super("Retrying", {}, request);
  }
};
var AbortError = class extends RequestError {
  name = "AbortError";
  code = "ERR_ABORTED";
  constructor(request) {
    super("This operation was aborted.", {}, request);
  }
};

// node_modules/got/dist/source/core/index.js
import process3 from "process";
import { Buffer as Buffer3 } from "buffer";
import { Duplex } from "stream";
import http2, { ServerResponse } from "http";

// node_modules/byte-counter/utilities.js
var textEncoder = new TextEncoder();
function byteLength(data) {
  if (typeof data === "string") {
    return textEncoder.encode(data).byteLength;
  }
  if (ArrayBuffer.isView(data) || data instanceof ArrayBuffer || data instanceof SharedArrayBuffer) {
    return data.byteLength;
  }
  return 0;
}

// node_modules/cacheable-request/dist/index.js
import crypto2 from "crypto";
import EventEmitter from "events";
import stream, { PassThrough as PassThroughStream } from "stream";
import urlLib, { URL as URL2 } from "url";

// node_modules/get-stream/source/index.js
import { on } from "events";
import { finished } from "stream/promises";

// node_modules/is-stream/index.js
function isStream(stream2, { checkOpen = true } = {}) {
  return stream2 !== null && typeof stream2 === "object" && (stream2.writable || stream2.readable || !checkOpen || stream2.writable === void 0 && stream2.readable === void 0) && typeof stream2.pipe === "function";
}
function isReadableStream(stream2, { checkOpen = true } = {}) {
  return isStream(stream2, { checkOpen }) && (stream2.readable || !checkOpen) && typeof stream2.read === "function" && typeof stream2.readable === "boolean" && typeof stream2.readableObjectMode === "boolean" && typeof stream2.destroy === "function" && typeof stream2.destroyed === "boolean";
}

// node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js
var a = Object.getPrototypeOf(
  Object.getPrototypeOf(
    /* istanbul ignore next */
    async function* () {
    }
  ).prototype
);
var c = class {
  #t;
  #n;
  #r = false;
  #e = void 0;
  constructor(e, t) {
    this.#t = e, this.#n = t;
  }
  next() {
    const e = () => this.#s();
    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;
  }
  return(e) {
    const t = () => this.#i(e);
    return this.#e ? this.#e.then(t, t) : t();
  }
  async #s() {
    if (this.#r)
      return {
        done: true,
        value: void 0
      };
    let e;
    try {
      e = await this.#t.read();
    } catch (t) {
      throw this.#e = void 0, this.#r = true, this.#t.releaseLock(), t;
    }
    return e.done && (this.#e = void 0, this.#r = true, this.#t.releaseLock()), e;
  }
  async #i(e) {
    if (this.#r)
      return {
        done: true,
        value: e
      };
    if (this.#r = true, !this.#n) {
      const t = this.#t.cancel(e);
      return this.#t.releaseLock(), await t, {
        done: true,
        value: e
      };
    }
    return this.#t.releaseLock(), {
      done: true,
      value: e
    };
  }
};
var n = /* @__PURE__ */ Symbol();
function i() {
  return this[n].next();
}
Object.defineProperty(i, "name", { value: "next" });
function o(r) {
  return this[n].return(r);
}
Object.defineProperty(o, "name", { value: "return" });
var u = Object.create(a, {
  next: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: i
  },
  return: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: o
  }
});
function h({ preventCancel: r = false } = {}) {
  const e = this.getReader(), t = new c(
    e,
    r
  ), s = Object.create(u);
  return s[n] = t, s;
}

// node_modules/get-stream/source/stream.js
var getAsyncIterable = (stream2) => {
  if (isReadableStream(stream2, { checkOpen: false }) && nodeImports.on !== void 0) {
    return getStreamIterable(stream2);
  }
  if (typeof stream2?.[Symbol.asyncIterator] === "function") {
    return stream2;
  }
  if (toString.call(stream2) === "[object ReadableStream]") {
    return h.call(stream2);
  }
  throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.");
};
var { toString } = Object.prototype;
var getStreamIterable = async function* (stream2) {
  const controller = new AbortController();
  const state = {};
  handleStreamEnd(stream2, controller, state);
  try {
    for await (const [chunk2] of nodeImports.on(stream2, "data", { signal: controller.signal })) {
      yield chunk2;
    }
  } catch (error2) {
    if (state.error !== void 0) {
      throw state.error;
    } else if (!controller.signal.aborted) {
      throw error2;
    }
  } finally {
    stream2.destroy();
  }
};
var handleStreamEnd = async (stream2, controller, state) => {
  try {
    await nodeImports.finished(stream2, {
      cleanup: true,
      readable: true,
      writable: false,
      error: false
    });
  } catch (error2) {
    state.error = error2;
  } finally {
    controller.abort();
  }
};
var nodeImports = {};

// node_modules/get-stream/source/contents.js
var getStreamContents = async (stream2, { init: init2, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
  const asyncIterable = getAsyncIterable(stream2);
  const state = init2();
  state.length = 0;
  try {
    for await (const chunk2 of asyncIterable) {
      const chunkType = getChunkType(chunk2);
      const convertedChunk = convertChunk[chunkType](chunk2, state);
      appendChunk({
        convertedChunk,
        state,
        getSize,
        truncateChunk,
        addChunk,
        maxBuffer
      });
    }
    appendFinalChunk({
      state,
      convertChunk,
      getSize,
      truncateChunk,
      addChunk,
      getFinalChunk,
      maxBuffer
    });
    return finalize(state);
  } catch (error2) {
    const normalizedError = typeof error2 === "object" && error2 !== null ? error2 : new Error(error2);
    normalizedError.bufferedData = finalize(state);
    throw normalizedError;
  }
};
var appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
  const convertedChunk = getFinalChunk(state);
  if (convertedChunk !== void 0) {
    appendChunk({
      convertedChunk,
      state,
      getSize,
      truncateChunk,
      addChunk,
      maxBuffer
    });
  }
};
var appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
  const chunkSize = getSize(convertedChunk);
  const newLength = state.length + chunkSize;
  if (newLength <= maxBuffer) {
    addNewChunk(convertedChunk, state, addChunk, newLength);
    return;
  }
  const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
  if (truncatedChunk !== void 0) {
    addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
  }
  throw new MaxBufferError();
};
var addNewChunk = (convertedChunk, state, addChunk, newLength) => {
  state.contents = addChunk(convertedChunk, state, newLength);
  state.length = newLength;
};
var getChunkType = (chunk2) => {
  const typeOfChunk = typeof chunk2;
  if (typeOfChunk === "string") {
    return "string";
  }
  if (typeOfChunk !== "object" || chunk2 === null) {
    return "others";
  }
  if (globalThis.Buffer?.isBuffer(chunk2)) {
    return "buffer";
  }
  const prototypeName = objectToString.call(chunk2);
  if (prototypeName === "[object ArrayBuffer]") {
    return "arrayBuffer";
  }
  if (prototypeName === "[object DataView]") {
    return "dataView";
  }
  if (Number.isInteger(chunk2.byteLength) && Number.isInteger(chunk2.byteOffset) && objectToString.call(chunk2.buffer) === "[object ArrayBuffer]") {
    return "typedArray";
  }
  return "others";
};
var { toString: objectToString } = Object.prototype;
var MaxBufferError = class extends Error {
  name = "MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
};

// node_modules/get-stream/source/utils.js
var noop = () => void 0;
var throwObjectStream = (chunk2) => {
  throw new Error(`Streams in object mode are not supported: ${String(chunk2)}`);
};
var getLengthProperty = (convertedChunk) => convertedChunk.length;

// node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream2, options) {
  return getStreamContents(stream2, arrayBufferMethods, options);
}
var initArrayBuffer = () => ({ contents: new ArrayBuffer(0) });
var useTextEncoder = (chunk2) => textEncoder2.encode(chunk2);
var textEncoder2 = new TextEncoder();
var useUint8Array = (chunk2) => new Uint8Array(chunk2);
var useUint8ArrayWithOffset = (chunk2) => new Uint8Array(chunk2.buffer, chunk2.byteOffset, chunk2.byteLength);
var truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length) => {
  const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
  new Uint8Array(newContents).set(convertedChunk, previousLength);
  return newContents;
};
var resizeArrayBufferSlow = (contents, length) => {
  if (length <= contents.byteLength) {
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var resizeArrayBuffer = (contents, length) => {
  if (length <= contents.maxByteLength) {
    contents.resize(length);
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
var SCALE_FACTOR = 2;
var finalizeArrayBuffer = ({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length);
var hasArrayBufferResize = () => "resize" in ArrayBuffer.prototype;
var arrayBufferMethods = {
  init: initArrayBuffer,
  convertChunk: {
    string: useTextEncoder,
    buffer: useUint8Array,
    arrayBuffer: useUint8Array,
    dataView: useUint8ArrayWithOffset,
    typedArray: useUint8ArrayWithOffset,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateArrayBufferChunk,
  addChunk: addArrayBufferChunk,
  getFinalChunk: noop,
  finalize: finalizeArrayBuffer
};

// node_modules/get-stream/source/buffer.js
async function getStreamAsBuffer(stream2, options) {
  if (!("Buffer" in globalThis)) {
    throw new Error("getStreamAsBuffer() is only supported in Node.js");
  }
  try {
    return arrayBufferToNodeBuffer(await getStreamAsArrayBuffer(stream2, options));
  } catch (error2) {
    if (error2.bufferedData !== void 0) {
      error2.bufferedData = arrayBufferToNodeBuffer(error2.bufferedData);
    }
    throw error2;
  }
}
var arrayBufferToNodeBuffer = (arrayBuffer) => globalThis.Buffer.from(arrayBuffer);

// node_modules/get-stream/source/index.js
Object.assign(nodeImports, { on, finished });

// node_modules/cacheable-request/dist/index.js
var import_http_cache_semantics = __toESM(require_http_cache_semantics(), 1);

// node_modules/@keyv/serialize/dist/index.js
import { Buffer as Buffer2 } from "buffer";
var _serialize = (data, escapeColonStrings = true) => {
  if (data === void 0 || data === null) {
    return "null";
  }
  if (typeof data === "string") {
    return JSON.stringify(
      escapeColonStrings && data.startsWith(":") ? `:${data}` : data
    );
  }
  if (Buffer2.isBuffer(data)) {
    return JSON.stringify(`:base64:${data.toString("base64")}`);
  }
  if (data?.toJSON) {
    data = data.toJSON();
  }
  if (typeof data === "object") {
    let s = "";
    const array = Array.isArray(data);
    s = array ? "[" : "{";
    let first = true;
    for (const k in data) {
      const ignore = typeof data[k] === "function" || !array && data[k] === void 0;
      if (!Object.hasOwn(data, k) || ignore) {
        continue;
      }
      if (!first) {
        s += ",";
      }
      first = false;
      if (array) {
        s += _serialize(data[k], escapeColonStrings);
      } else if (data[k] !== void 0) {
        s += `${_serialize(k, false)}:${_serialize(data[k], escapeColonStrings)}`;
      }
    }
    s += array ? "]" : "}";
    return s;
  }
  return JSON.stringify(data);
};
var defaultSerialize = (data) => {
  return _serialize(data, true);
};
var defaultDeserialize = (data) => JSON.parse(data, (_, value) => {
  if (typeof value === "string") {
    if (value.startsWith(":base64:")) {
      return Buffer2.from(value.slice(8), "base64");
    }
    return value.startsWith(":") ? value.slice(1) : value;
  }
  return value;
});

// node_modules/cacheable-request/node_modules/keyv/dist/index.js
var EventManager = class {
  _eventListeners;
  _maxListeners;
  constructor() {
    this._eventListeners = /* @__PURE__ */ new Map();
    this._maxListeners = 100;
  }
  maxListeners() {
    return this._maxListeners;
  }
  // Add an event listener
  addListener(event, listener) {
    this.on(event, listener);
  }
  on(event, listener) {
    if (!this._eventListeners.has(event)) {
      this._eventListeners.set(event, []);
    }
    const listeners = this._eventListeners.get(event);
    if (listeners) {
      if (listeners.length >= this._maxListeners) {
        console.warn(
          `MaxListenersExceededWarning: Possible event memory leak detected. ${listeners.length + 1} ${event} listeners added. Use setMaxListeners() to increase limit.`
        );
      }
      listeners.push(listener);
    }
    return this;
  }
  // Remove an event listener
  removeListener(event, listener) {
    this.off(event, listener);
  }
  off(event, listener) {
    const listeners = this._eventListeners.get(event) ?? [];
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
    if (listeners.length === 0) {
      this._eventListeners.delete(event);
    }
  }
  once(event, listener) {
    const onceListener = (...arguments_) => {
      listener(...arguments_);
      this.off(event, onceListener);
    };
    this.on(event, onceListener);
  }
  // Emit an event
  // biome-ignore lint/suspicious/noExplicitAny: type format
  emit(event, ...arguments_) {
    const listeners = this._eventListeners.get(event);
    if (listeners && listeners.length > 0) {
      for (const listener of listeners) {
        listener(...arguments_);
      }
    }
  }
  // Get all listeners for a specific event
  listeners(event) {
    return this._eventListeners.get(event) ?? [];
  }
  // Remove all listeners for a specific event
  removeAllListeners(event) {
    if (event) {
      this._eventListeners.delete(event);
    } else {
      this._eventListeners.clear();
    }
  }
  // Set the maximum number of listeners for a single event
  setMaxListeners(n2) {
    this._maxListeners = n2;
  }
};
var event_manager_default = EventManager;
var HooksManager = class extends event_manager_default {
  _hookHandlers;
  constructor() {
    super();
    this._hookHandlers = /* @__PURE__ */ new Map();
  }
  // Adds a handler function for a specific event
  addHandler(event, handler) {
    const eventHandlers = this._hookHandlers.get(event);
    if (eventHandlers) {
      eventHandlers.push(handler);
    } else {
      this._hookHandlers.set(event, [handler]);
    }
  }
  // Removes a specific handler function for a specific event
  removeHandler(event, handler) {
    const eventHandlers = this._hookHandlers.get(event);
    if (eventHandlers) {
      const index = eventHandlers.indexOf(handler);
      if (index !== -1) {
        eventHandlers.splice(index, 1);
      }
    }
  }
  // Triggers all handlers for a specific event with provided data
  // biome-ignore lint/suspicious/noExplicitAny: type format
  trigger(event, data) {
    const eventHandlers = this._hookHandlers.get(event);
    if (eventHandlers) {
      for (const handler of eventHandlers) {
        try {
          handler(data);
        } catch (error2) {
          this.emit(
            "error",
            new Error(
              `Error in hook handler for event "${event}": ${error2.message}`
            )
          );
        }
      }
    }
  }
  // Provides read-only access to the current handlers
  get handlers() {
    return new Map(this._hookHandlers);
  }
};
var hooks_manager_default = HooksManager;
var StatsManager = class extends event_manager_default {
  enabled = true;
  hits = 0;
  misses = 0;
  sets = 0;
  deletes = 0;
  errors = 0;
  constructor(enabled) {
    super();
    if (enabled !== void 0) {
      this.enabled = enabled;
    }
    this.reset();
  }
  hit() {
    if (this.enabled) {
      this.hits++;
    }
  }
  miss() {
    if (this.enabled) {
      this.misses++;
    }
  }
  set() {
    if (this.enabled) {
      this.sets++;
    }
  }
  delete() {
    if (this.enabled) {
      this.deletes++;
    }
  }
  hitsOrMisses(array) {
    for (const item of array) {
      if (item === void 0) {
        this.miss();
      } else {
        this.hit();
      }
    }
  }
  reset() {
    this.hits = 0;
    this.misses = 0;
    this.sets = 0;
    this.deletes = 0;
    this.errors = 0;
  }
};
var stats_manager_default = StatsManager;
var iterableAdapters = [
  "sqlite",
  "postgres",
  "mysql",
  "mongo",
  "redis",
  "valkey",
  "etcd"
];
var Keyv = class extends event_manager_default {
  opts;
  iterator;
  hooks = new hooks_manager_default();
  stats = new stats_manager_default(false);
  /**
   * Time to live in milliseconds
   */
  _ttl;
  /**
   * Namespace
   */
  _namespace;
  /**
   * Store
   */
  // biome-ignore lint/suspicious/noExplicitAny: type format
  _store = /* @__PURE__ */ new Map();
  _serialize = defaultSerialize;
  _deserialize = defaultDeserialize;
  _compression;
  _useKeyPrefix = true;
  _throwOnErrors = false;
  /**
   * Keyv Constructor
   * @param {KeyvStoreAdapter | KeyvOptions} store
   * @param {Omit<KeyvOptions, 'store'>} [options] if you provide the store you can then provide the Keyv Options
   */
  constructor(store, options) {
    super();
    options ??= {};
    store ??= {};
    this.opts = {
      namespace: "keyv",
      serialize: defaultSerialize,
      deserialize: defaultDeserialize,
      emitErrors: true,
      // @ts-expect-error - Map is not a KeyvStoreAdapter
      store: /* @__PURE__ */ new Map(),
      ...options
    };
    if (store && store.get) {
      this.opts.store = store;
    } else {
      this.opts = {
        ...this.opts,
        ...store
      };
    }
    this._store = this.opts.store ?? /* @__PURE__ */ new Map();
    this._compression = this.opts.compression;
    this._serialize = this.opts.serialize;
    this._deserialize = this.opts.deserialize;
    if (this.opts.namespace) {
      this._namespace = this.opts.namespace;
    }
    if (this._store) {
      if (!this._isValidStorageAdapter(this._store)) {
        throw new Error("Invalid storage adapter");
      }
      if (typeof this._store.on === "function") {
        this._store.on("error", (error2) => this.emit("error", error2));
      }
      this._store.namespace = this._namespace;
      if (typeof this._store[Symbol.iterator] === "function" && this._store instanceof Map) {
        this.iterator = this.generateIterator(
          this._store
        );
      } else if ("iterator" in this._store && this._store.opts && this._checkIterableAdapter()) {
        this.iterator = this.generateIterator(
          // biome-ignore lint/style/noNonNullAssertion: need to fix
          this._store.iterator.bind(this._store)
        );
      }
    }
    if (this.opts.stats) {
      this.stats.enabled = this.opts.stats;
    }
    if (this.opts.ttl) {
      this._ttl = this.opts.ttl;
    }
    if (this.opts.useKeyPrefix !== void 0) {
      this._useKeyPrefix = this.opts.useKeyPrefix;
    }
    if (this.opts.throwOnErrors !== void 0) {
      this._throwOnErrors = this.opts.throwOnErrors;
    }
  }
  /**
   * Get the current store
   */
  // biome-ignore lint/suspicious/noExplicitAny: type format
  get store() {
    return this._store;
  }
  /**
   * Set the current store. This will also set the namespace, event error handler, and generate the iterator. If the store is not valid it will throw an error.
   * @param {KeyvStoreAdapter | Map<any, any> | any} store the store to set
   */
  // biome-ignore lint/suspicious/noExplicitAny: type format
  set store(store) {
    if (this._isValidStorageAdapter(store)) {
      this._store = store;
      this.opts.store = store;
      if (typeof store.on === "function") {
        store.on("error", (error2) => this.emit("error", error2));
      }
      if (this._namespace) {
        this._store.namespace = this._namespace;
      }
      if (typeof store[Symbol.iterator] === "function" && store instanceof Map) {
        this.iterator = this.generateIterator(
          store
        );
      } else if ("iterator" in store && store.opts && this._checkIterableAdapter()) {
        this.iterator = this.generateIterator(store.iterator?.bind(store));
      }
    } else {
      throw new Error("Invalid storage adapter");
    }
  }
  /**
   * Get the current compression function
   * @returns {CompressionAdapter} The current compression function
   */
  get compression() {
    return this._compression;
  }
  /**
   * Set the current compression function
   * @param {CompressionAdapter} compress The compression function to set
   */
  set compression(compress) {
    this._compression = compress;
  }
  /**
   * Get the current namespace.
   * @returns {string | undefined} The current namespace.
   */
  get namespace() {
    return this._namespace;
  }
  /**
   * Set the current namespace.
   * @param {string | undefined} namespace The namespace to set.
   */
  set namespace(namespace) {
    this._namespace = namespace;
    this.opts.namespace = namespace;
    this._store.namespace = namespace;
    if (this.opts.store) {
      this.opts.store.namespace = namespace;
    }
  }
  /**
   * Get the current TTL.
   * @returns {number} The current TTL in milliseconds.
   */
  get ttl() {
    return this._ttl;
  }
  /**
   * Set the current TTL.
   * @param {number} ttl The TTL to set in milliseconds.
   */
  set ttl(ttl2) {
    this.opts.ttl = ttl2;
    this._ttl = ttl2;
  }
  /**
   * Get the current serialize function.
   * @returns {Serialize} The current serialize function.
   */
  get serialize() {
    return this._serialize;
  }
  /**
   * Set the current serialize function.
   * @param {Serialize} serialize The serialize function to set.
   */
  set serialize(serialize) {
    this.opts.serialize = serialize;
    this._serialize = serialize;
  }
  /**
   * Get the current deserialize function.
   * @returns {Deserialize} The current deserialize function.
   */
  get deserialize() {
    return this._deserialize;
  }
  /**
   * Set the current deserialize function.
   * @param {Deserialize} deserialize The deserialize function to set.
   */
  set deserialize(deserialize) {
    this.opts.deserialize = deserialize;
    this._deserialize = deserialize;
  }
  /**
   * Get the current useKeyPrefix value. This will enable or disable key prefixing.
   * @returns {boolean} The current useKeyPrefix value.
   * @default true
   */
  get useKeyPrefix() {
    return this._useKeyPrefix;
  }
  /**
   * Set the current useKeyPrefix value. This will enable or disable key prefixing.
   * @param {boolean} value The useKeyPrefix value to set.
   */
  set useKeyPrefix(value) {
    this._useKeyPrefix = value;
    this.opts.useKeyPrefix = value;
  }
  /**
   * Get the current throwErrors value. This will enable or disable throwing errors on methods in addition to emitting them.
   * @return {boolean} The current throwOnErrors value.
   */
  get throwOnErrors() {
    return this._throwOnErrors;
  }
  /**
   * Set the current throwOnErrors value. This will enable or disable throwing errors on methods in addition to emitting them.
   * @param {boolean} value The throwOnErrors value to set.
   */
  set throwOnErrors(value) {
    this._throwOnErrors = value;
    this.opts.throwOnErrors = value;
  }
  generateIterator(iterator) {
    const function_ = async function* () {
      for await (const [key, raw] of typeof iterator === "function" ? iterator(this._store.namespace) : iterator) {
        const data = await this.deserializeData(raw);
        if (this._useKeyPrefix && this._store.namespace && !key.includes(this._store.namespace)) {
          continue;
        }
        if (typeof data.expires === "number" && Date.now() > data.expires) {
          this.delete(key);
          continue;
        }
        yield [this._getKeyUnprefix(key), data.value];
      }
    };
    return function_.bind(this);
  }
  _checkIterableAdapter() {
    return iterableAdapters.includes(this._store.opts.dialect) || iterableAdapters.some(
      (element) => this._store.opts.url.includes(element)
    );
  }
  _getKeyPrefix(key) {
    if (!this._useKeyPrefix) {
      return key;
    }
    if (!this._namespace) {
      return key;
    }
    return `${this._namespace}:${key}`;
  }
  _getKeyPrefixArray(keys) {
    if (!this._useKeyPrefix) {
      return keys;
    }
    if (!this._namespace) {
      return keys;
    }
    return keys.map((key) => `${this._namespace}:${key}`);
  }
  _getKeyUnprefix(key) {
    if (!this._useKeyPrefix) {
      return key;
    }
    return key.split(":").splice(1).join(":");
  }
  // biome-ignore lint/suspicious/noExplicitAny: type format
  _isValidStorageAdapter(store) {
    return store instanceof Map || typeof store.get === "function" && typeof store.set === "function" && typeof store.delete === "function" && typeof store.clear === "function";
  }
  // eslint-disable-next-line @stylistic/max-len
  async get(key, options) {
    const { store } = this.opts;
    const isArray2 = Array.isArray(key);
    const keyPrefixed = isArray2 ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
    const isDataExpired = (data) => typeof data.expires === "number" && Date.now() > data.expires;
    if (isArray2) {
      if (options?.raw === true) {
        return this.getMany(key, { raw: true });
      }
      return this.getMany(key, { raw: false });
    }
    this.hooks.trigger("preGet", { key: keyPrefixed });
    let rawData;
    try {
      rawData = await store.get(keyPrefixed);
    } catch (error2) {
      if (this.throwOnErrors) {
        throw error2;
      }
    }
    const deserializedData = typeof rawData === "string" || this.opts.compression ? await this.deserializeData(rawData) : rawData;
    if (deserializedData === void 0 || deserializedData === null) {
      this.hooks.trigger("postGet", {
        key: keyPrefixed,
        value: void 0
      });
      this.stats.miss();
      return void 0;
    }
    if (isDataExpired(deserializedData)) {
      await this.delete(key);
      this.hooks.trigger("postGet", {
        key: keyPrefixed,
        value: void 0
      });
      this.stats.miss();
      return void 0;
    }
    this.hooks.trigger("postGet", {
      key: keyPrefixed,
      value: deserializedData
    });
    this.stats.hit();
    return options?.raw ? deserializedData : deserializedData.value;
  }
  async getMany(keys, options) {
    const { store } = this.opts;
    const keyPrefixed = this._getKeyPrefixArray(keys);
    const isDataExpired = (data) => typeof data.expires === "number" && Date.now() > data.expires;
    this.hooks.trigger("preGetMany", { keys: keyPrefixed });
    if (store.getMany === void 0) {
      const promises = keyPrefixed.map(async (key) => {
        const rawData2 = await store.get(key);
        const deserializedRow = typeof rawData2 === "string" || this.opts.compression ? await this.deserializeData(rawData2) : rawData2;
        if (deserializedRow === void 0 || deserializedRow === null) {
          return void 0;
        }
        if (isDataExpired(deserializedRow)) {
          await this.delete(key);
          return void 0;
        }
        return options?.raw ? deserializedRow : deserializedRow.value;
      });
      const deserializedRows = await Promise.allSettled(promises);
      const result2 = deserializedRows.map(
        // biome-ignore lint/suspicious/noExplicitAny: type format
        (row) => row.value
      );
      this.hooks.trigger("postGetMany", result2);
      if (result2.length > 0) {
        this.stats.hit();
      }
      return result2;
    }
    const rawData = await store.getMany(keyPrefixed);
    const result = [];
    const expiredKeys = [];
    for (const index in rawData) {
      let row = rawData[index];
      if (typeof row === "string") {
        row = await this.deserializeData(row);
      }
      if (row === void 0 || row === null) {
        result.push(void 0);
        continue;
      }
      if (isDataExpired(row)) {
        expiredKeys.push(keys[index]);
        result.push(void 0);
        continue;
      }
      const value = options?.raw ? row : row.value;
      result.push(value);
    }
    if (expiredKeys.length > 0) {
      await this.deleteMany(expiredKeys);
    }
    this.hooks.trigger("postGetMany", result);
    if (result.length > 0) {
      this.stats.hit();
    }
    return result;
  }
  /**
   * Get the raw value of a key. This is the replacement for setting raw to true in the get() method.
   * @param {string} key the key to get
   * @returns {Promise<StoredDataRaw<Value> | undefined>} will return a StoredDataRaw<Value> or undefined if the key does not exist or is expired.
   */
  async getRaw(key) {
    const { store } = this.opts;
    const keyPrefixed = this._getKeyPrefix(key);
    this.hooks.trigger("preGetRaw", { key: keyPrefixed });
    const rawData = await store.get(keyPrefixed);
    if (rawData === void 0 || rawData === null) {
      this.hooks.trigger("postGetRaw", {
        key: keyPrefixed,
        value: void 0
      });
      this.stats.miss();
      return void 0;
    }
    const deserializedData = typeof rawData === "string" || this.opts.compression ? await this.deserializeData(rawData) : rawData;
    if (deserializedData !== void 0 && deserializedData.expires !== void 0 && deserializedData.expires !== null && // biome-ignore lint/style/noNonNullAssertion: need to fix
    deserializedData.expires < Date.now()) {
      this.hooks.trigger("postGetRaw", {
        key: keyPrefixed,
        value: void 0
      });
      this.stats.miss();
      await this.delete(key);
      return void 0;
    }
    this.stats.hit();
    this.hooks.trigger("postGetRaw", {
      key: keyPrefixed,
      value: deserializedData
    });
    return deserializedData;
  }
  /**
   * Get the raw values of many keys. This is the replacement for setting raw to true in the getMany() method.
   * @param {string[]} keys the keys to get
   * @returns {Promise<Array<StoredDataRaw<Value>>>} will return an array of StoredDataRaw<Value> or undefined if the key does not exist or is expired.
   */
  async getManyRaw(keys) {
    const { store } = this.opts;
    const keyPrefixed = this._getKeyPrefixArray(keys);
    if (keys.length === 0) {
      const result2 = Array.from({ length: keys.length }).fill(
        void 0
      );
      this.stats.misses += keys.length;
      this.hooks.trigger("postGetManyRaw", {
        keys: keyPrefixed,
        values: result2
      });
      return result2;
    }
    let result = [];
    if (store.getMany === void 0) {
      const promises = keyPrefixed.map(async (key) => {
        const rawData = await store.get(key);
        if (rawData !== void 0 && rawData !== null) {
          return this.deserializeData(rawData);
        }
        return void 0;
      });
      const deserializedRows = await Promise.allSettled(promises);
      result = deserializedRows.map(
        // biome-ignore lint/suspicious/noExplicitAny: type format
        (row) => row.value
      );
    } else {
      const rawData = await store.getMany(keyPrefixed);
      for (const row of rawData) {
        if (row !== void 0 && row !== null) {
          result.push(await this.deserializeData(row));
        } else {
          result.push(void 0);
        }
      }
    }
    const expiredKeys = [];
    const isDataExpired = (data) => typeof data.expires === "number" && Date.now() > data.expires;
    for (const [index, row] of result.entries()) {
      if (row !== void 0 && isDataExpired(row)) {
        expiredKeys.push(keyPrefixed[index]);
        result[index] = void 0;
      }
    }
    if (expiredKeys.length > 0) {
      await this.deleteMany(expiredKeys);
    }
    this.stats.hitsOrMisses(result);
    this.hooks.trigger("postGetManyRaw", {
      keys: keyPrefixed,
      values: result
    });
    return result;
  }
  /**
   * Set an item to the store
   * @param {string | Array<KeyvEntry>} key the key to use. If you pass in an array of KeyvEntry it will set many items
   * @param {Value} value the value of the key
   * @param {number} [ttl] time to live in milliseconds
   * @returns {boolean} if it sets then it will return a true. On failure will return false.
   */
  async set(key, value, ttl2) {
    const data = { key, value, ttl: ttl2 };
    this.hooks.trigger("preSet", data);
    const keyPrefixed = this._getKeyPrefix(data.key);
    data.ttl ??= this._ttl;
    if (data.ttl === 0) {
      data.ttl = void 0;
    }
    const { store } = this.opts;
    const expires = typeof data.ttl === "number" ? Date.now() + data.ttl : void 0;
    if (typeof data.value === "symbol") {
      this.emit("error", "symbol cannot be serialized");
      throw new Error("symbol cannot be serialized");
    }
    const formattedValue = { value: data.value, expires };
    const serializedValue = await this.serializeData(formattedValue);
    let result = true;
    try {
      const value2 = await store.set(keyPrefixed, serializedValue, data.ttl);
      if (typeof value2 === "boolean") {
        result = value2;
      }
    } catch (error2) {
      result = false;
      this.emit("error", error2);
      if (this._throwOnErrors) {
        throw error2;
      }
    }
    this.hooks.trigger("postSet", {
      key: keyPrefixed,
      value: serializedValue,
      ttl: ttl2
    });
    this.stats.set();
    return result;
  }
  /**
   * Set many items to the store
   * @param {Array<KeyvEntry>} entries the entries to set
   * @returns {boolean[]} will return an array of booleans if it sets then it will return a true. On failure will return false.
   */
  // biome-ignore lint/correctness/noUnusedVariables: type format
  async setMany(entries2) {
    let results = [];
    try {
      if (this._store.setMany === void 0) {
        const promises = [];
        for (const entry of entries2) {
          promises.push(this.set(entry.key, entry.value, entry.ttl));
        }
        const promiseResults = await Promise.all(promises);
        results = promiseResults;
      } else {
        const serializedEntries = await Promise.all(
          entries2.map(async ({ key, value, ttl: ttl2 }) => {
            ttl2 ??= this._ttl;
            if (ttl2 === 0) {
              ttl2 = void 0;
            }
            const expires = typeof ttl2 === "number" ? Date.now() + ttl2 : void 0;
            if (typeof value === "symbol") {
              this.emit("error", "symbol cannot be serialized");
              throw new Error("symbol cannot be serialized");
            }
            const formattedValue = { value, expires };
            const serializedValue = await this.serializeData(formattedValue);
            const keyPrefixed = this._getKeyPrefix(key);
            return { key: keyPrefixed, value: serializedValue, ttl: ttl2 };
          })
        );
        results = await this._store.setMany(serializedEntries);
      }
    } catch (error2) {
      this.emit("error", error2);
      if (this._throwOnErrors) {
        throw error2;
      }
      results = entries2.map(() => false);
    }
    return results;
  }
  /**
   * Delete an Entry
   * @param {string | string[]} key the key to be deleted. if an array it will delete many items
   * @returns {boolean} will return true if item or items are deleted. false if there is an error
   */
  async delete(key) {
    const { store } = this.opts;
    if (Array.isArray(key)) {
      return this.deleteMany(key);
    }
    const keyPrefixed = this._getKeyPrefix(key);
    this.hooks.trigger("preDelete", { key: keyPrefixed });
    let result = true;
    try {
      const value = await store.delete(keyPrefixed);
      if (typeof value === "boolean") {
        result = value;
      }
    } catch (error2) {
      result = false;
      this.emit("error", error2);
      if (this._throwOnErrors) {
        throw error2;
      }
    }
    this.hooks.trigger("postDelete", {
      key: keyPrefixed,
      value: result
    });
    this.stats.delete();
    return result;
  }
  /**
   * Delete many items from the store
   * @param {string[]} keys the keys to be deleted
   * @returns {boolean} will return true if item or items are deleted. false if there is an error
   */
  async deleteMany(keys) {
    try {
      const { store } = this.opts;
      const keyPrefixed = this._getKeyPrefixArray(keys);
      this.hooks.trigger("preDelete", { key: keyPrefixed });
      if (store.deleteMany !== void 0) {
        return await store.deleteMany(keyPrefixed);
      }
      const promises = keyPrefixed.map(async (key) => store.delete(key));
      const results = await Promise.all(promises);
      const returnResult = results.every(Boolean);
      this.hooks.trigger("postDelete", {
        key: keyPrefixed,
        value: returnResult
      });
      return returnResult;
    } catch (error2) {
      this.emit("error", error2);
      if (this._throwOnErrors) {
        throw error2;
      }
      return false;
    }
  }
  /**
   * Clear the store
   * @returns {void}
   */
  async clear() {
    this.emit("clear");
    const { store } = this.opts;
    try {
      await store.clear();
    } catch (error2) {
      this.emit("error", error2);
      if (this._throwOnErrors) {
        throw error2;
      }
    }
  }
  async has(key) {
    if (Array.isArray(key)) {
      return this.hasMany(key);
    }
    const keyPrefixed = this._getKeyPrefix(key);
    const { store } = this.opts;
    if (store.has !== void 0 && !(store instanceof Map)) {
      return store.has(keyPrefixed);
    }
    let rawData;
    try {
      rawData = await store.get(keyPrefixed);
    } catch (error2) {
      this.emit("error", error2);
      if (this._throwOnErrors) {
        throw error2;
      }
      return false;
    }
    if (rawData) {
      const data = await this.deserializeData(rawData);
      if (data) {
        if (data.expires === void 0 || data.expires === null) {
          return true;
        }
        return data.expires > Date.now();
      }
    }
    return false;
  }
  /**
   * Check if many keys exist
   * @param {string[]} keys the keys to check
   * @returns {boolean[]} will return an array of booleans if the keys exist
   */
  async hasMany(keys) {
    const keyPrefixed = this._getKeyPrefixArray(keys);
    const { store } = this.opts;
    if (store.hasMany !== void 0) {
      return store.hasMany(keyPrefixed);
    }
    const results = [];
    for (const key of keys) {
      results.push(await this.has(key));
    }
    return results;
  }
  /**
   * Will disconnect the store. This is only available if the store has a disconnect method
   * @returns {Promise<void>}
   */
  async disconnect() {
    const { store } = this.opts;
    this.emit("disconnect");
    if (typeof store.disconnect === "function") {
      return store.disconnect();
    }
  }
  // biome-ignore lint/suspicious/noExplicitAny: type format
  emit(event, ...arguments_) {
    if (event === "error" && !this.opts.emitErrors) {
      return;
    }
    super.emit(event, ...arguments_);
  }
  async serializeData(data) {
    if (!this._serialize) {
      return data;
    }
    if (this._compression?.compress) {
      return this._serialize({
        value: await this._compression.compress(data.value),
        expires: data.expires
      });
    }
    return this._serialize(data);
  }
  async deserializeData(data) {
    if (!this._deserialize) {
      return data;
    }
    if (this._compression?.decompress && typeof data === "string") {
      const result = await this._deserialize(data);
      return {
        value: await this._compression.decompress(result?.value),
        expires: result?.expires
      };
    }
    if (typeof data === "string") {
      return this._deserialize(data);
    }
    return void 0;
  }
};

// node_modules/mimic-response/index.js
var knownProperties = [
  "aborted",
  "complete",
  "headers",
  "httpVersion",
  "httpVersionMinor",
  "httpVersionMajor",
  "method",
  "rawHeaders",
  "rawTrailers",
  "setTimeout",
  "socket",
  "statusCode",
  "statusMessage",
  "trailers",
  "url"
];
function mimicResponse(fromStream, toStream) {
  if (toStream._readableState.autoDestroy) {
    throw new Error("The second stream must have the `autoDestroy` option set to `false`");
  }
  const fromProperties = /* @__PURE__ */ new Set([...Object.keys(fromStream), ...knownProperties]);
  const properties = {};
  for (const property of fromProperties) {
    if (property in toStream) {
      continue;
    }
    properties[property] = {
      get() {
        const value = fromStream[property];
        const isFunction3 = typeof value === "function";
        return isFunction3 ? value.bind(fromStream) : value;
      },
      set(value) {
        fromStream[property] = value;
      },
      enumerable: true,
      configurable: false
    };
  }
  Object.defineProperties(toStream, properties);
  fromStream.once("aborted", () => {
    toStream.destroy();
    toStream.emit("aborted");
  });
  fromStream.once("close", () => {
    if (fromStream.complete) {
      if (toStream.readable) {
        toStream.once("end", () => {
          toStream.emit("close");
        });
      } else {
        toStream.emit("close");
      }
    } else {
      toStream.emit("close");
    }
  });
  return toStream;
}

// node_modules/normalize-url/index.js
var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
var DATA_URL_DEFAULT_CHARSET = "us-ascii";
var testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
var supportedProtocols = /* @__PURE__ */ new Set([
  "https:",
  "http:",
  "file:"
]);
var hasCustomProtocol = (urlString) => {
  try {
    const { protocol } = new URL(urlString);
    return protocol.endsWith(":") && !protocol.includes(".") && !supportedProtocols.has(protocol);
  } catch {
    return false;
  }
};
var normalizeDataURL = (urlString, { stripHash }) => {
  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
  if (!match) {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  let { type: type2, data, hash } = match.groups;
  const mediaType = type2.split(";");
  hash = stripHash ? "" : hash;
  let isBase64 = false;
  if (mediaType[mediaType.length - 1] === "base64") {
    mediaType.pop();
    isBase64 = true;
  }
  const mimeType = mediaType.shift()?.toLowerCase() ?? "";
  const attributes = mediaType.map((attribute) => {
    let [key, value = ""] = attribute.split("=").map((string) => string.trim());
    if (key === "charset") {
      value = value.toLowerCase();
      if (value === DATA_URL_DEFAULT_CHARSET) {
        return "";
      }
    }
    return `${key}${value ? `=${value}` : ""}`;
  }).filter(Boolean);
  const normalizedMediaType = [
    ...attributes
  ];
  if (isBase64) {
    normalizedMediaType.push("base64");
  }
  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }
  return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
};
function normalizeUrl(urlString, options) {
  options = {
    defaultProtocol: "http",
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    removeExplicitPort: false,
    sortQueryParameters: true,
    removePath: false,
    transformPath: false,
    ...options
  };
  if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) {
    options.defaultProtocol = `${options.defaultProtocol}:`;
  }
  urlString = urlString.trim();
  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }
  if (hasCustomProtocol(urlString)) {
    return urlString;
  }
  const hasRelativeProtocol = urlString.startsWith("//");
  const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }
  const urlObject = new URL(urlString);
  if (options.forceHttp && options.forceHttps) {
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
  }
  if (options.forceHttp && urlObject.protocol === "https:") {
    urlObject.protocol = "http:";
  }
  if (options.forceHttps && urlObject.protocol === "http:") {
    urlObject.protocol = "https:";
  }
  if (options.stripAuthentication) {
    urlObject.username = "";
    urlObject.password = "";
  }
  if (options.stripHash) {
    urlObject.hash = "";
  } else if (options.stripTextFragment) {
    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "");
  }
  if (urlObject.pathname) {
    const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
    let lastIndex = 0;
    let result = "";
    for (; ; ) {
      const match = protocolRegex.exec(urlObject.pathname);
      if (!match) {
        break;
      }
      const protocol = match[0];
      const protocolAtIndex = match.index;
      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
      result += intermediate.replace(/\/{2,}/g, "/");
      result += protocol;
      lastIndex = protocolAtIndex + protocol.length;
    }
    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
    result += remnant.replace(/\/{2,}/g, "/");
    urlObject.pathname = result;
  }
  if (urlObject.pathname) {
    try {
      urlObject.pathname = decodeURI(urlObject.pathname).replace(/\\/g, "%5C");
    } catch {
    }
  }
  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }
  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObject.pathname.split("/");
    const lastComponent = pathComponents[pathComponents.length - 1];
    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, -1);
      urlObject.pathname = pathComponents.slice(1).join("/") + "/";
    }
  }
  if (options.removePath) {
    urlObject.pathname = "/";
  }
  if (options.transformPath && typeof options.transformPath === "function") {
    const pathComponents = urlObject.pathname.split("/").filter(Boolean);
    const newComponents = options.transformPath(pathComponents);
    urlObject.pathname = newComponents?.length > 0 ? `/${newComponents.join("/")}` : "/";
  }
  if (urlObject.hostname) {
    urlObject.hostname = urlObject.hostname.replace(/\.$/, "");
    if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) {
      urlObject.hostname = urlObject.hostname.replace(/^www\./, "");
    }
  }
  if (Array.isArray(options.removeQueryParameters)) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (testParameter(key, options.removeQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
    urlObject.search = "";
  }
  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (!testParameter(key, options.keepQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (options.sortQueryParameters) {
    const originalSearch = urlObject.search;
    urlObject.searchParams.sort();
    try {
      urlObject.search = decodeURIComponent(urlObject.search);
    } catch {
    }
    const partsWithoutEquals = originalSearch.slice(1).split("&").filter((p) => p && !p.includes("="));
    for (const part of partsWithoutEquals) {
      const decoded = decodeURIComponent(part);
      urlObject.search = urlObject.search.replace(`?${decoded}=`, `?${decoded}`).replace(`&${decoded}=`, `&${decoded}`);
    }
  }
  if (options.removeTrailingSlash) {
    urlObject.pathname = urlObject.pathname.replace(/\/$/, "");
  }
  if (options.removeExplicitPort && urlObject.port) {
    urlObject.port = "";
  }
  const oldUrlString = urlString;
  urlString = urlObject.toString();
  if (!options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "") {
    urlString = urlString.replace(/\/$/, "");
  }
  if ((options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash) {
    urlString = urlString.replace(/\/$/, "");
  }
  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, "//");
  }
  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, "");
  }
  return urlString;
}

// node_modules/responselike/index.js
import { Readable as ReadableStream2 } from "stream";

// node_modules/lowercase-keys/index.js
function lowercaseKeys(object) {
  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key.toLowerCase(), value]));
}

// node_modules/responselike/index.js
var Response = class extends ReadableStream2 {
  statusCode;
  headers;
  body;
  url;
  complete;
  constructor({ statusCode, headers, body, url }) {
    if (typeof statusCode !== "number") {
      throw new TypeError("Argument `statusCode` should be a number");
    }
    if (typeof headers !== "object") {
      throw new TypeError("Argument `headers` should be an object");
    }
    if (!(body instanceof Uint8Array)) {
      throw new TypeError("Argument `body` should be a buffer");
    }
    if (typeof url !== "string") {
      throw new TypeError("Argument `url` should be a string");
    }
    let bodyPushed = false;
    super({
      read() {
        if (!bodyPushed) {
          bodyPushed = true;
          this.push(body);
          return;
        }
        this.push(null);
      }
    });
    this.statusCode = statusCode;
    this.headers = lowercaseKeys(headers);
    this.body = body;
    this.url = url;
    this.complete = true;
  }
};

// node_modules/cacheable-request/dist/types.js
var RequestError2 = class extends Error {
  constructor(error2) {
    super(error2.message);
    Object.defineProperties(this, Object.getOwnPropertyDescriptors(error2));
  }
};
var CacheError2 = class extends Error {
  constructor(error2) {
    super(error2.message);
    Object.defineProperties(this, Object.getOwnPropertyDescriptors(error2));
  }
};

// node_modules/cacheable-request/dist/index.js
var CacheableRequest = class {
  constructor(cacheRequest, cacheAdapter) {
    this.cache = new Keyv({ namespace: "cacheable-request" });
    this.hooks = /* @__PURE__ */ new Map();
    this.request = () => (options, callback) => {
      let url;
      if (typeof options === "string") {
        url = normalizeUrlObject(parseWithWhatwg(options));
        options = {};
      } else if (options instanceof urlLib.URL) {
        url = normalizeUrlObject(parseWithWhatwg(options.toString()));
        options = {};
      } else {
        const [pathname, ...searchParts] = (options.path ?? "").split("?");
        const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
        url = normalizeUrlObject({ ...options, pathname, search });
      }
      options = {
        headers: {},
        method: "GET",
        cache: true,
        strictTtl: false,
        automaticFailover: false,
        ...options,
        ...urlObjectToRequestOptions(url)
      };
      options.headers = Object.fromEntries(entries(options.headers).map(([key2, value]) => [
        key2.toLowerCase(),
        value
      ]));
      const ee = new EventEmitter();
      const normalizedUrlString = normalizeUrl(urlLib.format(url), {
        stripWWW: false,
        removeTrailingSlash: false,
        stripAuthentication: false
      });
      let key = `${options.method}:${normalizedUrlString}`;
      if (options.body && options.method !== void 0 && ["POST", "PATCH", "PUT"].includes(options.method)) {
        if (options.body instanceof stream.Readable) {
          options.cache = false;
        } else {
          key += `:${crypto2.createHash("md5").update(options.body).digest("hex")}`;
        }
      }
      let revalidate = false;
      let madeRequest = false;
      const makeRequest = (options_) => {
        madeRequest = true;
        let requestErrored = false;
        let requestErrorCallback = () => {
        };
        const requestErrorPromise = new Promise((resolve) => {
          requestErrorCallback = () => {
            if (!requestErrored) {
              requestErrored = true;
              resolve();
            }
          };
        });
        const handler = async (response) => {
          if (revalidate) {
            response.status = response.statusCode;
            const originalPolicy = import_http_cache_semantics.default.fromObject(revalidate.cachePolicy);
            const revalidatedPolicy = originalPolicy.revalidatedPolicy(options_, response);
            if (!revalidatedPolicy.modified) {
              response.resume();
              await new Promise((resolve) => {
                response.once("end", resolve);
              });
              const headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());
              const originalHeaders = convertHeaders(originalPolicy.responseHeaders());
              const preserveHeaders = [
                "content-encoding",
                "content-type",
                "content-length",
                "content-language",
                "content-location",
                "etag"
              ];
              for (const headerName of preserveHeaders) {
                if (originalHeaders[headerName] !== void 0 && headers[headerName] === void 0) {
                  headers[headerName] = originalHeaders[headerName];
                }
              }
              response = new Response({
                statusCode: revalidate.statusCode,
                headers,
                body: revalidate.body,
                url: revalidate.url
              });
              response.cachePolicy = revalidatedPolicy.policy;
              response.fromCache = true;
            }
          }
          if (!response.fromCache) {
            response.cachePolicy = new import_http_cache_semantics.default(options_, response, options_);
            response.fromCache = false;
          }
          let clonedResponse;
          if (options_.cache && response.cachePolicy.storable()) {
            clonedResponse = cloneResponse(response);
            (async () => {
              try {
                const bodyPromise = getStreamAsBuffer(response);
                await Promise.race([
                  requestErrorPromise,
                  new Promise((resolve) => response.once("end", resolve)),
                  new Promise((resolve) => response.once("close", resolve))
                ]);
                const body = await bodyPromise;
                let value = {
                  url: response.url,
                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                  body,
                  cachePolicy: response.cachePolicy.toObject()
                };
                let ttl2 = options_.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                if (options_.maxTtl) {
                  ttl2 = ttl2 ? Math.min(ttl2, options_.maxTtl) : options_.maxTtl;
                }
                if (this.hooks.size > 0) {
                  for (const key_ of this.hooks.keys()) {
                    value = await this.runHook(key_, value, response);
                  }
                }
                await this.cache.set(key, value, ttl2);
              } catch (error2) {
                ee.emit("error", new CacheError2(error2));
              }
            })();
          } else if (options_.cache && revalidate) {
            (async () => {
              try {
                await this.cache.delete(key);
              } catch (error2) {
                ee.emit("error", new CacheError2(error2));
              }
            })();
          }
          ee.emit("response", clonedResponse ?? response);
          if (typeof callback === "function") {
            callback(clonedResponse ?? response);
          }
        };
        try {
          const request_ = this.cacheRequest(options_, handler);
          request_.once("error", requestErrorCallback);
          request_.once("abort", requestErrorCallback);
          request_.once("destroy", requestErrorCallback);
          ee.emit("request", request_);
        } catch (error2) {
          ee.emit("error", new RequestError2(error2));
        }
      };
      (async () => {
        const get = async (options_) => {
          await Promise.resolve();
          const cacheEntry = options_.cache ? await this.cache.get(key) : void 0;
          if (cacheEntry === void 0 && !options_.forceRefresh) {
            makeRequest(options_);
            return;
          }
          const policy = import_http_cache_semantics.default.fromObject(cacheEntry.cachePolicy);
          if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {
            const headers = convertHeaders(policy.responseHeaders());
            const bodyBuffer = cacheEntry.body;
            const body = Buffer.from(bodyBuffer);
            const response = new Response({
              statusCode: cacheEntry.statusCode,
              headers,
              body,
              url: cacheEntry.url
            });
            response.cachePolicy = policy;
            response.fromCache = true;
            ee.emit("response", response);
            if (typeof callback === "function") {
              callback(response);
            }
          } else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {
            await this.cache.delete(key);
            options_.headers = policy.revalidationHeaders(options_);
            makeRequest(options_);
          } else {
            revalidate = cacheEntry;
            options_.headers = policy.revalidationHeaders(options_);
            makeRequest(options_);
          }
        };
        const errorHandler = (error2) => ee.emit("error", new CacheError2(error2));
        if (this.cache instanceof Keyv) {
          const cachek = this.cache;
          cachek.once("error", errorHandler);
          ee.on("error", () => {
            cachek.removeListener("error", errorHandler);
          });
          ee.on("response", () => {
            cachek.removeListener("error", errorHandler);
          });
        }
        try {
          await get(options);
        } catch (error2) {
          if (options.automaticFailover && !madeRequest) {
            makeRequest(options);
          }
          ee.emit("error", new CacheError2(error2));
        }
      })();
      return ee;
    };
    this.addHook = (name, function_) => {
      if (!this.hooks.has(name)) {
        this.hooks.set(name, function_);
      }
    };
    this.removeHook = (name) => this.hooks.delete(name);
    this.getHook = (name) => this.hooks.get(name);
    this.runHook = async (name, ...arguments_) => this.hooks.get(name)?.(...arguments_);
    if (cacheAdapter) {
      if (cacheAdapter instanceof Keyv) {
        this.cache = cacheAdapter;
      } else {
        this.cache = new Keyv({
          store: cacheAdapter,
          namespace: "cacheable-request"
        });
      }
    }
    this.request = this.request.bind(this);
    this.cacheRequest = cacheRequest;
  }
};
var entries = Object.entries;
var cloneResponse = (response) => {
  const clone = new PassThroughStream({ autoDestroy: false });
  mimicResponse(response, clone);
  return response.pipe(clone);
};
var urlObjectToRequestOptions = (url) => {
  const options = { ...url };
  options.path = `${url.pathname || "/"}${url.search || ""}`;
  delete options.pathname;
  delete options.search;
  return options;
};
var normalizeUrlObject = (url) => (
  // If url was parsed by url.parse or new URL:
  // - hostname will be set
  // - host will be hostname[:port]
  // - port will be set if it was explicit in the parsed string
  // Otherwise, url was from request options:
  // - hostname or host may be set
  // - host shall not have port encoded
  {
    protocol: url.protocol,
    auth: url.auth,
    hostname: url.hostname || url.host || "localhost",
    port: url.port,
    pathname: url.pathname,
    search: url.search
  }
);
var convertHeaders = (headers) => {
  const result = [];
  for (const name of Object.keys(headers)) {
    result[name.toLowerCase()] = headers[name];
  }
  return result;
};
var parseWithWhatwg = (raw) => {
  const u2 = new URL2(raw);
  return {
    protocol: u2.protocol,
    // E.g. 'https:'
    slashes: true,
    // Always true for WHATWG URLs
    /* c8 ignore next 3 */
    auth: u2.username || u2.password ? `${u2.username}:${u2.password}` : void 0,
    host: u2.host,
    // E.g. 'example.com:8080'
    port: u2.port,
    // E.g. '8080'
    hostname: u2.hostname,
    // E.g. 'example.com'
    hash: u2.hash,
    // E.g. '#quux'
    search: u2.search,
    // E.g. '?bar=baz'
    query: Object.fromEntries(u2.searchParams),
    // { bar: 'baz' }
    pathname: u2.pathname,
    // E.g. '/foo'
    path: u2.pathname + u2.search,
    // '/foo?bar=baz'
    href: u2.href
    // Full serialized URL
  };
};
var dist_default = CacheableRequest;

// node_modules/decompress-response/index.js
import { Transform as TransformStream2, PassThrough as PassThroughStream2 } from "stream";
import zlib from "zlib";
var supportsZstd = typeof zlib.createZstdDecompress === "function";
function decompressResponse(response) {
  const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
  const supportedEncodings = ["gzip", "deflate", "br"];
  if (supportsZstd) {
    supportedEncodings.push("zstd");
  }
  if (!supportedEncodings.includes(contentEncoding)) {
    return response;
  }
  let isEmpty = true;
  const headers = { ...response.headers };
  const finalStream = new PassThroughStream2({
    autoDestroy: false
  });
  finalStream.once("error", () => {
    response.destroy();
  });
  function handleContentEncoding(data) {
    let decompressStream;
    if (contentEncoding === "zstd") {
      decompressStream = zlib.createZstdDecompress();
    } else if (contentEncoding === "br") {
      decompressStream = zlib.createBrotliDecompress();
    } else if (contentEncoding === "deflate" && data.length > 0 && (data[0] & 8) === 0) {
      decompressStream = zlib.createInflateRaw();
    } else {
      decompressStream = zlib.createUnzip();
    }
    decompressStream.once("error", (error2) => {
      if (isEmpty && !response.readable) {
        finalStream.end();
        return;
      }
      finalStream.destroy(error2);
    });
    checker.pipe(decompressStream).pipe(finalStream);
  }
  const checker = new TransformStream2({
    transform(data, _encoding, callback) {
      if (isEmpty === false) {
        callback(null, data);
        return;
      }
      isEmpty = false;
      handleContentEncoding(data);
      callback(null, data);
    },
    flush(callback) {
      if (isEmpty) {
        finalStream.end();
      }
      callback();
    }
  });
  delete headers["content-encoding"];
  delete headers["content-length"];
  finalStream.headers = headers;
  mimicResponse(response, finalStream);
  response.pipe(checker);
  return finalStream;
}

// node_modules/form-data-encoder/lib/index.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var MAX_CHUNK_SIZE = 65536;
function* chunk(value) {
  if (value.byteLength <= MAX_CHUNK_SIZE) {
    yield value;
    return;
  }
  let offset = 0;
  while (offset < value.byteLength) {
    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);
    const buffer = value.buffer.slice(offset, offset + size);
    offset += buffer.byteLength;
    yield new Uint8Array(buffer);
  }
}
var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
  let size = 16;
  let res = "";
  while (size--) {
    res += alphabet[Math.random() * alphabet.length << 0];
  }
  return res;
}
var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");
var isFunction2 = (value) => typeof value === "function";
var isReadableStreamFallback = (value) => !!value && typeof value === "object" && !Array.isArray(value) && isFunction2(value.getReader);
var isAsyncIterable2 = (value) => isFunction2(value[Symbol.asyncIterator]);
async function* readStream(readable) {
  const reader = readable.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    yield value;
  }
}
async function* chunkStream(stream2) {
  for await (const value of stream2) {
    yield* chunk(value);
  }
}
var getStreamIterator = (source) => {
  if (isAsyncIterable2(source)) {
    return chunkStream(source);
  }
  if (isReadableStreamFallback(source)) {
    return chunkStream(readStream(source));
  }
  throw new TypeError(
    "Unsupported data source: Expected either ReadableStream or async iterable."
  );
};
var isFile = (value) => Boolean(
  value && typeof value === "object" && isFunction2(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction2(value.stream) && value.name != null
);
var isFormData2 = (value) => Boolean(
  value && isFunction2(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction2(value.append) && isFunction2(value.getAll) && isFunction2(value.entries) && isFunction2(value[Symbol.iterator])
);
var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function isPlainObject2(value) {
  if (getType(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === void 0) {
    return true;
  }
  return pp.constructor?.toString?.() === Object.toString();
}
var normalizeValue = (value) => String(value).replace(/\r|\n/g, (match, i2, str) => {
  if (match === "\r" && str[i2 + 1] !== "\n" || match === "\n" && str[i2 - 1] !== "\r") {
    return "\r\n";
  }
  return match;
});
function getProperty(target, prop) {
  if (typeof prop === "string") {
    for (const [name, value] of Object.entries(target)) {
      if (prop.toLowerCase() === name.toLowerCase()) {
        return value;
      }
    }
  }
  return void 0;
}
var proxyHeaders = (object) => new Proxy(
  object,
  {
    get: (target, prop) => getProperty(target, prop),
    has: (target, prop) => getProperty(target, prop) !== void 0
  }
);
var defaultOptions = {
  enableAdditionalHeaders: false
};
var readonlyProp = { writable: false, configurable: false };
var _CRLF;
var _CRLF_BYTES;
var _CRLF_BYTES_LENGTH;
var _DASHES;
var _encoder;
var _footer;
var _form;
var _options;
var _FormDataEncoder_instances;
var getFieldHeader_fn;
var getContentLength_fn;
var FormDataEncoder = class {
  constructor(form, boundaryOrOptions, options) {
    __privateAdd(this, _FormDataEncoder_instances);
    __privateAdd(this, _CRLF, "\r\n");
    __privateAdd(this, _CRLF_BYTES);
    __privateAdd(this, _CRLF_BYTES_LENGTH);
    __privateAdd(this, _DASHES, "-".repeat(2));
    __privateAdd(this, _encoder, new TextEncoder());
    __privateAdd(this, _footer);
    __privateAdd(this, _form);
    __privateAdd(this, _options);
    if (!isFormData2(form)) {
      throw new TypeError("Expected first argument to be a FormData instance.");
    }
    let boundary;
    if (isPlainObject2(boundaryOrOptions)) {
      options = boundaryOrOptions;
    } else {
      boundary = boundaryOrOptions;
    }
    if (!boundary) {
      boundary = `form-data-encoder-${createBoundary()}`;
    }
    if (typeof boundary !== "string") {
      throw new TypeError("Expected boundary argument to be a string.");
    }
    if (options && !isPlainObject2(options)) {
      throw new TypeError("Expected options argument to be an object.");
    }
    __privateSet(this, _form, Array.from(form.entries()));
    __privateSet(this, _options, { ...defaultOptions, ...options });
    __privateSet(this, _CRLF_BYTES, __privateGet(this, _encoder).encode(__privateGet(this, _CRLF)));
    __privateSet(this, _CRLF_BYTES_LENGTH, __privateGet(this, _CRLF_BYTES).byteLength);
    this.boundary = boundary;
    this.contentType = `multipart/form-data; boundary=${this.boundary}`;
    __privateSet(this, _footer, __privateGet(this, _encoder).encode(
      `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _DASHES)}${__privateGet(this, _CRLF).repeat(2)}`
    ));
    const headers = {
      "Content-Type": this.contentType
    };
    const contentLength = __privateMethod(this, _FormDataEncoder_instances, getContentLength_fn).call(this);
    if (contentLength) {
      this.contentLength = contentLength;
      headers["Content-Length"] = contentLength;
    }
    this.headers = proxyHeaders(Object.freeze(headers));
    Object.defineProperties(this, {
      boundary: readonlyProp,
      contentType: readonlyProp,
      contentLength: readonlyProp,
      headers: readonlyProp
    });
  }
  /**
   * Creates an iterator allowing to go through form-data parts (with metadata).
   * This method **will not** read the files and **will not** split values big into smaller chunks.
   *
   * Using this method, you can convert form-data content into Blob:
   *
   * @example
   *
   * ```ts
   * import {Readable} from "stream"
   *
   * import {FormDataEncoder} from "form-data-encoder"
   *
   * import {FormData} from "formdata-polyfill/esm-min.js"
   * import {fileFrom} from "fetch-blob/form.js"
   * import {File} from "fetch-blob/file.js"
   * import {Blob} from "fetch-blob"
   *
   * import fetch from "node-fetch"
   *
   * const form = new FormData()
   *
   * form.set("field", "Just a random string")
   * form.set("file", new File(["Using files is class amazing"]))
   * form.set("fileFromPath", await fileFrom("path/to/a/file.txt"))
   *
   * const encoder = new FormDataEncoder(form)
   *
   * const options = {
   *   method: "post",
   *   body: new Blob(encoder, {type: encoder.contentType})
   * }
   *
   * const response = await fetch("https://httpbin.org/post", options)
   *
   * console.log(await response.json())
   * ```
   */
  *values() {
    for (const [name, raw] of __privateGet(this, _form)) {
      const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));
      yield __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value);
      yield value;
      yield __privateGet(this, _CRLF_BYTES);
    }
    yield __privateGet(this, _footer);
  }
  /**
   * Creates an async iterator allowing to perform the encoding by portions.
   * This method reads through files and splits big values into smaller pieces (65536 bytes per each).
   *
   * @example
   *
   * ```ts
   * import {Readable} from "stream"
   *
   * import {FormData, File, fileFromPath} from "formdata-node"
   * import {FormDataEncoder} from "form-data-encoder"
   *
   * import fetch from "node-fetch"
   *
   * const form = new FormData()
   *
   * form.set("field", "Just a random string")
   * form.set("file", new File(["Using files is class amazing"], "file.txt"))
   * form.set("fileFromPath", await fileFromPath("path/to/a/file.txt"))
   *
   * const encoder = new FormDataEncoder(form)
   *
   * const options = {
   *   method: "post",
   *   headers: encoder.headers,
   *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)
   * }
   *
   * const response = await fetch("https://httpbin.org/post", options)
   *
   * console.log(await response.json())
   * ```
   */
  async *encode() {
    for (const part of this.values()) {
      if (isFile(part)) {
        yield* getStreamIterator(part.stream());
      } else {
        yield* chunk(part);
      }
    }
  }
  /**
   * Creates an iterator allowing to read through the encoder data using for...of loops
   */
  [Symbol.iterator]() {
    return this.values();
  }
  /**
   * Creates an **async** iterator allowing to read through the encoder data using for-await...of loops
   */
  [Symbol.asyncIterator]() {
    return this.encode();
  }
};
_CRLF = /* @__PURE__ */ new WeakMap();
_CRLF_BYTES = /* @__PURE__ */ new WeakMap();
_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap();
_DASHES = /* @__PURE__ */ new WeakMap();
_encoder = /* @__PURE__ */ new WeakMap();
_footer = /* @__PURE__ */ new WeakMap();
_form = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_FormDataEncoder_instances = /* @__PURE__ */ new WeakSet();
getFieldHeader_fn = function(name, value) {
  let header = "";
  header += `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _CRLF)}`;
  header += `Content-Disposition: form-data; name="${escapeName(name)}"`;
  if (isFile(value)) {
    header += `; filename="${escapeName(value.name)}"${__privateGet(this, _CRLF)}`;
    header += `Content-Type: ${value.type || "application/octet-stream"}`;
  }
  if (__privateGet(this, _options).enableAdditionalHeaders === true) {
    const size = isFile(value) ? value.size : value.byteLength;
    if (size != null && !isNaN(size)) {
      header += `${__privateGet(this, _CRLF)}Content-Length: ${size}`;
    }
  }
  return __privateGet(this, _encoder).encode(`${header}${__privateGet(this, _CRLF).repeat(2)}`);
};
getContentLength_fn = function() {
  let length = 0;
  for (const [name, raw] of __privateGet(this, _form)) {
    const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));
    const size = isFile(value) ? value.size : value.byteLength;
    if (size == null || isNaN(size)) {
      return void 0;
    }
    length += __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value).byteLength;
    length += size;
    length += __privateGet(this, _CRLF_BYTES_LENGTH);
  }
  return String(length + __privateGet(this, _footer).byteLength);
};

// node_modules/got/dist/source/core/utils/timer.js
import { errorMonitor } from "events";
import { types } from "util";

// node_modules/got/dist/source/core/utils/defer-to-connect.js
function isTlsSocket(socket) {
  return "encrypted" in socket;
}
var deferToConnect = (socket, fn) => {
  let listeners;
  if (typeof fn === "function") {
    const connect = fn;
    listeners = { connect };
  } else {
    listeners = fn;
  }
  const hasConnectListener = typeof listeners.connect === "function";
  const hasSecureConnectListener = typeof listeners.secureConnect === "function";
  const hasCloseListener = typeof listeners.close === "function";
  const onConnect = () => {
    if (hasConnectListener) {
      listeners.connect();
    }
    if (isTlsSocket(socket) && hasSecureConnectListener) {
      if (socket.authorized) {
        listeners.secureConnect();
      } else {
        socket.once("secureConnect", listeners.secureConnect);
      }
    }
    if (hasCloseListener) {
      socket.once("close", listeners.close);
    }
  };
  if (socket.writable && !socket.connecting) {
    onConnect();
  } else if (socket.connecting) {
    socket.once("connect", onConnect);
  } else if (socket.destroyed && hasCloseListener) {
    const hadError = "_hadError" in socket ? Boolean(socket._hadError) : false;
    listeners.close(hadError);
  }
};
var defer_to_connect_default = deferToConnect;

// node_modules/got/dist/source/core/utils/timer.js
var timer = (request) => {
  if (request.timings) {
    return request.timings;
  }
  const timings = {
    start: Date.now(),
    socket: void 0,
    lookup: void 0,
    connect: void 0,
    secureConnect: void 0,
    upload: void 0,
    response: void 0,
    end: void 0,
    error: void 0,
    abort: void 0,
    phases: {
      wait: void 0,
      dns: void 0,
      tcp: void 0,
      tls: void 0,
      request: void 0,
      firstByte: void 0,
      download: void 0,
      total: void 0
    }
  };
  request.timings = timings;
  const handleError = (origin) => {
    origin.once(errorMonitor, () => {
      timings.error = Date.now();
      timings.phases.total = timings.error - timings.start;
    });
  };
  handleError(request);
  const onAbort = () => {
    timings.abort = Date.now();
    timings.phases.total = timings.abort - timings.start;
  };
  request.prependOnceListener("abort", onAbort);
  const onSocket = (socket) => {
    timings.socket = Date.now();
    timings.phases.wait = timings.socket - timings.start;
    if (types.isProxy(socket)) {
      return;
    }
    const socketAlreadyConnected = socket.writable && !socket.connecting;
    if (socketAlreadyConnected) {
      timings.lookup = timings.socket;
      timings.connect = timings.socket;
      if (socket.__initial_connection_timings__) {
        timings.phases.dns = socket.__initial_connection_timings__.dnsPhase;
        timings.phases.tcp = socket.__initial_connection_timings__.tcpPhase;
        timings.phases.tls = socket.__initial_connection_timings__.tlsPhase;
        if (timings.phases.tls !== void 0) {
          timings.secureConnect = timings.socket;
        }
      } else {
        timings.phases.dns = 0;
        timings.phases.tcp = 0;
      }
      return;
    }
    const lookupListener = () => {
      timings.lookup = Date.now();
      timings.phases.dns = timings.lookup - timings.socket;
    };
    socket.prependOnceListener("lookup", lookupListener);
    defer_to_connect_default(socket, {
      connect() {
        timings.connect = Date.now();
        if (timings.lookup === void 0) {
          socket.removeListener("lookup", lookupListener);
          timings.lookup = timings.socket;
          timings.phases.dns = 0;
        }
        timings.phases.tcp = timings.connect - timings.lookup;
        if (timings.phases.tcp === 0 && timings.phases.dns && timings.phases.dns > 0) {
          timings.phases.dns = 0;
        }
        if (!socket.__initial_connection_timings__) {
          socket.__initial_connection_timings__ = {
            dnsPhase: timings.phases.dns,
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion -- TypeScript can't prove this is defined due to callback structure
            tcpPhase: timings.phases.tcp
          };
        }
      },
      secureConnect() {
        timings.secureConnect = Date.now();
        timings.phases.tls = timings.secureConnect - timings.connect;
        if (socket.__initial_connection_timings__) {
          socket.__initial_connection_timings__.tlsPhase = timings.phases.tls;
        }
      }
    });
  };
  if (request.socket) {
    onSocket(request.socket);
  } else {
    request.prependOnceListener("socket", onSocket);
  }
  const onUpload = () => {
    timings.upload = Date.now();
    const secureOrConnect = timings.secureConnect ?? timings.connect;
    if (secureOrConnect !== void 0) {
      timings.phases.request = timings.upload - secureOrConnect;
    }
  };
  if (request.writableFinished) {
    onUpload();
  } else {
    request.prependOnceListener("finish", onUpload);
  }
  request.prependOnceListener("response", (response) => {
    timings.response = Date.now();
    timings.phases.firstByte = timings.response - timings.upload;
    response.timings = timings;
    handleError(response);
    response.prependOnceListener("end", () => {
      request.off("abort", onAbort);
      response.off("aborted", onAbort);
      if (timings.phases.total !== void 0) {
        return;
      }
      timings.end = Date.now();
      timings.phases.download = timings.end - timings.response;
      timings.phases.total = timings.end - timings.start;
    });
    response.prependOnceListener("aborted", onAbort);
  });
  return timings;
};
var timer_default = timer;

// node_modules/got/dist/source/core/utils/get-body-size.js
import { promisify } from "util";

// node_modules/got/dist/source/core/utils/is-form-data.js
function isFormData3(body) {
  return distribution_default.nodeStream(body) && distribution_default.function(body.getBoundary);
}

// node_modules/got/dist/source/core/utils/get-body-size.js
async function getBodySize(body, headers) {
  if (headers && "content-length" in headers) {
    return Number(headers["content-length"]);
  }
  if (!body) {
    return 0;
  }
  if (distribution_default.string(body)) {
    return new TextEncoder().encode(body).byteLength;
  }
  if (distribution_default.buffer(body)) {
    return body.length;
  }
  if (distribution_default.typedArray(body)) {
    return body.byteLength;
  }
  if (isFormData3(body)) {
    try {
      return await promisify(body.getLength.bind(body))();
    } catch (error2) {
      const typedError = error2;
      throw new Error(`Cannot determine content-length for form-data with stream(s) of unknown length. This is a limitation of the \`form-data\` package. To fix this, either:
1. Use the \`knownLength\` option when appending streams:
   form.append('file', stream, {knownLength: 12345});
2. Switch to spec-compliant FormData (formdata-node package)
See: https://github.com/form-data/form-data#alternative-submission-methods
Original error: ${typedError.message}`);
    }
  }
  return void 0;
}

// node_modules/got/dist/source/core/utils/proxy-events.js
function proxyEvents(from, to, events) {
  const eventFunctions = {};
  for (const event of events) {
    const eventFunction = (...arguments_) => {
      to.emit(event, ...arguments_);
    };
    eventFunctions[event] = eventFunction;
    from.on(event, eventFunction);
  }
  return () => {
    for (const [event, eventFunction] of Object.entries(eventFunctions)) {
      from.off(event, eventFunction);
    }
  };
}

// node_modules/got/dist/source/core/timed-out.js
import net from "net";

// node_modules/got/dist/source/core/utils/unhandle.js
function unhandle() {
  const handlers = [];
  return {
    once(origin, event, function_) {
      origin.once(event, function_);
      handlers.push({ origin, event, fn: function_ });
    },
    unhandleAll() {
      for (const handler of handlers) {
        const { origin, event, fn } = handler;
        origin.removeListener(event, fn);
      }
      handlers.length = 0;
    }
  };
}

// node_modules/got/dist/source/core/timed-out.js
var reentry = /* @__PURE__ */ Symbol("reentry");
var noop2 = () => {
};
var TimeoutError2 = class extends Error {
  event;
  name = "TimeoutError";
  code = "ETIMEDOUT";
  constructor(threshold, event) {
    super(`Timeout awaiting '${event}' for ${threshold}ms`);
    this.event = event;
  }
};
function timedOut(request, delays, options) {
  if (reentry in request) {
    return noop2;
  }
  request[reentry] = true;
  const cancelers = [];
  const { once, unhandleAll } = unhandle();
  const handled = /* @__PURE__ */ new Map();
  const addTimeout = (delay3, callback, event) => {
    const timeout = setTimeout(callback, delay3, delay3, event);
    timeout.unref?.();
    const cancel = () => {
      handled.set(event, true);
      clearTimeout(timeout);
    };
    cancelers.push(cancel);
    return cancel;
  };
  const { host, hostname: hostname2 } = options;
  const timeoutHandler = (delay3, event) => {
    setTimeout(() => {
      if (!handled.has(event)) {
        request.destroy(new TimeoutError2(delay3, event));
      }
    }, 0);
  };
  const cancelTimeouts = () => {
    for (const cancel of cancelers) {
      cancel();
    }
    unhandleAll();
  };
  request.once("error", (error2) => {
    cancelTimeouts();
    if (request.listenerCount("error") === 0) {
      throw error2;
    }
  });
  if (delays.request !== void 0) {
    const cancelTimeout = addTimeout(delays.request, timeoutHandler, "request");
    once(request, "response", (response) => {
      once(response, "end", cancelTimeout);
    });
  }
  if (delays.socket !== void 0) {
    const { socket } = delays;
    const socketTimeoutHandler = () => {
      timeoutHandler(socket, "socket");
    };
    request.setTimeout(socket, socketTimeoutHandler);
    cancelers.push(() => {
      request.removeListener("timeout", socketTimeoutHandler);
    });
  }
  const hasLookup = delays.lookup !== void 0;
  const hasConnect = delays.connect !== void 0;
  const hasSecureConnect = delays.secureConnect !== void 0;
  const hasSend = delays.send !== void 0;
  if (hasLookup || hasConnect || hasSecureConnect || hasSend) {
    once(request, "socket", (socket) => {
      const { socketPath } = request;
      if (socket.connecting) {
        const hasPath = Boolean(socketPath ?? net.isIP(hostname2 ?? host ?? "") !== 0);
        if (hasLookup && !hasPath && socket.address().address === void 0) {
          const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
          once(socket, "lookup", cancelTimeout);
        }
        if (hasConnect) {
          const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
          if (hasPath) {
            once(socket, "connect", timeConnect());
          } else {
            once(socket, "lookup", (error2) => {
              if (error2 === null) {
                once(socket, "connect", timeConnect());
              }
            });
          }
        }
        if (hasSecureConnect && options.protocol === "https:") {
          once(socket, "connect", () => {
            const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
            once(socket, "secureConnect", cancelTimeout);
          });
        }
      }
      if (hasSend) {
        const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
        if (socket.connecting) {
          once(socket, "connect", () => {
            once(request, "upload-complete", timeRequest());
          });
        } else {
          once(request, "upload-complete", timeRequest());
        }
      }
    });
  }
  if (delays.response !== void 0) {
    once(request, "upload-complete", () => {
      const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
      once(request, "response", cancelTimeout);
    });
  }
  if (delays.read !== void 0) {
    once(request, "response", (response) => {
      const cancelTimeout = addTimeout(delays.read, timeoutHandler, "read");
      once(response, "end", cancelTimeout);
    });
  }
  return cancelTimeouts;
}

// node_modules/got/dist/source/core/utils/url-to-options.js
function urlToOptions(url) {
  url = url;
  const options = {
    protocol: url.protocol,
    hostname: distribution_default.string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
    host: url.host,
    hash: url.hash,
    search: url.search,
    pathname: url.pathname,
    href: url.href,
    path: `${url.pathname || ""}${url.search || ""}`
  };
  if (distribution_default.string(url.port) && url.port.length > 0) {
    options.port = Number(url.port);
  }
  if (url.username || url.password) {
    options.auth = `${url.username || ""}:${url.password || ""}`;
  }
  return options;
}

// node_modules/got/dist/source/core/utils/weakable-map.js
var WeakableMap = class {
  weakMap = /* @__PURE__ */ new WeakMap();
  map = /* @__PURE__ */ new Map();
  set(key, value) {
    if (typeof key === "object") {
      this.weakMap.set(key, value);
    } else {
      this.map.set(key, value);
    }
  }
  get(key) {
    if (typeof key === "object") {
      return this.weakMap.get(key);
    }
    return this.map.get(key);
  }
  has(key) {
    if (typeof key === "object") {
      return this.weakMap.has(key);
    }
    return this.map.has(key);
  }
};

// node_modules/got/dist/source/core/calculate-retry-delay.js
var calculateRetryDelay = ({ attemptCount, retryOptions, error: error2, retryAfter, computedValue }) => {
  if (error2.name === "RetryError") {
    return 1;
  }
  if (attemptCount > retryOptions.limit) {
    return 0;
  }
  const hasMethod = retryOptions.methods.includes(error2.options.method);
  const hasErrorCode = retryOptions.errorCodes.includes(error2.code);
  const hasStatusCode = error2.response && retryOptions.statusCodes.includes(error2.response.statusCode);
  if (!hasMethod || !hasErrorCode && !hasStatusCode) {
    return 0;
  }
  if (error2.response) {
    if (retryAfter) {
      if (retryAfter > computedValue) {
        return 0;
      }
      return retryAfter;
    }
    if (error2.response.statusCode === 413) {
      return 0;
    }
  }
  const noise = Math.random() * retryOptions.noise;
  return Math.min(2 ** (attemptCount - 1) * 1e3, retryOptions.backoffLimit) + noise;
};
var calculate_retry_delay_default = calculateRetryDelay;

// node_modules/got/dist/source/core/options.js
import process2 from "process";
import { promisify as promisify3, inspect } from "util";
import { checkServerIdentity } from "tls";
import https from "https";
import http from "http";

// node_modules/cacheable-lookup/source/index.js
import {
  V4MAPPED,
  ADDRCONFIG,
  ALL,
  promises as dnsPromises,
  lookup as dnsLookup
} from "dns";
import { promisify as promisify2 } from "util";
import os from "os";
var { Resolver: AsyncResolver } = dnsPromises;
var kCacheableLookupCreateConnection = /* @__PURE__ */ Symbol("cacheableLookupCreateConnection");
var kCacheableLookupInstance = /* @__PURE__ */ Symbol("cacheableLookupInstance");
var kExpires = /* @__PURE__ */ Symbol("expires");
var supportsALL = typeof ALL === "number";
var verifyAgent = (agent) => {
  if (!(agent && typeof agent.createConnection === "function")) {
    throw new Error("Expected an Agent instance as the first argument");
  }
};
var map4to6 = (entries2) => {
  for (const entry of entries2) {
    if (entry.family === 6) {
      continue;
    }
    entry.address = `::ffff:${entry.address}`;
    entry.family = 6;
  }
};
var getIfaceInfo = () => {
  let has4 = false;
  let has6 = false;
  for (const device of Object.values(os.networkInterfaces())) {
    for (const iface of device) {
      if (iface.internal) {
        continue;
      }
      if (iface.family === "IPv6") {
        has6 = true;
      } else {
        has4 = true;
      }
      if (has4 && has6) {
        return { has4, has6 };
      }
    }
  }
  return { has4, has6 };
};
var isIterable2 = (map) => {
  return Symbol.iterator in map;
};
var ignoreNoResultErrors = (dnsPromise) => {
  return dnsPromise.catch((error2) => {
    if (error2.code === "ENODATA" || error2.code === "ENOTFOUND" || error2.code === "ENOENT") {
      return [];
    }
    throw error2;
  });
};
var ttl = { ttl: true };
var all = { all: true };
var all4 = { all: true, family: 4 };
var all6 = { all: true, family: 6 };
var CacheableLookup = class {
  constructor({
    cache = /* @__PURE__ */ new Map(),
    maxTtl = Infinity,
    fallbackDuration = 3600,
    errorTtl = 0.15,
    resolver = new AsyncResolver(),
    lookup = dnsLookup
  } = {}) {
    this.maxTtl = maxTtl;
    this.errorTtl = errorTtl;
    this._cache = cache;
    this._resolver = resolver;
    this._dnsLookup = lookup && promisify2(lookup);
    this.stats = {
      cache: 0,
      query: 0
    };
    if (this._resolver instanceof AsyncResolver) {
      this._resolve4 = this._resolver.resolve4.bind(this._resolver);
      this._resolve6 = this._resolver.resolve6.bind(this._resolver);
    } else {
      this._resolve4 = promisify2(this._resolver.resolve4.bind(this._resolver));
      this._resolve6 = promisify2(this._resolver.resolve6.bind(this._resolver));
    }
    this._iface = getIfaceInfo();
    this._pending = {};
    this._nextRemovalTime = false;
    this._hostnamesToFallback = /* @__PURE__ */ new Set();
    this.fallbackDuration = fallbackDuration;
    if (fallbackDuration > 0) {
      const interval = setInterval(() => {
        this._hostnamesToFallback.clear();
      }, fallbackDuration * 1e3);
      if (interval.unref) {
        interval.unref();
      }
      this._fallbackInterval = interval;
    }
    this.lookup = this.lookup.bind(this);
    this.lookupAsync = this.lookupAsync.bind(this);
  }
  set servers(servers) {
    this.clear();
    this._resolver.setServers(servers);
  }
  get servers() {
    return this._resolver.getServers();
  }
  lookup(hostname2, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (typeof options === "number") {
      options = {
        family: options
      };
    }
    if (!callback) {
      throw new Error("Callback must be a function.");
    }
    this.lookupAsync(hostname2, options).then((result) => {
      if (options.all) {
        callback(null, result);
      } else {
        callback(null, result.address, result.family, result.expires, result.ttl, result.source);
      }
    }, callback);
  }
  async lookupAsync(hostname2, options = {}) {
    if (typeof options === "number") {
      options = {
        family: options
      };
    }
    let cached = await this.query(hostname2);
    if (options.family === 6) {
      const filtered = cached.filter((entry) => entry.family === 6);
      if (options.hints & V4MAPPED) {
        if (supportsALL && options.hints & ALL || filtered.length === 0) {
          map4to6(cached);
        } else {
          cached = filtered;
        }
      } else {
        cached = filtered;
      }
    } else if (options.family === 4) {
      cached = cached.filter((entry) => entry.family === 4);
    }
    if (options.hints & ADDRCONFIG) {
      const { _iface } = this;
      cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
    }
    if (cached.length === 0) {
      const error2 = new Error(`cacheableLookup ENOTFOUND ${hostname2}`);
      error2.code = "ENOTFOUND";
      error2.hostname = hostname2;
      throw error2;
    }
    if (options.all) {
      return cached;
    }
    return cached[0];
  }
  async query(hostname2) {
    let source = "cache";
    let cached = await this._cache.get(hostname2);
    if (cached) {
      this.stats.cache++;
    }
    if (!cached) {
      const pending = this._pending[hostname2];
      if (pending) {
        this.stats.cache++;
        cached = await pending;
      } else {
        source = "query";
        const newPromise = this.queryAndCache(hostname2);
        this._pending[hostname2] = newPromise;
        this.stats.query++;
        try {
          cached = await newPromise;
        } finally {
          delete this._pending[hostname2];
        }
      }
    }
    cached = cached.map((entry) => {
      return { ...entry, source };
    });
    return cached;
  }
  async _resolve(hostname2) {
    const [A, AAAA] = await Promise.all([
      ignoreNoResultErrors(this._resolve4(hostname2, ttl)),
      ignoreNoResultErrors(this._resolve6(hostname2, ttl))
    ]);
    let aTtl = 0;
    let aaaaTtl = 0;
    let cacheTtl = 0;
    const now = Date.now();
    for (const entry of A) {
      entry.family = 4;
      entry.expires = now + entry.ttl * 1e3;
      aTtl = Math.max(aTtl, entry.ttl);
    }
    for (const entry of AAAA) {
      entry.family = 6;
      entry.expires = now + entry.ttl * 1e3;
      aaaaTtl = Math.max(aaaaTtl, entry.ttl);
    }
    if (A.length > 0) {
      if (AAAA.length > 0) {
        cacheTtl = Math.min(aTtl, aaaaTtl);
      } else {
        cacheTtl = aTtl;
      }
    } else {
      cacheTtl = aaaaTtl;
    }
    return {
      entries: [
        ...A,
        ...AAAA
      ],
      cacheTtl
    };
  }
  async _lookup(hostname2) {
    try {
      const [A, AAAA] = await Promise.all([
        // Passing {all: true} doesn't return all IPv4 and IPv6 entries.
        // See https://github.com/szmarczak/cacheable-lookup/issues/42
        ignoreNoResultErrors(this._dnsLookup(hostname2, all4)),
        ignoreNoResultErrors(this._dnsLookup(hostname2, all6))
      ]);
      return {
        entries: [
          ...A,
          ...AAAA
        ],
        cacheTtl: 0
      };
    } catch {
      return {
        entries: [],
        cacheTtl: 0
      };
    }
  }
  async _set(hostname2, data, cacheTtl) {
    if (this.maxTtl > 0 && cacheTtl > 0) {
      cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3;
      data[kExpires] = Date.now() + cacheTtl;
      try {
        await this._cache.set(hostname2, data, cacheTtl);
      } catch (error2) {
        this.lookupAsync = async () => {
          const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
          cacheError.cause = error2;
          throw cacheError;
        };
      }
      if (isIterable2(this._cache)) {
        this._tick(cacheTtl);
      }
    }
  }
  async queryAndCache(hostname2) {
    if (this._hostnamesToFallback.has(hostname2)) {
      return this._dnsLookup(hostname2, all);
    }
    let query = await this._resolve(hostname2);
    if (query.entries.length === 0 && this._dnsLookup) {
      query = await this._lookup(hostname2);
      if (query.entries.length !== 0 && this.fallbackDuration > 0) {
        this._hostnamesToFallback.add(hostname2);
      }
    }
    const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
    await this._set(hostname2, query.entries, cacheTtl);
    return query.entries;
  }
  _tick(ms) {
    const nextRemovalTime = this._nextRemovalTime;
    if (!nextRemovalTime || ms < nextRemovalTime) {
      clearTimeout(this._removalTimeout);
      this._nextRemovalTime = ms;
      this._removalTimeout = setTimeout(() => {
        this._nextRemovalTime = false;
        let nextExpiry = Infinity;
        const now = Date.now();
        for (const [hostname2, entries2] of this._cache) {
          const expires = entries2[kExpires];
          if (now >= expires) {
            this._cache.delete(hostname2);
          } else if (expires < nextExpiry) {
            nextExpiry = expires;
          }
        }
        if (nextExpiry !== Infinity) {
          this._tick(nextExpiry - now);
        }
      }, ms);
      if (this._removalTimeout.unref) {
        this._removalTimeout.unref();
      }
    }
  }
  install(agent) {
    verifyAgent(agent);
    if (kCacheableLookupCreateConnection in agent) {
      throw new Error("CacheableLookup has been already installed");
    }
    agent[kCacheableLookupCreateConnection] = agent.createConnection;
    agent[kCacheableLookupInstance] = this;
    agent.createConnection = (options, callback) => {
      if (!("lookup" in options)) {
        options.lookup = this.lookup;
      }
      return agent[kCacheableLookupCreateConnection](options, callback);
    };
  }
  uninstall(agent) {
    verifyAgent(agent);
    if (agent[kCacheableLookupCreateConnection]) {
      if (agent[kCacheableLookupInstance] !== this) {
        throw new Error("The agent is not owned by this CacheableLookup instance");
      }
      agent.createConnection = agent[kCacheableLookupCreateConnection];
      delete agent[kCacheableLookupCreateConnection];
      delete agent[kCacheableLookupInstance];
    }
  }
  updateInterfaceInfo() {
    const { _iface } = this;
    this._iface = getIfaceInfo();
    if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
      this._cache.clear();
    }
  }
  clear(hostname2) {
    if (hostname2) {
      this._cache.delete(hostname2);
      return;
    }
    this._cache.clear();
  }
};

// node_modules/got/dist/source/core/options.js
var import_http2_wrapper = __toESM(require_source(), 1);

// node_modules/got/dist/source/core/parse-link-header.js
function parseLinkHeader(link) {
  const parsed = [];
  const items = link.split(",");
  for (const item of items) {
    const [rawUriReference, ...rawLinkParameters] = item.split(";");
    const trimmedUriReference = rawUriReference.trim();
    if (trimmedUriReference[0] !== "<" || trimmedUriReference.at(-1) !== ">") {
      throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
    }
    const reference = trimmedUriReference.slice(1, -1);
    const parameters = {};
    if (rawLinkParameters.length === 0) {
      throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(";")}`);
    }
    for (const rawParameter of rawLinkParameters) {
      const trimmedRawParameter = rawParameter.trim();
      const center = trimmedRawParameter.indexOf("=");
      if (center === -1) {
        throw new Error(`Failed to parse Link header: ${link}`);
      }
      const name = trimmedRawParameter.slice(0, center).trim();
      const value = trimmedRawParameter.slice(center + 1).trim();
      parameters[name] = value;
    }
    parsed.push({
      reference,
      parameters
    });
  }
  return parsed;
}

// node_modules/got/dist/source/core/options.js
var [major, minor] = process2.versions.node.split(".").map(Number);
function wrapAssertionWithContext(optionName, assertionFn) {
  try {
    assertionFn();
  } catch (error2) {
    if (error2 instanceof Error) {
      error2.message = `Option '${optionName}': ${error2.message}`;
    }
    throw error2;
  }
}
function assertAny2(optionName, validators, value) {
  wrapAssertionWithContext(optionName, () => {
    assert.any(validators, value);
  });
}
function assertPlainObject2(optionName, value) {
  wrapAssertionWithContext(optionName, () => {
    assert.plainObject(value);
  });
}
function validateSearchParameters(searchParameters) {
  for (const key in searchParameters) {
    const value = searchParameters[key];
    assertAny2(`searchParams.${key}`, [distribution_default.string, distribution_default.number, distribution_default.boolean, distribution_default.null, distribution_default.undefined], value);
  }
}
var globalCache = /* @__PURE__ */ new Map();
var globalDnsCache;
var getGlobalDnsCache = () => {
  if (globalDnsCache) {
    return globalDnsCache;
  }
  globalDnsCache = new CacheableLookup();
  return globalDnsCache;
};
var wrapQuickLruIfNeeded = (value) => {
  if (value?.[Symbol.toStringTag] === "QuickLRU" && typeof value.evict === "function") {
    return {
      get(key) {
        return value.get(key);
      },
      set(key, cacheValue, ttl2) {
        if (ttl2 === void 0) {
          value.set(key, cacheValue);
        } else {
          value.set(key, cacheValue, { maxAge: ttl2 });
        }
        return true;
      },
      delete(key) {
        return value.delete(key);
      },
      clear() {
        return value.clear();
      },
      has(key) {
        return value.has(key);
      }
    };
  }
  return value;
};
var defaultInternals = {
  request: void 0,
  agent: {
    http: void 0,
    https: void 0,
    http2: void 0
  },
  h2session: void 0,
  decompress: true,
  timeout: {
    connect: void 0,
    lookup: void 0,
    read: void 0,
    request: void 0,
    response: void 0,
    secureConnect: void 0,
    send: void 0,
    socket: void 0
  },
  prefixUrl: "",
  body: void 0,
  form: void 0,
  json: void 0,
  cookieJar: void 0,
  ignoreInvalidCookies: false,
  searchParams: void 0,
  dnsLookup: void 0,
  dnsCache: void 0,
  context: {},
  hooks: {
    init: [],
    beforeRequest: [],
    beforeError: [],
    beforeRedirect: [],
    beforeRetry: [],
    beforeCache: [],
    afterResponse: []
  },
  followRedirect: true,
  maxRedirects: 10,
  cache: void 0,
  throwHttpErrors: true,
  username: "",
  password: "",
  http2: false,
  allowGetBody: false,
  copyPipedHeaders: true,
  headers: {
    "user-agent": "got (https://github.com/sindresorhus/got)"
  },
  methodRewriting: false,
  dnsLookupIpVersion: void 0,
  parseJson: JSON.parse,
  stringifyJson: JSON.stringify,
  retry: {
    limit: 2,
    methods: [
      "GET",
      "PUT",
      "HEAD",
      "DELETE",
      "OPTIONS",
      "TRACE"
    ],
    statusCodes: [
      408,
      413,
      429,
      500,
      502,
      503,
      504,
      521,
      522,
      524
    ],
    errorCodes: [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ECONNREFUSED",
      "EPIPE",
      "ENOTFOUND",
      "ENETUNREACH",
      "EAI_AGAIN"
    ],
    maxRetryAfter: void 0,
    calculateDelay: ({ computedValue }) => computedValue,
    backoffLimit: Number.POSITIVE_INFINITY,
    noise: 100,
    // TODO: Change default to `true` in the next major version to fix https://github.com/sindresorhus/got/issues/2243
    enforceRetryRules: false
  },
  localAddress: void 0,
  method: "GET",
  createConnection: void 0,
  cacheOptions: {
    shared: void 0,
    cacheHeuristic: void 0,
    immutableMinTimeToLive: void 0,
    ignoreCargoCult: void 0
  },
  https: {
    alpnProtocols: void 0,
    rejectUnauthorized: void 0,
    checkServerIdentity: void 0,
    serverName: void 0,
    certificateAuthority: void 0,
    key: void 0,
    certificate: void 0,
    passphrase: void 0,
    pfx: void 0,
    ciphers: void 0,
    honorCipherOrder: void 0,
    minVersion: void 0,
    maxVersion: void 0,
    signatureAlgorithms: void 0,
    tlsSessionLifetime: void 0,
    dhparam: void 0,
    ecdhCurve: void 0,
    certificateRevocationLists: void 0,
    secureOptions: void 0
  },
  encoding: void 0,
  resolveBodyOnly: false,
  isStream: false,
  responseType: "text",
  url: void 0,
  pagination: {
    transform(response) {
      if (response.request.options.responseType === "json") {
        return response.body;
      }
      return JSON.parse(response.body);
    },
    paginate({ response }) {
      const rawLinkHeader = response.headers.link;
      if (typeof rawLinkHeader !== "string" || rawLinkHeader.trim() === "") {
        return false;
      }
      const parsed = parseLinkHeader(rawLinkHeader);
      const next = parsed.find((entry) => entry.parameters.rel === "next" || entry.parameters.rel === '"next"');
      if (next) {
        return {
          url: new URL(next.reference, response.url)
        };
      }
      return false;
    },
    filter: () => true,
    shouldContinue: () => true,
    countLimit: Number.POSITIVE_INFINITY,
    backoff: 0,
    requestLimit: 1e4,
    stackAllItems: false
  },
  setHost: true,
  maxHeaderSize: void 0,
  signal: void 0,
  enableUnixSockets: false,
  strictContentLength: false
};
var cloneInternals = (internals) => {
  const { hooks, retry } = internals;
  const result = {
    ...internals,
    context: { ...internals.context },
    cacheOptions: { ...internals.cacheOptions },
    https: { ...internals.https },
    agent: { ...internals.agent },
    headers: { ...internals.headers },
    retry: {
      ...retry,
      errorCodes: [...retry.errorCodes],
      methods: [...retry.methods],
      statusCodes: [...retry.statusCodes]
    },
    timeout: { ...internals.timeout },
    hooks: {
      init: [...hooks.init],
      beforeRequest: [...hooks.beforeRequest],
      beforeError: [...hooks.beforeError],
      beforeRedirect: [...hooks.beforeRedirect],
      beforeRetry: [...hooks.beforeRetry],
      beforeCache: [...hooks.beforeCache],
      afterResponse: [...hooks.afterResponse]
    },
    searchParams: internals.searchParams ? new URLSearchParams(internals.searchParams) : void 0,
    pagination: { ...internals.pagination }
  };
  return result;
};
var cloneRaw = (raw) => {
  const { hooks, retry } = raw;
  const result = { ...raw };
  if (distribution_default.object(raw.context)) {
    result.context = { ...raw.context };
  }
  if (distribution_default.object(raw.cacheOptions)) {
    result.cacheOptions = { ...raw.cacheOptions };
  }
  if (distribution_default.object(raw.https)) {
    result.https = { ...raw.https };
  }
  if (distribution_default.object(raw.cacheOptions)) {
    result.cacheOptions = { ...result.cacheOptions };
  }
  if (distribution_default.object(raw.agent)) {
    result.agent = { ...raw.agent };
  }
  if (distribution_default.object(raw.headers)) {
    result.headers = { ...raw.headers };
  }
  if (distribution_default.object(retry)) {
    result.retry = { ...retry };
    if (distribution_default.array(retry.errorCodes)) {
      result.retry.errorCodes = [...retry.errorCodes];
    }
    if (distribution_default.array(retry.methods)) {
      result.retry.methods = [...retry.methods];
    }
    if (distribution_default.array(retry.statusCodes)) {
      result.retry.statusCodes = [...retry.statusCodes];
    }
  }
  if (distribution_default.object(raw.timeout)) {
    result.timeout = { ...raw.timeout };
  }
  if (distribution_default.object(hooks)) {
    result.hooks = {
      ...hooks
    };
    if (distribution_default.array(hooks.init)) {
      result.hooks.init = [...hooks.init];
    }
    if (distribution_default.array(hooks.beforeRequest)) {
      result.hooks.beforeRequest = [...hooks.beforeRequest];
    }
    if (distribution_default.array(hooks.beforeError)) {
      result.hooks.beforeError = [...hooks.beforeError];
    }
    if (distribution_default.array(hooks.beforeRedirect)) {
      result.hooks.beforeRedirect = [...hooks.beforeRedirect];
    }
    if (distribution_default.array(hooks.beforeRetry)) {
      result.hooks.beforeRetry = [...hooks.beforeRetry];
    }
    if (distribution_default.array(hooks.beforeCache)) {
      result.hooks.beforeCache = [...hooks.beforeCache];
    }
    if (distribution_default.array(hooks.afterResponse)) {
      result.hooks.afterResponse = [...hooks.afterResponse];
    }
  }
  if (raw.searchParams) {
    if (distribution_default.string(raw.searchParams)) {
      result.searchParams = raw.searchParams;
    } else if (raw.searchParams instanceof URLSearchParams) {
      result.searchParams = new URLSearchParams(raw.searchParams);
    } else if (distribution_default.object(raw.searchParams)) {
      result.searchParams = { ...raw.searchParams };
    }
  }
  if (distribution_default.object(raw.pagination)) {
    result.pagination = { ...raw.pagination };
  }
  return result;
};
var getHttp2TimeoutOption = (internals) => {
  const delays = [internals.timeout.socket, internals.timeout.connect, internals.timeout.lookup, internals.timeout.request, internals.timeout.secureConnect].filter((delay3) => typeof delay3 === "number");
  if (delays.length > 0) {
    return Math.min(...delays);
  }
  return void 0;
};
var init = (options, withOptions, self2) => {
  const initHooks = options.hooks?.init;
  if (initHooks) {
    for (const hook of initHooks) {
      hook(withOptions, self2);
    }
  }
};
var Options = class _Options {
  _unixOptions;
  _internals;
  _merging = false;
  _init;
  constructor(input, options, defaults2) {
    assertAny2("input", [distribution_default.string, distribution_default.urlInstance, distribution_default.object, distribution_default.undefined], input);
    assertAny2("options", [distribution_default.object, distribution_default.undefined], options);
    assertAny2("defaults", [distribution_default.object, distribution_default.undefined], defaults2);
    if (input instanceof _Options || options instanceof _Options) {
      throw new TypeError("The defaults must be passed as the third argument");
    }
    this._internals = cloneInternals(defaults2?._internals ?? defaults2 ?? defaultInternals);
    this._init = [...defaults2?._init ?? []];
    try {
      if (distribution_default.plainObject(input)) {
        try {
          this.merge(input);
          this.merge(options);
        } finally {
          this.url = input.url;
        }
      } else {
        try {
          this.merge(options);
        } finally {
          if (options?.url !== void 0) {
            if (input === void 0) {
              this.url = options.url;
            } else {
              throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
            }
          } else if (input !== void 0) {
            this.url = input;
          }
        }
      }
    } catch (error2) {
      error2.options = this;
      throw error2;
    }
  }
  merge(options) {
    if (!options) {
      return;
    }
    if (options instanceof _Options) {
      const initArray = [...options._init];
      for (const init2 of initArray) {
        this.merge(init2);
      }
      return;
    }
    options = cloneRaw(options);
    init(this, options, this);
    init(options, options, this);
    this._merging = true;
    if ("isStream" in options) {
      this.isStream = options.isStream;
    }
    try {
      let push = false;
      for (const key in options) {
        if (key === "mutableDefaults" || key === "handlers") {
          continue;
        }
        if (key === "url") {
          continue;
        }
        if (key === "preserveHooks") {
          continue;
        }
        if (!(key in this)) {
          throw new Error(`Unexpected option: ${key}`);
        }
        const value = options[key];
        if (value === void 0) {
          continue;
        }
        this[key] = value;
        push = true;
      }
      if (push) {
        this._init.push(options);
      }
    } finally {
      this._merging = false;
    }
  }
  /**
      Custom request function.
      The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).
  
      @default http.request | https.request
      */
  get request() {
    return this._internals.request;
  }
  set request(value) {
    assertAny2("request", [distribution_default.function, distribution_default.undefined], value);
    this._internals.request = value;
  }
  /**
      An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
      This is necessary because a request to one protocol might redirect to another.
      In such a scenario, Got will switch over to the right protocol agent for you.
  
      If a key is not present, it will default to a global agent.
  
      @example
      ```
      import got from 'got';
      import HttpAgent from 'agentkeepalive';
  
      const {HttpsAgent} = HttpAgent;
  
      await got('https://sindresorhus.com', {
          agent: {
              http: new HttpAgent(),
              https: new HttpsAgent()
          }
      });
      ```
      */
  get agent() {
    return this._internals.agent;
  }
  set agent(value) {
    assertPlainObject2("agent", value);
    for (const key in value) {
      if (!(key in this._internals.agent)) {
        throw new TypeError(`Unexpected agent option: ${key}`);
      }
      assertAny2(`agent.${key}`, [distribution_default.object, distribution_default.undefined, (v) => v === false], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.agent, value);
    } else {
      this._internals.agent = { ...value };
    }
  }
  get h2session() {
    return this._internals.h2session;
  }
  set h2session(value) {
    this._internals.h2session = value;
  }
  /**
      Decompress the response automatically.
  
      This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.
  
      If this is disabled, a compressed response is returned as a `Buffer`.
      This may be useful if you want to handle decompression yourself or stream the raw compressed data.
  
      @default true
      */
  get decompress() {
    return this._internals.decompress;
  }
  set decompress(value) {
    assert.boolean(value);
    this._internals.decompress = value;
  }
  /**
      Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
      By default, there's no timeout.
  
      This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:
  
      - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
          Does not apply when using a Unix domain socket.
      - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
      - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
      - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
      - `response` starts when the request has been written to the socket and ends when the response headers are received.
      - `send` starts when the socket is connected and ends with the request has been written to the socket.
      - `request` starts when the request is initiated and ends when the response's end event fires.
      */
  get timeout() {
    return this._internals.timeout;
  }
  set timeout(value) {
    assertPlainObject2("timeout", value);
    for (const key in value) {
      if (!(key in this._internals.timeout)) {
        throw new Error(`Unexpected timeout option: ${key}`);
      }
      assertAny2(`timeout.${key}`, [distribution_default.number, distribution_default.undefined], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.timeout, value);
    } else {
      this._internals.timeout = { ...value };
    }
  }
  /**
      When specified, `prefixUrl` will be prepended to `url`.
      The prefix can be any valid URL, either relative or absolute.
      A trailing slash `/` is optional - one will be added automatically.
  
      __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.
  
      __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
      For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
      The latter is used by browsers.
  
      __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.
  
      __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
      If the URL doesn't include it anymore, it will throw.
  
      @example
      ```
      import got from 'got';
  
      await got('unicorn', {prefixUrl: 'https://cats.com'});
      //=> 'https://cats.com/unicorn'
  
      const instance = got.extend({
          prefixUrl: 'https://google.com'
      });
  
      await instance('unicorn', {
          hooks: {
              beforeRequest: [
                  options => {
                      options.prefixUrl = 'https://cats.com';
                  }
              ]
          }
      });
      //=> 'https://cats.com/unicorn'
      ```
      */
  get prefixUrl() {
    return this._internals.prefixUrl;
  }
  set prefixUrl(value) {
    assertAny2("prefixUrl", [distribution_default.string, distribution_default.urlInstance], value);
    if (value === "") {
      this._internals.prefixUrl = "";
      return;
    }
    value = value.toString();
    if (!value.endsWith("/")) {
      value += "/";
    }
    if (this._internals.prefixUrl && this._internals.url) {
      const { href } = this._internals.url;
      this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
    }
    this._internals.prefixUrl = value;
  }
  /**
      __Note #1__: The `body` option cannot be used with the `json` or `form` option.
  
      __Note #2__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.
  
      __Note #4__: This option is not enumerable and will not be merged with the instance defaults.
  
      The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / typed array ([`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), etc.) / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.
  
      Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.
  
      You can use `Iterable` and `AsyncIterable` objects as request body, including Web [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream):
  
      @example
      ```
      import got from 'got';
  
      // Using an async generator
      async function* generateData() {
          yield 'Hello, ';
          yield 'world!';
      }
  
      await got.post('https://httpbin.org/anything', {
          body: generateData()
      });
      ```
      */
  get body() {
    return this._internals.body;
  }
  set body(value) {
    assertAny2("body", [distribution_default.string, distribution_default.buffer, distribution_default.nodeStream, distribution_default.generator, distribution_default.asyncGenerator, distribution_default.iterable, distribution_default.asyncIterable, isFormData2, distribution_default.typedArray, distribution_default.undefined], value);
    if (distribution_default.nodeStream(value)) {
      assert.truthy(value.readable);
    }
    if (value !== void 0) {
      assert.undefined(this._internals.form);
      assert.undefined(this._internals.json);
    }
    this._internals.body = value;
  }
  /**
      The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).
  
      If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.
  
      __Note #1__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
      */
  get form() {
    return this._internals.form;
  }
  set form(value) {
    assertAny2("form", [distribution_default.plainObject, distribution_default.undefined], value);
    if (value !== void 0) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.json);
    }
    this._internals.form = value;
  }
  /**
      JSON request body. If the `content-type` header is not set, it will be set to `application/json`.
  
      __Important__: This option only affects the request body you send to the server. To parse the response as JSON, you must either call `.json()` on the promise or set `responseType: 'json'` in the options.
  
      __Note #1__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
      */
  get json() {
    return this._internals.json;
  }
  set json(value) {
    if (value !== void 0) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.form);
    }
    this._internals.json = value;
  }
  /**
      The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).
  
      Properties from `options` will override properties in the parsed `url`.
  
      If no protocol is specified, it will throw a `TypeError`.
  
      __Note__: The query string is **not** parsed as search params.
  
      @example
      ```
      await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
      await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
  
      // The query string is overridden by `searchParams`
      await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
      ```
      */
  get url() {
    return this._internals.url;
  }
  set url(value) {
    assertAny2("url", [distribution_default.string, distribution_default.urlInstance, distribution_default.undefined], value);
    if (value === void 0) {
      this._internals.url = void 0;
      return;
    }
    if (distribution_default.string(value) && value.startsWith("/")) {
      throw new Error("`url` must not start with a slash");
    }
    const valueString = value.toString();
    const isAbsolute = distribution_default.urlInstance(value) || /^[a-z][a-z\d+.-]*:\/\//i.test(valueString);
    const urlString = isAbsolute ? valueString : `${this.prefixUrl}${valueString}`;
    const url = new URL(urlString);
    this._internals.url = url;
    if (url.protocol === "unix:") {
      url.href = `http://unix${url.pathname}${url.search}`;
    }
    if (url.protocol !== "http:" && url.protocol !== "https:") {
      const error2 = new Error(`Unsupported protocol: ${url.protocol}`);
      error2.code = "ERR_UNSUPPORTED_PROTOCOL";
      throw error2;
    }
    if (this._internals.username) {
      url.username = this._internals.username;
      this._internals.username = "";
    }
    if (this._internals.password) {
      url.password = this._internals.password;
      this._internals.password = "";
    }
    if (this._internals.searchParams) {
      url.search = this._internals.searchParams.toString();
      this._internals.searchParams = void 0;
    }
    if (url.hostname === "unix") {
      if (!this._internals.enableUnixSockets) {
        throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
      }
      const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
      if (matches?.groups) {
        const { socketPath, path: path2 } = matches.groups;
        this._unixOptions = {
          socketPath,
          path: path2,
          host: ""
        };
      } else {
        this._unixOptions = void 0;
      }
      return;
    }
    this._unixOptions = void 0;
  }
  /**
      Cookie support. You don't have to care about parsing or how to store them.
  
      __Note__: If you provide this option, `options.headers.cookie` will be overridden.
      */
  get cookieJar() {
    return this._internals.cookieJar;
  }
  set cookieJar(value) {
    assertAny2("cookieJar", [distribution_default.object, distribution_default.undefined], value);
    if (value === void 0) {
      this._internals.cookieJar = void 0;
      return;
    }
    let { setCookie, getCookieString } = value;
    assert.function(setCookie);
    assert.function(getCookieString);
    if (setCookie.length === 4 && getCookieString.length === 0) {
      setCookie = promisify3(setCookie.bind(value));
      getCookieString = promisify3(getCookieString.bind(value));
      this._internals.cookieJar = {
        setCookie,
        getCookieString
      };
    } else {
      this._internals.cookieJar = value;
    }
  }
  /**
      You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
  
      @example
      ```
      import got from 'got';
  
      const abortController = new AbortController();
  
      const request = got('https://httpbin.org/anything', {
          signal: abortController.signal
      });
  
      setTimeout(() => {
          abortController.abort();
      }, 100);
      ```
      */
  get signal() {
    return this._internals.signal;
  }
  set signal(value) {
    assert.object(value);
    this._internals.signal = value;
  }
  /**
      Ignore invalid cookies instead of throwing an error.
      Only useful when the `cookieJar` option has been set. Not recommended.
  
      @default false
      */
  get ignoreInvalidCookies() {
    return this._internals.ignoreInvalidCookies;
  }
  set ignoreInvalidCookies(value) {
    assert.boolean(value);
    this._internals.ignoreInvalidCookies = value;
  }
  /**
      Query string that will be added to the request URL.
      This will override the query string in `url`.
  
      If you need to pass in an array, you can do it using a `URLSearchParams` instance.
  
      @example
      ```
      import got from 'got';
  
      const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);
  
      await got('https://example.com', {searchParams});
  
      console.log(searchParams.toString());
      //=> 'key=a&key=b'
      ```
      */
  get searchParams() {
    if (this._internals.url) {
      return this._internals.url.searchParams;
    }
    if (this._internals.searchParams === void 0) {
      this._internals.searchParams = new URLSearchParams();
    }
    return this._internals.searchParams;
  }
  set searchParams(value) {
    assertAny2("searchParams", [distribution_default.string, distribution_default.object, distribution_default.undefined], value);
    const url = this._internals.url;
    if (value === void 0) {
      this._internals.searchParams = void 0;
      if (url) {
        url.search = "";
      }
      return;
    }
    const searchParameters = this.searchParams;
    let updated;
    if (distribution_default.string(value)) {
      updated = new URLSearchParams(value);
    } else if (value instanceof URLSearchParams) {
      updated = value;
    } else {
      validateSearchParameters(value);
      updated = new URLSearchParams();
      for (const key in value) {
        const entry = value[key];
        if (entry === null) {
          updated.append(key, "");
        } else if (entry === void 0) {
          searchParameters.delete(key);
        } else {
          updated.append(key, entry);
        }
      }
    }
    if (this._merging) {
      for (const key of updated.keys()) {
        searchParameters.delete(key);
      }
      for (const [key, value2] of updated) {
        searchParameters.append(key, value2);
      }
    } else if (url) {
      url.search = searchParameters.toString();
    } else {
      this._internals.searchParams = searchParameters;
    }
  }
  get searchParameters() {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  set searchParameters(_value) {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  get dnsLookup() {
    return this._internals.dnsLookup;
  }
  set dnsLookup(value) {
    assertAny2("dnsLookup", [distribution_default.function, distribution_default.undefined], value);
    this._internals.dnsLookup = value;
  }
  /**
      An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
      Useful when making lots of requests to different *public* hostnames.
  
      `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.
  
      __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.
  
      @default false
      */
  get dnsCache() {
    return this._internals.dnsCache;
  }
  set dnsCache(value) {
    assertAny2("dnsCache", [distribution_default.object, distribution_default.boolean, distribution_default.undefined], value);
    if (value === true) {
      this._internals.dnsCache = getGlobalDnsCache();
    } else if (value === false) {
      this._internals.dnsCache = void 0;
    } else {
      this._internals.dnsCache = value;
    }
  }
  /**
      User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.
  
      @example
      ```
      import got from 'got';
  
      const instance = got.extend({
          hooks: {
              beforeRequest: [
                  options => {
                      if (!options.context || !options.context.token) {
                          throw new Error('Token required');
                      }
  
                      options.headers.token = options.context.token;
                  }
              ]
          }
      });
  
      const context = {
          token: 'secret'
      };
  
      const response = await instance('https://httpbin.org/headers', {context});
  
      // Let's see the headers
      console.log(response.body);
      ```
      */
  get context() {
    return this._internals.context;
  }
  set context(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.context, value);
    } else {
      this._internals.context = { ...value };
    }
  }
  /**
  Hooks allow modifications during the request lifecycle.
  Hook functions may be async and are run serially.
  */
  get hooks() {
    return this._internals.hooks;
  }
  set hooks(value) {
    assert.object(value);
    for (const knownHookEvent in value) {
      if (!(knownHookEvent in this._internals.hooks)) {
        throw new Error(`Unexpected hook event: ${knownHookEvent}`);
      }
      const typedKnownHookEvent = knownHookEvent;
      const hooks = value[typedKnownHookEvent];
      assertAny2(`hooks.${knownHookEvent}`, [distribution_default.array, distribution_default.undefined], hooks);
      if (hooks) {
        for (const hook of hooks) {
          assert.function(hook);
        }
      }
      if (this._merging) {
        if (hooks) {
          this._internals.hooks[typedKnownHookEvent].push(...hooks);
        }
      } else {
        if (!hooks) {
          throw new Error(`Missing hook event: ${knownHookEvent}`);
        }
        this._internals.hooks[knownHookEvent] = [...hooks];
      }
    }
  }
  /**
      Whether redirect responses should be followed automatically.
  
      Optionally, pass a function to dynamically decide based on the response object.
  
      Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
      This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.
  
      @default true
      */
  get followRedirect() {
    return this._internals.followRedirect;
  }
  set followRedirect(value) {
    assertAny2("followRedirect", [distribution_default.boolean, distribution_default.function], value);
    this._internals.followRedirect = value;
  }
  get followRedirects() {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  set followRedirects(_value) {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  /**
      If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.
  
      @default 10
      */
  get maxRedirects() {
    return this._internals.maxRedirects;
  }
  set maxRedirects(value) {
    assert.number(value);
    this._internals.maxRedirects = value;
  }
  /**
      A cache adapter instance for storing cached response data.
  
      @default false
      */
  get cache() {
    return this._internals.cache;
  }
  set cache(value) {
    assertAny2("cache", [distribution_default.object, distribution_default.string, distribution_default.boolean, distribution_default.undefined], value);
    if (value === true) {
      this._internals.cache = globalCache;
    } else if (value === false) {
      this._internals.cache = void 0;
    } else {
      this._internals.cache = wrapQuickLruIfNeeded(value);
    }
  }
  /**
      Determines if a `got.HTTPError` is thrown for unsuccessful responses.
  
      If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
      This may be useful if you are checking for resource availability and are expecting error responses.
  
      @default true
      */
  get throwHttpErrors() {
    return this._internals.throwHttpErrors;
  }
  set throwHttpErrors(value) {
    assert.boolean(value);
    this._internals.throwHttpErrors = value;
  }
  get username() {
    const url = this._internals.url;
    const value = url ? url.username : this._internals.username;
    return decodeURIComponent(value);
  }
  set username(value) {
    assert.string(value);
    const url = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url) {
      url.username = fixedValue;
    } else {
      this._internals.username = fixedValue;
    }
  }
  get password() {
    const url = this._internals.url;
    const value = url ? url.password : this._internals.password;
    return decodeURIComponent(value);
  }
  set password(value) {
    assert.string(value);
    const url = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url) {
      url.password = fixedValue;
    } else {
      this._internals.password = fixedValue;
    }
  }
  /**
      If set to `true`, Got will additionally accept HTTP2 requests.
  
      It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.
  
      __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.
  
      __Note__: Overriding `options.request` will disable HTTP2 support.
  
      @default false
  
      @example
      ```
      import got from 'got';
  
      const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});
  
      console.log(headers.via);
      //=> '2 nghttpx'
      ```
      */
  get http2() {
    return this._internals.http2;
  }
  set http2(value) {
    assert.boolean(value);
    this._internals.http2 = value;
  }
  /**
      Set this to `true` to allow sending body for the `GET` method.
      However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
      This option is only meant to interact with non-compliant servers when you have no other choice.
  
      __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.
  
      @default false
      */
  get allowGetBody() {
    return this._internals.allowGetBody;
  }
  set allowGetBody(value) {
    assert.boolean(value);
    this._internals.allowGetBody = value;
  }
  /**
      Automatically copy headers from piped streams.
  
      When piping a request into a Got stream (e.g., `request.pipe(got.stream(url))`), this controls whether headers from the source stream are automatically merged into the Got request headers.
  
      Note: Piped headers overwrite any explicitly set headers with the same name. To override this, either set `copyPipedHeaders` to `false` and manually copy safe headers, or use a `beforeRequest` hook to force specific header values after piping.
  
      Useful for proxy scenarios, but you may want to disable this to filter out headers like `Host`, `Connection`, `Authorization`, etc.
  
      @default true
  
      @example
      ```
      import got from 'got';
      import {pipeline} from 'node:stream/promises';
  
      // Disable automatic header copying and manually copy only safe headers
      server.get('/proxy', async (request, response) => {
          const gotStream = got.stream('https://example.com', {
              copyPipedHeaders: false,
              headers: {
                  'user-agent': request.headers['user-agent'],
                  'accept': request.headers['accept'],
                  // Explicitly NOT copying host, connection, authorization, etc.
              }
          });
  
          await pipeline(request, gotStream, response);
      });
      ```
  
      @example
      ```
      import got from 'got';
  
      // Override piped headers using beforeRequest hook
      const gotStream = got.stream('https://example.com', {
          hooks: {
              beforeRequest: [
                  options => {
                      // Force specific header values after piping
                      options.headers.host = 'example.com';
                      delete options.headers.authorization;
                  }
              ]
          }
      });
      ```
      */
  get copyPipedHeaders() {
    return this._internals.copyPipedHeaders;
  }
  set copyPipedHeaders(value) {
    assert.boolean(value);
    this._internals.copyPipedHeaders = value;
  }
  /**
      Request headers.
  
      Existing headers will be overwritten. Headers set to `undefined` will be omitted.
  
      @default {}
      */
  get headers() {
    return this._internals.headers;
  }
  set headers(value) {
    assertPlainObject2("headers", value);
    if (this._merging) {
      Object.assign(this._internals.headers, lowercaseKeys(value));
    } else {
      this._internals.headers = lowercaseKeys(value);
    }
  }
  /**
      Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.
  
      As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
      Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.
  
      __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).
  
      @default false
      */
  get methodRewriting() {
    return this._internals.methodRewriting;
  }
  set methodRewriting(value) {
    assert.boolean(value);
    this._internals.methodRewriting = value;
  }
  /**
      Indicates which DNS record family to use.
  
      Values:
      - `undefined`: IPv4 (if present) or IPv6
      - `4`: Only IPv4
      - `6`: Only IPv6
  
      @default undefined
      */
  get dnsLookupIpVersion() {
    return this._internals.dnsLookupIpVersion;
  }
  set dnsLookupIpVersion(value) {
    if (value !== void 0 && value !== 4 && value !== 6) {
      throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
    }
    this._internals.dnsLookupIpVersion = value;
  }
  /**
      A function used to parse JSON responses.
  
      @example
      ```
      import got from 'got';
      import Bourne from '@hapi/bourne';
  
      const parsed = await got('https://example.com', {
          parseJson: text => Bourne.parse(text)
      }).json();
  
      console.log(parsed);
      ```
      */
  get parseJson() {
    return this._internals.parseJson;
  }
  set parseJson(value) {
    assert.function(value);
    this._internals.parseJson = value;
  }
  /**
      A function used to stringify the body of JSON requests.
  
      @example
      ```
      import got from 'got';
  
      await got.post('https://example.com', {
          stringifyJson: object => JSON.stringify(object, (key, value) => {
              if (key.startsWith('_')) {
                  return;
              }
  
              return value;
          }),
          json: {
              some: 'payload',
              _ignoreMe: 1234
          }
      });
      ```
  
      @example
      ```
      import got from 'got';
  
      await got.post('https://example.com', {
          stringifyJson: object => JSON.stringify(object, (key, value) => {
              if (typeof value === 'number') {
                  return value.toString();
              }
  
              return value;
          }),
          json: {
              some: 'payload',
              number: 1
          }
      });
      ```
      */
  get stringifyJson() {
    return this._internals.stringifyJson;
  }
  set stringifyJson(value) {
    assert.function(value);
    this._internals.stringifyJson = value;
  }
  /**
      An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.
  
      Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).
  
      The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
      The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).
  
      The `enforceRetryRules` property is a `boolean` that, when set to `true`, enforces the `limit`, `methods`, `statusCodes`, and `errorCodes` options before calling `calculateDelay`. Your `calculateDelay` function is only invoked when a retry is allowed based on these criteria. When `false` (default), `calculateDelay` receives the computed value but can override all retry logic.
  
      __Note:__ When `enforceRetryRules` is `false`, you must check `computedValue` in your `calculateDelay` function to respect the default retry logic. When `true`, the retry rules are enforced automatically.
  
      By default, it retries *only* on the specified methods, status codes, and on these network errors:
  
      - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
      - `ECONNRESET`: Connection was forcibly closed by a peer.
      - `EADDRINUSE`: Could not bind to any free port.
      - `ECONNREFUSED`: Connection was refused by the server.
      - `EPIPE`: The remote side of the stream being written has been closed.
      - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
      - `ENETUNREACH`: No internet connection.
      - `EAI_AGAIN`: DNS lookup timed out.
  
      __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
      __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
      */
  get retry() {
    return this._internals.retry;
  }
  set retry(value) {
    assertPlainObject2("retry", value);
    assertAny2("retry.calculateDelay", [distribution_default.function, distribution_default.undefined], value.calculateDelay);
    assertAny2("retry.maxRetryAfter", [distribution_default.number, distribution_default.undefined], value.maxRetryAfter);
    assertAny2("retry.limit", [distribution_default.number, distribution_default.undefined], value.limit);
    assertAny2("retry.methods", [distribution_default.array, distribution_default.undefined], value.methods);
    assertAny2("retry.statusCodes", [distribution_default.array, distribution_default.undefined], value.statusCodes);
    assertAny2("retry.errorCodes", [distribution_default.array, distribution_default.undefined], value.errorCodes);
    assertAny2("retry.noise", [distribution_default.number, distribution_default.undefined], value.noise);
    assertAny2("retry.enforceRetryRules", [distribution_default.boolean, distribution_default.undefined], value.enforceRetryRules);
    if (value.noise && Math.abs(value.noise) > 100) {
      throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
    }
    for (const key in value) {
      if (!(key in this._internals.retry)) {
        throw new Error(`Unexpected retry option: ${key}`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.retry, value);
    } else {
      this._internals.retry = { ...value };
    }
    const { retry } = this._internals;
    retry.methods = [...new Set(retry.methods.map((method) => method.toUpperCase()))];
    retry.statusCodes = [...new Set(retry.statusCodes)];
    retry.errorCodes = [...new Set(retry.errorCodes)];
  }
  /**
      From `http.RequestOptions`.
  
      The IP address used to send the request from.
      */
  get localAddress() {
    return this._internals.localAddress;
  }
  set localAddress(value) {
    assertAny2("localAddress", [distribution_default.string, distribution_default.undefined], value);
    this._internals.localAddress = value;
  }
  /**
      The HTTP method used to make the request.
  
      @default 'GET'
      */
  get method() {
    return this._internals.method;
  }
  set method(value) {
    assert.string(value);
    this._internals.method = value.toUpperCase();
  }
  get createConnection() {
    return this._internals.createConnection;
  }
  set createConnection(value) {
    assertAny2("createConnection", [distribution_default.function, distribution_default.undefined], value);
    this._internals.createConnection = value;
  }
  /**
      From `http-cache-semantics`
  
      @default {}
      */
  get cacheOptions() {
    return this._internals.cacheOptions;
  }
  set cacheOptions(value) {
    assertPlainObject2("cacheOptions", value);
    assertAny2("cacheOptions.shared", [distribution_default.boolean, distribution_default.undefined], value.shared);
    assertAny2("cacheOptions.cacheHeuristic", [distribution_default.number, distribution_default.undefined], value.cacheHeuristic);
    assertAny2("cacheOptions.immutableMinTimeToLive", [distribution_default.number, distribution_default.undefined], value.immutableMinTimeToLive);
    assertAny2("cacheOptions.ignoreCargoCult", [distribution_default.boolean, distribution_default.undefined], value.ignoreCargoCult);
    for (const key in value) {
      if (!(key in this._internals.cacheOptions)) {
        throw new Error(`Cache option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.cacheOptions, value);
    } else {
      this._internals.cacheOptions = { ...value };
    }
  }
  /**
  Options for the advanced HTTPS API.
  */
  get https() {
    return this._internals.https;
  }
  set https(value) {
    assertPlainObject2("https", value);
    assertAny2("https.rejectUnauthorized", [distribution_default.boolean, distribution_default.undefined], value.rejectUnauthorized);
    assertAny2("https.checkServerIdentity", [distribution_default.function, distribution_default.undefined], value.checkServerIdentity);
    assertAny2("https.serverName", [distribution_default.string, distribution_default.undefined], value.serverName);
    assertAny2("https.certificateAuthority", [distribution_default.string, distribution_default.object, distribution_default.array, distribution_default.undefined], value.certificateAuthority);
    assertAny2("https.key", [distribution_default.string, distribution_default.object, distribution_default.array, distribution_default.undefined], value.key);
    assertAny2("https.certificate", [distribution_default.string, distribution_default.object, distribution_default.array, distribution_default.undefined], value.certificate);
    assertAny2("https.passphrase", [distribution_default.string, distribution_default.undefined], value.passphrase);
    assertAny2("https.pfx", [distribution_default.string, distribution_default.buffer, distribution_default.array, distribution_default.undefined], value.pfx);
    assertAny2("https.alpnProtocols", [distribution_default.array, distribution_default.undefined], value.alpnProtocols);
    assertAny2("https.ciphers", [distribution_default.string, distribution_default.undefined], value.ciphers);
    assertAny2("https.dhparam", [distribution_default.string, distribution_default.buffer, distribution_default.undefined], value.dhparam);
    assertAny2("https.signatureAlgorithms", [distribution_default.string, distribution_default.undefined], value.signatureAlgorithms);
    assertAny2("https.minVersion", [distribution_default.string, distribution_default.undefined], value.minVersion);
    assertAny2("https.maxVersion", [distribution_default.string, distribution_default.undefined], value.maxVersion);
    assertAny2("https.honorCipherOrder", [distribution_default.boolean, distribution_default.undefined], value.honorCipherOrder);
    assertAny2("https.tlsSessionLifetime", [distribution_default.number, distribution_default.undefined], value.tlsSessionLifetime);
    assertAny2("https.ecdhCurve", [distribution_default.string, distribution_default.undefined], value.ecdhCurve);
    assertAny2("https.certificateRevocationLists", [distribution_default.string, distribution_default.buffer, distribution_default.array, distribution_default.undefined], value.certificateRevocationLists);
    assertAny2("https.secureOptions", [distribution_default.number, distribution_default.undefined], value.secureOptions);
    for (const key in value) {
      if (!(key in this._internals.https)) {
        throw new Error(`HTTPS option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.https, value);
    } else {
      this._internals.https = { ...value };
    }
  }
  /**
      [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.
  
      To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
      Don't set this option to `null`.
  
      __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.
  
      @default 'utf-8'
      */
  get encoding() {
    return this._internals.encoding;
  }
  set encoding(value) {
    if (value === null) {
      throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
    }
    assertAny2("encoding", [distribution_default.string, distribution_default.undefined], value);
    this._internals.encoding = value;
  }
  /**
      When set to `true` the promise will return the Response body instead of the Response object.
  
      @default false
      */
  get resolveBodyOnly() {
    return this._internals.resolveBodyOnly;
  }
  set resolveBodyOnly(value) {
    assert.boolean(value);
    this._internals.resolveBodyOnly = value;
  }
  /**
      Returns a `Stream` instead of a `Promise`.
      This is equivalent to calling `got.stream(url, options?)`.
  
      @default false
      */
  get isStream() {
    return this._internals.isStream;
  }
  set isStream(value) {
    assert.boolean(value);
    this._internals.isStream = value;
  }
  /**
      The parsing method.
  
      The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.
  
      It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.
  
      __Note__: When using streams, this option is ignored.
  
      @example
      ```
      const responsePromise = got(url);
      const bufferPromise = responsePromise.buffer();
      const jsonPromise = responsePromise.json();
  
      const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
      // `response` is an instance of Got Response
      // `buffer` is an instance of Buffer
      // `json` is an object
      ```
  
      @example
      ```
      // This
      const body = await got(url).json();
  
      // is semantically the same as this
      const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
      ```
      */
  get responseType() {
    return this._internals.responseType;
  }
  set responseType(value) {
    if (value === void 0) {
      this._internals.responseType = "text";
      return;
    }
    if (value !== "text" && value !== "buffer" && value !== "json") {
      throw new Error(`Invalid \`responseType\` option: ${value}`);
    }
    this._internals.responseType = value;
  }
  get pagination() {
    return this._internals.pagination;
  }
  set pagination(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.pagination, value);
    } else {
      this._internals.pagination = value;
    }
  }
  get auth() {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  set auth(_value) {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  get setHost() {
    return this._internals.setHost;
  }
  set setHost(value) {
    assert.boolean(value);
    this._internals.setHost = value;
  }
  get maxHeaderSize() {
    return this._internals.maxHeaderSize;
  }
  set maxHeaderSize(value) {
    assertAny2("maxHeaderSize", [distribution_default.number, distribution_default.undefined], value);
    this._internals.maxHeaderSize = value;
  }
  get enableUnixSockets() {
    return this._internals.enableUnixSockets;
  }
  set enableUnixSockets(value) {
    assert.boolean(value);
    this._internals.enableUnixSockets = value;
  }
  /**
      Throw an error if the server response's `content-length` header value doesn't match the number of bytes received.
  
      This is useful for detecting truncated responses and follows RFC 9112 requirements for message completeness.
  
      __Note__: Responses without a `content-length` header are not validated.
      __Note__: When enabled and validation fails, a `ReadError` with code `ERR_HTTP_CONTENT_LENGTH_MISMATCH` will be thrown.
  
      @default false
      */
  get strictContentLength() {
    return this._internals.strictContentLength;
  }
  set strictContentLength(value) {
    assert.boolean(value);
    this._internals.strictContentLength = value;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  toJSON() {
    return { ...this._internals };
  }
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
    return inspect(this._internals, options);
  }
  createNativeRequestOptions() {
    const internals = this._internals;
    const url = internals.url;
    let agent;
    if (url.protocol === "https:") {
      if (internals.http2) {
        agent = {
          ...internals.agent,
          http2: internals.agent.http2 ?? import_http2_wrapper.default.globalAgent
        };
      } else {
        agent = internals.agent.https;
      }
    } else {
      agent = internals.agent.http;
    }
    const { https: https2 } = internals;
    let { pfx } = https2;
    if (distribution_default.array(pfx) && distribution_default.plainObject(pfx[0])) {
      pfx = pfx.map((object) => ({
        buf: object.buffer,
        passphrase: object.passphrase
      }));
    }
    return {
      ...internals.cacheOptions,
      ...this._unixOptions,
      // HTTPS options
      // eslint-disable-next-line @typescript-eslint/naming-convention
      ALPNProtocols: https2.alpnProtocols,
      ca: https2.certificateAuthority,
      cert: https2.certificate,
      key: https2.key,
      passphrase: https2.passphrase,
      pfx: https2.pfx,
      rejectUnauthorized: https2.rejectUnauthorized,
      checkServerIdentity: https2.checkServerIdentity ?? checkServerIdentity,
      servername: https2.serverName,
      ciphers: https2.ciphers,
      honorCipherOrder: https2.honorCipherOrder,
      minVersion: https2.minVersion,
      maxVersion: https2.maxVersion,
      sigalgs: https2.signatureAlgorithms,
      sessionTimeout: https2.tlsSessionLifetime,
      dhparam: https2.dhparam,
      ecdhCurve: https2.ecdhCurve,
      crl: https2.certificateRevocationLists,
      secureOptions: https2.secureOptions,
      // HTTP options
      lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
      family: internals.dnsLookupIpVersion,
      agent,
      setHost: internals.setHost,
      method: internals.method,
      maxHeaderSize: internals.maxHeaderSize,
      localAddress: internals.localAddress,
      headers: internals.headers,
      createConnection: internals.createConnection,
      timeout: internals.http2 ? getHttp2TimeoutOption(internals) : void 0,
      // HTTP/2 options
      h2session: internals.h2session
    };
  }
  getRequestFunction() {
    const url = this._internals.url;
    const { request } = this._internals;
    if (!request && url) {
      return this.getFallbackRequestFunction();
    }
    return request;
  }
  getFallbackRequestFunction() {
    const url = this._internals.url;
    if (!url) {
      return;
    }
    if (url.protocol === "https:") {
      if (this._internals.http2) {
        if (major < 15 || major === 15 && minor < 10) {
          const error2 = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
          error2.code = "EUNSUPPORTED";
          throw error2;
        }
        return import_http2_wrapper.default.auto;
      }
      return https.request;
    }
    return http.request;
  }
  freeze() {
    const options = this._internals;
    Object.freeze(options);
    Object.freeze(options.hooks);
    Object.freeze(options.hooks.afterResponse);
    Object.freeze(options.hooks.beforeError);
    Object.freeze(options.hooks.beforeRedirect);
    Object.freeze(options.hooks.beforeRequest);
    Object.freeze(options.hooks.beforeRetry);
    Object.freeze(options.hooks.init);
    Object.freeze(options.https);
    Object.freeze(options.cacheOptions);
    Object.freeze(options.agent);
    Object.freeze(options.headers);
    Object.freeze(options.timeout);
    Object.freeze(options.retry);
    Object.freeze(options.retry.errorCodes);
    Object.freeze(options.retry.methods);
    Object.freeze(options.retry.statusCodes);
  }
};

// node_modules/got/dist/source/core/response.js
var isResponseOk = (response) => {
  const { statusCode } = response;
  const { followRedirect } = response.request.options;
  const shouldFollow = typeof followRedirect === "function" ? followRedirect(response) : followRedirect;
  const limitStatusCode = shouldFollow ? 299 : 399;
  return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
};
var ParseError = class extends RequestError {
  name = "ParseError";
  code = "ERR_BODY_PARSE_FAILURE";
  constructor(error2, response) {
    const { options } = response.request;
    super(`${error2.message} in "${options.url.toString()}"`, error2, response.request);
  }
};
var parseBody = (response, responseType, parseJson, encoding) => {
  const { rawBody } = response;
  try {
    if (responseType === "text") {
      return rawBody.toString(encoding);
    }
    if (responseType === "json") {
      return rawBody.length === 0 ? "" : parseJson(rawBody.toString(encoding));
    }
    if (responseType === "buffer") {
      return rawBody;
    }
  } catch (error2) {
    throw new ParseError(error2, response);
  }
  throw new ParseError({
    message: `Unknown body type '${responseType}'`,
    name: "Error"
  }, response);
};

// node_modules/got/dist/source/core/utils/is-client-request.js
function isClientRequest(clientRequest) {
  return clientRequest.writable && !clientRequest.writableEnded;
}
var is_client_request_default = isClientRequest;

// node_modules/got/dist/source/core/utils/is-unix-socket-url.js
function isUnixSocketURL(url) {
  return url.protocol === "unix:" || url.hostname === "unix";
}
function getUnixSocketPath(url) {
  if (!isUnixSocketURL(url)) {
    return void 0;
  }
  return /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`)?.groups?.socketPath;
}

// node_modules/got/dist/source/core/diagnostics-channel.js
import { randomUUID } from "crypto";
import diagnosticsChannel from "diagnostics_channel";
var channels = {
  requestCreate: diagnosticsChannel.channel("got:request:create"),
  requestStart: diagnosticsChannel.channel("got:request:start"),
  responseStart: diagnosticsChannel.channel("got:response:start"),
  responseEnd: diagnosticsChannel.channel("got:response:end"),
  retry: diagnosticsChannel.channel("got:request:retry"),
  error: diagnosticsChannel.channel("got:request:error"),
  redirect: diagnosticsChannel.channel("got:response:redirect")
};
function generateRequestId() {
  return randomUUID();
}
function publishRequestCreate(message) {
  if (channels.requestCreate.hasSubscribers) {
    channels.requestCreate.publish(message);
  }
}
function publishRequestStart(message) {
  if (channels.requestStart.hasSubscribers) {
    channels.requestStart.publish(message);
  }
}
function publishResponseStart(message) {
  if (channels.responseStart.hasSubscribers) {
    channels.responseStart.publish(message);
  }
}
function publishResponseEnd(message) {
  if (channels.responseEnd.hasSubscribers) {
    channels.responseEnd.publish(message);
  }
}
function publishRetry(message) {
  if (channels.retry.hasSubscribers) {
    channels.retry.publish(message);
  }
}
function publishError(message) {
  if (channels.error.hasSubscribers) {
    channels.error.publish(message);
  }
}
function publishRedirect(message) {
  if (channels.redirect.hasSubscribers) {
    channels.redirect.publish(message);
  }
}

// node_modules/got/dist/source/core/index.js
var supportsBrotli = distribution_default.string(process3.versions.brotli);
var supportsZstd2 = distribution_default.string(process3.versions.zstd);
var methodsWithoutBody = /* @__PURE__ */ new Set(["GET", "HEAD"]);
var methodsWithoutBodyStream = /* @__PURE__ */ new Set(["OPTIONS", "DELETE", "PATCH"]);
var cacheableStore = new WeakableMap();
var redirectCodes = /* @__PURE__ */ new Set([300, 301, 302, 303, 304, 307, 308]);
var errorsProcessedByHooks = /* @__PURE__ */ new WeakSet();
var proxiedRequestEvents = [
  "socket",
  "connect",
  "continue",
  "information",
  "upgrade"
];
var noop3 = () => {
};
var Request = class _Request extends Duplex {
  // @ts-expect-error - Ignoring for now.
  ["constructor"];
  _noPipe;
  // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568
  options;
  response;
  requestUrl;
  redirectUrls = [];
  retryCount = 0;
  _stopReading = false;
  _stopRetry = noop3;
  _downloadedSize = 0;
  _uploadedSize = 0;
  _pipedServerResponses = /* @__PURE__ */ new Set();
  _request;
  _responseSize;
  _bodySize;
  _unproxyEvents = noop3;
  _isFromCache;
  _triggerRead = false;
  _jobs = [];
  _cancelTimeouts = noop3;
  _removeListeners = noop3;
  _nativeResponse;
  _flushed = false;
  _aborted = false;
  _expectedContentLength;
  _compressedBytesCount;
  _requestId = generateRequestId();
  // We need this because `this._request` if `undefined` when using cache
  _requestInitialized = false;
  constructor(url, options, defaults2) {
    super({
      // Don't destroy immediately, as the error may be emitted on unsuccessful retry
      autoDestroy: false,
      // It needs to be zero because we're just proxying the data to another stream
      highWaterMark: 0
    });
    this.on("pipe", (source) => {
      if (this.options.copyPipedHeaders && source?.headers) {
        Object.assign(this.options.headers, source.headers);
      }
    });
    this.on("newListener", (event) => {
      if (event === "retry" && this.listenerCount("retry") > 0) {
        throw new Error("A retry listener has been attached already.");
      }
    });
    try {
      this.options = new Options(url, options, defaults2);
      if (!this.options.url) {
        if (this.options.prefixUrl === "") {
          throw new TypeError("Missing `url` property");
        }
        this.options.url = "";
      }
      this.requestUrl = this.options.url;
      publishRequestCreate({
        requestId: this._requestId,
        url: this.options.url?.toString() ?? "",
        method: this.options.method
      });
    } catch (error2) {
      const { options: options2 } = error2;
      if (options2) {
        this.options = options2;
      }
      this.flush = async () => {
        this.flush = async () => {
        };
        process3.nextTick(() => {
          if (this.options) {
            this._beforeError(error2);
          } else {
            const requestError = error2 instanceof RequestError ? error2 : new RequestError(error2.message, error2, this);
            this.destroy(requestError);
          }
        });
      };
      return;
    }
    const { body } = this.options;
    if (distribution_default.nodeStream(body)) {
      body.once("error", (error2) => {
        if (this._flushed) {
          this._beforeError(new UploadError(error2, this));
        } else {
          this.flush = async () => {
            this.flush = async () => {
            };
            this._beforeError(new UploadError(error2, this));
          };
        }
      });
    }
    if (this.options.signal) {
      const abort = () => {
        if (this.options.signal?.reason?.name === "TimeoutError") {
          this.destroy(new TimeoutError(this.options.signal.reason, this.timings, this));
        } else {
          this.destroy(new AbortError(this));
        }
      };
      if (this.options.signal.aborted) {
        abort();
      } else {
        this.options.signal.addEventListener("abort", abort);
        this._removeListeners = () => {
          this.options.signal?.removeEventListener("abort", abort);
        };
      }
    }
  }
  async flush() {
    if (this._flushed) {
      return;
    }
    this._flushed = true;
    try {
      await this._finalizeBody();
      if (this.destroyed) {
        return;
      }
      await this._makeRequest();
      if (this.destroyed) {
        this._request?.destroy();
        return;
      }
      for (const job of this._jobs) {
        job();
      }
      this._jobs.length = 0;
      this._requestInitialized = true;
    } catch (error2) {
      this._beforeError(error2);
    }
  }
  _beforeError(error2) {
    if (this._stopReading) {
      return;
    }
    const { response, options } = this;
    const attemptCount = this.retryCount + (error2.name === "RetryError" ? 0 : 1);
    this._stopReading = true;
    if (!(error2 instanceof RequestError)) {
      error2 = new RequestError(error2.message, error2, this);
    }
    const typedError = error2;
    void (async () => {
      if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {
        response.setEncoding(this.readableEncoding);
        const success = await this._setRawBody(response);
        if (success) {
          response.body = response.rawBody.toString();
        }
      }
      if (this.listenerCount("retry") !== 0) {
        let backoff;
        try {
          let retryAfter;
          if (response && "retry-after" in response.headers) {
            retryAfter = Number(response.headers["retry-after"]);
            if (Number.isNaN(retryAfter)) {
              retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
              if (retryAfter <= 0) {
                retryAfter = 1;
              }
            } else {
              retryAfter *= 1e3;
            }
          }
          const retryOptions = options.retry;
          const computedValue = calculate_retry_delay_default({
            attemptCount,
            retryOptions,
            error: typedError,
            retryAfter,
            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY
          });
          if (retryOptions.enforceRetryRules && computedValue === 0) {
            backoff = 0;
          } else {
            backoff = await retryOptions.calculateDelay({
              attemptCount,
              retryOptions,
              error: typedError,
              retryAfter,
              computedValue
            });
          }
        } catch (error_) {
          void this._error(new RequestError(error_.message, error_, this));
          return;
        }
        if (backoff) {
          await new Promise((resolve) => {
            const timeout = setTimeout(resolve, backoff);
            this._stopRetry = () => {
              clearTimeout(timeout);
              resolve();
            };
          });
          if (this.destroyed) {
            return;
          }
          const bodyBeforeHooks = this.options.body;
          try {
            for (const hook of this.options.hooks.beforeRetry) {
              await hook(typedError, this.retryCount + 1);
            }
          } catch (error_) {
            void this._error(new RequestError(error_.message, error_, this));
            return;
          }
          if (this.destroyed) {
            return;
          }
          const bodyAfterHooks = this.options.body;
          const bodyWasReassigned = bodyBeforeHooks !== bodyAfterHooks;
          if (bodyWasReassigned) {
            const oldBody = bodyBeforeHooks;
            this.options.body = void 0;
            this.destroy();
            if (distribution_default.nodeStream(oldBody) && oldBody !== bodyAfterHooks) {
              oldBody.destroy();
            }
            if (distribution_default.nodeStream(bodyAfterHooks) && (bodyAfterHooks.readableEnded || bodyAfterHooks.destroyed)) {
              throw new TypeError("The reassigned stream body must be readable. Ensure you provide a fresh, readable stream in the beforeRetry hook.");
            }
            this.options._internals.body = bodyAfterHooks;
          } else {
            this.destroy();
          }
          publishRetry({
            requestId: this._requestId,
            retryCount: this.retryCount + 1,
            error: typedError,
            delay: backoff
          });
          this.emit("retry", this.retryCount + 1, error2, (updatedOptions) => {
            const request = new _Request(options.url, updatedOptions, options);
            request.retryCount = this.retryCount + 1;
            process3.nextTick(() => {
              void request.flush();
            });
            return request;
          });
          return;
        }
      }
      void this._error(typedError);
    })();
  }
  _read() {
    this._triggerRead = true;
    const { response } = this;
    if (response && !this._stopReading) {
      if (response.readableLength) {
        this._triggerRead = false;
      }
      let data;
      while ((data = response.read()) !== null) {
        this._downloadedSize += data.length;
        const progress = this.downloadProgress;
        if (progress.percent < 1) {
          this.emit("downloadProgress", progress);
        }
        this.push(data);
      }
    }
  }
  _write(chunk2, encoding, callback) {
    const write = () => {
      this._writeRequest(chunk2, encoding, callback);
    };
    if (this._requestInitialized) {
      write();
    } else {
      this._jobs.push(write);
    }
  }
  _final(callback) {
    const endRequest = () => {
      if (!this._request || this._request.destroyed) {
        callback();
        return;
      }
      this._request.end((error2) => {
        if (this._request?._writableState?.errored) {
          return;
        }
        if (!error2) {
          this._bodySize = this._uploadedSize;
          this.emit("uploadProgress", this.uploadProgress);
          this._request?.emit("upload-complete");
        }
        callback(error2);
      });
    };
    if (this._requestInitialized) {
      endRequest();
    } else {
      this._jobs.push(endRequest);
    }
  }
  _destroy(error2, callback) {
    this._stopReading = true;
    this.flush = async () => {
    };
    this._stopRetry();
    this._cancelTimeouts();
    this._removeListeners();
    if (this.options) {
      const { body } = this.options;
      if (distribution_default.nodeStream(body)) {
        body.destroy();
      }
    }
    if (this._request) {
      this._request.destroy();
    }
    const timings = this._request?.timings;
    if (timings && distribution_default.undefined(timings.end) && !distribution_default.undefined(timings.response) && distribution_default.undefined(timings.error) && distribution_default.undefined(timings.abort)) {
      timings.end = Date.now();
      if (distribution_default.undefined(timings.phases.total)) {
        timings.phases.download = timings.end - timings.response;
        timings.phases.total = timings.end - timings.start;
      }
    }
    if (error2 !== null && !distribution_default.undefined(error2)) {
      const processedByHooks = error2 instanceof Error && errorsProcessedByHooks.has(error2);
      if (!processedByHooks && !(error2 instanceof RequestError)) {
        error2 = error2 instanceof Error ? new RequestError(error2.message, error2, this) : new RequestError(String(error2), {}, this);
      }
    }
    callback(error2);
  }
  pipe(destination, options) {
    if (destination instanceof ServerResponse) {
      this._pipedServerResponses.add(destination);
    }
    return super.pipe(destination, options);
  }
  unpipe(destination) {
    if (destination instanceof ServerResponse) {
      this._pipedServerResponses.delete(destination);
    }
    super.unpipe(destination);
    return this;
  }
  _checkContentLengthMismatch() {
    if (this.options.strictContentLength && this._expectedContentLength !== void 0) {
      const actualSize = this._compressedBytesCount ?? this._downloadedSize;
      if (actualSize !== this._expectedContentLength) {
        this._beforeError(new ReadError({
          message: `Content-Length mismatch: expected ${this._expectedContentLength} bytes, received ${actualSize} bytes`,
          name: "Error",
          code: "ERR_HTTP_CONTENT_LENGTH_MISMATCH"
        }, this));
        return true;
      }
    }
    return false;
  }
  async _finalizeBody() {
    const { options } = this;
    const { headers } = options;
    const isForm = !distribution_default.undefined(options.form);
    const isJSON = !distribution_default.undefined(options.json);
    const isBody = !distribution_default.undefined(options.body);
    const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
    if (isForm || isJSON || isBody) {
      if (cannotHaveBody) {
        throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
      }
      const noContentType = !distribution_default.string(headers["content-type"]);
      if (isBody) {
        if (isFormData2(options.body)) {
          const encoder = new FormDataEncoder(options.body);
          if (noContentType) {
            headers["content-type"] = encoder.headers["Content-Type"];
          }
          if ("Content-Length" in encoder.headers) {
            headers["content-length"] = encoder.headers["Content-Length"];
          }
          options.body = encoder.encode();
        }
        if (isFormData3(options.body) && noContentType) {
          headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
        }
      } else if (isForm) {
        if (noContentType) {
          headers["content-type"] = "application/x-www-form-urlencoded";
        }
        const { form } = options;
        options.form = void 0;
        options.body = new URLSearchParams(form).toString();
      } else {
        if (noContentType) {
          headers["content-type"] = "application/json";
        }
        const { json } = options;
        options.json = void 0;
        options.body = options.stringifyJson(json);
      }
      const uploadBodySize = await getBodySize(options.body, options.headers);
      if (distribution_default.undefined(headers["content-length"]) && distribution_default.undefined(headers["transfer-encoding"]) && !cannotHaveBody && !distribution_default.undefined(uploadBodySize)) {
        headers["content-length"] = String(uploadBodySize);
      }
    }
    if (options.responseType === "json" && !("accept" in options.headers)) {
      options.headers.accept = "application/json";
    }
    this._bodySize = Number(headers["content-length"]) || void 0;
  }
  async _onResponseBase(response) {
    if (this.isAborted) {
      return;
    }
    const { options } = this;
    const { url } = options;
    this._nativeResponse = response;
    const statusCode = response.statusCode;
    const { method } = options;
    const hasNoBody = method === "HEAD" || statusCode >= 100 && statusCode < 200 || statusCode === 204 || statusCode === 205 || statusCode === 304;
    if (options.decompress && !hasNoBody) {
      if (options.strictContentLength) {
        this._compressedBytesCount = 0;
        this._nativeResponse.on("data", (chunk2) => {
          this._compressedBytesCount += byteLength(chunk2);
        });
      }
      response = decompressResponse(response);
    }
    const typedResponse = response;
    typedResponse.statusMessage = typedResponse.statusMessage || http2.STATUS_CODES[statusCode];
    typedResponse.url = options.url.toString();
    typedResponse.requestUrl = this.requestUrl;
    typedResponse.redirectUrls = this.redirectUrls;
    typedResponse.request = this;
    typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
    typedResponse.ip = this.ip;
    typedResponse.retryCount = this.retryCount;
    typedResponse.ok = isResponseOk(typedResponse);
    this._isFromCache = typedResponse.isFromCache;
    this._responseSize = Number(response.headers["content-length"]) || void 0;
    this.response = typedResponse;
    publishResponseStart({
      requestId: this._requestId,
      url: typedResponse.url,
      statusCode,
      headers: response.headers,
      isFromCache: typedResponse.isFromCache
    });
    response.once("error", (error2) => {
      this._aborted = true;
      response.destroy();
      this._beforeError(new ReadError(error2, this));
    });
    response.once("aborted", () => {
      this._aborted = true;
      if (!this._checkContentLengthMismatch()) {
        this._beforeError(new ReadError({
          name: "Error",
          message: "The server aborted pending request",
          code: "ECONNRESET"
        }, this));
      }
    });
    const rawCookies = response.headers["set-cookie"];
    if (distribution_default.object(options.cookieJar) && rawCookies) {
      let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
      if (options.ignoreInvalidCookies) {
        promises = promises.map(async (promise) => {
          try {
            await promise;
          } catch {
          }
        });
      }
      try {
        await Promise.all(promises);
      } catch (error2) {
        this._beforeError(error2);
        return;
      }
    }
    if (this.isAborted) {
      return;
    }
    if (response.headers.location && redirectCodes.has(statusCode)) {
      const shouldFollow = typeof options.followRedirect === "function" ? options.followRedirect(typedResponse) : options.followRedirect;
      if (shouldFollow) {
        response.resume();
        this._cancelTimeouts();
        this._unproxyEvents();
        if (this.redirectUrls.length >= options.maxRedirects) {
          this._beforeError(new MaxRedirectsError(this));
          return;
        }
        this._request = void 0;
        this._downloadedSize = 0;
        const updatedOptions = new Options(void 0, void 0, this.options);
        const serverRequestedGet = statusCode === 303 && updatedOptions.method !== "GET" && updatedOptions.method !== "HEAD";
        const canRewrite = statusCode !== 307 && statusCode !== 308;
        const userRequestedGet = updatedOptions.methodRewriting && canRewrite;
        if (serverRequestedGet || userRequestedGet) {
          updatedOptions.method = "GET";
          updatedOptions.body = void 0;
          updatedOptions.json = void 0;
          updatedOptions.form = void 0;
          delete updatedOptions.headers["content-length"];
        }
        try {
          const redirectBuffer = Buffer3.from(response.headers.location, "binary").toString();
          const redirectUrl = new URL(redirectBuffer, url);
          if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {
            this._beforeError(new RequestError("Cannot redirect to UNIX socket", {}, this));
            return;
          }
          const isDifferentOrigin = redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port || getUnixSocketPath(url) !== getUnixSocketPath(redirectUrl);
          if (isDifferentOrigin) {
            if ("host" in updatedOptions.headers) {
              delete updatedOptions.headers.host;
            }
            if ("cookie" in updatedOptions.headers) {
              delete updatedOptions.headers.cookie;
            }
            if ("authorization" in updatedOptions.headers) {
              delete updatedOptions.headers.authorization;
            }
            if (updatedOptions.username || updatedOptions.password) {
              updatedOptions.username = "";
              updatedOptions.password = "";
            }
          } else {
            redirectUrl.username = updatedOptions.username;
            redirectUrl.password = updatedOptions.password;
          }
          this.redirectUrls.push(redirectUrl);
          updatedOptions.url = redirectUrl;
          for (const hook of updatedOptions.hooks.beforeRedirect) {
            await hook(updatedOptions, typedResponse);
          }
          publishRedirect({
            requestId: this._requestId,
            fromUrl: url.toString(),
            toUrl: redirectUrl.toString(),
            statusCode
          });
          this.emit("redirect", updatedOptions, typedResponse);
          this.options = updatedOptions;
          await this._makeRequest();
        } catch (error2) {
          this._beforeError(error2);
          return;
        }
        return;
      }
    }
    if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {
      this._beforeError(new HTTPError(typedResponse));
      return;
    }
    const wasDecompressed = response !== this._nativeResponse;
    if (!hasNoBody && (!wasDecompressed || options.strictContentLength)) {
      const contentLengthHeader = this._nativeResponse.headers["content-length"];
      if (contentLengthHeader !== void 0) {
        const expectedLength = Number(contentLengthHeader);
        if (!Number.isNaN(expectedLength) && expectedLength >= 0) {
          this._expectedContentLength = expectedLength;
        }
      }
    }
    response.once("end", () => {
      if (this._checkContentLengthMismatch()) {
        return;
      }
      this._responseSize = this._downloadedSize;
      this.emit("downloadProgress", this.downloadProgress);
      publishResponseEnd({
        requestId: this._requestId,
        url: typedResponse.url,
        statusCode,
        bodySize: this._downloadedSize,
        timings: this.timings
      });
      this.push(null);
    });
    this.emit("downloadProgress", this.downloadProgress);
    response.on("readable", () => {
      if (this._triggerRead) {
        this._read();
      }
    });
    this.on("resume", () => {
      response.resume();
    });
    this.on("pause", () => {
      response.pause();
    });
    if (this._noPipe) {
      const success = await this._setRawBody();
      if (success) {
        this.emit("response", response);
      }
      return;
    }
    this.emit("response", response);
    for (const destination of this._pipedServerResponses) {
      if (destination.headersSent) {
        continue;
      }
      const wasDecompressed2 = response !== this._nativeResponse;
      for (const key in response.headers) {
        if (Object.hasOwn(response.headers, key)) {
          const value = response.headers[key];
          if (wasDecompressed2 && (key === "content-encoding" || key === "content-length")) {
            continue;
          }
          if (value !== void 0) {
            destination.setHeader(key, value);
          }
        }
      }
      destination.statusCode = statusCode;
    }
  }
  async _setRawBody(from = this) {
    if (from.readableEnded) {
      return false;
    }
    try {
      const fromArray = await from.toArray();
      const rawBody = isBuffer(fromArray.at(0)) ? Buffer3.concat(fromArray) : Buffer3.from(fromArray.join(""));
      if (!this.isAborted) {
        this.response.rawBody = rawBody;
        return true;
      }
    } catch {
    }
    return false;
  }
  async _onResponse(response) {
    try {
      await this._onResponseBase(response);
    } catch (error2) {
      this._beforeError(error2);
    }
  }
  _onRequest(request) {
    const { options } = this;
    const { timeout, url } = options;
    publishRequestStart({
      requestId: this._requestId,
      url: url?.toString() ?? "",
      method: options.method,
      headers: options.headers
    });
    timer_default(request);
    this._cancelTimeouts = timedOut(request, timeout, url);
    if (this.options.http2) {
      request.removeAllListeners("timeout");
      request.once("socket", (socket) => {
        socket.removeAllListeners("timeout");
      });
    }
    const responseEventName = options.cache ? "cacheableResponse" : "response";
    request.once(responseEventName, (response) => {
      void this._onResponse(response);
    });
    request.once("error", (error2) => {
      this._aborted = true;
      request.destroy();
      error2 = error2 instanceof TimeoutError2 ? new TimeoutError(error2, this.timings, this) : new RequestError(error2.message, error2, this);
      this._beforeError(error2);
    });
    this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);
    this._request = request;
    this.emit("uploadProgress", this.uploadProgress);
    this._sendBody();
    this.emit("request", request);
  }
  async _asyncWrite(chunk2) {
    return new Promise((resolve, reject) => {
      super.write(chunk2, (error2) => {
        if (error2) {
          reject(error2);
          return;
        }
        resolve();
      });
    });
  }
  _sendBody() {
    const { body } = this.options;
    const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
    if (distribution_default.nodeStream(body)) {
      body.pipe(currentRequest);
    } else if (distribution_default.buffer(body)) {
      this._writeRequest(body, void 0, () => {
      });
      currentRequest.end();
    } else if (distribution_default.typedArray(body)) {
      const typedArray = body;
      const uint8View = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
      this._writeRequest(uint8View, void 0, () => {
      });
      currentRequest.end();
    } else if (distribution_default.asyncIterable(body) || distribution_default.iterable(body) && !distribution_default.string(body) && !isBuffer(body)) {
      (async () => {
        try {
          for await (const chunk2 of body) {
            await this._asyncWrite(chunk2);
          }
          super.end();
        } catch (error2) {
          this._beforeError(error2);
        }
      })();
    } else if (distribution_default.undefined(body)) {
      const cannotHaveBody = methodsWithoutBody.has(this.options.method) && !(this.options.method === "GET" && this.options.allowGetBody);
      const shouldAutoEndStream = methodsWithoutBodyStream.has(this.options.method);
      if ((this._noPipe ?? false) || cannotHaveBody || currentRequest !== this || shouldAutoEndStream) {
        currentRequest.end();
      }
    } else {
      this._writeRequest(body, void 0, () => {
      });
      currentRequest.end();
    }
  }
  _prepareCache(cache) {
    if (cacheableStore.has(cache)) {
      return;
    }
    const cacheableRequest = new dist_default(((requestOptions, handler) => {
      const wrappedHandler = handler ? (response) => {
        const { beforeCacheHooks, gotRequest } = requestOptions;
        if (!beforeCacheHooks || beforeCacheHooks.length === 0) {
          handler(response);
          return;
        }
        try {
          for (const hook of beforeCacheHooks) {
            const result2 = hook(response);
            if (result2 === false) {
              response.headers["cache-control"] = "no-cache, no-store, must-revalidate";
              response.headers.pragma = "no-cache";
              response.headers.expires = "0";
              handler(response);
              return;
            }
            if (distribution_default.promise(result2)) {
              throw new TypeError("beforeCache hooks must be synchronous. The hook returned a Promise, but this hook must return synchronously. If you need async logic, use beforeRequest hook instead.");
            }
            if (result2 !== void 0) {
              throw new TypeError("beforeCache hook must return false or undefined. To modify the response, mutate it directly.");
            }
          }
        } catch (error2) {
          if (gotRequest) {
            gotRequest._beforeError(error2 instanceof RequestError ? error2 : new RequestError(error2.message, error2, gotRequest));
            return;
          }
          console.error("Got: beforeCache hook error (request context unavailable):", error2);
          handler(response);
          return;
        }
        handler(response);
      } : handler;
      const result = requestOptions._request(requestOptions, wrappedHandler);
      if (distribution_default.promise(result)) {
        result.once = (event, handler2) => {
          if (event === "error") {
            (async () => {
              try {
                await result;
              } catch (error2) {
                handler2(error2);
              }
            })();
          } else if (event === "abort" || event === "destroy") {
            (async () => {
              try {
                const request = await result;
                request.once(event, handler2);
              } catch {
              }
            })();
          } else {
            throw new Error(`Unknown HTTP2 promise event: ${event}`);
          }
          return result;
        };
      }
      return result;
    }), cache);
    cacheableStore.set(cache, cacheableRequest.request());
  }
  async _createCacheableRequest(url, options) {
    return new Promise((resolve, reject) => {
      Object.assign(options, urlToOptions(url));
      let request;
      const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
        response._readableState.autoDestroy = false;
        if (request) {
          const fix = () => {
            if (response.req) {
              response.complete = response.req.res.complete;
            } else if (response.complete === void 0) {
              response.complete = true;
            }
          };
          response.prependOnceListener("end", fix);
          fix();
          (await request).emit("cacheableResponse", response);
        }
        resolve(response);
      });
      cacheRequest.once("error", reject);
      cacheRequest.once("request", async (requestOrPromise) => {
        request = requestOrPromise;
        resolve(request);
      });
    });
  }
  async _makeRequest() {
    const { options } = this;
    const { headers, username, password } = options;
    const cookieJar = options.cookieJar;
    for (const key in headers) {
      if (distribution_default.undefined(headers[key])) {
        delete headers[key];
      } else if (distribution_default.null(headers[key])) {
        throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
      }
    }
    if (options.decompress && distribution_default.undefined(headers["accept-encoding"])) {
      const encodings = ["gzip", "deflate"];
      if (supportsBrotli) {
        encodings.push("br");
      }
      if (supportsZstd2) {
        encodings.push("zstd");
      }
      headers["accept-encoding"] = encodings.join(", ");
    }
    if (username || password) {
      const credentials = Buffer3.from(`${username}:${password}`).toString("base64");
      headers.authorization = `Basic ${credentials}`;
    }
    if (cookieJar) {
      const cookieString = await cookieJar.getCookieString(options.url.toString());
      if (distribution_default.nonEmptyString(cookieString)) {
        headers.cookie = cookieString;
      }
    }
    let request;
    for (const hook of options.hooks.beforeRequest) {
      const result = await hook(options, { retryCount: this.retryCount });
      if (!distribution_default.undefined(result)) {
        request = () => result;
        break;
      }
    }
    request ||= options.getRequestFunction();
    const url = options.url;
    this._requestOptions = options.createNativeRequestOptions();
    if (options.cache) {
      this._requestOptions._request = request;
      this._requestOptions.cache = options.cache;
      this._requestOptions.body = options.body;
      this._requestOptions.beforeCacheHooks = options.hooks.beforeCache;
      this._requestOptions.gotRequest = this;
      try {
        this._prepareCache(options.cache);
      } catch (error2) {
        throw new CacheError(error2, this);
      }
    }
    const function_ = options.cache ? this._createCacheableRequest : request;
    try {
      let requestOrResponse = function_(url, this._requestOptions);
      if (distribution_default.promise(requestOrResponse)) {
        requestOrResponse = await requestOrResponse;
      }
      if (distribution_default.undefined(requestOrResponse)) {
        requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);
        if (distribution_default.promise(requestOrResponse)) {
          requestOrResponse = await requestOrResponse;
        }
      }
      if (is_client_request_default(requestOrResponse)) {
        this._onRequest(requestOrResponse);
      } else if (this.writableEnded) {
        void this._onResponse(requestOrResponse);
      } else {
        this.once("finish", () => {
          void this._onResponse(requestOrResponse);
        });
        this._sendBody();
      }
    } catch (error2) {
      if (error2 instanceof CacheError2) {
        throw new CacheError(error2, this);
      }
      throw error2;
    }
  }
  async _error(error2) {
    try {
      if (this.options && error2 instanceof HTTPError && !this.options.throwHttpErrors) {
      } else if (this.options) {
        const hooks = this.options.hooks.beforeError;
        if (hooks.length > 0) {
          for (const hook of hooks) {
            error2 = await hook(error2);
            if (!(error2 instanceof Error)) {
              throw new TypeError(`The \`beforeError\` hook must return an Error instance. Received ${distribution_default.string(error2) ? "string" : String(typeof error2)}.`);
            }
          }
          if (!(error2 instanceof RequestError)) {
            errorsProcessedByHooks.add(error2);
          }
        }
      }
    } catch (error_) {
      error2 = new RequestError(error_.message, error_, this);
    }
    publishError({
      requestId: this._requestId,
      url: this.options?.url?.toString() ?? "",
      error: error2,
      timings: this.timings
    });
    this.destroy(error2);
    if (this._noPipe) {
      process3.nextTick(() => {
        this.emit("error", error2);
      });
    }
  }
  _writeRequest(chunk2, encoding, callback) {
    if (!this._request || this._request.destroyed) {
      callback();
      return;
    }
    this._request.write(chunk2, encoding, (error2) => {
      if (!error2 && !this._request.destroyed) {
        const bytes = typeof chunk2 === "string" ? Buffer3.from(chunk2, encoding) : chunk2;
        this._uploadedSize += byteLength(bytes);
        const progress = this.uploadProgress;
        if (progress.percent < 1) {
          this.emit("uploadProgress", progress);
        }
      }
      callback(error2);
    });
  }
  /**
  The remote IP address.
  */
  get ip() {
    return this.socket?.remoteAddress;
  }
  /**
  Indicates whether the request has been aborted or not.
  */
  get isAborted() {
    return this._aborted;
  }
  get socket() {
    return this._request?.socket ?? void 0;
  }
  /**
  Progress event for downloading (receiving a response).
  */
  get downloadProgress() {
    let percent;
    if (this._responseSize) {
      percent = this._downloadedSize / this._responseSize;
    } else if (this._responseSize === this._downloadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._downloadedSize,
      total: this._responseSize
    };
  }
  /**
  Progress event for uploading (sending a request).
  */
  get uploadProgress() {
    let percent;
    if (this._bodySize) {
      percent = this._uploadedSize / this._bodySize;
    } else if (this._bodySize === this._uploadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._uploadedSize,
      total: this._bodySize
    };
  }
  /**
      The object contains the following properties:
  
      - `start` - Time when the request started.
      - `socket` - Time when a socket was assigned to the request.
      - `lookup` - Time when the DNS lookup finished.
      - `connect` - Time when the socket successfully connected.
      - `secureConnect` - Time when the socket securely connected.
      - `upload` - Time when the request finished uploading.
      - `response` - Time when the request fired `response` event.
      - `end` - Time when the response fired `end` event.
      - `error` - Time when the request fired `error` event.
      - `abort` - Time when the request fired `abort` event.
      - `phases`
          - `wait` - `timings.socket - timings.start`
          - `dns` - `timings.lookup - timings.socket`
          - `tcp` - `timings.connect - timings.lookup`
          - `tls` - `timings.secureConnect - timings.connect`
          - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
          - `firstByte` - `timings.response - timings.upload`
          - `download` - `timings.end - timings.response`
          - `total` - `(timings.end || timings.error || timings.abort) - timings.start`
  
      If something has not been measured yet, it will be `undefined`.
  
      __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
      */
  get timings() {
    return this._request?.timings;
  }
  /**
  Whether the response was retrieved from the cache.
  */
  get isFromCache() {
    return this._isFromCache;
  }
  get reusedSocket() {
    return this._request?.reusedSocket;
  }
  /**
  Whether the stream is read-only. Returns `true` when `body`, `json`, or `form` options are provided.
  */
  get isReadonly() {
    return !distribution_default.undefined(this.options?.body) || !distribution_default.undefined(this.options?.json) || !distribution_default.undefined(this.options?.form);
  }
};

// node_modules/got/dist/source/as-promise/types.js
var CancelError2 = class extends RequestError {
  constructor(request) {
    super("Promise was canceled", {}, request);
    this.name = "CancelError";
    this.code = "ERR_CANCELED";
  }
  /**
  Whether the promise is canceled.
  */
  get isCanceled() {
    return true;
  }
};

// node_modules/got/dist/source/as-promise/index.js
var proxiedRequestEvents2 = [
  "request",
  "response",
  "redirect",
  "uploadProgress",
  "downloadProgress"
];
function asPromise(firstRequest) {
  let globalRequest;
  let globalResponse;
  let normalizedOptions;
  const emitter = new EventEmitter2();
  let promiseSettled = false;
  const promise = new PCancelable((resolve, reject, onCancel) => {
    onCancel(() => {
      globalRequest.destroy();
    });
    onCancel.shouldReject = false;
    onCancel(() => {
      promiseSettled = true;
      reject(new CancelError2(globalRequest));
    });
    const makeRequest = (retryCount) => {
      onCancel(() => {
      });
      const request = firstRequest ?? new Request(void 0, void 0, normalizedOptions);
      request.retryCount = retryCount;
      request._noPipe = true;
      globalRequest = request;
      request.once("response", async (response) => {
        const contentEncoding = (response.headers["content-encoding"] ?? "").toLowerCase();
        const isCompressed = contentEncoding === "gzip" || contentEncoding === "deflate" || contentEncoding === "br" || contentEncoding === "zstd";
        const { options } = request;
        if (isCompressed && !options.decompress) {
          response.body = response.rawBody;
        } else {
          try {
            response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);
          } catch (error2) {
            try {
              response.body = response.rawBody.toString();
            } catch (error3) {
              request._beforeError(new ParseError(error3, response));
              return;
            }
            if (isResponseOk(response)) {
              request._beforeError(error2);
              return;
            }
          }
        }
        try {
          const hooks = options.hooks.afterResponse;
          for (const [index, hook] of hooks.entries()) {
            response = await hook(response, async (updatedOptions) => {
              const preserveHooks = updatedOptions.preserveHooks ?? false;
              options.merge(updatedOptions);
              options.prefixUrl = "";
              if (updatedOptions.url) {
                options.url = updatedOptions.url;
              }
              if (!preserveHooks) {
                options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);
              }
              throw new RetryError(request);
            });
            if (!(distribution_default.object(response) && distribution_default.number(response.statusCode) && "body" in response)) {
              throw new TypeError("The `afterResponse` hook returned an invalid value");
            }
          }
        } catch (error2) {
          request._beforeError(error2);
          return;
        }
        globalResponse = response;
        if (!isResponseOk(response)) {
          request._beforeError(new HTTPError(response));
          return;
        }
        request.destroy();
        promiseSettled = true;
        resolve(request.options.resolveBodyOnly ? response.body : response);
      });
      let handledFinalError = false;
      const onError = (error2) => {
        if (promise.isCanceled) {
          return;
        }
        if (!request._stopReading) {
          request._beforeError(error2);
          return;
        }
        if (handledFinalError) {
          return;
        }
        handledFinalError = true;
        promiseSettled = true;
        const { options } = request;
        if (error2 instanceof HTTPError && !options.throwHttpErrors) {
          const { response } = error2;
          request.destroy();
          resolve(request.options.resolveBodyOnly ? response.body : response);
          return;
        }
        reject(error2);
      };
      request.on("error", onError);
      const previousBody = request.options?.body;
      request.once("retry", (newRetryCount, error2) => {
        firstRequest = void 0;
        if (promiseSettled) {
          return;
        }
        const newBody = request.options.body;
        if (previousBody === newBody && distribution_default.nodeStream(newBody)) {
          error2.message = "Cannot retry with consumed body stream";
          onError(error2);
          return;
        }
        normalizedOptions = request.options;
        makeRequest(newRetryCount);
      });
      proxyEvents(request, emitter, proxiedRequestEvents2);
      if (distribution_default.undefined(firstRequest)) {
        void request.flush();
      }
    };
    makeRequest(0);
  });
  promise.on = (event, function_) => {
    emitter.on(event, function_);
    return promise;
  };
  promise.off = (event, function_) => {
    emitter.off(event, function_);
    return promise;
  };
  const shortcut = (promiseToAwait, responseType) => {
    const newPromise = (async () => {
      await promiseToAwait;
      const { options } = globalResponse.request;
      return parseBody(globalResponse, responseType, options.parseJson, options.encoding);
    })();
    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promiseToAwait));
    return newPromise;
  };
  promise.json = function() {
    if (globalRequest.options) {
      const { headers } = globalRequest.options;
      if (!globalRequest.writableFinished && !("accept" in headers)) {
        headers.accept = "application/json";
      }
    }
    return shortcut(this, "json");
  };
  promise.buffer = function() {
    return shortcut(this, "buffer");
  };
  promise.text = function() {
    return shortcut(this, "text");
  };
  return promise;
}

// node_modules/got/dist/source/create.js
var isGotInstance = (value) => distribution_default.function(value);
var aliases = [
  "get",
  "post",
  "put",
  "patch",
  "head",
  "delete"
];
var create = (defaults2) => {
  defaults2 = {
    options: new Options(void 0, void 0, defaults2.options),
    handlers: [...defaults2.handlers],
    mutableDefaults: defaults2.mutableDefaults
  };
  Object.defineProperty(defaults2, "mutableDefaults", {
    enumerable: true,
    configurable: false,
    writable: false
  });
  const got2 = ((url, options, defaultOptions2 = defaults2.options) => {
    const request = new Request(url, options, defaultOptions2);
    let promise;
    const lastHandler = (normalized) => {
      request.options = normalized;
      request._noPipe = !normalized?.isStream;
      void request.flush();
      if (normalized?.isStream) {
        return request;
      }
      promise ||= asPromise(request);
      return promise;
    };
    let iteration = 0;
    const iterateHandlers = (newOptions) => {
      const handler = defaults2.handlers[iteration++] ?? lastHandler;
      const result = handler(newOptions, iterateHandlers);
      if (distribution_default.promise(result) && !request.options?.isStream) {
        promise ||= asPromise(request);
        if (result !== promise) {
          const descriptors = Object.getOwnPropertyDescriptors(promise);
          for (const key in descriptors) {
            if (key in result) {
              delete descriptors[key];
            }
          }
          Object.defineProperties(result, descriptors);
          result.cancel = promise.cancel;
        }
      }
      return result;
    };
    return iterateHandlers(request.options);
  });
  got2.extend = (...instancesOrOptions) => {
    const options = new Options(void 0, void 0, defaults2.options);
    const handlers = [...defaults2.handlers];
    let mutableDefaults;
    for (const value of instancesOrOptions) {
      if (isGotInstance(value)) {
        options.merge(value.defaults.options);
        handlers.push(...value.defaults.handlers);
        mutableDefaults = value.defaults.mutableDefaults;
      } else {
        options.merge(value);
        if (value.handlers) {
          handlers.push(...value.handlers);
        }
        mutableDefaults = value.mutableDefaults;
      }
    }
    return create({
      options,
      handlers,
      mutableDefaults: Boolean(mutableDefaults)
    });
  };
  const paginateEach = (async function* (url, options) {
    let normalizedOptions = new Options(url, options, defaults2.options);
    normalizedOptions.resolveBodyOnly = false;
    const { pagination } = normalizedOptions;
    assert.function(pagination.transform);
    assert.function(pagination.shouldContinue);
    assert.function(pagination.filter);
    assert.function(pagination.paginate);
    assert.number(pagination.countLimit);
    assert.number(pagination.requestLimit);
    assert.number(pagination.backoff);
    const allItems = [];
    let { countLimit } = pagination;
    let numberOfRequests = 0;
    while (numberOfRequests < pagination.requestLimit) {
      if (numberOfRequests !== 0) {
        await delay(pagination.backoff);
      }
      const response = await got2(void 0, void 0, normalizedOptions);
      const parsed = await pagination.transform(response);
      const currentItems = [];
      assert.array(parsed);
      for (const item of parsed) {
        if (pagination.filter({ item, currentItems, allItems })) {
          if (!pagination.shouldContinue({ item, currentItems, allItems })) {
            return;
          }
          yield item;
          if (pagination.stackAllItems) {
            allItems.push(item);
          }
          currentItems.push(item);
          if (--countLimit <= 0) {
            return;
          }
        }
      }
      const optionsToMerge = pagination.paginate({
        response,
        currentItems,
        allItems
      });
      if (optionsToMerge === false) {
        return;
      }
      if (optionsToMerge === response.request.options) {
        normalizedOptions = response.request.options;
      } else {
        normalizedOptions.merge(optionsToMerge);
        try {
          assert.any([distribution_default.urlInstance, distribution_default.undefined], optionsToMerge.url);
        } catch (error2) {
          if (error2 instanceof Error) {
            error2.message = `Option 'pagination.paginate.url': ${error2.message}`;
          }
          throw error2;
        }
        if (optionsToMerge.url !== void 0) {
          normalizedOptions.prefixUrl = "";
          normalizedOptions.url = optionsToMerge.url;
        }
      }
      numberOfRequests++;
    }
  });
  got2.paginate = paginateEach;
  got2.paginate.all = (async (url, options) => {
    const results = [];
    for await (const item of paginateEach(url, options)) {
      results.push(item);
    }
    return results;
  });
  got2.paginate.each = paginateEach;
  got2.stream = ((url, options) => got2(url, { ...options, isStream: true }));
  for (const method of aliases) {
    got2[method] = ((url, options) => got2(url, { ...options, method }));
    got2.stream[method] = ((url, options) => got2(url, { ...options, method, isStream: true }));
  }
  if (!defaults2.mutableDefaults) {
    Object.freeze(defaults2.handlers);
    defaults2.options.freeze();
  }
  Object.defineProperty(got2, "defaults", {
    value: defaults2,
    writable: false,
    configurable: false,
    enumerable: true
  });
  return got2;
};
var create_default = create;

// node_modules/got/dist/source/index.js
var defaults = {
  options: new Options(),
  handlers: [],
  mutableDefaults: false
};
var got = create_default(defaults);

// node_modules/detsys-ts/dist/index.mjs
var actionsCache = __toESM(require_cache4(), 1);
import { resolveSrv } from "dns/promises";
import { exec as exec2 } from "child_process";
import * as path from "path";
var readFileAsync = promisify4(fs$1.readFile);
var linuxReleaseInfoOptionsDefaults = {
  mode: "async",
  customFile: null,
  debug: false
};
function releaseInfo(infoOptions) {
  const options = {
    ...linuxReleaseInfoOptionsDefaults,
    ...infoOptions
  };
  const searchOsReleaseFileList = osReleaseFileList(options.customFile);
  if (os$1.type() !== "Linux") if (options.mode === "sync") return getOsInfo();
  else return Promise.resolve(getOsInfo());
  if (options.mode === "sync") return readSyncOsreleaseFile(searchOsReleaseFileList, options);
  else return Promise.resolve(readAsyncOsReleaseFile(searchOsReleaseFileList, options));
}
function formatFileData(sourceData, srcParseData) {
  const lines = srcParseData.split("\n");
  for (const line of lines) {
    const lineData = line.split("=");
    if (lineData.length === 2) {
      lineData[1] = lineData[1].replace(/["'\r]/gi, "");
      Object.defineProperty(sourceData, lineData[0].toLowerCase(), {
        value: lineData[1],
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return sourceData;
}
function osReleaseFileList(customFile) {
  const DEFAULT_OS_RELEASE_FILES = ["/etc/os-release", "/usr/lib/os-release"];
  if (!customFile) return DEFAULT_OS_RELEASE_FILES;
  else return Array(customFile);
}
function getOsInfo() {
  return {
    type: os$1.type(),
    platform: os$1.platform(),
    hostname: os$1.hostname(),
    arch: os$1.arch(),
    release: os$1.release()
  };
}
async function readAsyncOsReleaseFile(fileList, options) {
  let fileData = null;
  for (const osReleaseFile of fileList) try {
    if (options.debug) console.log(`Trying to read '${osReleaseFile}'...`);
    fileData = await readFileAsync(osReleaseFile, "binary");
    if (options.debug) console.log(`Read data:
${fileData}`);
    break;
  } catch (error2) {
    if (options.debug) console.error(error2);
  }
  if (fileData === null) throw new Error("Cannot read os-release file!");
  return formatFileData(getOsInfo(), fileData);
}
function readSyncOsreleaseFile(releaseFileList, options) {
  let fileData = null;
  for (const osReleaseFile of releaseFileList) try {
    if (options.debug) console.log(`Trying to read '${osReleaseFile}'...`);
    fileData = fs$1.readFileSync(osReleaseFile, "binary");
    if (options.debug) console.log(`Read data:
${fileData}`);
    break;
  } catch (error2) {
    if (options.debug) console.error(error2);
  }
  if (fileData === null) throw new Error("Cannot read os-release file!");
  return formatFileData(getOsInfo(), fileData);
}
var getWindowsInfo = async () => {
  const { stdout: version } = await exec$1.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, { silent: true });
  const { stdout: name } = await exec$1.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, { silent: true });
  return {
    name: name.trim(),
    version: version.trim()
  };
};
var getMacOsInfo = async () => {
  const { stdout } = await exec$1.getExecOutput("sw_vers", void 0, { silent: true });
  const version = stdout.match(/ProductVersion:\s*(.+)/)?.[1] ?? "";
  return {
    name: stdout.match(/ProductName:\s*(.+)/)?.[1] ?? "",
    version
  };
};
var getLinuxInfo = async () => {
  let data = {};
  try {
    data = releaseInfo({ mode: "sync" });
    actionsCore.debug(`Identified release info: ${JSON.stringify(data)}`);
  } catch (e) {
    actionsCore.debug(`Error collecting release info: ${e}`);
  }
  return {
    name: getPropertyViaWithDefault(data, [
      "id",
      "name",
      "pretty_name",
      "id_like"
    ], "unknown"),
    version: getPropertyViaWithDefault(data, [
      "version_id",
      "version",
      "version_codename"
    ], "unknown")
  };
};
function getPropertyViaWithDefault(data, names, defaultValue) {
  for (const name of names) {
    const ret = getPropertyWithDefault(data, name, defaultValue);
    if (ret !== defaultValue) return ret;
  }
  return defaultValue;
}
function getPropertyWithDefault(data, name, defaultValue) {
  if (!data.hasOwnProperty(name)) return defaultValue;
  const value = data[name];
  if (typeof value !== typeof defaultValue) return defaultValue;
  return value;
}
var platform2 = os2.platform();
var arch2 = os2.arch();
var isWindows = platform2 === "win32";
var isMacOS = platform2 === "darwin";
var isLinux = platform2 === "linux";
async function getDetails() {
  return {
    ...await (isWindows ? getWindowsInfo() : isMacOS ? getMacOsInfo() : getLinuxInfo()),
    platform: platform2,
    arch: arch2,
    isWindows,
    isMacOS,
    isLinux
  };
}
function stringifyError(e) {
  if (e instanceof Error) return e.message;
  else if (typeof e === "string") return e;
  else return JSON.stringify(e);
}
var START_SLOP_SECONDS = 5;
async function collectBacktraces(prefixes, programNameDenyList, startTimestampMs) {
  if (isMacOS) return await collectBacktracesMacOS(prefixes, programNameDenyList, startTimestampMs);
  if (isLinux) return await collectBacktracesSystemd(prefixes, programNameDenyList, startTimestampMs);
  return /* @__PURE__ */ new Map();
}
async function collectBacktracesMacOS(prefixes, programNameDenyList, startTimestampMs) {
  const backtraces = /* @__PURE__ */ new Map();
  try {
    const { stdout: logJson } = await exec$1.getExecOutput("log", [
      "show",
      "--style",
      "json",
      "--last",
      "1m",
      "--no-info",
      "--predicate",
      "sender = 'ReportCrash'"
    ], { silent: true });
    const sussyArray = JSON.parse(logJson);
    if (!Array.isArray(sussyArray)) throw new Error(`Log json isn't an array: ${logJson}`);
    if (sussyArray.length > 0) {
      actionsCore.info(`Collecting crash data...`);
      const delay3 = async (ms) => new Promise((resolve) => setTimeout(resolve, ms));
      await delay3(5e3);
    }
  } catch {
    actionsCore.debug("Failed to check logs for in-progress crash dumps; now proceeding with the assumption that all crash dumps completed.");
  }
  const dirs = [["system", "/Library/Logs/DiagnosticReports/"], ["user", `${process.env["HOME"]}/Library/Logs/DiagnosticReports/`]];
  for (const [source, dir] of dirs) {
    const fileNames = (await readdir(dir)).filter((fileName) => {
      return prefixes.some((prefix) => fileName.startsWith(prefix));
    }).filter((fileName) => {
      return !programNameDenyList.some((programName) => fileName.startsWith(programName));
    }).filter((fileName) => {
      return !fileName.endsWith(".diag");
    });
    const doGzip = promisify4(gzip);
    for (const fileName of fileNames) try {
      if ((await stat(`${dir}/${fileName}`)).ctimeMs >= startTimestampMs) {
        const buf = await doGzip(await readFile2(`${dir}/${fileName}`));
        backtraces.set(`backtrace_value_${source}_${fileName}`, buf.toString("base64"));
      }
    } catch (innerError) {
      backtraces.set(`backtrace_failure_${source}_${fileName}`, stringifyError(innerError));
    }
  }
  return backtraces;
}
async function collectBacktracesSystemd(prefixes, programNameDenyList, startTimestampMs) {
  const sinceSeconds = Math.ceil((Date.now() - startTimestampMs) / 1e3) + START_SLOP_SECONDS;
  const backtraces = /* @__PURE__ */ new Map();
  const coredumps = [];
  try {
    const { stdout: coredumpjson } = await exec$1.getExecOutput("coredumpctl", [
      "--json=pretty",
      "list",
      "--since",
      `${sinceSeconds} seconds ago`
    ], { silent: true });
    const sussyArray = JSON.parse(coredumpjson);
    if (!Array.isArray(sussyArray)) throw new Error(`Coredump isn't an array: ${coredumpjson}`);
    for (const sussyObject of sussyArray) {
      const keys = Object.keys(sussyObject);
      if (keys.includes("exe") && keys.includes("pid")) if (typeof sussyObject.exe == "string" && typeof sussyObject.pid == "number") {
        const execParts = sussyObject.exe.split("/");
        const binaryName = execParts[execParts.length - 1];
        if (prefixes.some((prefix) => binaryName.startsWith(prefix)) && !programNameDenyList.includes(binaryName)) coredumps.push({
          exe: sussyObject.exe,
          pid: sussyObject.pid
        });
      } else actionsCore.debug(`Mysterious coredump entry missing exe string and/or pid number: ${JSON.stringify(sussyObject)}`);
      else actionsCore.debug(`Mysterious coredump entry missing exe value and/or pid value: ${JSON.stringify(sussyObject)}`);
    }
  } catch (innerError) {
    actionsCore.debug(`Cannot collect backtraces: ${stringifyError(innerError)}`);
    return backtraces;
  }
  const doGzip = promisify4(gzip);
  for (const coredump of coredumps) try {
    const { stdout: logText } = await exec$1.getExecOutput("coredumpctl", ["info", `${coredump.pid}`], { silent: true });
    const buf = await doGzip(logText);
    backtraces.set(`backtrace_value_${coredump.pid}`, buf.toString("base64"));
  } catch (innerError) {
    backtraces.set(`backtrace_failure_${coredump.pid}`, stringifyError(innerError));
  }
  return backtraces;
}
var OPTIONAL_VARIABLES = ["INVOCATION_ID"];
function identify() {
  const repository = hashEnvironmentVariables("GHR", [
    "GITHUB_SERVER_URL",
    "GITHUB_REPOSITORY_OWNER",
    "GITHUB_REPOSITORY_OWNER_ID",
    "GITHUB_REPOSITORY",
    "GITHUB_REPOSITORY_ID"
  ]);
  const run_differentiator = hashEnvironmentVariables("GHWJA", [
    "GITHUB_SERVER_URL",
    "GITHUB_REPOSITORY_OWNER",
    "GITHUB_REPOSITORY_OWNER_ID",
    "GITHUB_REPOSITORY",
    "GITHUB_REPOSITORY_ID",
    "GITHUB_WORKFLOW",
    "GITHUB_JOB",
    "GITHUB_RUN_ID",
    "GITHUB_RUN_NUMBER",
    "GITHUB_RUN_ATTEMPT",
    "INVOCATION_ID"
  ]);
  const ident = {
    $anon_distinct_id: process.env["RUNNER_TRACKING_ID"] || randomUUID2(),
    correlation_source: "github-actions",
    github_repository_hash: repository,
    github_workflow_hash: hashEnvironmentVariables("GHW", [
      "GITHUB_SERVER_URL",
      "GITHUB_REPOSITORY_OWNER",
      "GITHUB_REPOSITORY_OWNER_ID",
      "GITHUB_REPOSITORY",
      "GITHUB_REPOSITORY_ID",
      "GITHUB_WORKFLOW"
    ]),
    github_workflow_job_hash: hashEnvironmentVariables("GHWJ", [
      "GITHUB_SERVER_URL",
      "GITHUB_REPOSITORY_OWNER",
      "GITHUB_REPOSITORY_OWNER_ID",
      "GITHUB_REPOSITORY",
      "GITHUB_REPOSITORY_ID",
      "GITHUB_WORKFLOW",
      "GITHUB_JOB"
    ]),
    github_workflow_run_hash: hashEnvironmentVariables("GHWJR", [
      "GITHUB_SERVER_URL",
      "GITHUB_REPOSITORY_OWNER",
      "GITHUB_REPOSITORY_OWNER_ID",
      "GITHUB_REPOSITORY",
      "GITHUB_REPOSITORY_ID",
      "GITHUB_WORKFLOW",
      "GITHUB_JOB",
      "GITHUB_RUN_ID"
    ]),
    github_workflow_run_differentiator_hash: run_differentiator,
    $session_id: run_differentiator,
    $groups: {
      github_repository: repository,
      github_organization: hashEnvironmentVariables("GHO", [
        "GITHUB_SERVER_URL",
        "GITHUB_REPOSITORY_OWNER",
        "GITHUB_REPOSITORY_OWNER_ID"
      ])
    },
    is_ci: true
  };
  actionsCore.debug("Correlation data:");
  actionsCore.debug(JSON.stringify(ident, null, 2));
  return ident;
}
function hashEnvironmentVariables(prefix, variables) {
  const hash = createHash("sha256");
  for (const varName of variables) {
    let value = process.env[varName];
    if (value === void 0) if (OPTIONAL_VARIABLES.includes(varName)) {
      actionsCore.debug(`Optional environment variable not set: ${varName} -- substituting with the variable name`);
      value = varName;
    } else {
      actionsCore.debug(`Environment variable not set: ${varName} -- can't generate the requested identity`);
      return;
    }
    hash.update(value);
    hash.update("\0");
  }
  return `${prefix}-${hash.digest("hex")}`;
}
var DEFAULT_LOOKUP = "_detsys_ids._tcp.install.determinate.systems.";
var ALLOWED_SUFFIXES = [".install.determinate.systems", ".install.detsys.dev"];
var DEFAULT_IDS_HOST = "https://install.determinate.systems";
var LOOKUP = process.env["IDS_LOOKUP"] ?? DEFAULT_LOOKUP;
var DEFAULT_TIMEOUT = 1e4;
var IdsHost = class {
  constructor(idsProjectName, diagnosticsSuffix, runtimeDiagnosticsUrl) {
    this.idsProjectName = idsProjectName;
    this.diagnosticsSuffix = diagnosticsSuffix;
    this.runtimeDiagnosticsUrl = runtimeDiagnosticsUrl;
    this.client = void 0;
  }
  async getGot(recordFailoverCallback) {
    if (this.client === void 0) this.client = got.extend({
      timeout: { request: DEFAULT_TIMEOUT },
      retry: {
        limit: Math.max((await this.getUrlsByPreference()).length, 3),
        methods: ["GET", "HEAD"]
      },
      hooks: {
        beforeRetry: [async (error2, retryCount) => {
          const prevUrl = await this.getRootUrl();
          this.markCurrentHostBroken();
          const nextUrl = await this.getRootUrl();
          if (recordFailoverCallback !== void 0) recordFailoverCallback(error2, prevUrl, nextUrl);
          actionsCore.info(`Retrying after error ${error2.code}, retry #: ${retryCount}`);
        }],
        beforeRequest: [async (options) => {
          const currentUrl = options.url;
          if (this.isUrlSubjectToDynamicUrls(currentUrl)) {
            const newUrl = new URL(currentUrl);
            newUrl.host = (await this.getRootUrl()).host;
            options.url = newUrl;
            actionsCore.debug(`Transmuted ${currentUrl} into ${newUrl}`);
          } else actionsCore.debug(`No transmutations on ${currentUrl}`);
        }]
      }
    });
    return this.client;
  }
  markCurrentHostBroken() {
    this.prioritizedURLs?.shift();
  }
  setPrioritizedUrls(urls) {
    this.prioritizedURLs = urls;
  }
  isUrlSubjectToDynamicUrls(url) {
    if (url.origin === DEFAULT_IDS_HOST) return true;
    for (const suffix of ALLOWED_SUFFIXES) if (url.host.endsWith(suffix)) return true;
    return false;
  }
  async getDynamicRootUrl() {
    const idsHost = process.env["IDS_HOST"];
    if (idsHost !== void 0) try {
      return new URL(idsHost);
    } catch (err) {
      actionsCore.error(`IDS_HOST environment variable is not a valid URL. Ignoring. ${stringifyError(err)}`);
    }
    let url = void 0;
    try {
      url = (await this.getUrlsByPreference())[0];
    } catch (err) {
      actionsCore.error(`Error collecting IDS URLs by preference: ${stringifyError(err)}`);
    }
    if (url === void 0) return;
    else return new URL(url);
  }
  async getRootUrl() {
    const url = await this.getDynamicRootUrl();
    if (url === void 0) return new URL(DEFAULT_IDS_HOST);
    return url;
  }
  async getDiagnosticsUrl() {
    if (this.runtimeDiagnosticsUrl === "") return;
    if (this.runtimeDiagnosticsUrl !== "-" && this.runtimeDiagnosticsUrl !== void 0) try {
      return new URL(this.runtimeDiagnosticsUrl);
    } catch (err) {
      actionsCore.info(`User-provided diagnostic endpoint ignored: not a valid URL: ${stringifyError(err)}`);
    }
    try {
      const diagnosticUrl = await this.getRootUrl();
      diagnosticUrl.pathname += "events/batch";
      return diagnosticUrl;
    } catch (err) {
      actionsCore.info(`Generated diagnostic endpoint ignored, and diagnostics are disabled: not a valid URL: ${stringifyError(err)}`);
      return;
    }
  }
  async getUrlsByPreference() {
    if (this.prioritizedURLs === void 0) this.prioritizedURLs = orderRecordsByPriorityWeight(await discoverServiceRecords()).flatMap((record) => recordToUrl(record) || []);
    return this.prioritizedURLs;
  }
};
function recordToUrl(record) {
  const urlStr = `https://${record.name}:${record.port}`;
  try {
    return new URL(urlStr);
  } catch (err) {
    actionsCore.debug(`Record ${JSON.stringify(record)} produced an invalid URL: ${urlStr} (${err})`);
    return;
  }
}
async function discoverServiceRecords() {
  return await discoverServicesStub(resolveSrv(LOOKUP), 1e3);
}
async function discoverServicesStub(lookup, timeout) {
  const defaultFallback = new Promise((resolve, _reject) => {
    setTimeout(resolve, timeout, []);
  });
  let records;
  try {
    records = await Promise.race([lookup, defaultFallback]);
  } catch (reason) {
    actionsCore.debug(`Error resolving SRV records: ${stringifyError(reason)}`);
    records = [];
  }
  const acceptableRecords = records.filter((record) => {
    for (const suffix of ALLOWED_SUFFIXES) if (record.name.endsWith(suffix)) return true;
    actionsCore.debug(`Unacceptable domain due to an invalid suffix: ${record.name}`);
    return false;
  });
  if (acceptableRecords.length === 0) actionsCore.debug(`No records found for ${LOOKUP}`);
  else actionsCore.debug(`Resolved ${LOOKUP} to ${JSON.stringify(acceptableRecords)}`);
  return acceptableRecords;
}
function orderRecordsByPriorityWeight(records) {
  const byPriorityWeight = /* @__PURE__ */ new Map();
  for (const record of records) {
    const existing = byPriorityWeight.get(record.priority);
    if (existing) existing.push(record);
    else byPriorityWeight.set(record.priority, [record]);
  }
  const prioritizedRecords = [];
  const keys = Array.from(byPriorityWeight.keys()).sort((a2, b) => a2 - b);
  for (const priority of keys) {
    const recordsByPrio = byPriorityWeight.get(priority);
    if (recordsByPrio === void 0) continue;
    prioritizedRecords.push(...weightedRandom(recordsByPrio));
  }
  return prioritizedRecords;
}
function weightedRandom(records) {
  const scratchRecords = records.slice();
  const result = [];
  while (scratchRecords.length > 0) {
    const weights = [];
    for (let i2 = 0; i2 < scratchRecords.length; i2++) weights.push(scratchRecords[i2].weight + (i2 > 0 ? scratchRecords[i2 - 1].weight : 0));
    const point = Math.random() * weights[weights.length - 1];
    for (let selectedIndex = 0; selectedIndex < weights.length; selectedIndex++) if (weights[selectedIndex] > point) {
      result.push(scratchRecords.splice(selectedIndex, 1)[0]);
      break;
    }
  }
  return result;
}
var getBool = (name) => {
  return actionsCore.getBooleanInput(name);
};
var getBoolOrUndefined = (name) => {
  if (getStringOrUndefined(name) === void 0) return;
  return actionsCore.getBooleanInput(name);
};
var getStringOrNull = (name) => {
  const value = actionsCore.getInput(name);
  if (value === "") return null;
  else return value;
};
var getStringOrUndefined = (name) => {
  const value = actionsCore.getInput(name);
  if (value === "") return;
  else return value;
};
function getArchOs() {
  const envArch = process.env.RUNNER_ARCH;
  const envOs = process.env.RUNNER_OS;
  if (envArch && envOs) return `${envArch}-${envOs}`;
  else {
    actionsCore.error(`Can't identify the platform: RUNNER_ARCH or RUNNER_OS undefined (${envArch}-${envOs})`);
    throw new Error("RUNNER_ARCH and/or RUNNER_OS is not defined");
  }
}
function getNixPlatform(archOs) {
  const mappedTo = (/* @__PURE__ */ new Map([
    ["X64-macOS", "x86_64-darwin"],
    ["ARM64-macOS", "aarch64-darwin"],
    ["X64-Linux", "x86_64-linux"],
    ["ARM64-Linux", "aarch64-linux"]
  ])).get(archOs);
  if (mappedTo) return mappedTo;
  else {
    actionsCore.error(`ArchOs (${archOs}) doesn't map to a supported Nix platform.`);
    throw new Error(`Cannot convert ArchOs (${archOs}) to a supported Nix platform.`);
  }
}
function constructSourceParameters(legacyPrefix) {
  return {
    path: noisilyGetInput("path", legacyPrefix),
    url: noisilyGetInput("url", legacyPrefix),
    tag: noisilyGetInput("tag", legacyPrefix),
    pr: noisilyGetInput("pr", legacyPrefix),
    branch: noisilyGetInput("branch", legacyPrefix),
    revision: noisilyGetInput("revision", legacyPrefix)
  };
}
function noisilyGetInput(suffix, legacyPrefix) {
  const preferredInput = getStringOrUndefined(`source-${suffix}`);
  if (!legacyPrefix) return preferredInput;
  const legacyInput = getStringOrUndefined(`${legacyPrefix}-${suffix}`);
  if (preferredInput && legacyInput) {
    actionsCore.warning(`The supported option source-${suffix} and the legacy option ${legacyPrefix}-${suffix} are both set. Preferring source-${suffix}. Please stop setting ${legacyPrefix}-${suffix}.`);
    return preferredInput;
  } else if (legacyInput) {
    actionsCore.warning(`The legacy option ${legacyPrefix}-${suffix} is set. Please migrate to source-${suffix}.`);
    return legacyInput;
  } else return preferredInput;
}
var pkgVersion = "1.0";
var EVENT_BACKTRACES = "backtrace";
var EVENT_EXCEPTION = "exception";
var EVENT_ARTIFACT_CACHE_HIT = "artifact_cache_hit";
var EVENT_ARTIFACT_CACHE_MISS = "artifact_cache_miss";
var EVENT_ARTIFACT_CACHE_PERSIST = "artifact_cache_persist";
var EVENT_PREFLIGHT_REQUIRE_NIX_DENIED = "preflight-require-nix-denied";
var EVENT_STORE_IDENTITY_FAILED = "store_identity_failed";
var FACT_ARTIFACT_FETCHED_FROM_CACHE = "artifact_fetched_from_cache";
var FACT_ENDED_WITH_EXCEPTION = "ended_with_exception";
var FACT_FINAL_EXCEPTION = "final_exception";
var FACT_OS = "$os";
var FACT_OS_VERSION = "$os_version";
var FACT_SOURCE_URL = "source_url";
var FACT_SOURCE_URL_ETAG = "source_url_etag";
var FACT_NIX_VERSION = "nix_version";
var FACT_NIX_LOCATION = "nix_location";
var FACT_NIX_STORE_TRUST = "nix_store_trusted";
var FACT_NIX_STORE_VERSION = "nix_store_version";
var FACT_NIX_STORE_CHECK_METHOD = "nix_store_check_method";
var FACT_NIX_STORE_CHECK_ERROR = "nix_store_check_error";
var STATE_KEY_EXECUTION_PHASE = "detsys_action_execution_phase";
var STATE_KEY_NIX_NOT_FOUND = "detsys_action_nix_not_found";
var STATE_NOT_FOUND = "not-found";
var STATE_KEY_CROSS_PHASE_ID = "detsys_cross_phase_id";
var STATE_BACKTRACE_START_TIMESTAMP = "detsys_backtrace_start_timestamp";
var DIAGNOSTIC_ENDPOINT_TIMEOUT_MS = 1e4;
var CHECK_IN_ENDPOINT_TIMEOUT_MS = 1e3;
var PROGRAM_NAME_CRASH_DENY_LIST = [
  "nix-expr-tests",
  "nix-store-tests",
  "nix-util-tests"
];
var determinateStateDir = "/var/lib/determinate";
var determinateIdentityFile = path.join(determinateStateDir, "identity.json");
var isRoot = typeof process.geteuid === "function" && process.geteuid() === 0;
async function sudoEnsureDeterminateStateDir() {
  const code = await exec$1.exec("sudo", [
    "mkdir",
    "-p",
    determinateStateDir
  ]);
  if (code !== 0) throw new Error(`sudo mkdir -p exit: ${code}`);
}
async function ensureDeterminateStateDir() {
  if (isRoot) await mkdir(determinateStateDir, { recursive: true });
  else return sudoEnsureDeterminateStateDir();
}
async function sudoWriteCorrelationHashes(hashes) {
  const buffer = Buffer.from(hashes);
  const code = await exec$1.exec("sudo", ["tee", determinateIdentityFile], {
    input: buffer,
    outStream: createWriteStream("/dev/null")
  });
  if (code !== 0) throw new Error(`sudo tee exit: ${code}`);
}
async function writeCorrelationHashes(hashes) {
  await ensureDeterminateStateDir();
  if (isRoot) await fs.writeFile(determinateIdentityFile, hashes, "utf-8");
  else return sudoWriteCorrelationHashes(hashes);
}
var DetSysAction = class {
  determineExecutionPhase() {
    if (actionsCore.getState(STATE_KEY_EXECUTION_PHASE) === "") {
      actionsCore.saveState(STATE_KEY_EXECUTION_PHASE, "post");
      return "main";
    } else return "post";
  }
  constructor(actionOptions) {
    this.actionOptions = makeOptionsConfident(actionOptions);
    this.idsHost = new IdsHost(this.actionOptions.idsProjectName, actionOptions.diagnosticsSuffix, process.env["INPUT_DIAGNOSTIC-ENDPOINT"]);
    this.exceptionAttachments = /* @__PURE__ */ new Map();
    this.nixStoreTrust = "unknown";
    this.strictMode = getBool("_internal-strict-mode");
    if (getBoolOrUndefined("_internal-obliterate-actions-id-token-request-variables") === true) {
      process.env["ACTIONS_ID_TOKEN_REQUEST_URL"] = void 0;
      process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"] = void 0;
    }
    this.features = {};
    this.featureEventMetadata = {};
    this.events = [];
    this.getCrossPhaseId();
    this.collectBacktraceSetup();
    this.facts = {
      $lib: "idslib",
      $lib_version: pkgVersion,
      project: this.actionOptions.name,
      ids_project: this.actionOptions.idsProjectName
    };
    for (const [target, env] of [
      ["github_action_ref", "GITHUB_ACTION_REF"],
      ["github_action_repository", "GITHUB_ACTION_REPOSITORY"],
      ["github_event_name", "GITHUB_EVENT_NAME"],
      ["$os", "RUNNER_OS"],
      ["arch", "RUNNER_ARCH"]
    ]) {
      const value = process.env[env];
      if (value) this.facts[target] = value;
    }
    this.identity = identify();
    this.archOs = getArchOs();
    this.nixSystem = getNixPlatform(this.archOs);
    this.facts.$app_name = `${this.actionOptions.name}/action`;
    this.facts.arch_os = this.archOs;
    this.facts.nix_system = this.nixSystem;
    getDetails().then((details) => {
      if (details.name !== "unknown") this.addFact(FACT_OS, details.name);
      if (details.version !== "unknown") this.addFact(FACT_OS_VERSION, details.version);
    }).catch((e) => {
      actionsCore.debug(`Failure getting platform details: ${stringifyError$1(e)}`);
    });
    this.executionPhase = this.determineExecutionPhase();
    this.facts.execution_phase = this.executionPhase;
    if (this.actionOptions.fetchStyle === "gh-env-style") this.architectureFetchSuffix = this.archOs;
    else if (this.actionOptions.fetchStyle === "nix-style") this.architectureFetchSuffix = this.nixSystem;
    else if (this.actionOptions.fetchStyle === "universal") this.architectureFetchSuffix = "universal";
    else throw new Error(`fetchStyle ${this.actionOptions.fetchStyle} is not a valid style`);
    this.sourceParameters = constructSourceParameters(this.actionOptions.legacySourcePrefix);
    this.recordEvent(`begin_${this.executionPhase}`);
  }
  /**
  * Attach a file to the diagnostics data in error conditions.
  *
  * The file at `location` doesn't need to exist when stapleFile is called.
  *
  * If the file doesn't exist or is unreadable when trying to staple the attachments, the JS error will be stored in a context value at `staple_failure_{name}`.
  * If the file is readable, the file's contents will be stored in a context value at `staple_value_{name}`.
  */
  stapleFile(name, location) {
    this.exceptionAttachments.set(name, location);
  }
  /**
  * Execute the Action as defined.
  */
  execute() {
    this.executeAsync().catch((error2) => {
      console.log(error2);
      process.exitCode = 1;
    });
  }
  getTemporaryName() {
    const tmpDir = process.env["RUNNER_TEMP"] || tmpdir();
    return path.join(tmpDir, `${this.actionOptions.name}-${randomUUID2()}`);
  }
  addFact(key, value) {
    this.facts[key] = value;
  }
  async getDiagnosticsUrl() {
    return await this.idsHost.getDiagnosticsUrl();
  }
  getUniqueId() {
    return this.identity.github_workflow_run_differentiator_hash || process.env.RUNNER_TRACKING_ID || randomUUID2();
  }
  getCrossPhaseId() {
    let crossPhaseId = actionsCore.getState(STATE_KEY_CROSS_PHASE_ID);
    if (crossPhaseId === "") {
      crossPhaseId = randomUUID2();
      actionsCore.saveState(STATE_KEY_CROSS_PHASE_ID, crossPhaseId);
    }
    return crossPhaseId;
  }
  getCorrelationHashes() {
    return this.identity;
  }
  recordEvent(eventName, context = {}) {
    const prefixedName = eventName === "$feature_flag_called" ? eventName : `${this.actionOptions.eventPrefix}${eventName}`;
    this.events.push({
      name: prefixedName,
      distinct_id: this.identity.$anon_distinct_id,
      uuid: randomUUID2(),
      timestamp: /* @__PURE__ */ new Date(),
      properties: {
        ...context,
        ...this.identity,
        ...this.facts,
        ...Object.fromEntries(Object.entries(this.featureEventMetadata).map(([name, variant]) => [`$feature/${name}`, variant]))
      }
    });
  }
  /**
  * Unpacks the closure returned by `fetchArtifact()`, imports the
  * contents into the Nix store, and returns the path of the executable at
  * `/nix/store/STORE_PATH/bin/${bin}`.
  */
  async unpackClosure(bin) {
    const artifact = await this.fetchArtifact();
    const { stdout } = await promisify4(exec2)(`cat "${artifact}" | xz -d | nix-store --import`);
    return `${stdout.split(os$1.EOL).at(-2)}/bin/${bin}`;
  }
  /**
  * Fetches the executable at the URL determined by the `source-*` inputs and
  * other facts, `chmod`s it, and returns the path to the executable on disk.
  */
  async fetchExecutable() {
    const binaryPath = await this.fetchArtifact();
    await chmod(binaryPath, constants.S_IXUSR | constants.S_IXGRP);
    return binaryPath;
  }
  get isMain() {
    return this.executionPhase === "main";
  }
  get isPost() {
    return this.executionPhase === "post";
  }
  async executeAsync() {
    try {
      await this.checkIn();
      const correlationHashes = JSON.stringify(this.getCorrelationHashes());
      process.env.DETSYS_CORRELATION = correlationHashes;
      try {
        await writeCorrelationHashes(correlationHashes);
      } catch (error2) {
        this.recordEvent(EVENT_STORE_IDENTITY_FAILED, { error: String(error2) });
      }
      if (!await this.preflightRequireNix()) {
        this.recordEvent(EVENT_PREFLIGHT_REQUIRE_NIX_DENIED);
        return;
      } else {
        await this.preflightNixStoreInfo();
        await this.preflightNixVersion();
        this.addFact(FACT_NIX_STORE_TRUST, this.nixStoreTrust);
      }
      if (this.isMain) {
        await this.main();
        await this.preflightNixVersion();
      } else if (this.isPost) await this.post();
      this.addFact(FACT_ENDED_WITH_EXCEPTION, false);
    } catch (e) {
      this.addFact(FACT_ENDED_WITH_EXCEPTION, true);
      const reportable = stringifyError$1(e);
      this.addFact(FACT_FINAL_EXCEPTION, reportable);
      if (this.isPost) actionsCore.warning(reportable);
      else actionsCore.setFailed(reportable);
      const doGzip = promisify4(gzip);
      const exceptionContext = /* @__PURE__ */ new Map();
      for (const [attachmentLabel, filePath] of this.exceptionAttachments) try {
        const buf = await doGzip(readFileSync2(filePath));
        exceptionContext.set(`staple_value_${attachmentLabel}`, buf.toString("base64"));
      } catch (innerError) {
        exceptionContext.set(`staple_failure_${attachmentLabel}`, stringifyError$1(innerError));
      }
      this.recordEvent(EVENT_EXCEPTION, Object.fromEntries(exceptionContext));
    } finally {
      if (this.isPost) await this.collectBacktraces();
      await this.complete();
    }
  }
  async getClient() {
    return await this.idsHost.getGot((incitingError, prevUrl, nextUrl) => {
      this.recordPlausibleTimeout(incitingError);
      this.recordEvent("ids-failover", {
        previousUrl: prevUrl.toString(),
        nextUrl: nextUrl.toString()
      });
    });
  }
  async checkIn() {
    const checkin = await this.requestCheckIn();
    if (checkin === void 0) return;
    this.features = checkin.options;
    for (const [key, feature] of Object.entries(this.features)) this.featureEventMetadata[key] = feature.variant;
    const impactSymbol = /* @__PURE__ */ new Map([
      ["none", "\u26AA"],
      ["maintenance", "\u{1F6E0}\uFE0F"],
      ["minor", "\u{1F7E1}"],
      ["major", "\u{1F7E0}"],
      ["critical", "\u{1F534}"]
    ]);
    const defaultImpactSymbol = "\u{1F535}";
    if (checkin.status !== null) {
      const summaries = [];
      for (const incident of checkin.status.incidents) summaries.push(`${impactSymbol.get(incident.impact) || defaultImpactSymbol} ${incident.status.replace("_", " ")}: ${incident.name} (${incident.shortlink})`);
      for (const maintenance of checkin.status.scheduled_maintenances) summaries.push(`${impactSymbol.get(maintenance.impact) || defaultImpactSymbol} ${maintenance.status.replace("_", " ")}: ${maintenance.name} (${maintenance.shortlink})`);
      if (summaries.length > 0) {
        actionsCore.info(`\x1B[0;31m\x1B[1m\x1B[4m${checkin.status.page.name} Status`);
        for (const notice of summaries) actionsCore.info(notice);
        actionsCore.info(`See: ${checkin.status.page.url}`);
        actionsCore.info(``);
      }
    }
  }
  getFeature(name) {
    if (!this.features.hasOwnProperty(name)) return;
    const result = this.features[name];
    if (result === void 0) return;
    this.recordEvent("$feature_flag_called", {
      $feature_flag: name,
      $feature_flag_response: result.variant
    });
    return result;
  }
  /**
  * Check in to install.determinate.systems, to accomplish three things:
  *
  * 1. Preflight the server selected from IdsHost, to increase the chances of success.
  * 2. Fetch any incidents and maintenance events to let users know in case things are weird.
  * 3. Get feature flag data so we can gently roll out new features.
  */
  async requestCheckIn() {
    for (let attemptsRemaining = 5; attemptsRemaining > 0; attemptsRemaining--) {
      const checkInUrl = await this.getCheckInUrl();
      if (checkInUrl === void 0) return;
      try {
        actionsCore.debug(`Preflighting via ${checkInUrl}`);
        const props = {
          distinct_id: this.identity.$anon_distinct_id,
          anon_distinct_id: this.identity.$anon_distinct_id,
          groups: this.identity.$groups,
          person_properties: {
            ci: "github",
            ...this.identity,
            ...this.facts
          }
        };
        return await (await this.getClient()).post(checkInUrl, {
          json: props,
          timeout: { request: CHECK_IN_ENDPOINT_TIMEOUT_MS }
        }).json();
      } catch (e) {
        this.recordPlausibleTimeout(e);
        actionsCore.debug(`Error checking in: ${stringifyError$1(e)}`);
        this.idsHost.markCurrentHostBroken();
      }
    }
  }
  recordPlausibleTimeout(e) {
    if (e instanceof TimeoutError && "timings" in e && "request" in e) {
      const reportContext = {
        url: e.request.requestUrl?.toString(),
        retry_count: e.request.retryCount
      };
      for (const [key, value] of Object.entries(e.timings.phases)) if (Number.isFinite(value)) reportContext[`timing_phase_${key}`] = value;
      this.recordEvent("timeout", reportContext);
    }
  }
  /**
  * Fetch an artifact, such as a tarball, from the location determined by the
  * `source-*` inputs. If `source-binary` is specified, this will return a path
  * to a binary on disk; otherwise, the artifact will be downloaded from the
  * URL determined by the other `source-*` inputs (`source-url`, `source-pr`,
  * etc.).
  */
  async fetchArtifact() {
    const sourceBinary = getStringOrNull("source-binary");
    if (sourceBinary !== null && sourceBinary !== "") {
      actionsCore.debug(`Using the provided source binary at ${sourceBinary}`);
      return sourceBinary;
    }
    actionsCore.startGroup(`Downloading ${this.actionOptions.name} for ${this.architectureFetchSuffix}`);
    try {
      actionsCore.info(`Fetching from ${await this.getSourceUrl()}`);
      const correlatedUrl = await this.getSourceUrl();
      correlatedUrl.searchParams.set("ci", "github");
      correlatedUrl.searchParams.set("correlation", JSON.stringify(this.identity));
      const versionCheckup = await (await this.getClient()).head(correlatedUrl);
      if (versionCheckup.headers.etag) {
        const v = versionCheckup.headers.etag;
        this.addFact(FACT_SOURCE_URL_ETAG, v);
        actionsCore.debug(`Checking the tool cache for ${await this.getSourceUrl()} at ${v}`);
        const cached = await this.getCachedVersion(v);
        if (cached) {
          this.facts[FACT_ARTIFACT_FETCHED_FROM_CACHE] = true;
          actionsCore.debug(`Tool cache hit.`);
          return cached;
        }
      }
      this.facts[FACT_ARTIFACT_FETCHED_FROM_CACHE] = false;
      actionsCore.debug(`No match from the cache, re-fetching from the redirect: ${versionCheckup.url}`);
      const destFile = this.getTemporaryName();
      const fetchStream = await this.downloadFile(new URL(versionCheckup.url), destFile);
      if (fetchStream.response?.headers.etag) {
        const v = fetchStream.response.headers.etag;
        try {
          await this.saveCachedVersion(v, destFile);
        } catch (e) {
          actionsCore.debug(`Error caching the artifact: ${stringifyError$1(e)}`);
        }
      }
      return destFile;
    } catch (e) {
      this.recordPlausibleTimeout(e);
      throw e;
    } finally {
      actionsCore.endGroup();
    }
  }
  /**
  * A helper function for failing on error only if strict mode is enabled.
  * This is intended only for CI environments testing Actions themselves.
  */
  failOnError(msg) {
    if (this.strictMode) actionsCore.setFailed(`strict mode failure: ${msg}`);
  }
  async downloadFile(url, destination) {
    const client = await this.getClient();
    return new Promise((resolve, reject) => {
      let writeStream;
      let failed = false;
      const retry = (stream2) => {
        if (writeStream) writeStream.destroy();
        writeStream = createWriteStream(destination, {
          encoding: "binary",
          mode: 493
        });
        writeStream.once("error", (error2) => {
          failed = true;
          reject(error2);
        });
        writeStream.on("finish", () => {
          if (!failed) resolve(stream2);
        });
        stream2.once("retry", (_count, _error, createRetryStream) => {
          retry(createRetryStream());
        });
        stream2.pipe(writeStream);
      };
      retry(client.stream(url));
    });
  }
  async complete() {
    this.recordEvent(`complete_${this.executionPhase}`);
    await this.submitEvents();
  }
  async getCheckInUrl() {
    const checkInUrl = await this.idsHost.getDynamicRootUrl();
    if (checkInUrl === void 0) return;
    checkInUrl.pathname += "check-in";
    return checkInUrl;
  }
  async getSourceUrl() {
    const p = this.sourceParameters;
    if (p.url) {
      this.addFact(FACT_SOURCE_URL, p.url);
      return new URL(p.url);
    }
    const fetchUrl = await this.idsHost.getRootUrl();
    fetchUrl.pathname += this.actionOptions.idsProjectName;
    if (p.tag) fetchUrl.pathname += `/tag/${p.tag}`;
    else if (p.pr) fetchUrl.pathname += `/pr/${p.pr}`;
    else if (p.branch) fetchUrl.pathname += `/branch/${p.branch}`;
    else if (p.revision) fetchUrl.pathname += `/rev/${p.revision}`;
    else fetchUrl.pathname += `/stable`;
    fetchUrl.pathname += `/${this.architectureFetchSuffix}`;
    this.addFact(FACT_SOURCE_URL, fetchUrl.toString());
    return fetchUrl;
  }
  cacheKey(version) {
    const cleanedVersion = version.replace(/[^a-zA-Z0-9-+.]/g, "");
    return `determinatesystem-${this.actionOptions.name}-${this.architectureFetchSuffix}-${cleanedVersion}`;
  }
  async getCachedVersion(version) {
    const startCwd = process.cwd();
    try {
      const tempDir = this.getTemporaryName();
      await mkdir(tempDir);
      process.chdir(tempDir);
      process.env.GITHUB_WORKSPACE_BACKUP = process.env.GITHUB_WORKSPACE;
      delete process.env.GITHUB_WORKSPACE;
      if (await actionsCache.restoreCache([this.actionOptions.name], this.cacheKey(version), [], void 0, true)) {
        this.recordEvent(EVENT_ARTIFACT_CACHE_HIT);
        return `${tempDir}/${this.actionOptions.name}`;
      }
      this.recordEvent(EVENT_ARTIFACT_CACHE_MISS);
      return;
    } finally {
      process.env.GITHUB_WORKSPACE = process.env.GITHUB_WORKSPACE_BACKUP;
      delete process.env.GITHUB_WORKSPACE_BACKUP;
      process.chdir(startCwd);
    }
  }
  async saveCachedVersion(version, toolPath) {
    const startCwd = process.cwd();
    try {
      const tempDir = this.getTemporaryName();
      await mkdir(tempDir);
      process.chdir(tempDir);
      await copyFile(toolPath, `${tempDir}/${this.actionOptions.name}`);
      process.env.GITHUB_WORKSPACE_BACKUP = process.env.GITHUB_WORKSPACE;
      delete process.env.GITHUB_WORKSPACE;
      await actionsCache.saveCache([this.actionOptions.name], this.cacheKey(version), void 0, true);
      this.recordEvent(EVENT_ARTIFACT_CACHE_PERSIST);
    } finally {
      process.env.GITHUB_WORKSPACE = process.env.GITHUB_WORKSPACE_BACKUP;
      delete process.env.GITHUB_WORKSPACE_BACKUP;
      process.chdir(startCwd);
    }
  }
  collectBacktraceSetup() {
    if (!process.env.DETSYS_BACKTRACE_COLLECTOR) {
      actionsCore.exportVariable("DETSYS_BACKTRACE_COLLECTOR", this.getCrossPhaseId());
      actionsCore.saveState(STATE_BACKTRACE_START_TIMESTAMP, Date.now());
    }
  }
  async collectBacktraces() {
    try {
      if (process.env.DETSYS_BACKTRACE_COLLECTOR !== this.getCrossPhaseId()) return;
      const backtraces = await collectBacktraces(this.actionOptions.binaryNamePrefixes, this.actionOptions.binaryNamesDenyList, parseInt(actionsCore.getState(STATE_BACKTRACE_START_TIMESTAMP)));
      actionsCore.debug(`Backtraces identified: ${backtraces.size}`);
      if (backtraces.size > 0) this.recordEvent(EVENT_BACKTRACES, Object.fromEntries(backtraces));
    } catch (innerError) {
      actionsCore.debug(`Error collecting backtraces: ${stringifyError$1(innerError)}`);
    }
  }
  async preflightRequireNix() {
    let nixLocation;
    const pathParts = (process.env["PATH"] || "").split(":");
    for (const location of pathParts) {
      const candidateNix = path.join(location, "nix");
      try {
        await fs.access(candidateNix, fs.constants.X_OK);
        actionsCore.debug(`Found Nix at ${candidateNix}`);
        nixLocation = candidateNix;
        break;
      } catch {
        actionsCore.debug(`Nix not at ${candidateNix}`);
      }
    }
    this.addFact(FACT_NIX_LOCATION, nixLocation || "");
    if (this.actionOptions.requireNix === "ignore") return true;
    if (actionsCore.getState(STATE_KEY_NIX_NOT_FOUND) === STATE_NOT_FOUND) return false;
    if (nixLocation !== void 0) return true;
    actionsCore.saveState(STATE_KEY_NIX_NOT_FOUND, STATE_NOT_FOUND);
    switch (this.actionOptions.requireNix) {
      case "fail":
        actionsCore.setFailed(["This action can only be used when Nix is installed.", "Add `- uses: DeterminateSystems/determinate-nix-action@v3` earlier in your workflow."].join(" "));
        break;
      case "warn":
        actionsCore.warning(["This action is in no-op mode because Nix is not installed.", "Add `- uses: DeterminateSystems/determinate-nix-action@v3` earlier in your workflow."].join(" "));
        break;
    }
    return false;
  }
  async preflightNixStoreInfo() {
    let output = "";
    const options = {};
    options.silent = true;
    options.listeners = { stdout: (data) => {
      output += data.toString();
    } };
    try {
      output = "";
      await exec$1.exec("nix", [
        "store",
        "info",
        "--json"
      ], options);
      this.addFact(FACT_NIX_STORE_CHECK_METHOD, "info");
    } catch {
      try {
        output = "";
        await exec$1.exec("nix", [
          "store",
          "ping",
          "--json"
        ], options);
        this.addFact(FACT_NIX_STORE_CHECK_METHOD, "ping");
      } catch {
        this.addFact(FACT_NIX_STORE_CHECK_METHOD, "none");
        return;
      }
    }
    try {
      const parsed = JSON.parse(output);
      if (parsed.trusted === 1) this.nixStoreTrust = "trusted";
      else if (parsed.trusted === 0) this.nixStoreTrust = "untrusted";
      else if (parsed.trusted !== void 0) this.addFact(FACT_NIX_STORE_CHECK_ERROR, `Mysterious trusted value: ${JSON.stringify(parsed.trusted)}`);
      this.addFact(FACT_NIX_STORE_VERSION, JSON.stringify(parsed.version));
    } catch (e) {
      this.addFact(FACT_NIX_STORE_CHECK_ERROR, stringifyError$1(e));
    }
  }
  async preflightNixVersion() {
    let output = "unknown";
    try {
      ({ stdout: output } = await exec$1.getExecOutput("nix", ["--version"], { silent: true }));
      output = output.trim() || "unknown";
    } catch {
    }
    this.addFact(FACT_NIX_VERSION, output);
  }
  async submitEvents() {
    const diagnosticsUrl = await this.idsHost.getDiagnosticsUrl();
    if (diagnosticsUrl === void 0) {
      actionsCore.debug("Diagnostics are disabled. Not sending the following events:");
      actionsCore.debug(JSON.stringify(this.events, void 0, 2));
      return;
    }
    const batch = {
      sent_at: /* @__PURE__ */ new Date(),
      batch: this.events
    };
    try {
      await (await this.getClient()).post(diagnosticsUrl, {
        json: batch,
        timeout: { request: DIAGNOSTIC_ENDPOINT_TIMEOUT_MS }
      });
    } catch (err) {
      this.recordPlausibleTimeout(err);
      actionsCore.debug(`Error submitting diagnostics event to ${diagnosticsUrl}: ${stringifyError$1(err)}`);
    }
    this.events = [];
  }
};
function stringifyError$1(error2) {
  return error2 instanceof Error || typeof error2 == "string" ? error2.toString() : JSON.stringify(error2);
}
function makeOptionsConfident(actionOptions) {
  const idsProjectName = actionOptions.idsProjectName ?? actionOptions.name;
  const finalOpts = {
    name: actionOptions.name,
    idsProjectName,
    eventPrefix: actionOptions.eventPrefix || "action:",
    fetchStyle: actionOptions.fetchStyle,
    legacySourcePrefix: actionOptions.legacySourcePrefix,
    requireNix: actionOptions.requireNix,
    binaryNamePrefixes: actionOptions.binaryNamePrefixes ?? [
      "nix",
      "determinate-nixd",
      actionOptions.name
    ],
    binaryNamesDenyList: actionOptions.binaryNamePrefixes ?? PROGRAM_NAME_CRASH_DENY_LIST
  };
  actionsCore.debug("idslib options:");
  actionsCore.debug(JSON.stringify(finalOpts, void 0, 2));
  return finalOpts;
}

// src/index.ts
var EVENT_EXECUTION_FAILURE = "execution_failure";
var DeterminateCi = class extends DetSysAction {
  constructor() {
    super({
      name: "flake-iter",
      fetchStyle: "gh-env-style",
      diagnosticsSuffix: "telemetry",
      requireNix: "fail"
    });
  }
  async main() {
    const binaryPath = await this.fetchExecutable();
    const exitCode = await actionsExec.exec(binaryPath, [], {
      // To get $FLAKE_ITER_RUNNER_MAP or $FLAKE_ITER_NIX_SYSTEM (depending on workflow step)
      env: process.env,
      ignoreReturnCode: true
    });
    if (exitCode !== 0) {
      this.recordEvent(EVENT_EXECUTION_FAILURE, {
        exitCode
      });
      actionsCore2.setFailed(`Non-zero exit code of \`${exitCode}\`.`);
    }
  }
  // No post step
  async post() {
  }
};
function main() {
  new DeterminateCi().execute();
}
main();
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

keyv/dist/index.js:
  (* v8 ignore next -- @preserve *)

cacheable-request/dist/index.js:
  (* c8 ignore next -- @preserve *)
  (* v8 ignore next -- @preserve *)

detsys-ts/dist/index.mjs:
  (*!
  * linux-release-info
  * Get Linux release info (distribution name, version, arch, release, etc.)
  * from '/etc/os-release' or '/usr/lib/os-release' files and from native os
  * module. On Windows and Darwin platforms it only returns common node os module
  * info (platform, hostname, release, and arch)
  *
  * Licensed under MIT
  * Copyright (c) 2018-2020 [Samuel Carreira]
  *)
*/
//# sourceMappingURL=index.js.map